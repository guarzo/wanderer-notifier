A. Audit & Extract Shared UI Components
1. Identify Repeated Patterns
Cards: ActivityChartCard.jsx, KillComparison.tsx, KillmailChartCard.jsx all wrap a title + chart + footer.

Dashboard Layout: Dashboard.jsx and SchedulerDashboard.jsx share grid layouts and padding.

2. Create a components/ui Library
Directory: renderer/src/components/ui/

Card.jsx

jsx
Copy
Edit
import { Card, CardContent, CardHeader } from "@/components/ui/card";

export function DataCard({ title, children, footer }) {
  return (
    <Card className="p-4 rounded-2xl shadow-sm">
      <CardHeader className="text-xl font-semibold">{title}</CardHeader>
      <CardContent>{children}</CardContent>
      {footer && <div className="mt-4 text-sm text-gray-500">{footer}</div>}
    </Card>
  );
}
GridLayout.jsx

jsx
Copy
Edit
export function GridLayout({ children }) {
  return (
    <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
      {children}
    </div>
  );
}
3. Refactor Existing Components
Before in ActivityChartCard.jsx:

jsx
Copy
Edit
<div className="rounded-lg shadow p-4 bg-white">
  <h2 className="text-lg">{title}</h2>
  <Chart ... />
</div>
After:

jsx
Copy
Edit
import { DataCard } from "@/components/ui/Card";
export default function ActivityChartCard({ title, data }) {
  return (
    <DataCard title={title}>
      <Chart data={data} />
    </DataCard>
  );
}
B. Introduce PropTypes or Migrate to TypeScript
Why
Catch mismatched props early.

Improve IDE autocompletion.

1. PropTypes (JSX)
Install:

bash
Copy
Edit
npm install prop-types
Example in KillComparison.jsx:

jsx
Copy
Edit
import PropTypes from "prop-types";

function KillComparison({ kills, timeframe }) { … }

KillComparison.propTypes = {
  kills: PropTypes.arrayOf(PropTypes.shape({
    date: PropTypes.string.isRequired,
    count: PropTypes.number.isRequired
  })).isRequired,
  timeframe: PropTypes.oneOf(["daily","weekly","monthly"])
};

export default KillComparison;
2. Or Full TS Migration
Rename .jsx → .tsx and add interfaces:

ts
Copy
Edit
interface KillComparisonProps {
  kills: { date: string; count: number }[];
  timeframe: "daily" | "weekly" | "monthly";
}

export default function KillComparison({ kills, timeframe }: KillComparisonProps) { … }
C. Centralize Tailwind Configuration
Why
Enforce a consistent design system (colors, spacing).

Prevent “magic” classes scattered across files.

1. Edit tailwind.config.cjs
js
Copy
Edit
module.exports = {
  theme: {
    extend: {
      colors: {
        primary: "#2f3136",
        accent: "#88c0d0",
        cardBg: "#ffffff",
        cardShadow: "0 2px 8px rgba(0,0,0,0.1)"
      },
      spacing: {
        card: "1rem",
        layout: "2rem"
      }
    }
  }
};
2. Use Tokens in Components
jsx
Copy
Edit
<div className="bg-cardBg shadow-[cardShadow] p-card rounded-2xl">
  …
</div>
D. Add Storybook for Component QA
1. Install & Initialize
bash
Copy
Edit
npx sb init --builder vite
2. Write Stories in components/ui/__stories__
jsx
Copy
Edit
import React from "react";
import { DataCard } from "../Card";

export default { title: "UI/DataCard", component: DataCard };

export const Default = () => (
  <DataCard title="Sample Card">
    <p>Card content here.</p>
  </DataCard>
);
3. Run & Validate
bash
Copy
Edit
npm run storybook
E. Linting & Formatting
1. ESLint + Prettier
Ensure rules enforce:

No unused imports.

Consistent JSX quotes.

Sort-tailwind-classes (via eslint-plugin-tailwindcss).

.eslintrc.js snippet:

js
Copy
Edit
extends: [
  "plugin:react/recommended",
  "plugin:tailwindcss/recommended",
  "prettier"
],
rules: {
  "react/prop-types": "off" // if using TS
}
2. Husky Pre-commit
bash
Copy
Edit
npx husky-init && npm install
npx husky set .husky/pre-commit "npm run lint && npm run format"
F. Milestones & Checklist

Task	Done
[ ] Extract DataCard, GridLayout, and other shared components	
[ ] Refactor all cards and layouts to use shared components	
[ ] Add PropTypes or migrate key files to TS	
[ ] Centralize Tailwind tokens in tailwind.config.cjs	
[ ] Install & configure Storybook, write stories for UI library	
[ ] Configure ESLint, Prettier, and Husky pre-commit	
[ ] Update README in renderer/ with dev & testing instructions	
By modularizing UI patterns, enforcing types, and consolidating styles, your React codebase will become more DRY, easier to maintain, and safer to evolve