1. Define a Unified Logger Facade
   Why
   Eliminates confusion over which logger to call (AppLogger, BatchLogger, json_formatter, etc.).

Standardizes message format and metadata across the system.

Implementation
Create lib/wanderer_notifier/logger.ex:

elixir
Copy
Edit
defmodule WandererNotifier.Logger do
@moduledoc """
Central logging interface.
Provides structured log methods with consistent metadata.
"""

require Logger

@doc "Log an info message with optional metadata."
def info(msg, meta \\ %{}) when is_binary(msg) and is_map(meta) do
Logger.info(fn -> format(msg, meta) end)
end

@doc "Log a warning message with optional metadata."
def warn(msg, meta \\ %{}) when is_binary(msg) and is_map(meta) do
Logger.warn(fn -> format(msg, meta) end)
end

@doc "Log an error message with optional metadata."
def error(msg, meta \\ %{}) when is_binary(msg) and is_map(meta) do
Logger.error(fn -> format(msg, meta) end)
end

# Internal: merge message and metadata into one string

defp format(msg, meta) do
meta_json = Jason.encode!(meta)
"#{msg} ┃ meta=#{meta_json}"
end
end 2. Replace All Custom Logger Modules
Why
Removes overlapping functionality.

Reduces code surface area and maintenance burden.

Steps
Remove or deprecate:

lib/wanderer_notifier/logger/app_logger.ex

lib/wanderer_notifier/logger/batch_logger.ex

lib/wanderer_notifier/logger/json_formatter.ex

lib/wanderer_notifier/logger/startup_tracker.ex

Search & replace all calls:

elixir
Copy
Edit

# Old

AppLogger.api_error("Fetch failed", error: reason)

# New

alias WandererNotifier.Logger
Logger.error("Fetch failed", %{error: reason, module: **MODULE**})
Ensure every call site adds relevant metadata (e.g., request_id, module, function).

3. Centralize Error Handling in Controllers
   Why
   Prevents inconsistent JSON error shapes.

Guarantees stacktraces are logged uniformly.

Implementation
In lib/wanderer_notifier/api/controller.ex (from the Module Organization section), add:

elixir
Copy
Edit

# At the bottom of the `__using__` quote:

defp handle_error(conn, error) do
WandererNotifier.Logger.error("Controller error", %{error: inspect(error), path: conn.request_path})
send_error(conn, 500, "internal_server_error")
end

# And wrap each action in a rescue block:

get "/foo" do
try do
data = MyApp.do_work(params)
send_success(conn, data)
rescue
error -> handle_error(conn, error)
end
end
Then remove any per-controller handle_error/3 functions and calls to FallbackController.

4. Add Telemetry for Error Metrics
   Why
   Enables monitoring of error rates and performance.

Integrates with tools like Prometheus or AppSignal.

Implementation
Emit Telemetry events in our logger:

elixir
Copy
Edit
def error(msg, meta) do
:telemetry.execute([:wanderer_notifier, :error], %{}, meta)
Logger.error(fn -> format(msg, meta) end)
end
Subscribe in your supervision tree:

elixir
Copy
Edit
:telemetry.attach("log-error-metrics", [:wanderer_notifier, :error], &Metrics.handle_error/4, nil)
Implement Metrics.handle_error/4 to increment counters.

5. Update config/\*.exs for Logger Formatting
   Why
   Ensures our Logger facade output is formatted correctly.

Strips out JSON formatter if not used.

Implementation
In config/config.exs:

elixir
Copy
Edit
config :logger,
backends: [:console],
format: "$time $metadata[$level] $message\n",
metadata: [:module, :function, :request_id]
Remove any custom :logger, :json_formatter backends.

Milestones & Checklist

Task Done
[ ] Add WandererNotifier.Logger facade module
[ ] Remove app*logger.ex, batch_logger.ex, json_formatter.ex, etc.
[ ] Replace all AppLogger.api*_ calls with Logger.info/warn/error
[ ] Centralize controller handle_error in Api.Controller
[ ] Emit Telemetry events on errors
[ ] Update config/_.exs to use our console logger format
[ ] Validate logs in dev and production follow the new format
[ ] Add tests or manual verifications for at least two logging scenarios
By consolidating into a single Logger and centralizing error boundaries, you’ll achieve consistent, structured logs and make it trivial to hook into monitoring systems.
