<repomix>This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where content has been formatted for parsing.<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: priv/**/*, **/*.svg, .notes/**/*, .cursor/**/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style</notes><additional_info></additional_info></file_summary><directory_structure>_layouts/
  default.html
.devcontainer/
  devcontainer.json
  docker-compose.yml
  Dockerfile
.github/
  actions/
    common-checkout-cache/
      action.yml
    common-docker-build/
      action.yml
    common-elixir-setup/
      action.yml
    common-node-setup/
      action.yml
    common-versioning/
      action.yml
  workflows/
    adhoc.yml
    automatic.yml
    docs.yml
    release.yml
    test.yml
assets/
  css/
    style.scss
  package.json
config/
  config.exs
  dev.exs
  prod.exs
  runtime.exs
  test.exs
lib/
  wanderer_notifier/
    api/
      controllers/
        health_controller.ex
        kill_controller.ex
        notification_controller.ex
        web_controller.ex
      controller.ex
    cache/
      behaviour.ex
      cachex_impl.ex
      keys.ex
    config/
      config.ex
      version.ex
    core/
      application/
        service.ex
      stats.ex
    esi/
      entities/
        alliance.ex
        character.ex
        corporation.ex
        solar_system.ex
      client.ex
      service_behaviour.ex
      service_mock.ex
      service.ex
    helpers/
      deduplication_helper.ex
    http_client/
      behaviour.ex
      httpoison.ex
    killmail/
      cache.ex
      context.ex
      enrichment.ex
      killmail.ex
      metric_registry.ex
      metrics.ex
      mode.ex
      notification.ex
      pipeline.ex
      processor.ex
      zkill_client.ex
    license/
      client.ex
      service.ex
    logger/
      logger.ex
    map/
      clients/
        characters_client.ex
        client.ex
        systems_client.ex
      map_character.ex
      map_system.ex
      system_static_info.ex
    notifications/
      determiner/
        character.ex
        kill.ex
      formatters/
        base.ex
        embed.ex
        kill.ex
      behaviour.ex
      factory_behaviour.ex
      factory.ex
      interface.ex
      killmail_notification.ex
      utils.ex
    notifiers/
      discord/
        behaviour.ex
        component_builder.ex
        constants.ex
        feature_flags.ex
        neo_client.ex
        notifier.ex
      formatters/
        structured.ex
      helpers/
        deduplication.ex
        test_notifications.ex
      behaviour.ex
      test.ex
    schedulers/
      character_update_scheduler.ex
      registry.ex
      scheduler.ex
      service_status_scheduler.ex
      supervisor.ex
      system_update_scheduler.ex
    utilities/
      character_utils.ex
      datetime_util.ex
      debug.ex
      list_utils.ex
      map_util.ex
      number_human.ex
      time_helpers.ex
      type_helpers.ex
    web/
      router.ex
      server.ex
    zkill/
      websocket.ex
    application.ex
rel/
  overlays/
    env.bat
    env.sh
    sys.config
    wanderer_notifier.service
renderer/
  src/
    components/
      ActivityChartCard.jsx
      CharacterKillsCard.jsx
      ChartsDashboard.jsx
      Dashboard.jsx
      KillComparison.tsx
      KillComparisonTrends.tsx
      KillmailChartCard.jsx
      Navigation.tsx
      SchedulerCard.jsx
      SchedulerDashboard.jsx
    utils/
      api.ts
    App.css
    App.jsx
    index.css
    main.jsx
  .gitignore
  eslint.config.js
  index.html
  package.json
  postcss.config.cjs
  README.md
  tailwind.config.cjs
  vite.config.js
  watch-and-copy.js
  watch-sync.js
scripts/
  dev.sh
  setup_test_env.sh
  test_docker_image.sh
  validate_and_start.sh
  version.sh
test/
  support/
    fixtures/
      api_responses.ex
    mocks/
      cache_mock.ex
      mock_date.ex
      mock_notifier_factory.ex
    stubs/
      discord_notifier.ex
    mocks.ex
    test_cache_stubs.ex
  wanderer_notifier/
    api/
      api_test.exs
    config/
      debug_test.exs
      notifications_test.exs
      timings_test.exs
      version_test.exs
    core/
      application/
        service_test.exs
    data/
      cache/
        cache_test.exs
        helpers_test.exs
        keys_test.exs
      character_test.exs
      datetime_util_test.exs
      killmail_test.exs
      map_util_test.exs
      system_test.exs
    esi/
      entities_test.exs
      service_test.exs
    helpers/
      deduplication_helper_test.exs
      sample_test.exs
    http/
      http_test.exs
    notifiers/
      discord/
        notifier_test.exs
      helpers/
        deduplication_test.exs
      structured_formatter_test.exs
  README.md
  test_helper.exs
_config.yml
.coderabbit.yaml
.credo.exs
.cursorignore
.cursorrules
.dockerignore
.env.example
.env.template
.formatter.exs
.gitignore
cicd.txt
docker-compose.yml
Dockerfile
index.md
Makefile
mix.exs
NOTIFICATION_TROUBLESHOOTING_PLAN.md
notifications.md
originalformatter.ex
react.txt
README-GH-PAGES.md
README.md
start.sh</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="_layouts/default.html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;{{ site.lang | default: &quot;en-US&quot; }}&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#157878&quot;&gt;
  &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ &apos;/assets/css/style.css?v=&apos; | append: site.github.build_revision | relative_url }}&quot;&gt;
  {% seo %}
&lt;/head&gt;
&lt;body&gt;
  &lt;header class=&quot;page-header&quot; role=&quot;banner&quot;&gt;
    &lt;h1 class=&quot;project-name&quot;&gt;{{ page.title | default: site.title }}&lt;/h1&gt;
    &lt;h2 class=&quot;project-tagline&quot;&gt;{{ page.description | default: site.description }}&lt;/h2&gt;
    
    &lt;nav class=&quot;main-nav&quot;&gt;
      &lt;a href=&quot;{{ site.baseurl }}/&quot; class=&quot;btn&quot;&gt;Home&lt;/a&gt;
      &lt;a href=&quot;{{ site.baseurl }}/notifications.html&quot; class=&quot;btn&quot;&gt;Notifications&lt;/a&gt;
      &lt;a href=&quot;https://wanderer.ltd/&quot; class=&quot;btn&quot;&gt;Wanderer&lt;/a&gt;
      &lt;a href=&quot;{{ site.github.repository_url }}&quot; class=&quot;btn&quot;&gt;View on GitHub&lt;/a&gt;
    &lt;/nav&gt;
  &lt;/header&gt;

  &lt;main id=&quot;content&quot; class=&quot;main-content&quot; role=&quot;main&quot;&gt;
    {{ content }}

    &lt;footer class=&quot;site-footer&quot;&gt;
      &lt;span class=&quot;site-footer-owner&quot;&gt;
        &lt;a href=&quot;{{ site.github.repository_url }}&quot;&gt;{{ site.github.repository_name }}&lt;/a&gt; is maintained by 
        &lt;a href=&quot;{{ site.github.owner_url }}&quot;&gt;{{ site.github.owner_name }}&lt;/a&gt;.
      &lt;/span&gt;
      &lt;span class=&quot;site-footer-credits&quot;&gt;This page was generated by &lt;a href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;.&lt;/span&gt;
    &lt;/footer&gt;
  &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</file><file path=".devcontainer/devcontainer.json">{
  &quot;name&quot;: &quot;Notifier Dev Container&quot;,

  // Use docker-compose for container configuration
  &quot;dockerComposeFile&quot;: &quot;docker-compose.yml&quot;,
  &quot;service&quot;: &quot;app&quot;,
  &quot;workspaceFolder&quot;: &quot;/workspace&quot;,

  &quot;runArgs&quot;: [
    &quot;--add-host=host.docker.internal:host-gateway&quot;,
    &quot;-v&quot;, &quot;/var/run/docker.sock:/var/run/docker.sock&quot;
  ],

  &quot;features&quot;: {
    &quot;ghcr.io/devcontainers/features/common-utils:2&quot;: {
      &quot;networkArgs&quot;: [&quot;--add-host=host.docker.internal:host-gateway&quot;]
    }
  },

  // Add port forwarding configuration
  &quot;forwardPorts&quot;: [4001],

  &quot;remoteUser&quot;: &quot;elixir&quot;,
  &quot;updateRemoteUserUID&quot;: false,
  
  // Set environment variables
  &quot;remoteEnv&quot;: {
    &quot;NODE_OPTIONS&quot;: &quot;--max-old-space-size=4096&quot;,
    &quot;CLAUDE_CONFIG_DIR&quot;: &quot;/home/elixir/.claude&quot;,
    &quot;POWERLEVEL9K_DISABLE_GITSTATUS&quot;: &quot;true&quot;
  },
  
  // Custom configurations for VS Code
  &quot;customizations&quot;: {
    &quot;vscode&quot;: {
      &quot;extensions&quot;: [
        &quot;JakeBecker.elixir-ls&quot;,
        &quot;esbenp.prettier-vscode&quot;,
        &quot;pantajoe.vscode-elixir-credo&quot;,
        &quot;ms-vsliveshare.vsliveshare&quot;,
        &quot;eamodio.gitlens&quot;,
        &quot;streetsidesoftware.code-spell-checker&quot;,
        &quot;bradlc.vscode-tailwindcss&quot;
      ],
      &quot;settings&quot;: {
        &quot;editor.formatOnSave&quot;: true,
        &quot;editor.defaultFormatter&quot;: null,
        &quot;editor.codeActionsOnSave&quot;: {
          &quot;source.fixAll.eslint&quot;: &quot;explicit&quot;
        },
        &quot;terminal.integrated.defaultProfile.linux&quot;: &quot;zsh&quot;,
        &quot;terminal.integrated.profiles.linux&quot;: {
          &quot;bash&quot;: {
            &quot;path&quot;: &quot;bash&quot;,
            &quot;icon&quot;: &quot;terminal-bash&quot;
          },
          &quot;zsh&quot;: {
            &quot;path&quot;: &quot;zsh&quot;
          }
        },
        &quot;[elixir]&quot;: {
          &quot;editor.formatOnSave&quot;: true
        },
        &quot;elixirLS.suggestSpecs&quot;: true,
        &quot;elixirLS.dialyzerEnabled&quot;: true,
        &quot;elixirLS.signatureAfterComplete&quot;: true,
        &quot;elixirLS.fetchDeps&quot;: true,
        &quot;elixirLS.enableTestLenses&quot;: true,
        &quot;explorer.fileNesting.enabled&quot;: true,
        &quot;explorer.fileNesting.patterns&quot;: {
          &quot;mix.exs&quot;: &quot;mix.lock&quot;
        },
        &quot;cSpell.words&quot;: [
          &quot;Credo&quot;,
          &quot;devcontainer&quot;,
          &quot;elixir&quot;,
          &quot;inotify&quot;,
          &quot;wanderer&quot;
        ]
      }
    }
  },

  &quot;postCreateCommand&quot;: &quot;mix local.hex --force &amp;&amp; mix local.rebar --force &amp;&amp; mix deps.get &amp;&amp; cd renderer &amp;&amp; npm install&quot;
}</file><file path=".devcontainer/docker-compose.yml">version: &quot;3.8&quot;
services:
  app:
    build:
      context: ..
      dockerfile: .devcontainer/Dockerfile
      args:
        USERNAME: elixir
        NODE_VERSION: 20.x
        INSTALL_ELIXIR_LS: &quot;true&quot;
    volumes:
      - ..:/workspace:cached
      - claude-code-bashhistory:/commandhistory
      - claude-code-config:/home/elixir/.claude
      - elixir-ls-cache:/home/elixir/.elixir-ls
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - NODE_OPTIONS=--max-old-space-size=4096
      - CLAUDE_CONFIG_DIR=/home/elixir/.claude
      - POWERLEVEL9K_DISABLE_GITSTATUS=true
    command: sleep infinity
    user: elixir
    ports:
      - &quot;4001:4000&quot; # Main application
    # This allows the container to access host.docker.internal
    extra_hosts:
      - &quot;host.docker.internal:host-gateway&quot;

volumes:
  claude-code-bashhistory:
  claude-code-config:
  elixir-ls-cache:</file><file path=".devcontainer/Dockerfile">FROM elixir:otp-27

# Define ARGs for customization
ARG USERNAME=elixir
ARG NODE_VERSION=20.x
ARG INSTALL_ELIXIR_LS=true

# Install OS packages and Node.js (via nodesource),
# plus inotify-tools and yarn
RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
    sudo \
    curl \
    make \
    git \
    bash \
    build-essential \
    ca-certificates \
    jq \
    vim \
    net-tools \
    procps \
    zsh \
    unzip \
    gnupg \
    postgresql-client \
    # Optionally add any other tools you need, e.g. vim, wget...
    &amp;&amp; curl -sL https://deb.nodesource.com/setup_${NODE_VERSION} | bash - \
    &amp;&amp; apt-get install -y --no-install-recommends nodejs inotify-tools \
    &amp;&amp; npm install -g yarn \
    &amp;&amp; apt-get clean \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Create a non-root user with the USERNAME arg
RUN useradd -ms /bin/bash ${USERNAME}

# Give the user passwordless sudo
RUN usermod -aG sudo ${USERNAME} &amp;&amp; \
    echo &quot;${USERNAME} ALL=(ALL) NOPASSWD:ALL&quot; &gt;&gt; /etc/sudoers

# Persist bash history.
RUN SNIPPET=&quot;export PROMPT_COMMAND=&apos;history -a&apos; &amp;&amp; export HISTFILE=/commandhistory/.bash_history&quot; \
  &amp;&amp; mkdir /commandhistory \
  &amp;&amp; touch /commandhistory/.bash_history \
  &amp;&amp; chown -R ${USERNAME} /commandhistory

# Set `DEVCONTAINER` environment variable to help with orientation
ENV DEVCONTAINER=true

# Create workspace and config directories and set permissions
RUN mkdir -p /workspace /home/${USERNAME}/.claude &amp;&amp; \
  chown -R ${USERNAME}:${USERNAME} /workspace /home/${USERNAME}/.claude

# Set a working directory (your choice)
WORKDIR /workspace

# Switch to the non-root user by default
USER ${USERNAME}

# Install global packages
ENV NPM_CONFIG_PREFIX=/home/${USERNAME}/.npm-global
ENV PATH=$PATH:/home/${USERNAME}/.npm-global/bin

# Set the default shell to zsh rather than sh
ENV SHELL /bin/zsh

# Create global npm directory with correct permissions
RUN mkdir -p /home/${USERNAME}/.npm-global &amp;&amp; \
    chown -R ${USERNAME}:${USERNAME} /home/${USERNAME}/.npm-global

RUN npm install -g @anthropic-ai/claude-code

# Install Hex/Rebar global for the container
RUN mix local.hex --force &amp;&amp; mix local.rebar --force

# Install Credo for linting
RUN mix archive.install --force hex credo

# Install ElixirLS if enabled
RUN if [ &quot;$INSTALL_ELIXIR_LS&quot; = &quot;true&quot; ]; then \
    mkdir -p /home/${USERNAME}/.elixir-ls &amp;&amp; \
    cd /home/${USERNAME}/.elixir-ls &amp;&amp; \
    git clone --depth=1 https://github.com/elixir-lsp/elixir-ls.git . &amp;&amp; \
    mix deps.get &amp;&amp; \
    mix compile &amp;&amp; \
    mix elixir_ls.release2 -o /home/${USERNAME}/.elixir-ls/release &amp;&amp; \
    chown -R ${USERNAME}:${USERNAME} /home/${USERNAME}/.elixir-ls; \
    fi

# Leaving CMD/ENTRYPOINT unset here so you can specify the run command externally.</file><file path=".github/actions/common-checkout-cache/action.yml">name: &quot;Common Checkout and Cache&quot;
description: &quot;Restore dependencies cache&quot;
inputs:
  branch:
    description: &quot;Branch to checkout&quot;
    required: false
    default: &quot;main&quot;
  cache-key-prefix:
    description: &quot;Cache key prefix (e.g., mix)&quot;
    required: true
  cache-paths:
    description: &quot;Cache paths to restore (newline separated)&quot;
    required: false
    default: |
      deps
      _build
      priv/static
runs:
  using: &quot;composite&quot;
  steps:
    - name: Restore dependencies cache
      uses: actions/cache@v3
      with:
        path: ${{ inputs.cache-paths }}
        key: ${{ runner.os }}-${{ inputs.cache-key-prefix }}-${{ hashFiles(&apos;**/mix.lock&apos;) }}
        restore-keys: |
          ${{ runner.os }}-${{ inputs.cache-key-prefix }}-
          ${{ runner.os }}-mix-</file><file path=".github/actions/common-docker-build/action.yml">name: &quot;Common Docker Build&quot;
description: &quot;Build and optionally push a Docker image using Buildx&quot;
inputs:
  context:
    description: &quot;Build context&quot;
    required: false
    default: &quot;.&quot;
  push:
    description: &quot;Push image after building (true/false)&quot;
    required: false
    default: &quot;false&quot;
  load:
    description: &quot;Load image into Docker daemon (true/false)&quot;
    required: false
    default: &quot;false&quot;
  tags:
    description: &quot;Docker image tags (comma-separated if multiple)&quot;
    required: true
  build-args:
    description: &quot;Build arguments (newline separated)&quot;
    required: false
  cache-from:
    description: &quot;Cache-from configuration&quot;
    required: false
  cache-to:
    description: &quot;Cache-to configuration&quot;
    required: false
  docker_username:
    description: &quot;Docker Hub username (required if pushing)&quot;
    required: false
  docker_password:
    description: &quot;Docker Hub password (required if pushing)&quot;
    required: false
runs:
  using: &quot;composite&quot;
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [[ &quot;${{ inputs.push }}&quot; == &quot;true&quot; ]]; then
          if [[ -z &quot;${{ inputs.tags }}&quot; ]]; then
            echo &quot;Error: tags are required when push is true&quot;
            exit 1
          fi
          if [[ -z &quot;${{ inputs.docker_username }}&quot; || -z &quot;${{ inputs.docker_password }}&quot; ]]; then
            echo &quot;Error: Docker credentials are required when push is true&quot;
            exit 1
          fi
        fi

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        buildkitd-flags: --debug

    - name: Login to Docker Hub
      if: inputs.push == &apos;true&apos;
      uses: docker/login-action@v2
      with:
        username: ${{ inputs.docker_username }}
        password: ${{ inputs.docker_password }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ${{ inputs.context }}
        push: ${{ inputs.push }}
        load: ${{ inputs.load }}
        tags: ${{ inputs.tags }}
        build-args: ${{ inputs.build-args }}
        cache-from: ${{ inputs.cache-from }}
        cache-to: ${{ inputs.cache-to }}</file><file path=".github/actions/common-elixir-setup/action.yml">name: &quot;Common Elixir Setup&quot;
description: &quot;Set up Elixir environment&quot;
inputs:
  elixir-version:
    description: &quot;Elixir version&quot;
    required: true
  otp-version:
    description: &quot;OTP version&quot;
    required: true
runs:
  using: &quot;composite&quot;
  steps:
    - name: Set up Elixir
      uses: erlef/setup-beam@v1
      with:
        elixir-version: ${{ inputs.elixir-version }}
        otp-version: ${{ inputs.otp-version }}</file><file path=".github/actions/common-node-setup/action.yml">name: &quot;Common Node.js Setup&quot;
description: &quot;Set up Node.js with caching for frontend dependencies&quot;
inputs:
  node_version:
    description: &quot;Node.js version&quot;
    required: true
  cache_dependency_path:
    description: &quot;Path to package-lock.json (or yarn.lock)&quot;
    required: true
runs:
  using: &quot;composite&quot;
  steps:
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node_version }}
        cache: npm
        cache-dependency-path: ${{ inputs.cache_dependency_path }}</file><file path=".github/actions/common-versioning/action.yml">name: &quot;Common Versioning&quot;
description: &quot;Generate version and Docker tag information based on mode (adhoc, automatic, release)&quot;
inputs:
  mode:
    description: &quot;Mode: adhoc, automatic, or release&quot;
    required: true
  branch:
    description: &quot;Branch name (required for adhoc mode)&quot;
    required: false
  version_type:
    description: &quot;Version increment type (required for release mode)&quot;
    required: false
outputs:
  short_sha:
    description: &quot;Short SHA of the current commit&quot;
  version:
    description: &quot;Version number (for release and adhoc modes)&quot;
  full_version:
    description: &quot;Full version string including build metadata&quot;
  dev_version:
    description: &quot;Development version string (for automatic mode)&quot;
  safe_branch:
    description: &quot;Sanitized branch name (for adhoc mode)&quot;
  docker_tags:
    description: &quot;Comma-separated list of Docker tags to apply&quot;
runs:
  using: &quot;composite&quot;
  steps:
    - name: Run versioning script
      shell: bash
      run: |
        set -x  # Enable debug output
        SHORT_SHA=$(git rev-parse --short HEAD)
        echo &quot;short_sha=${SHORT_SHA}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;

        if [ &quot;${{ inputs.mode }}&quot; = &quot;adhoc&quot; ]; then
          if [ -z &quot;${{ inputs.branch }}&quot; ]; then
            echo &quot;Branch input is required for adhoc mode&quot;
            exit 1
          fi
          SAFE_BRANCH=$(echo &quot;${{ inputs.branch }}&quot; | sed &apos;s/\//-/g&apos;)
          CURRENT_VERSION=$(./scripts/version.sh get)
          FULL_VERSION=&quot;${CURRENT_VERSION}-${SAFE_BRANCH}+$(date +&apos;%Y%m%d&apos;).${SHORT_SHA}&quot;
          DOCKER_TAG_LIST=&quot;guarzo/wanderer-notifier:branch-${SAFE_BRANCH},guarzo/wanderer-notifier:branch-${SAFE_BRANCH}-$(date +&apos;%Y%m%d&apos;)-${SHORT_SHA}&quot;
          echo &quot;version=${CURRENT_VERSION}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
          echo &quot;full_version=${FULL_VERSION}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
          echo &quot;safe_branch=${SAFE_BRANCH}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
          echo &quot;docker_tags=${DOCKER_TAG_LIST}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
        elif [ &quot;${{ inputs.mode }}&quot; = &quot;automatic&quot; ]; then
          DEV_VERSION=&quot;dev-$(date +&apos;%Y%m%d&apos;)-${SHORT_SHA}&quot;
          DOCKER_TAGS=&quot;guarzo/wanderer-notifier:dev,guarzo/wanderer-notifier:sha-${SHORT_SHA}&quot;
          echo &quot;dev_version=${DEV_VERSION}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
          echo &quot;docker_tags=${DOCKER_TAGS}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
        elif [ &quot;${{ inputs.mode }}&quot; = &quot;release&quot; ]; then
          if [ -z &quot;${{ inputs.version_type }}&quot; ]; then
            echo &quot;Version type input is required for release mode&quot;
            exit 1
          fi
          echo &quot;Running in release mode with version_type: ${{ inputs.version_type }}&quot;
          chmod +x ./scripts/version.sh
          
          echo &quot;Current version from version.sh get:&quot;
          CURRENT_VERSION=$(./scripts/version.sh get)
          echo &quot;$CURRENT_VERSION&quot;
          
          echo &quot;Bumping version...&quot;
          NEW_VERSION=$(./scripts/version.sh bump ${{ inputs.version_type }})
          echo &quot;New version will be: ${NEW_VERSION}&quot;
          
          echo &quot;Updating version files...&quot;
          ./scripts/version.sh update ${{ inputs.version_type }}
          
          # Verify the version was updated and use it
          UPDATED_VERSION=$(cat VERSION)
          echo &quot;Updated version from VERSION file: ${UPDATED_VERSION}&quot;
          
          # Generate the full version string
          FULL_VERSION=&quot;${UPDATED_VERSION}+$(date +&apos;%Y%m%d&apos;).${SHORT_SHA}&quot;
          echo &quot;Full version will be: ${FULL_VERSION}&quot;

          # Set outputs using printf to ensure no trailing newlines
          {
            printf &quot;version=%s\n&quot; &quot;${UPDATED_VERSION}&quot;
            printf &quot;full_version=%s\n&quot; &quot;${FULL_VERSION}&quot;
          } &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
          
          echo &quot;Debug: Contents of GITHUB_OUTPUT:&quot;
          cat &quot;$GITHUB_OUTPUT&quot;
          
          echo &quot;Debug: Showing contents of VERSION file:&quot;
          cat VERSION
          echo &quot;Debug: Showing relevant line from mix.exs:&quot;
          grep &quot;version:&quot; mix.exs
        else
          echo &quot;Invalid mode: ${{ inputs.mode }}&quot;
          exit 1
        fi</file><file path=".github/workflows/adhoc.yml">name: Ad-hoc
run-name: Adhoc - Building ${{ github.event.inputs.branch }}

on:
  workflow_dispatch:
    inputs:
      branch:
        description: &quot;Branch to build&quot;
        required: true
        default: &quot;main&quot;

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      MIX_ENV: prod
    steps:
      - name: Initial checkout
        uses: actions/checkout@v3

      - name: Common Checkout and Cache
        uses: ./.github/actions/common-checkout-cache
        with:
          branch: ${{ github.event.inputs.branch }}
          cache-key-prefix: mix
          cache-paths: |
            deps
            _build
            priv/static

      - name: Generate version information
        id: version
        uses: ./.github/actions/common-versioning
        with:
          mode: adhoc
          branch: ${{ github.event.inputs.branch }}

      - name: Common Node.js Setup
        uses: ./.github/actions/common-node-setup
        with:
          node_version: &quot;20&quot;
          cache_dependency_path: &quot;renderer/package-lock.json&quot;

      - name: Install frontend dependencies and build
        run: |
          cd renderer
          npm ci
          npm run build
          cd ..

      - name: Build Docker image (for testing)
        uses: ./.github/actions/common-docker-build
        with:
          context: .
          push: false
          load: true
          tags: guarzo/wanderer-notifier:sha-${{ steps.version.outputs.short_sha }}
          build-args: |
            APP_VERSION=${{ steps.version.outputs.full_version }}
            WANDERER_NOTIFIER_API_TOKEN=${{ secrets.NOTIFIER_API_TOKEN }}
          cache-from: type=registry,ref=guarzo/wanderer-notifier:latest
          cache-to: type=inline

      - name: Test Docker image
        run: |
          echo &quot;Testing Docker image...&quot;
          ./scripts/test_docker_image.sh -t &quot;sha-${{ steps.version.outputs.short_sha }}&quot; --basic --discord-token &quot;${{ secrets.FAKE_DISCORD_TOKEN }}&quot;
          echo &quot;Docker image test passed successfully!&quot;

      - name: Push Docker image with branch tags
        uses: ./.github/actions/common-docker-build
        with:
          context: .
          push: true
          tags: ${{ steps.version.outputs.docker_tags }}
          build-args: |
            APP_VERSION=${{ steps.version.outputs.full_version }}
            WANDERER_NOTIFIER_API_TOKEN=${{ secrets.NOTIFIER_API_TOKEN }}
          cache-from: type=registry,ref=guarzo/wanderer-notifier:latest
          cache-to: type=inline
          docker_username: guarzo
          docker_password: ${{ secrets.DOCKERHUB_PAT }}</file><file path=".github/workflows/automatic.yml">name: Automatic Image
run-name: Automatic - ${{ github.event.head_commit.message || &apos;Manual trigger&apos; }}

on:
  push:
    branches: [main]
    paths-ignore:
      - &quot;mix.exs&quot; # Ignore version bump commits
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      MIX_ENV: prod
    steps:
      - name: Initial checkout
        uses: actions/checkout@v3

      - name: Common Checkout and Cache
        uses: ./.github/actions/common-checkout-cache
        with:
          branch: main
          cache-key-prefix: mix
          cache-paths: |
            deps
            _build
            priv/static

      - name: Generate version information
        id: version
        uses: ./.github/actions/common-versioning
        with:
          mode: automatic

      - name: Common Node.js Setup
        uses: ./.github/actions/common-node-setup
        with:
          node_version: &quot;20&quot;
          cache_dependency_path: &quot;renderer/package-lock.json&quot;

      - name: Install frontend dependencies and build
        run: |
          cd renderer
          npm ci
          npm run build
          cd ..

      - name: Build Docker image (SHA tagged)
        uses: ./.github/actions/common-docker-build
        with:
          context: .
          push: false
          load: true
          tags: guarzo/wanderer-notifier:sha-${{ steps.version.outputs.short_sha }}
          build-args: |
            APP_VERSION=${{ steps.version.outputs.dev_version }}
            WANDERER_NOTIFIER_API_TOKEN=${{ secrets.WANDERER_NOTIFIER_API_TOKEN }}
          cache-from: type=registry,ref=guarzo/wanderer-notifier:dev
          cache-to: type=inline

      - name: Test Docker image
        run: |
          echo &quot;Testing Docker image...&quot;
          ./scripts/test_docker_image.sh -t &quot;sha-${{ steps.version.outputs.short_sha }}&quot; --basic --discord-token &quot;${{ secrets.FAKE_DISCORD_TOKEN }}&quot;
          echo &quot;Docker image test passed successfully!&quot;

      - name: Build and Push Docker image with tags
        uses: ./.github/actions/common-docker-build
        with:
          context: .
          push: true
          tags: guarzo/wanderer-notifier:dev,guarzo/wanderer-notifier:sha-${{ steps.version.outputs.short_sha }}
          build-args: |
            APP_VERSION=${{ steps.version.outputs.dev_version }}
            WANDERER_NOTIFIER_API_TOKEN=${{ secrets.NOTIFIER_API_TOKEN }}
          cache-from: type=registry,ref=guarzo/wanderer-notifier:dev
          cache-to: type=inline
          docker_username: guarzo
          docker_password: ${{ secrets.DOCKERHUB_PAT }}</file><file path=".github/workflows/docs.yml">name: Docs

on:
  push:
    branches:
      - main
    paths:
      - &apos;index.md&apos;
      - &apos;notifications.md&apos;
      - &apos;license.md&apos;
      - &apos;_layouts/**&apos;
      - &apos;assets/**&apos;
      - &apos;_config.yml&apos;
      - &apos;.github/workflows/docs.yml&apos;
  workflow_dispatch:

concurrency:
  group: github-pages-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure Pages
        uses: actions/configure-pages@v5

      - name: Setup Ruby &amp; Cache Gems
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: &apos;3.2&apos;
          bundler-cache: true

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Create Image Directories and Placeholder Images
        run: |
          mkdir -p assets/images
          
          # Create placeholder images if they don&apos;t exist
          if [ ! -f &quot;assets/images/paid-kill.png&quot; ]; then
            echo &quot;Creating placeholder for paid-kill.png&quot;
            convert -size 600x400 canvas:lightblue -font Arial -pointsize 20 -fill black -annotate +30+30 &quot;Licensed Kill Notification Example&quot; assets/images/paid-kill.png
          fi
          
          if [ ! -f &quot;assets/images/free-kill.png&quot; ]; then
            echo &quot;Creating placeholder for free-kill.png&quot;
            convert -size 600x150 canvas:lightgray -font Arial -pointsize 20 -fill black -annotate +30+30 &quot;Free Kill Notification Example&quot; assets/images/free-kill.png
          fi
          
          if [ ! -f &quot;assets/images/paid-character.png&quot; ]; then
            echo &quot;Creating placeholder for paid-character.png&quot;
            convert -size 600x300 canvas:lightgreen -font Arial -pointsize 20 -fill black -annotate +30+30 &quot;Licensed Character Notification Example&quot; assets/images/paid-character.png
          fi
          
          if [ ! -f &quot;assets/images/free-character.png&quot; ]; then
            echo &quot;Creating placeholder for free-character.png&quot;
            convert -size 600x100 canvas:lightgray -font Arial -pointsize 20 -fill black -annotate +30+30 &quot;Free Character Notification Example&quot; assets/images/free-character.png
          fi
          
          if [ ! -f &quot;assets/images/paid-system.png&quot; ]; then
            echo &quot;Creating placeholder for paid-system.png&quot;
            convert -size 600x300 canvas:orange -font Arial -pointsize 20 -fill black -annotate +30+30 &quot;Licensed System Notification Example&quot; assets/images/paid-system.png
          fi
          
          if [ ! -f &quot;assets/images/free-system.png&quot; ]; then
            echo &quot;Creating placeholder for free-system.png&quot;
            convert -size 600x100 canvas:lightgray -font Arial -pointsize 20 -fill black -annotate +30+30 &quot;Free System Notification Example&quot; assets/images/free-system.png
          fi
          
          if [ ! -f &quot;assets/images/dashboard.png&quot; ]; then
            echo &quot;Creating placeholder for dashboard.png&quot;
            convert -size 800x600 canvas:white -font Arial -pointsize 20 -fill black -annotate +30+30 &quot;Wanderer Notifier Dashboard&quot; assets/images/dashboard.png
          fi

      - name: Build with Jekyll
        uses: actions/jekyll-build-pages@v1
        with:
          source: ./
          destination: ./_site

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./_site

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: github-pages
      url: ${{ steps.deploy.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deploy
        uses: actions/deploy-pages@v4</file><file path=".github/workflows/release.yml">name: Release
run-name: Release - ${{ github.event.inputs.version_type }} version update

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: &quot;Version increment type&quot;
        required: true
        default: &quot;patch&quot;
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  release:
    runs-on: ubuntu-latest
    env:
      MIX_ENV: prod
    steps:
      - name: Initial checkout
        uses: actions/checkout@v3

      - name: Common Checkout and Cache
        uses: ./.github/actions/common-checkout-cache
        with:
          branch: main
          cache-key-prefix: mix
          cache-paths: |
            deps
            _build
            priv/static

      - name: Generate version information
        id: version
        uses: ./.github/actions/common-versioning
        with:
          mode: release
          version_type: ${{ github.event.inputs.version_type }}

      - name: Debug version info
        run: |
          echo &quot;Version: ${{ steps.version.outputs.version }}&quot;
          echo &quot;Full version: ${{ steps.version.outputs.full_version }}&quot;
          echo &quot;Short SHA: ${{ steps.version.outputs.short_sha }}&quot;

      - name: Update workflow title
        run: |
          echo &quot;title=Release - Version v${{ steps.version.outputs.version }}&quot; &gt;&gt; $GITHUB_STEP_SUMMARY

      - name: Create version bump commit and tag
        run: |
          git config --local user.email &quot;actions@github.com&quot;
          git config --local user.name &quot;GitHub Actions&quot;

          # Debug git status
          echo &quot;Git status before changes:&quot;
          git status

          # Stage all version-related files
          git add VERSION mix.exs

          echo &quot;Git status after staging:&quot;
          git status

          # Get the version number for commit message
          VERSION=&quot;${{ steps.version.outputs.version }}&quot;
          echo &quot;Debug: Version from outputs: $VERSION&quot;

          # Fallback to reading from VERSION file if output is empty
          if [ -z &quot;$VERSION&quot; ]; then
            VERSION=$(cat VERSION)
            echo &quot;Debug: Version from file: $VERSION&quot;
          fi

          if [ -z &quot;$VERSION&quot; ]; then
            echo &quot;Error: Could not determine version number&quot;
            exit 1
          fi

          echo &quot;Using version: $VERSION&quot;

          # Create version bump commit with [skip ci]
          git commit -m &quot;Release version v$VERSION [skip ci]&quot;

          # Create annotated tag
          git tag -a &quot;v$VERSION&quot; -m &quot;Release v$VERSION&quot;

          # Push both the commit and tag
          git push origin main &quot;v$VERSION&quot;

      - name: Common Node.js Setup
        uses: ./.github/actions/common-node-setup
        with:
          node_version: &quot;20&quot;
          cache_dependency_path: &quot;renderer/package-lock.json&quot;

      - name: Install frontend dependencies and build
        run: |
          cd renderer
          npm ci
          npm run build
          cd ..

      - name: Build Docker image (SHA tagged)
        uses: ./.github/actions/common-docker-build
        with:
          context: .
          push: false
          load: true
          tags: guarzo/wanderer-notifier:sha-${{ steps.version.outputs.short_sha }}
          build-args: |
            APP_VERSION=${{ steps.version.outputs.full_version }}
            WANDERER_NOTIFIER_API_TOKEN=${{ secrets.NOTIFIER_API_TOKEN }}
          cache-from: type=registry,ref=guarzo/wanderer-notifier:latest
          cache-to: type=inline

      - name: Test Docker image
        run: |
          echo &quot;Testing Docker image...&quot;
          ./scripts/test_docker_image.sh -t &quot;sha-${{ steps.version.outputs.short_sha }}&quot; --discord-token &quot;${{ secrets.FAKE_DISCORD_TOKEN }}&quot;
          echo &quot;Docker image validation successful!&quot;

      - name: Extract major version
        id: major_version
        run: |
          VERSION=&quot;${{ steps.version.outputs.version }}&quot;
          MAJOR_VERSION=&quot;v${VERSION%%.*}&quot;
          echo &quot;value=${MAJOR_VERSION}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;

      - name: Push Docker image with release tags
        uses: ./.github/actions/common-docker-build
        with:
          context: .
          push: true
          tags: guarzo/wanderer-notifier:latest,guarzo/wanderer-notifier:${{ steps.major_version.outputs.value }},guarzo/wanderer-notifier:v${{ steps.version.outputs.version }}
          build-args: |
            APP_VERSION=${{ steps.version.outputs.full_version }}
            WANDERER_NOTIFIER_API_TOKEN=${{ secrets.NOTIFIER_API_TOKEN }}
          cache-from: type=registry,ref=guarzo/wanderer-notifier:latest
          cache-to: type=inline
          docker_username: guarzo
          docker_password: ${{ secrets.DOCKERHUB_PAT }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: &quot;v${{ steps.version.outputs.version }}&quot;
          name: &quot;Release v${{ steps.version.outputs.version }}&quot;
          body: |
            ## Wanderer Notifier v${{ steps.version.outputs.version }}

            Build: ${{ steps.version.outputs.full_version }}

            ### Docker Image
            ```
            docker pull guarzo/wanderer-notifier:v${{ steps.version.outputs.version }}
            ```
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</file><file path=".github/workflows/test.yml">name: Test
run-name: Test - ${{ github.event.head_commit.message || github.event.pull_request.title }}

on:
  push:
    branches: [main]
    paths-ignore:
      - &quot;mix.exs&quot; # Ignore version bump commits
  pull_request:
    branches: [main]

# Cancel in-progress runs for the same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Build and test
    runs-on: ubuntu-latest
    env:
      DISCORD_BOT_TOKEN: ${{ secrets.FAKE_DISCORD_TOKEN }}
      WANDERER_DISCORD_BOT_TOKEN: ${{ secrets.FAKE_DISCORD_TOKEN }}
      MIX_ENV: &quot;test&quot;
      CACHE_DIR: &quot;/tmp/wanderer_notifier_cache&quot;
      WANDERER_CACHE_DIR: &quot;/tmp/wanderer_notifier_cache&quot;
      WANDERER_NOTIFIER_API_TOKEN: ${{ secrets.NOTIFIER_API_TOKEN }}
    outputs:
      cache-key: ${{ steps.cache-key.outputs.value }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Generate a cache key based on mix.lock and elixir version
      - id: cache-key
        run: |
          echo &quot;value=${{ runner.os }}-mix-${{ hashFiles(&apos;**/mix.lock&apos;) }}-1.18-27&quot; &gt;&gt; $GITHUB_OUTPUT

      - name: Common Checkout and Cache
        uses: ./.github/actions/common-checkout-cache
        with:
          cache-key-prefix: mix-test
          cache-paths: |
            deps
            _build

      - name: Common Elixir Setup for Test
        uses: ./.github/actions/common-elixir-setup
        with:
          elixir-version: &quot;1.18&quot;
          otp-version: &quot;27&quot;

      - name: Install dependencies
        run: |
          mix deps.get
          mix deps.compile

      - name: Compile (warnings as errors)
        run: mix compile --warnings-as-errors

      - name: Run tests
        run: mix test

      - name: Generate test coverage
        run: mix test --cover
        continue-on-error: true

  lint:
    name: Lint code
    runs-on: ubuntu-latest
    needs: test # We depend on test job for the cache
    env:
      MIX_ENV: &quot;dev&quot;
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Common Checkout and Cache
        uses: ./.github/actions/common-checkout-cache
        with:
          cache-key-prefix: mix-lint
          cache-paths: |
            deps
            _build

      - name: Common Elixir Setup for Test
        uses: ./.github/actions/common-elixir-setup
        with:
          elixir-version: &quot;1.18&quot;
          otp-version: &quot;27&quot;

      - name: Install dependencies
        run: |
          mix local.hex --force
          mix deps.get
          mix deps.compile

      - name: Check formatting
        run: mix format --check-formatted

      - name: Run code quality checks
        run: mix credo --strict

  docker:
    name: Validate Docker image
    runs-on: ubuntu-latest
    needs: lint
    env:
      MIX_ENV: prod
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-flags: --debug

      - name: Generate short SHA
        id: sha
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo &quot;short_sha=${SHORT_SHA}&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;
          echo &quot;Using SHA: ${SHORT_SHA}&quot;

      - name: Build Docker image (for testing)
        uses: ./.github/actions/common-docker-build
        with:
          context: .
          push: false
          load: true
          tags: wanderer-notifier:pr-${{ steps.sha.outputs.short_sha }}
          build-args: |
            APP_VERSION=0.0.0-ci-test
            WANDERER_NOTIFIER_API_TOKEN=${{ secrets.NOTIFIER_API_TOKEN }}

      - name: Full Docker validation with web server
        env:
          DISCORD_TOKEN: ${{ secrets.FAKE_DISCORD_TOKEN }}
          MAP_URL_WITH_NAME: &quot;http://example.com/map?name=testmap&quot;
          MAP_TOKEN: &quot;test-map-token&quot;
          DISCORD_CHANNEL_ID: &quot;123456789&quot;
          LICENSE_KEY: &quot;test-license-key&quot;
        run: |
          echo &quot;Running comprehensive Docker validation...&quot;
          chmod +x ./scripts/test_docker_image.sh
          ./scripts/test_docker_image.sh -i wanderer-notifier -t pr-${{ steps.sha.outputs.short_sha }} \
            --discord-token &quot;$DISCORD_TOKEN&quot; \
            --env &quot;WANDERER_MAP_URL=$MAP_URL_WITH_NAME&quot; \
            --env &quot;WANDERER_MAP_TOKEN=$MAP_TOKEN&quot; \
            --env &quot;WANDERER_DISCORD_CHANNEL_ID=$DISCORD_CHANNEL_ID&quot; \
            --env &quot;WANDERER_LICENSE_KEY=$LICENSE_KEY&quot; \
            --env &quot;WANDERER_ENV=test&quot; \
            --env &quot;WANDERER_FEATURE_DISABLE_WEBSOCKET=true&quot;
          echo &quot;Docker image validation successful!&quot;</file><file path="assets/css/style.scss">@import &quot;{{ site.theme }}&quot;;

/* Custom styles */
.main-nav {
  margin-top: 1rem;
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.main-content {
  max-width: 64rem;
  padding: 2rem 6rem;
  margin: 0 auto;
  font-size: 1.1rem;
}

.page-header {
  background-color: #24292e;
  background-image: linear-gradient(120deg, #24292e, #0366d6);
}

@media screen and (max-width: 42em) {
  .main-content {
    padding: 2rem 1rem;
  }
}

/* Image styles */
.main-content img {
  max-width: 100%;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 5px;
  display: block;
  margin: 1rem auto;
  box-shadow: 0 1px 3px rgba(0,0,0,0.12);
}

/* Table styles */
.main-content table {
  width: 100%;
  margin-bottom: 1rem;
  border-collapse: collapse;
}

.main-content table th, 
.main-content table td {
  padding: 0.75rem;
  vertical-align: top;
  border: 1px solid #dee2e6;
}

.main-content table th {
  background-color: #f8f9fa;
}

/* Feature list styling */
.feature-list {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
  margin: 2rem 0;
}

.feature-card {
  border: 1px solid #e1e4e8;
  border-radius: 6px;
  padding: 1.5rem;
  background-color: #f6f8fa;
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.feature-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0,0,0,0.1);
}

.feature-card h3 {
  margin-top: 0;
  border-bottom: 1px solid #eaecef;
  padding-bottom: 0.5rem;
}

/* Code block styles */
.main-content pre {
  background-color: #f6f8fa;
  border-radius: 6px;
  padding: 1rem;
  overflow-x: auto;
}

.main-content code {
  background-color: #f6f8fa;
  padding: 0.2em 0.4em;
  border-radius: 3px;
}</file><file path="assets/package.json">{
  &quot;dependencies&quot;: {
    &quot;@mui/x-date-pickers&quot;: &quot;^7.28.0&quot;
  }
}</file><file path="config/config.exs">import Config

# Set environment based on MIX_ENV at compile time
config :wanderer_notifier, env: config_env()

# Configure HTTP client
config :wanderer_notifier, http_client: WandererNotifier.HttpClient.Httpoison

# Configure MIME types
config :mime, :types, %{
  &quot;text/html&quot; =&gt; [&quot;html&quot;, &quot;htm&quot;],
  &quot;text/css&quot; =&gt; [&quot;css&quot;],
  &quot;application/javascript&quot; =&gt; [&quot;js&quot;],
  &quot;text/javascript&quot; =&gt; [&quot;mjs&quot;],
  &quot;application/json&quot; =&gt; [&quot;json&quot;],
  &quot;image/png&quot; =&gt; [&quot;png&quot;],
  &quot;image/jpeg&quot; =&gt; [&quot;jpg&quot;, &quot;jpeg&quot;],
  &quot;image/svg+xml&quot; =&gt; [&quot;svg&quot;]
}

# Configure MIME extensions preferences
config :mime, :extensions, %{
  &quot;mjs&quot; =&gt; &quot;text/javascript&quot;
}

# Configure websocket defaults
config :wanderer_notifier, :websocket, %{
  enabled: true,
  url: &quot;wss://zkillboard.com/websocket/&quot;,
  reconnect_delay: 5000,
  max_reconnects: 20,
  reconnect_window: 3600
}

# Configure the logger
config :logger,
  level: :info,
  format: &quot;$time [$level] $message\n&quot;,
  backends: [:console]

# Console logger configuration
config :logger, :console,
  format: &quot;$time [$level] $message\n&quot;,
  metadata: [:trace_id],
  colors: [
    debug: :cyan,
    info: :green,
    warn: :yellow,
    error: :red
  ]

# Module-specific log levels
# This allows fine-grained control over logging
config :logger, :module_levels, %{
  &quot;WandererNotifier.Service.KillProcessor&quot; =&gt; :info,
  &quot;WandererNotifier.Core.Maintenance.Scheduler&quot; =&gt; :info,
  &quot;WandererNotifier.Config.Config&quot; =&gt; :info,
  &quot;WandererNotifier.Config.Timings&quot; =&gt; :info,
  &quot;WandererNotifier.ESI.Client&quot; =&gt; :warn,
  &quot;WandererNotifier.Map.Client&quot; =&gt; :info,
  &quot;WandererNotifier.Map.SystemsClient&quot; =&gt; :info,
  &quot;WandererNotifier.Map.CharactersClient&quot; =&gt; :info,
  &quot;WandererNotifier.Notifiers.Discord&quot; =&gt; :info,
  &quot;WandererNotifier.Application&quot; =&gt; :info,
  &quot;WandererNotifier.License.Service&quot; =&gt; :info,
  &quot;WandererNotifier.Core.Stats&quot; =&gt; :info,
  &quot;WandererNotifier.Data.Cache.Helpers&quot; =&gt; :warn,
  &quot;WandererNotifier.Data.Cache&quot; =&gt; :warn,
  &quot;WandererNotifier.Core.Application.Service&quot; =&gt; :info,
  &quot;WandererNotifier.Services.KillProcessor&quot; =&gt; :debug,
  &quot;WandererNotifier.Services.NotificationDeterminer&quot; =&gt; :debug,
  &quot;WandererNotifier.Supervisors.Basic&quot; =&gt; :info,
  &quot;WandererNotifier&quot; =&gt; :info,
  &quot;WandererNotifier.Cache.Helpers&quot; =&gt; :warn,
  &quot;WandererNotifier.Cache&quot; =&gt; :warn
}

# Nostrum compile-time configuration
config :nostrum,
  token: &quot;intentionally invalid for runtime config only&quot;,
  gateway_intents: [],
  cache_guilds: false,
  cache_users: false,
  cache_channels: false,
  caches: [],
  # Disable ffmpeg warnings since we&apos;re not using voice features
  ffmpeg: false

# Add backoff configuration to help with rate limiting
config :nostrum, :gateway,
  backoff: [
    initial: 1000,
    max: 120_000
  ]

# Configure cache
config :wanderer_notifier, cache_name: :wanderer_cache

# Configure service modules
config :wanderer_notifier,
  esi_service: WandererNotifier.ESI.Service,
  cache_impl: WandererNotifier.Cache.CachexImpl

# Import environment specific config. This must remain at the bottom
# of this file so it overrides the configuration defined above.
import_config &quot;#{config_env()}.exs&quot;</file><file path="config/dev.exs">import Config

# Enable hot code reloading
config :exsync,
  reload_timeout: 150,
  reload_callback: {WandererNotifier.Application, :reload},
  extensions: [&quot;.ex&quot;, &quot;.exs&quot;]

# Configure watchers for automatic frontend asset building
config :wanderer_notifier,
  watchers: [
    npm: [&quot;run&quot;, &quot;watch&quot;, cd: Path.expand(&quot;../renderer&quot;, __DIR__)]
  ]

# Set a higher log level in development to see more details
config :logger, level: :info

# Configure both console and file logging
config :logger,
  backends: [:console, {LoggerFileBackend, :debug_log}]

# Include more metadata in development logs
config :logger, :console,
  format: &quot;$time [$level] $message\n&quot;,
  metadata: [:trace_id]

# Configure file logging
config :logger, :debug_log,
  path: &quot;log/debug.log&quot;,
  level: :debug,
  format: &quot;$time [$level] $metadata$message\n&quot;,
  metadata: [:trace_id, :character_id, :kill_count, :killmail_id]

# Set ZKill-specific logs to info level
config :logger,
       :module_levels,
       %{
         # &quot;WandererNotifier.Api.ZKill&quot; =&gt; :info,
         # &quot;WandererNotifier.Api.ZKill.Client&quot; =&gt; :info,
         # &quot;WandererNotifier.Api.ZKill.Service&quot; =&gt; :info,
         # &quot;WandererNotifier.Api.ZKill.Websocket&quot; =&gt; :info
       }</file><file path="config/prod.exs">import Config

# Configure logger with basic settings - using string keys for metadata
config :logger,
  level: :info,
  format: &quot;$time [$level] $message $metadata\n&quot;,
  metadata: [],
  backends: [:console]

# Console logger configuration
config :logger, :console,
  format: &quot;$time [$level] $message $metadata\n&quot;,
  metadata: [],
  colors: [
    debug: :cyan,
    info: :green,
    warn: :yellow,
    error: :red
  ]

# Module-specific log levels for production
# More restrictive to reduce log spam
config :logger, :module_levels, %{
  &quot;WandererNotifier.Service.KillProcessor&quot; =&gt; :warning,
  &quot;WandererNotifier.Core.Maintenance.Scheduler&quot; =&gt; :warning,
  &quot;WandererNotifier.Config.Config&quot; =&gt; :info,
  &quot;WandererNotifier.Config.Timings&quot; =&gt; :info,
  &quot;WandererNotifier.Map.Client&quot; =&gt; :warn,
  &quot;WandererNotifier.Map.SystemsClient&quot; =&gt; :warn,
  &quot;WandererNotifier.Map.CharactersClient&quot; =&gt; :warn,
  &quot;WandererNotifier.Notifiers.Discord&quot; =&gt; :warn
}

# Runtime configuration should be in runtime.exs</file><file path="config/runtime.exs">import Config
import Dotenvy

# Helper to fetch required env vars or raise
fetch_env! = fn var -&gt;
  System.get_env(var) || raise(&quot;Missing ENV: #{var}&quot;)
end

# Load .env file and get all env vars as a map
env_vars = source!(&quot;.env&quot;)

# Explicitly set all .env variables in the process environment
Enum.each(env_vars, fn {k, v} -&gt; System.put_env(k, v) end)

config :nostrum,
  token: fetch_env!.(&quot;WANDERER_DISCORD_BOT_TOKEN&quot;)

config :wanderer_notifier,
  map_token: fetch_env!.(&quot;WANDERER_MAP_TOKEN&quot;),
  api_token: fetch_env!.(&quot;WANDERER_NOTIFIER_API_TOKEN&quot;),
  license_key: fetch_env!.(&quot;WANDERER_LICENSE_KEY&quot;),
  map_url_with_name: fetch_env!.(&quot;WANDERER_MAP_URL&quot;),
  discord_channel_id: fetch_env!.(&quot;WANDERER_DISCORD_CHANNEL_ID&quot;),
  port: (System.get_env(&quot;PORT&quot;) || &quot;4000&quot;) |&gt; String.to_integer(),
  discord_system_kill_channel_id: System.get_env(&quot;WANDERER_DISCORD_SYSTEM_KILL_CHANNEL_ID&quot;) || &quot;&quot;,
  discord_character_kill_channel_id: System.get_env(&quot;WANDERER_CHARACTER_KILL_CHANNEL_ID&quot;) || &quot;&quot;,
  discord_system_channel_id: System.get_env(&quot;WANDERER_SYSTEM_CHANNEL_ID&quot;) || &quot;&quot;,
  discord_character_channel_id: System.get_env(&quot;WANDERER_CHARACTER_CHANNEL_ID&quot;) || &quot;&quot;,
  license_manager_api_url: fetch_env!.(&quot;WANDERER_LICENSE_MANAGER_URL&quot;),
  features: %{
    notifications_enabled: (System.get_env(&quot;WANDERER_NOTIFICATIONS_ENABLED&quot;) || &quot;true&quot;) == &quot;true&quot;,
    character_notifications_enabled:
      (System.get_env(&quot;WANDERER_CHARACTER_NOTIFICATIONS_ENABLED&quot;) || &quot;true&quot;) == &quot;true&quot;,
    system_notifications_enabled:
      (System.get_env(&quot;WANDERER_SYSTEM_NOTIFICATIONS_ENABLED&quot;) || &quot;true&quot;) == &quot;true&quot;,
    kill_notifications_enabled:
      (System.get_env(&quot;WANDERER_KILL_NOTIFICATIONS_ENABLED&quot;) || &quot;true&quot;) == &quot;true&quot;,
    character_tracking_enabled:
      (System.get_env(&quot;WANDERER_CHARACTER_TRACKING_ENABLED&quot;) || &quot;true&quot;) == &quot;true&quot;,
    system_tracking_enabled:
      (System.get_env(&quot;WANDERER_SYSTEM_TRACKING_ENABLED&quot;) || &quot;true&quot;) == &quot;true&quot;,
    status_messages_disabled:
      (System.get_env(&quot;WANDERER_DISABLE_STATUS_MESSAGES&quot;) || &quot;false&quot;) == &quot;true&quot;,
    track_kspace_systems: (System.get_env(&quot;WANDERER_FEATURE_TRACK_KSPACE&quot;) || &quot;true&quot;) == &quot;true&quot;
  },
  character_exclude_list:
    (System.get_env(&quot;WANDERER_CHARACTER_EXCLUDE_LIST&quot;) || &quot;&quot;)
    |&gt; String.split(&quot;,&quot;, trim: true)
    |&gt; Enum.map(&amp;String.trim/1),
  websocket: %{
    reconnect_delay:
      (System.get_env(&quot;WANDERER_WEBSOCKET_RECONNECT_DELAY&quot;) || &quot;5000&quot;) |&gt; String.to_integer(),
    max_reconnects:
      (System.get_env(&quot;WANDERER_WEBSOCKET_MAX_RECONNECTS&quot;) || &quot;20&quot;) |&gt; String.to_integer(),
    reconnect_window:
      (System.get_env(&quot;WANDERER_WEBSOCKET_RECONNECT_WINDOW&quot;) || &quot;3600&quot;) |&gt; String.to_integer()
  },
  cache_dir: System.get_env(&quot;WANDERER_CACHE_DIR&quot;) || &quot;/app/data/cache&quot;,
  public_url: System.get_env(&quot;WANDERER_PUBLIC_URL&quot;),
  host: System.get_env(&quot;WANDERER_HOST&quot;) || &quot;localhost&quot;,
  scheme: System.get_env(&quot;WANDERER_SCHEME&quot;) || &quot;http&quot;</file><file path="config/test.exs">import Config

# Environment-specific configuration
config :wanderer_notifier, :test_env, true
config :wanderer_notifier, :env, :test
config :wanderer_notifier, :disable_status_messages, true

# Test mode configuration
config :nostrum, token: &quot;test_discord_token&quot;

# WandererNotifier test configuration
config :wanderer_notifier,
  discord_bot_token: &quot;test_token&quot;,
  discord_channel_id: &quot;123456789&quot;,
  map_url: &quot;https://example.com&quot;,
  map_token: &quot;test_map_token&quot;,
  test_mode: true,
  minimal_test: WandererNotifier.Config.fetch(&quot;MINIMAL_TEST&quot;, &quot;false&quot;) == &quot;true&quot;,
  features: %{
    notifications_enabled: true,
    character_notifications_enabled: true,
    system_notifications_enabled: true,
    kill_notifications_enabled: true,
    character_tracking_enabled: true,
    system_tracking_enabled: true,
    tracked_systems_notifications_enabled: true,
    tracked_characters_notifications_enabled: true,
    status_messages_disabled: true,
    track_kspace_systems: true
  },
  cache_repository: WandererNotifier.Data.Cache.RepositoryMock,
  esi_service: WandererNotifier.ESI.ServiceMock

# Configure cache
config :wanderer_notifier, :cache_dir, &quot;test/cache&quot;

# Logger configuration for tests
config :logger, level: :warning
config :logger, :console, format: &quot;[$level] $message\n&quot;</file><file path="lib/wanderer_notifier/api/controllers/health_controller.ex">defmodule WandererNotifier.Api.Controllers.HealthController do
  @moduledoc &quot;&quot;&quot;
  Controller for health check endpoints.
  &quot;&quot;&quot;
  use Plug.Router
  import WandererNotifier.Api.Controller

  plug(:match)

  plug(Plug.Parsers,
    parsers: [:json],
    pass: [&quot;application/json&quot;],
    json_decoder: Jason
  )

  plug(:dispatch)

  # Health check endpoint
  get &quot;/&quot; do
    send_success(conn, %{status: &quot;OK&quot;})
  end

  # Support HEAD requests for health checks
  head &quot;/&quot; do
    send_success(conn, %{status: &quot;OK&quot;})
  end

  match _ do
    send_error(conn, 404, &quot;not_found&quot;)
  end
end</file><file path="lib/wanderer_notifier/api/controllers/kill_controller.ex">defmodule WandererNotifier.Api.Controllers.KillController do
  @moduledoc &quot;&quot;&quot;
  Controller for kill-related endpoints.
  &quot;&quot;&quot;
  use Plug.Router
  import WandererNotifier.Api.Controller

  plug(:match)

  plug(Plug.Parsers,
    parsers: [:json],
    pass: [&quot;application/json&quot;],
    json_decoder: Jason
  )

  plug(:dispatch)

  alias WandererNotifier.Killmail.Cache
  alias WandererNotifier.Killmail.Processor
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Get recent kills
  get &quot;/recent&quot; do
    case get_recent_kills(conn) do
      {:ok, kills} -&gt;
        send_success(conn, kills)

      _error -&gt;
        send_resp(conn, 200, &quot;world&quot;)
    end
  end

  # Get kill details
  get &quot;/kill/:kill_id&quot; do
    case Cache.get_kill(kill_id) do
      {:ok, kill} -&gt; send_success(conn, kill)
      {:error, :not_cached} -&gt; send_error(conn, 404, &quot;Kill not found in cache&quot;)
      {:error, :not_found} -&gt; send_error(conn, 404, &quot;Kill not found&quot;)
      {:error, reason} -&gt; send_error(conn, 500, reason)
    end
  end

  # Get killmail list
  get &quot;/kills&quot; do
    kills = WandererNotifier.Killmail.Cache.get_latest_killmails()
    send_success(conn, kills)
  end

  match _ do
    send_error(conn, 404, &quot;not_found&quot;)
  end

  # Private functions
  defp get_recent_kills(conn) do
    {:ok, Processor.get_recent_kills()}
  rescue
    error -&gt;
      AppLogger.api_error(&quot;Error getting recent kills&quot;, %{
        error: inspect(error),
        stacktrace: Exception.format_stacktrace(__STACKTRACE__)
      })

      send_error(conn, 500, &quot;An unexpected error occurred&quot;)
  end
end</file><file path="lib/wanderer_notifier/api/controllers/notification_controller.ex">defmodule WandererNotifier.Api.Controllers.NotificationController do
  @moduledoc &quot;&quot;&quot;
  Controller for notification-related endpoints.
  &quot;&quot;&quot;
  use Plug.Router
  import WandererNotifier.Api.Controller

  plug(:match)

  plug(Plug.Parsers,
    parsers: [:json],
    pass: [&quot;application/json&quot;],
    json_decoder: Jason
  )

  plug(:dispatch)

  alias WandererNotifier.Config
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Notifiers.Helpers.TestNotifications, as: NotificationHelpers

  # Get notification settings
  get &quot;/settings&quot; do
    case get_notification_settings(conn) do
      {:ok, settings} -&gt;
        send_success(conn, settings)

      _error -&gt;
        send_resp(conn, 404, &quot;oops&quot;)
    end
  end

  # Send test notification
  post &quot;/test&quot; do
    type = conn.body_params[&quot;type&quot;] || &quot;kill&quot;

    result =
      case type do
        &quot;kill&quot; -&gt; NotificationHelpers.send_test_kill_notification()
        &quot;character&quot; -&gt; NotificationHelpers.send_test_character_notification()
        &quot;system&quot; -&gt; NotificationHelpers.send_test_system_notification()
        _ -&gt; {:error, &quot;Invalid notification type&quot;}
      end

    case result do
      {:ok, _} -&gt; send_success(conn, %{message: &quot;Test notification sent&quot;})
      {:error, reason} -&gt; send_error(conn, 400, reason)
    end
  end

  match _ do
    send_error(conn, 404, &quot;not_found&quot;)
  end

  # Private functions
  defp get_notification_settings(conn) do
    settings = %{
      channels: Config.discord_channel_id(),
      features: Config.features(),
      limits: Config.get_all_limits()
    }

    {:ok, settings}
  rescue
    error -&gt;
      AppLogger.api_error(&quot;Error getting notification settings&quot;, %{
        error: inspect(error),
        stacktrace: Exception.format_stacktrace(__STACKTRACE__)
      })

      send_error(conn, 500, &quot;An unexpected error occurred&quot;)
  end
end</file><file path="lib/wanderer_notifier/api/controllers/web_controller.ex">defmodule WandererNotifier.Api.Controllers.WebController do
  @moduledoc &quot;&quot;&quot;
  Controller for debug-related endpoints.
  &quot;&quot;&quot;
  use Plug.Router
  import WandererNotifier.Api.Controller

  plug(:match)

  plug(Plug.Parsers,
    parsers: [:json],
    pass: [&quot;application/json&quot;],
    json_decoder: Jason
  )

  plug(:dispatch)

  alias WandererNotifier.Core.Stats
  alias WandererNotifier.Config
  alias WandererNotifier.License.Service, as: License
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Get service status
  get &quot;/status&quot; do
    case get_service_status(conn) do
      {:ok, status} -&gt;
        send_success(conn, status)

      _error -&gt;
        send_resp(conn, 404, &quot;oops&quot;)
    end
  end

  # Get service stats
  get &quot;/stats&quot; do
    stats = get_stats_safely()
    send_success(conn, stats)
  end

  # Get scheduler stats
  get &quot;/scheduler-stats&quot; do
    scheduler_info = WandererNotifier.Schedulers.Registry.all_schedulers()

    # Transform scheduler info into a more friendly format
    formatted_schedulers =
      Enum.map(scheduler_info, fn %{module: module, enabled: enabled, config: config} -&gt;
        name =
          module
          |&gt; to_string()
          |&gt; String.split(&quot;.&quot;)
          |&gt; List.last()
          |&gt; String.replace(&quot;Scheduler&quot;, &quot;&quot;)

        type = if Map.has_key?(config, :interval), do: &quot;interval&quot;, else: &quot;time&quot;

        %{
          name: name,
          type: type,
          enabled: enabled,
          interval: Map.get(config, :interval),
          hour: Map.get(config, :hour),
          minute: Map.get(config, :minute),
          last_run: Map.get(config, :last_run),
          next_run: Map.get(config, :next_run),
          stats:
            Map.get(config, :stats, %{
              success_count: 0,
              error_count: 0,
              last_duration_ms: nil
            })
        }
      end)

    send_success(conn, %{
      schedulers: formatted_schedulers,
      summary: %{
        total: length(formatted_schedulers),
        enabled: Enum.count(formatted_schedulers, &amp; &amp;1.enabled),
        disabled: Enum.count(formatted_schedulers, &amp;(!&amp;1.enabled))
      }
    })
  end

  # Execute a specific scheduler
  post &quot;/schedulers/:name/execute&quot; do
    scheduler_name = conn.params[&quot;name&quot;]

    # Find the scheduler module
    scheduler_module =
      WandererNotifier.Schedulers.Registry.all_schedulers()
      |&gt; Enum.find(fn %{module: module} -&gt;
        module
        |&gt; to_string()
        |&gt; String.split(&quot;.&quot;)
        |&gt; List.last()
        |&gt; String.replace(&quot;Scheduler&quot;, &quot;&quot;) == scheduler_name
      end)

    case scheduler_module do
      %{module: module, enabled: true} -&gt;
        # Execute the scheduler
        module.run()
        send_success(conn, %{message: &quot;Scheduler execution triggered&quot;})

      %{enabled: false} -&gt;
        send_error(conn, 400, &quot;Scheduler is disabled&quot;)

      nil -&gt;
        send_error(conn, 404, &quot;Scheduler not found&quot;)
    end
  end

  # Execute all schedulers
  post &quot;/schedulers/execute&quot; do
    WandererNotifier.Schedulers.Registry.all_schedulers()
    |&gt; Enum.each(fn %{module: module, enabled: enabled} -&gt;
      if enabled, do: module.run()
    end)
    send_success(conn, %{message: &quot;All schedulers execution triggered&quot;})
  end

  match _ do
    send_error(conn, 404, &quot;not_found&quot;)
  end

  # Private functions

  defp get_service_status(conn) do
    AppLogger.api_info(&quot;Starting status endpoint processing&quot;)

    # Get license status safely
    AppLogger.api_info(&quot;Fetching license status&quot;)
    license_result = License.validate()
    AppLogger.api_info(&quot;License status result&quot;, %{result: inspect(license_result)})

    license_status = %{
      valid: license_result.valid,
      bot_assigned: license_result.bot_assigned,
      details: license_result.details,
      error: license_result.error,
      error_message: license_result.error_message,
      last_validated: license_result.last_validated
    }

    # Get stats safely
    AppLogger.api_info(&quot;Fetching stats&quot;)
    stats = get_stats_safely()

    # Get features and limits
    AppLogger.api_info(&quot;Fetching features and limits&quot;)
    features = Config.features()
    limits = Config.get_all_limits()

    # Build response
    {:ok,
     %{
       license: license_status,
       stats: stats,
       features: features,
       limits: limits
     }}
  rescue
    error -&gt;
      AppLogger.api_error(&quot;Error in debug status&quot;, %{
        error: inspect(error),
        stacktrace: Exception.format_stacktrace(__STACKTRACE__)
      })

      send_error(conn, 500, &quot;An unexpected error occurred&quot;)
  end

  defp get_stats_safely do
    case Stats.get_stats() do
      nil -&gt;
        AppLogger.api_warn(&quot;Stats.get_stats() returned nil&quot;)
        create_default_stats()

      stats when not is_map_key(stats, :notifications) or not is_map_key(stats, :websocket) -&gt;
        AppLogger.api_warn(&quot;Stats.get_stats() returned incomplete data: #{inspect(stats)}&quot;)
        create_default_stats()

      stats -&gt;
        AppLogger.api_info(&quot;Stats retrieved successfully&quot;, %{stats: inspect(stats)})
        stats
    end
  rescue
    error -&gt;
      AppLogger.api_error(&quot;Error getting stats&quot;, %{
        error: inspect(error),
        stacktrace: Exception.format_stacktrace(__STACKTRACE__)
      })

      create_default_stats()
  end

  defp create_default_stats do
    %{
      notifications: %{
        total: 0,
        success: 0,
        error: 0
      },
      websocket: %{
        connected: false,
        last_message: nil
      }
    }
  end
end</file><file path="lib/wanderer_notifier/api/controller.ex">defmodule WandererNotifier.Api.Controller do
  @moduledoc &quot;&quot;&quot;
  Base controller module that provides common functionality
  &quot;&quot;&quot;

  import Plug.Conn

  @doc &quot;&quot;&quot;
  Sends a JSON response
  &quot;&quot;&quot;
  def send_json_response(conn, status, data) do
    conn
    |&gt; put_resp_content_type(&quot;application/json&quot;)
    |&gt; send_resp(status, Jason.encode!(data))
  end

  @doc &quot;&quot;&quot;
  Sends a success response
  &quot;&quot;&quot;
  def send_success(conn, data) do
    send_json_response(conn, 200, data)
  end

  @doc &quot;&quot;&quot;
  Sends an error response
  &quot;&quot;&quot;
  def send_error(conn, status, message) do
    send_json_response(conn, status, %{error: message})
  end
end</file><file path="lib/wanderer_notifier/cache/behaviour.ex">defmodule WandererNotifier.Cache.Behaviour do
  @moduledoc &quot;&quot;&quot;
  Defines the behaviour for cache implementations.
  This is a unified behavior that combines functionality from both repository and cache operations.

  ## Implementation Guidelines

  1. Cache implementations should handle:
     - Basic CRUD operations (get/set/delete)
     - TTL support
     - Atomic updates
     - Batch operations
     - Error handling

  2. Error handling:
     - All operations should return {:ok, value} or {:error, reason}
     - Not found should be {:error, :not_found}
     - Implementation errors should provide meaningful error reasons

  3. Performance considerations:
     - Implementations should be optimized for high-volume operations
     - Consider using batch operations where possible
     - Handle concurrent access appropriately
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Gets a value from the cache by key.
  Returns {:ok, value} if found, {:error, :not_found} if not found, or {:error, reason} on error.
  &quot;&quot;&quot;
  @callback get(key :: any()) :: {:ok, any()} | {:error, :not_found | any()}

  @doc &quot;&quot;&quot;
  Sets a value in the cache with an optional TTL in seconds.
  &quot;&quot;&quot;
  @callback set(key :: any(), value :: any(), ttl :: non_neg_integer() | nil) ::
              :ok | {:ok, any()} | {:error, any()}

  @doc &quot;&quot;&quot;
  Puts a value in the cache without TTL.
  &quot;&quot;&quot;
  @callback put(key :: any(), value :: any()) :: :ok | {:ok, any()} | {:error, any()}

  @doc &quot;&quot;&quot;
  Deletes a value from the cache by key.
  &quot;&quot;&quot;
  @callback delete(key :: any()) :: :ok | {:ok, any()} | {:error, any()}

  @doc &quot;&quot;&quot;
  Clears the entire cache.
  &quot;&quot;&quot;
  @callback clear() :: :ok | {:ok, any()} | {:error, any()}

  @doc &quot;&quot;&quot;
  Gets and updates a value atomically using the provided update function.
  The update function receives the current value (or nil) and should return {current_value, new_value}.
  &quot;&quot;&quot;
  @callback get_and_update(key :: any(), update_fun :: (any() -&gt; {any(), any()})) ::
              {:ok, any()} | {:error, any()}

  @doc &quot;&quot;&quot;
  Gets recent kills from cache.
  This is a specialized function that was part of the repository behavior.
  &quot;&quot;&quot;
  @callback get_recent_kills() :: list()

  @doc &quot;&quot;&quot;
  Initializes batch logging for cache operations.
  &quot;&quot;&quot;
  @callback init_batch_logging() :: :ok

  @optional_callbacks [
    get_recent_kills: 0,
    init_batch_logging: 0
  ]
end</file><file path="lib/wanderer_notifier/cache/cachex_impl.ex">defmodule WandererNotifier.Cache.CachexImpl do
  @moduledoc &quot;&quot;&quot;
  Cachex-based implementation of the cache behaviour.
  Provides a high-performance cache implementation using Cachex.

  Features:
  - TTL support
  - Atomic operations
  - Batch operation support
  - Comprehensive error handling
  - Logging and monitoring
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Cache.Behaviour

  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Cache.Keys

  @cache_name Application.compile_env(:wanderer_notifier, :cache_name, :wanderer_cache)

  @impl true
  def init_batch_logging do
    AppLogger.init_batch_logger()
  end

  @impl true
  def get(key) do
    case Cachex.get(@cache_name, key) do
      {:ok, nil} -&gt; {:error, :not_found}
      {:ok, value} -&gt; {:ok, value}
      {:error, reason} -&gt; {:error, reason}
    end
  rescue
    e -&gt;
      AppLogger.cache_error(&quot;Error getting value&quot;,
        key: key,
        error: Exception.message(e)
      )

      {:error, e}
  end

  @impl true
  def set(key, value, ttl) do
    AppLogger.cache_debug(&quot;Setting cache value with TTL&quot;,
      key: key,
      ttl_seconds: ttl
    )

    result =
      if is_nil(ttl) do
        Cachex.put(@cache_name, key, value)
      else
        Cachex.put(@cache_name, key, value, ttl: :timer.seconds(ttl))
      end

    case result do
      {:ok, true} -&gt; :ok
      {:ok, false} -&gt; {:error, :set_failed}
      {:error, reason} -&gt; {:error, reason}
    end
  rescue
    e -&gt;
      AppLogger.cache_error(&quot;Error setting value with TTL&quot;,
        key: key,
        ttl_seconds: ttl,
        error: Exception.message(e)
      )

      {:error, e}
  end

  @impl true
  def put(key, value) do
    # For high-volume sets, we&apos;ll use batch logging
    AppLogger.count_batch_event(:cache_set, %{key_pattern: get_key_pattern(key)})

    case Cachex.put(@cache_name, key, value) do
      {:ok, true} -&gt; :ok
      {:ok, false} -&gt; {:error, :set_failed}
      {:error, reason} -&gt; {:error, reason}
    end
  rescue
    e -&gt;
      AppLogger.cache_error(&quot;Error setting value&quot;,
        key: key,
        error: Exception.message(e)
      )

      {:error, e}
  end

  @impl true
  def delete(key) do
    AppLogger.cache_debug(&quot;Deleting cache key&quot;, key: key)

    case Cachex.del(@cache_name, key) do
      {:ok, true} -&gt; :ok
      {:ok, false} -&gt; {:error, :not_found}
      {:error, reason} -&gt; {:error, reason}
    end
  rescue
    e -&gt;
      AppLogger.cache_error(&quot;Error deleting key&quot;,
        key: key,
        error: Exception.message(e)
      )

      {:error, e}
  end

  @impl true
  def clear do
    AppLogger.cache_info(&quot;Clearing entire cache&quot;)

    case Cachex.clear(@cache_name) do
      {:ok, true} -&gt; :ok
      {:ok, false} -&gt; {:error, :clear_failed}
      {:error, reason} -&gt; {:error, reason}
    end
  rescue
    e -&gt;
      AppLogger.cache_error(&quot;Error clearing cache&quot;,
        error: Exception.message(e)
      )

      {:error, e}
  end

  @impl true
  def get_and_update(key, update_fun) do
    try do
      Cachex.get_and_update(@cache_name, key, fn
        nil -&gt;
          {current, updated} = update_fun.(nil)
          {current, updated}

        existing -&gt;
          {current, updated} = update_fun.(existing)
          {current, updated}
      end)
    rescue
      e -&gt;
        AppLogger.cache_error(&quot;Error in get_and_update&quot;,
          key: key,
          error: Exception.message(e)
        )

        {:error, e}
    end
  end

  @impl true
  def get_recent_kills do
    case get(Keys.zkill_recent_kills()) do
      {:ok, kills} -&gt; kills
      _ -&gt; []
    end
  end

  # Helper to extract a pattern from the key for batch logging
  defp get_key_pattern(key) when is_binary(key) do
    # If key has a colon, take the part before the colon, otherwise use as-is
    case String.split(key, &quot;:&quot;, parts: 2) do
      [prefix, _] -&gt; &quot;#{prefix}:&quot;
      _ -&gt; key
    end
  end

  defp get_key_pattern(key), do: inspect(key)
end</file><file path="lib/wanderer_notifier/cache/keys.ex">defmodule WandererNotifier.Cache.Keys do
  @moduledoc &quot;&quot;&quot;
  Module for generating and validating cache keys.
  Provides functions for creating standardized cache keys for various data types.

  This module provides functions for generating and validating cache keys,
  ensuring consistent naming conventions across the application.

  Key Format: `prefix:entity_type:id` or `prefix:name`
  Examples:
    - `map:system:12345`
    - `tracked:character:98765`
    - `recent:kills`
  &quot;&quot;&quot;

  # Key prefixes
  # For mapping data (systems, characters)
  @prefix_map &quot;map&quot;
  # For tracked entities
  @prefix_tracked &quot;tracked&quot;
  # For ESI API data
  @prefix_esi &quot;esi&quot;
  # For zKillboard data
  @prefix_zkill &quot;zkill&quot;
  # For recent/list data
  @prefix_recent &quot;recent&quot;
  # For existence checks
  @prefix_exists &quot;exists&quot;
  # For application state
  @prefix_state &quot;state&quot;
  # For configuration
  @prefix_config &quot;config&quot;
  # For critical application data
  @prefix_critical &quot;critical&quot;
  # For array data
  @prefix_array &quot;array&quot;
  # For list data
  @prefix_list &quot;list&quot;
  # For general data
  @prefix_data &quot;data&quot;

  # Entity types
  @entity_system &quot;system&quot;
  @entity_character &quot;character&quot;
  @entity_killmail &quot;killmail&quot;
  @entity_kills &quot;kills&quot;
  @entity_corporation &quot;corporation&quot;
  @entity_alliance &quot;alliance&quot;

  # Separator
  @separator &quot;:&quot;

  @doc &quot;&quot;&quot;
  Generates a cache key for system data.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.system(30004759)
      &quot;map:system:30004759&quot;
  &quot;&quot;&quot;
  @spec system(integer() | String.t()) :: String.t()
  def system(id) when is_integer(id) or is_binary(id) do
    join_parts([@prefix_map, @entity_system, to_string(id)])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for character data.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.character(12345)
      &quot;map:character:12345&quot;
  &quot;&quot;&quot;
  @spec character(integer() | String.t()) :: String.t()
  def character(id) when is_integer(id) or is_binary(id) do
    join_parts([@prefix_map, @entity_character, to_string(id)])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for a tracked system.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.tracked_system(30004759)
      &quot;tracked:system:30004759&quot;
  &quot;&quot;&quot;
  @spec tracked_system(integer() | String.t()) :: String.t()
  def tracked_system(id) when is_integer(id) or is_binary(id) do
    join_parts([@prefix_tracked, @entity_system, to_string(id)])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for a tracked character.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.tracked_character(12345)
      &quot;tracked:character:12345&quot;
  &quot;&quot;&quot;
  @spec tracked_character(integer() | String.t()) :: String.t()
  def tracked_character(id) when is_integer(id) or is_binary(id) do
    join_parts([@prefix_tracked, @entity_character, to_string(id)])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for ESI killmail data.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.esi_killmail(12345)
      &quot;esi:killmail:12345&quot;
  &quot;&quot;&quot;
  @spec esi_killmail(integer() | String.t()) :: String.t()
  def esi_killmail(id) when is_integer(id) or is_binary(id) do
    join_parts([@prefix_esi, @entity_killmail, to_string(id)])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for recent kills.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.recent_kills()
      &quot;recent:kills&quot;
  &quot;&quot;&quot;
  @spec recent_kills() :: String.t()
  def recent_kills do
    join_parts([@prefix_recent, @entity_kills])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for checking if a killmail exists.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.killmail_exists(12345, 67890, &quot;victim&quot;)
      &quot;exists:killmail:12345:67890:victim&quot;
  &quot;&quot;&quot;
  @spec killmail_exists(integer() | String.t(), integer() | String.t(), String.t()) :: String.t()
  def killmail_exists(killmail_id, character_id, role)
      when (is_integer(killmail_id) or is_binary(killmail_id)) and
             (is_integer(character_id) or is_binary(character_id)) and
             is_binary(role) do
    join_parts([
      @prefix_exists,
      @entity_killmail,
      to_string(killmail_id),
      to_string(character_id),
      role
    ])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for a character&apos;s recent kills.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.character_recent_kills(12345)
      &quot;character:12345:recent_kills&quot;
  &quot;&quot;&quot;
  @spec character_recent_kills(integer() | String.t()) :: String.t()
  def character_recent_kills(character_id)
      when is_integer(character_id) or is_binary(character_id) do
    join_parts([@entity_character, to_string(character_id), &quot;recent_kills&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the character list.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.character_list()
      &quot;map:characters&quot;
  &quot;&quot;&quot;
  @spec character_list() :: String.t()
  def character_list do
    join_parts([@prefix_map, &quot;characters&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for kill comparison data.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.kill_comparison(&quot;daily&quot;, &quot;date=2023-05-01&quot;)
      &quot;kill_comparison:daily:date=2023-05-01&quot;
  &quot;&quot;&quot;
  @spec kill_comparison(String.t(), String.t()) :: String.t()
  def kill_comparison(type, params) when is_binary(type) and is_binary(params) do
    join_parts([&quot;kill_comparison&quot;, type, params])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for zkill recent kills.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.zkill_recent_kills()
      &quot;zkill:recent_kills&quot;
  &quot;&quot;&quot;
  @spec zkill_recent_kills() :: String.t()
  def zkill_recent_kills do
    join_parts([@prefix_zkill, &quot;recent_kills&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the tracked systems list.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.tracked_systems_list()
      &quot;tracked:systems&quot;
  &quot;&quot;&quot;
  @spec tracked_systems_list() :: String.t()
  def tracked_systems_list do
    join_parts([@prefix_tracked, &quot;systems&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the tracked characters list.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.tracked_characters_list()
      &quot;tracked:characters&quot;
  &quot;&quot;&quot;
  @spec tracked_characters_list() :: String.t()
  def tracked_characters_list do
    join_parts([@prefix_tracked, &quot;characters&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the map systems list.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.map_systems()
      &quot;map:systems&quot;
  &quot;&quot;&quot;
  @spec map_systems() :: String.t()
  def map_systems do
    join_parts([@prefix_map, &quot;systems&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the map system IDs list.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.map_system_ids()
      &quot;map:system_ids&quot;
  &quot;&quot;&quot;
  @spec map_system_ids() :: String.t()
  def map_system_ids do
    join_parts([@prefix_map, &quot;system_ids&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the critical startup data.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.critical_startup_data()
      &quot;critical:startup_data&quot;
  &quot;&quot;&quot;
  @spec critical_startup_data() :: String.t()
  def critical_startup_data do
    join_parts([@prefix_critical, &quot;startup_data&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the systems array.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.systems_array()
      &quot;array:systems&quot;
  &quot;&quot;&quot;
  @spec systems_array() :: String.t()
  def systems_array do
    join_parts([@prefix_array, &quot;systems&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the killmails array.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.killmails_array()
      &quot;array:killmails&quot;
  &quot;&quot;&quot;
  @spec killmails_array() :: String.t()
  def killmails_array do
    join_parts([@prefix_array, &quot;killmails&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the recent killmails list.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.recent_killmails_list()
      &quot;list:recent_killmails&quot;
  &quot;&quot;&quot;
  @spec recent_killmails_list() :: String.t()
  def recent_killmails_list do
    join_parts([@prefix_list, &quot;recent_killmails&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for the application state.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.application_state()
      &quot;state:application&quot;
  &quot;&quot;&quot;
  @spec application_state() :: String.t()
  def application_state do
    join_parts([@prefix_state, &quot;application&quot;])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for configuration.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.config(&quot;websocket&quot;)
      &quot;config:websocket&quot;
  &quot;&quot;&quot;
  @spec config(String.t()) :: String.t()
  def config(name) when is_binary(name) do
    join_parts([@prefix_config, name])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for zkill data.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.zkill_data(&quot;characterID&quot;, 12345)
      &quot;zkill:characterID:12345&quot;
  &quot;&quot;&quot;
  @spec zkill_data(String.t(), integer() | String.t()) :: String.t()
  def zkill_data(type, id) when is_binary(type) and (is_integer(id) or is_binary(id)) do
    join_parts([@prefix_zkill, type, to_string(id)])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for ESI data.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.esi_data(&quot;character&quot;, 12345)
      &quot;esi:character:12345&quot;
  &quot;&quot;&quot;
  @spec esi_data(String.t(), integer() | String.t()) :: String.t()
  def esi_data(type, id) when is_binary(type) and (is_integer(id) or is_binary(id)) do
    join_parts([@prefix_esi, type, to_string(id)])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for general data.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.data(&quot;some_key&quot;)
      &quot;data:some_key&quot;
  &quot;&quot;&quot;
  @spec data(String.t()) :: String.t()
  def data(key) when is_binary(key) do
    join_parts([@prefix_data, key])
  end

  @doc &quot;&quot;&quot;
  Validates if a key follows the standard pattern.

  ## Parameters
    - key: The cache key to validate

  ## Returns
    - true if key is valid
    - false if key is not valid

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.valid?(&quot;map:system:12345&quot;)
      true

      iex&gt; WandererNotifier.Cache.Keys.valid?(&quot;invalid-key&quot;)
      false
  &quot;&quot;&quot;
  @spec valid?(String.t()) :: boolean()
  def valid?(key) when is_binary(key) do
    # Pattern: at least one segment with a separator
    # Must have at least two parts
    String.contains?(key, @separator) &amp;&amp;
      length(String.split(key, @separator)) &gt;= 2
  end

  def valid?(_), do: false

  @doc &quot;&quot;&quot;
  Extracts components from a key based on a pattern.

  ## Parameters
    - key: The cache key to extract from
    - pattern: The pattern to match against

  ## Returns
    - List of extracted components if successful
    - Empty list if no match

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.extract_pattern(&quot;map:system:12345&quot;, &quot;map:system:*&quot;)
      [&quot;12345&quot;]

      iex&gt; WandererNotifier.Cache.Keys.extract_pattern(&quot;map:character:98765&quot;, &quot;map:*:*&quot;)
      [&quot;character&quot;, &quot;98765&quot;]
  &quot;&quot;&quot;
  @spec extract_pattern(String.t(), String.t()) :: list(String.t())
  def extract_pattern(key, pattern) when is_binary(key) and is_binary(pattern) do
    key_parts = String.split(key, @separator)
    pattern_parts = String.split(pattern, @separator)

    # Only continue if the parts match in length
    if length(key_parts) == length(pattern_parts) do
      extract_matching_parts(key_parts, pattern_parts, [])
    else
      []
    end
  end

  def extract_pattern(_, _), do: []

  # Helper function to extract matching parts
  defp extract_matching_parts([], [], acc), do: Enum.reverse(acc)

  defp extract_matching_parts([key_part | key_rest], [&quot;*&quot; | pattern_rest], acc) do
    # Wildcard matches any value, so add the key part to accumulator
    extract_matching_parts(key_rest, pattern_rest, [key_part | acc])
  end

  defp extract_matching_parts([key_part | key_rest], [pattern_part | pattern_rest], acc) do
    # Check if the parts match exactly
    if key_part == pattern_part do
      extract_matching_parts(key_rest, pattern_rest, acc)
    else
      # Pattern doesn&apos;t match
      []
    end
  end

  @doc &quot;&quot;&quot;
  Returns detailed information about a cache key.

  ## Parameters
    - key: The cache key to analyze

  ## Returns
    - Map with key details if valid
    - {:error, :invalid_key} if invalid

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.map_key_info(&quot;map:system:12345&quot;)
      %{
        prefix: &quot;map&quot;,
        entity_type: &quot;system&quot;,
        id: &quot;12345&quot;,
        parts: [&quot;map&quot;, &quot;system&quot;, &quot;12345&quot;]
      }
  &quot;&quot;&quot;
  @spec map_key_info(String.t()) :: map() | {:error, :invalid_key}
  def map_key_info(key) when is_binary(key) do
    if valid?(key) do
      parts = String.split(key, @separator)

      case parts do
        # Standard format: prefix:entity_type:id
        [prefix, entity_type, id | rest] -&gt;
          %{
            prefix: prefix,
            entity_type: entity_type,
            id: id,
            parts: parts,
            extra: rest
          }

        # Simple format: prefix:name
        [prefix, name] -&gt;
          %{
            prefix: prefix,
            name: name,
            parts: parts
          }

        _ -&gt;
          %{
            parts: parts
          }
      end
    else
      {:error, :invalid_key}
    end
  end

  def map_key_info(_), do: {:error, :invalid_key}

  # Private helper function to join parts with separator
  defp join_parts(parts) when is_list(parts) do
    Enum.join(parts, @separator)
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for tracked systems.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.tracked_systems()
      &quot;tracked:systems&quot;
  &quot;&quot;&quot;
  @spec tracked_systems() :: String.t()
  def tracked_systems do
    tracked_systems_list()
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for a killmail.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.killmail(12345, &quot;abc123&quot;)
      &quot;esi:killmail:12345:abc123&quot;
  &quot;&quot;&quot;
  @spec killmail(integer() | String.t(), String.t()) :: String.t()
  def killmail(kill_id, killmail_hash)
      when (is_integer(kill_id) or is_binary(kill_id)) and is_binary(killmail_hash) do
    join_parts([@prefix_esi, @entity_killmail, to_string(kill_id), killmail_hash])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for a corporation.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.corporation(12345)
      &quot;esi:corporation:12345&quot;
  &quot;&quot;&quot;
  @spec corporation(integer() | String.t()) :: String.t()
  def corporation(corporation_id) when is_integer(corporation_id) or is_binary(corporation_id) do
    join_parts([@prefix_esi, @entity_corporation, to_string(corporation_id)])
  end

  @doc &quot;&quot;&quot;
  Generates a cache key for an alliance.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.alliance(12345)
      &quot;esi:alliance:12345&quot;
  &quot;&quot;&quot;
  @spec alliance(integer() | String.t()) :: String.t()
  def alliance(alliance_id) when is_integer(alliance_id) or is_binary(alliance_id) do
    join_parts([@prefix_esi, @entity_alliance, to_string(alliance_id)])
  end

  @spec alliance(integer() | String.t()) :: String.t() | nil
  def alliance(nil), do: nil

  @doc &quot;&quot;&quot;
  Generates a cache key for a ship type.

  ## Examples
      iex&gt; WandererNotifier.Cache.Keys.ship_type(12345)
      &quot;esi:ship_type:12345&quot;
  &quot;&quot;&quot;
  @spec ship_type(integer() | String.t()) :: String.t()
  def ship_type(ship_type_id) when is_integer(ship_type_id) or is_binary(ship_type_id) do
    join_parts([@prefix_esi, &quot;ship_type&quot;, to_string(ship_type_id)])
  end

  @doc &quot;&quot;&quot;
  Returns the cache key for a system.
  &quot;&quot;&quot;
  def system_key(system_id) when is_integer(system_id), do: system(system_id)

end</file><file path="lib/wanderer_notifier/config/config.ex">defmodule WandererNotifier.Config do
  @moduledoc &quot;&quot;&quot;
  Centralized configuration access for WandererNotifier.

  Provides grouped functions for:
    - General app config
    - Map settings
    - Debug/logging
    - Notifications
    - Features
    - Websocket
    - Cache
    - License
    - Web/server
    - API
  &quot;&quot;&quot;
  # --- General ENV helpers ---
  def fetch!(key), do: System.get_env(key) || raise(&quot;Missing ENV: #{key}&quot;)
  def fetch(key, default \\ nil), do: System.get_env(key) || default
  def fetch_int(key, default), do: fetch(key) |&gt; parse_int(default)
  defp parse_int(nil, default), do: default

  defp parse_int(str, default) do
    case Integer.parse(str) do
      {i, _} -&gt; i
      :error -&gt; default
    end
  end

  # --- General Application config ---
  def get(key, default \\ nil), do: Application.get_env(:wanderer_notifier, key, default)

  # --- Map config ---
  def map_url do
    raise &quot;map_url/0 is deprecated. Use map_url_with_name/0 and parse as needed.&quot;
  end

  def map_token do
    value = get(:map_token)
    value
  end

  def map_name do
    value = get(:map_name)
    value
  end

  def map_url_with_name, do: get(:map_url_with_name)
  def map_csrf_token, do: get(:map_csrf_token)

  def map_slug do
    url = map_url_with_name()
    uri = URI.parse(url || &quot;&quot;)
    slug = uri.path |&gt; String.trim(&quot;/&quot;) |&gt; String.split(&quot;/&quot;) |&gt; List.last()
    slug
  end

  def map_api_key, do: get(:map_api_key, &quot;&quot;)
  def static_info_cache_ttl, do: get(:static_info_cache_ttl, 3600)

  # --- Debug config ---
  def debug_logging_enabled?, do: get(:debug_logging_enabled, false)
  def toggle_debug_logging, do: set(:debug_logging_enabled, !debug_logging_enabled?())
  def set_debug_logging(state) when is_boolean(state), do: set(:debug_logging_enabled, state)
  defp set(key, value), do: Application.put_env(:wanderer_notifier, key, value)

  # --- Notification config ---
  def discord_channel_id, do: get(:discord_channel_id)
  def discord_system_kill_channel_id, do: get(:discord_system_kill_channel_id)
  def discord_character_kill_channel_id, do: get(:discord_character_kill_channel_id)
  def discord_system_channel_id, do: get(:discord_system_channel_id)
  def discord_character_channel_id, do: get(:discord_character_channel_id)
  def discord_charts_channel_id, do: get(:discord_charts_channel_id)
  def discord_bot_token, do: get(:discord_bot_token)
  def discord_webhook_url, do: get(:discord_webhook_url)
  def notification_features, do: get(:features, %{})
  def notification_feature_enabled?(flag), do: Map.get(notification_features(), flag, false)
  def min_kill_value, do: get(:min_kill_value, 0)
  def max_notifications_per_minute, do: get(:max_notifications_per_minute, 10)

  def character_exclude_list do
    get(:character_exclude_list, &quot;&quot;) |&gt; String.split(&quot;,&quot;, trim: true) |&gt; Enum.map(&amp;String.trim/1)
  end

  # --- Features ---
  def features, do: get(:features, %{})
  def feature_enabled?(flag), do: Map.get(features(), flag, false)
  def notifications_enabled?, do: feature_enabled?(:notifications_enabled)
  def character_notifications_enabled?, do: feature_enabled?(:character_notifications_enabled)
  def system_notifications_enabled?, do: feature_enabled?(:system_notifications_enabled)
  def kill_notifications_enabled?, do: feature_enabled?(:kill_notifications_enabled)
  def character_tracking_enabled?, do: feature_enabled?(:character_tracking_enabled)
  def system_tracking_enabled?, do: feature_enabled?(:system_tracking_enabled)

  def tracked_systems_notifications_enabled?,
    do: feature_enabled?(:tracked_systems_notifications_enabled)

  def tracked_characters_notifications_enabled?,
    do: feature_enabled?(:tracked_characters_notifications_enabled)

  def status_messages_disabled?, do: feature_enabled?(:status_messages_disabled)
  def track_kspace_systems?, do: feature_enabled?(:track_kspace_systems)

  # --- Websocket ---
  def websocket_config, do: get(:websocket, %{})
  def websocket_enabled?, do: Map.get(websocket_config(), :enabled, true)
  def websocket_reconnect_delay, do: Map.get(websocket_config(), :reconnect_delay, 5000)
  def websocket_max_reconnects, do: Map.get(websocket_config(), :max_reconnects, 20)
  def websocket_reconnect_window, do: Map.get(websocket_config(), :reconnect_window, 3600)

  # --- Cache ---
  def cache_dir, do: get(:cache_dir, &quot;/app/data/cache&quot;)
  def cache_name, do: get(:cache_name, :wanderer_notifier_cache)

  # --- License ---
  def license_key, do: get(:license_key)
  def license_manager_api_url, do: get(:license_manager_api_url)
  def license_manager_api_key, do: get(:license_manager_api_key)

  # --- Web/server ---
  def port, do: get(:port, 4000)
  def host, do: get(:host, &quot;localhost&quot;)
  def scheme, do: get(:scheme, &quot;http&quot;)
  def public_url, do: get(:public_url)

  # --- API ---
  def api_token, do: get(:api_token)
  def api_key, do: get(:api_key)
  def api_base_url, do: get(:api_base_url, &quot;http://localhost:4000/api&quot;)

  # --- Utility ---
  def get_env(key, default \\ nil), do: get(key, default)

  # --- Limits ---
  @doc &quot;Returns a map of system/character/notification limits.&quot;
  def get_all_limits do
    %{
      tracked_systems: get(:max_tracked_systems, 1000),
      tracked_characters: get(:max_tracked_characters, 1000),
      notification_history: get(:max_notification_history, 1000)
    }
  end

  # --- Notification API Token ---
  @doc &quot;Returns the notifier API token.&quot;
  def notifier_api_token, do: api_token()

  # --- Test Mode ---
  @doc &quot;Returns true if test mode is enabled.&quot;
  def test_mode_enabled?, do: feature_enabled?(:test_mode_enabled)

  # --- Timings and Intervals ---
  @doc &quot;Returns the character update scheduler interval in ms.&quot;
  def character_update_scheduler_interval, do: get(:character_update_scheduler_interval, 60_000)

  @doc &quot;Returns the system update scheduler interval in ms.&quot;
  def system_update_scheduler_interval, do: get(:system_update_scheduler_interval, 60_000)

  @doc &quot;Returns the license refresh interval in ms.&quot;
  def license_refresh_interval, do: get(:license_refresh_interval, 600_000)

  # --- Cache TTLs ---
  @doc &quot;Returns the characters cache TTL in seconds.&quot;
  def characters_cache_ttl, do: get(:characters_cache_ttl, 300)

  # --- Tracking Data Feature ---
  @doc &quot;Returns true if tracking data should be loaded.&quot;
  def should_load_tracking_data?, do: feature_enabled?(:should_load_tracking_data)

  # --- Map Debug Settings ---
  @doc &quot;Returns a map of debug-related map config.&quot;
  def map_debug_settings do
    %{
      debug_logging_enabled: debug_logging_enabled?(),
      map_url_with_name: map_url_with_name(),
      map_token: map_token(),
      map_name: map_name()
    }
  end

  # --- API Base URL ---
  @doc &quot;Returns the API base URL.&quot;
  def get_api_base_url do
    value = api_base_url()
    value
  end

  # --- Scheduler/Timing Accessors ---
  @doc &quot;Returns the service status interval in ms.&quot;
  def service_status_interval, do: get(:service_status_interval, 300_000)

  @doc &quot;Returns the killmail retention interval in ms.&quot;
  def killmail_retention_interval, do: get(:killmail_retention_interval, 600_000)

  @doc &quot;Returns the cache check interval in ms.&quot;
  def cache_check_interval, do: get(:cache_check_interval, 120_000)

  @doc &quot;Returns the cache sync interval in ms.&quot;
  def cache_sync_interval, do: get(:cache_sync_interval, 180_000)

  @doc &quot;Returns the cache cleanup interval in ms.&quot;
  def cache_cleanup_interval, do: get(:cache_cleanup_interval, 600_000)

  # --- Cache TTLs ---
  @doc &quot;Returns the systems cache TTL in seconds.&quot;
  def systems_cache_ttl, do: get(:systems_cache_ttl, 300)

  # Add a function to return the base URL portion of map_url_with_name
  def base_map_url do
    url = map_url_with_name()
    uri = URI.parse(url || &quot;&quot;)
    base_url = &quot;#{uri.scheme}://#{uri.host}#{if uri.port, do: &quot;:#{uri.port}&quot;, else: &quot;&quot;}&quot;
    base_url
  end
end</file><file path="lib/wanderer_notifier/config/version.ex">defmodule WandererNotifier.Config.Version do
  @moduledoc &quot;&quot;&quot;
  Configuration module for application version information.

  This module centralizes all version-related configuration,
  providing a standardized interface for retrieving version information.
  Version information is set at compile time rather than through
  environment variables.
  &quot;&quot;&quot;

  # Read from mix.exs at compile time
  @version (case File.read(&quot;mix.exs&quot;) do
              {:ok, content} -&gt;
                Regex.run(~r/version: &quot;([^&quot;]+)&quot;/, content)
                |&gt; case do
                  [_, version] -&gt; version
                  _ -&gt; &quot;0.0.0&quot;
                end

              _ -&gt;
                &quot;0.0.0&quot;
            end)

  @doc &quot;&quot;&quot;
  Returns the application version string.
  This is determined at compile time from mix.exs.
  &quot;&quot;&quot;
  @spec version() :: String.t()
  def version, do: @version

  @doc &quot;&quot;&quot;
  Returns the application version components as a tuple of integers.
  &quot;&quot;&quot;
  @spec version_tuple() :: {integer(), integer(), integer()}
  def version_tuple do
    @version
    |&gt; String.split(&quot;.&quot;)
    |&gt; Enum.map(&amp;String.to_integer/1)
    |&gt; List.to_tuple()
  end

  @doc &quot;&quot;&quot;
  Returns a map containing version information for use in logs and API responses.
  &quot;&quot;&quot;
  @spec version_info() :: map()
  def version_info do
    %{
      version: version(),
      major: elem(version_tuple(), 0),
      minor: elem(version_tuple(), 1),
      patch: elem(version_tuple(), 2)
    }
  end

  @doc &quot;&quot;&quot;
  Checks if the current version is at least the specified minimum version.
  &quot;&quot;&quot;
  @spec at_least?(String.t()) :: boolean()
  def at_least?(min_version) do
    current = version_tuple()

    min_version
    |&gt; String.split(&quot;.&quot;)
    |&gt; Enum.map(&amp;String.to_integer/1)
    |&gt; List.to_tuple()
    |&gt; then(fn min -&gt;
      compare_versions(current, min) &gt;= 0
    end)
  end

  # Private helper to compare version tuples
  defp compare_versions({major1, minor1, patch1}, {major2, minor2, patch2}) do
    cond do
      major1 &gt; major2 -&gt; 1
      major1 &lt; major2 -&gt; -1
      minor1 &gt; minor2 -&gt; 1
      minor1 &lt; minor2 -&gt; -1
      patch1 &gt; patch2 -&gt; 1
      patch1 &lt; patch2 -&gt; -1
      true -&gt; 0
    end
  end
end</file><file path="lib/wanderer_notifier/core/application/service.ex">defmodule WandererNotifier.Core.Application.Service do
  @moduledoc &quot;&quot;&quot;
  The main WandererNotifier service (GenServer).
  Coordinates periodic maintenance and kill processing.
  &quot;&quot;&quot;

  use GenServer
  alias WandererNotifier.ESI.Service, as: ESIService
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Config
  alias WandererNotifier.Helpers.DeduplicationHelper
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Notifiers.Formatters.Structured, as: StructuredFormatter
  alias WandererNotifier.Killmail.Processor, as: KillmailProcessor
  alias WandererNotifier.Schedulers.CharacterUpdateScheduler
  alias WandererNotifier.Schedulers.SystemUpdateScheduler
  alias WandererNotifier.Notifications.Interface, as: NotificationInterface
  alias WandererNotifier.ZKill.Websocket, as: ZKillWebsocket

  @default_interval :timer.minutes(5)

  defmodule State do
    @moduledoc &quot;&quot;&quot;
    Maintains the state of the application.
    &quot;&quot;&quot;
    defstruct [
      :ws_pid,
      processed_kill_ids: %{},
      last_status_time: nil,
      service_start_time: nil,
      last_systems_update: nil,
      last_characters_update: nil,
      systems_count: 0,
      characters_count: 0
    ]
  end

  @doc &quot;&quot;&quot;
  Starts the service.
  &quot;&quot;&quot;
  def start_link(opts \\ []) do
    AppLogger.startup_debug(&quot;Starting WandererNotifier Service&quot;)
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  def stop do
    GenServer.stop(__MODULE__)
  end

  @impl true
  def init(_opts) do
    AppLogger.startup_debug(&quot;Initializing WandererNotifier Service&quot;)
    # Trap exits so the GenServer doesn&apos;t crash when a linked process dies
    Process.flag(:trap_exit, true)
    now = :os.system_time(:second)

    # Initialize kill stats for tracking
    KillmailProcessor.init()

    # Debug system tracking status
    state = %State{
      service_start_time: now,
      last_status_time: now,
      last_systems_update: now,
      last_characters_update: now
    }

    state = start_zkill_ws(state)

    # Schedule Discord notification with a delay to ensure hackney is initialized
    Process.send_after(self(), :send_startup_notification, 2000)

    # Schedule first maintenance run
    schedule_next_run(@default_interval)

    # Schedule stats logging now that we&apos;re initialized
    KillmailProcessor.schedule_tasks()

    # Schedule a direct call to the maintenance scheduler after 10 seconds to handle both systems and characters
    Process.send_after(self(), :update_tracked_data, 10_000)

    {:ok, state}
  rescue
    e -&gt;
      AppLogger.startup_error(&quot; Error in Service initialization&quot;,
        error: Exception.message(e),
        stacktrace: Exception.format_stacktrace(__STACKTRACE__)
      )

      # Return a basic valid state to avoid crashing
      {:ok, %State{service_start_time: :os.system_time(:second)}}
  end

  def mark_as_processed(kill_id) do
    GenServer.cast(__MODULE__, {:mark_as_processed, kill_id})
  end

  @impl true
  def handle_cast({:mark_as_processed, kill_id}, state) do
    if Map.has_key?(state.processed_kill_ids, kill_id) do
      {:noreply, state}
    else
      new_state =
        %{
          state
          | processed_kill_ids:
              Map.put(state.processed_kill_ids, kill_id, :os.system_time(:second))
        }

      {:noreply, new_state}
    end
  end

  @impl true
  def handle_info(:run_maintenance, state) do
    try do
      run_maintenance()
      schedule_next_run(@default_interval)
    catch
      kind, error -&gt;
        handle_maintenance_error({kind, error})
    end

    {:noreply, state}
  end

  @impl true
  def handle_info(:maintenance, state) do
    # Maintenance is now handled by the dedicated maintenance service
    {:noreply, state}
  end

  @impl true
  def handle_info(:initial_maintenance, state) do
    # Maintenance is now handled by the dedicated maintenance service
    {:noreply, state}
  end

  @impl true
  def handle_info({:zkill_message, message}, state) do
    # Process the message with the KillmailProcessor
    new_state = KillmailProcessor.process_zkill_message(message, state)
    {:noreply, new_state}
  end

  @impl true
  def handle_info(:ws_disconnected, state) do
    AppLogger.websocket_warn(&quot;Websocket disconnected, scheduling reconnect&quot;,
      reconnect_delay_ms: Config.websocket_reconnect_delay()
    )

    Process.send_after(self(), :reconnect_ws, Config.websocket_reconnect_delay())
    {:noreply, state}
  end

  @impl true
  def handle_info(:reconnect_ws, state) do
    # Check if the websocket is enabled in config
    if Config.websocket_enabled?() do
      AppLogger.websocket_info(&quot;Attempting to reconnect WandererNotifier.ZKill.Websocket&quot;)
      new_state = reconnect_zkill_ws(state)
      {:noreply, new_state}
    else
      AppLogger.websocket_info(
        &quot;Skipping WandererNotifier.ZKill.Websocket reconnection - disabled by configuration&quot;
      )

      {:noreply, state}
    end
  end

  @impl true
  def handle_info(:force_refresh_cache, state) do
    AppLogger.cache_warn(
      &quot;Received force_refresh_cache message. Refreshing critical data after cache recovery&quot;
    )

    # Execute the system and character update schedulers directly
    SystemUpdateScheduler.run()
    CharacterUpdateScheduler.run()

    AppLogger.cache_info(&quot;Cache refresh completed after recovery&quot;)
    {:noreply, state}
  end

  @impl true
  def handle_info(:log_kill_stats, state) do
    KillmailProcessor.log_stats()
    {:noreply, state}
  rescue
    e -&gt;
      AppLogger.kill_error(&quot;Error logging kill stats&quot;, error: Exception.message(e))
      {:noreply, state}
  end

  @impl true
  def handle_info(:update_tracked_data, state) do
    AppLogger.startup_debug(&quot;Running scheduled initial data update&quot;)

    try do
      # Execute the system and character update schedulers directly
      SystemUpdateScheduler.run()
      CharacterUpdateScheduler.run()

      AppLogger.startup_debug(&quot;Initial tracked data update complete&quot;)

      {:noreply, state}
    rescue
      e -&gt;
        AppLogger.startup_error(&quot;Error in tracked data update&quot;,
          error: Exception.message(e),
          stacktrace: Exception.format_stacktrace(__STACKTRACE__)
        )

        # Try again in 5 seconds if there was an error
        Process.send_after(self(), :update_tracked_data, 5000)
        {:noreply, state}
    end
  end

  @impl true
  def handle_info({:debug_special_system, system_id}, state) do
    # Get system name for better logging
    system_name = get_system_name(system_id)

    AppLogger.maintenance_info(&quot;Processing debug request for system&quot;,
      system_id: system_id,
      system_name: system_name
    )

    # Get all tracked systems from cache
    tracked_systems =
      case CacheRepo.get(&quot;map:systems&quot;) do
        {:ok, value} -&gt; value
        _ -&gt; []
      end

    AppLogger.maintenance_info(&quot;Found tracked systems&quot;, count: length(tracked_systems))

    # Check if system is already tracked
    found =
      Enum.any?(tracked_systems, fn system -&gt;
        case system do
          %{solar_system_id: id} when not is_nil(id) -&gt;
            id_str = to_string(id)
            id_str == to_string(system_id)

          %{&quot;solar_system_id&quot; =&gt; id} when not is_nil(id) -&gt;
            id_str = to_string(id)
            id_str == to_string(system_id)

          %{system_id: id} when not is_nil(id) -&gt;
            id_str = to_string(id)
            id_str == to_string(system_id)

          %{&quot;system_id&quot; =&gt; id} when not is_nil(id) -&gt;
            id_str = to_string(id)
            id_str == to_string(system_id)

          id when is_integer(id) or is_binary(id) -&gt;
            id_str = to_string(id)
            id_str == to_string(system_id)

          _ -&gt;
            false
        end
      end)

    AppLogger.maintenance_info(&quot;System tracked status&quot;,
      system_id: system_id,
      system_name: system_name,
      is_tracked: found
    )

    # Try direct cache lookup
    direct_system =
      case CacheRepo.get(&quot;map:system:#{system_id}&quot;) do
        {:ok, value} -&gt; value
        _ -&gt; nil
      end

    AppLogger.cache_debug(&quot;Direct cache lookup result&quot;,
      key: &quot;map:system:#{system_id}&quot;,
      result: inspect(direct_system)
    )

    # Use the new CacheHelpers function instead of directly manipulating the cache
    ttl = Config.systems_cache_ttl()
    :ok = CacheRepo.set(WandererNotifier.Cache.Keys.tracked_system(system_id), true, ttl)

    AppLogger.maintenance_info(&quot;Added system to tracked systems&quot;,
      system_id: system_id,
      system_name: system_name
    )

    AppLogger.maintenance_info(&quot;Debug tracking operation complete&quot;,
      system_id: system_id,
      system_name: system_name
    )

    {:noreply, state}
  end

  @impl true
  def handle_info({:debug_special_character, character_id}, state) do
    # Get character name for better logging
    character_name = get_character_name(character_id)

    AppLogger.maintenance_info(&quot;Processing debug request for character&quot;,
      character_id: character_id,
      character_name: character_name
    )

    # Get all tracked characters from cache
    tracked_characters =
      case CacheRepo.get(&quot;tracked:character:#{character_id}&quot;) do
        {:ok, value} -&gt; value
        _ -&gt; []
      end

    AppLogger.maintenance_info(&quot;Found tracked characters&quot;, count: length(tracked_characters))

    # Check if character is already tracked
    character_id_str = to_string(character_id)

    # Try direct cache lookup
    direct_character =
      case CacheRepo.get(&quot;tracked:character:#{character_id_str}&quot;) do
        {:ok, value} -&gt; value
        _ -&gt; nil
      end

    AppLogger.cache_debug(&quot;Direct cache lookup result&quot;,
      key: &quot;tracked:character:#{character_id_str}&quot;,
      result: inspect(direct_character)
    )

    # Use the CacheHelpers function to add the character
    ttl = Config.characters_cache_ttl()
    :ok = CacheRepo.set(WandererNotifier.Cache.Keys.tracked_character(character_id), true, ttl)

    AppLogger.maintenance_info(&quot;Added character to tracked characters&quot;,
      character_id: character_id,
      character_name: character_name
    )

    AppLogger.maintenance_info(&quot;Debug tracking operation complete&quot;,
      character_id: character_id,
      character_name: character_name
    )

    {:noreply, state}
  end

  @impl true
  def handle_info({:EXIT, pid, reason}, state) when reason == :normal do
    AppLogger.processor_debug(&quot;Linked process exited normally&quot;, pid: inspect(pid))
    {:noreply, state}
  end

  @impl true
  def handle_info({:EXIT, pid, reason}, state) do
    AppLogger.processor_warn(&quot;Linked process exited abnormally&quot;,
      pid: inspect(pid),
      reason: inspect(reason)
    )

    # Check if the crashed process is the ZKill websocket (now WandererNotifier.ZKill.Websocket)
    if pid == state.ws_pid do
      AppLogger.websocket_warn(
        &quot;ZKill websocket crashed. Scheduling reconnect (WandererNotifier.ZKill.Websocket)&quot;,
        reconnect_delay_ms: Config.websocket_reconnect_delay()
      )

      Process.send_after(self(), :reconnect_ws, Config.websocket_reconnect_delay())
      {:noreply, %{state | ws_pid: nil}}
    else
      {:noreply, state}
    end
  end

  @impl true
  def handle_info({:clear_dedup_key, key}, state) do
    # Handle deduplication key expiration
    DeduplicationHelper.handle_clear_key(key)
    {:noreply, state}
  end

  @impl true
  def handle_info(:send_startup_notification, state) when state.config_loaded == false do
    # If config not loaded yet, schedule a retry
    AppLogger.startup_debug(&quot;Config not loaded yet, scheduling startup notification retry&quot;)
    Process.send_after(self(), :send_startup_notification, 1000)
    {:noreply, state}
  end

  @impl true
  def handle_info(:send_startup_notification, state) do
    AppLogger.startup_info(&quot;Sending startup notification&quot;, %{
      uptime: :os.system_time(:second) - state.service_start_time
    })

    # Create the notification
    generic_notification =
      StructuredFormatter.format_system_status_message(
        &quot;WandererNotifier Service Started&quot;,
        &quot;The service has started and is now operational.&quot;,
        %{
          websocket:
            Map.get(state, :websocket_status, %{
              connected: false,
              last_message: nil
            }),
          notifications: %{
            total: 0,
            kills: 0,
            systems: 0,
            characters: 0
          }
        },
        :os.system_time(:second) - state.service_start_time,
        %{},
        %{valid: true},
        state.systems_count,
        state.characters_count
      )

    discord_embed = StructuredFormatter.to_discord_format(generic_notification)

    # Get the main channel ID, with defensive check for test environment
    main_channel_id =
      try do
        Config.discord_channel_id()
      rescue
        _ -&gt;
          if Application.get_env(:wanderer_notifier, :environment) == :test,
            do: &quot;123456789&quot;,
            else: nil
      end

    # Send notification via factory - specify main channel to avoid nil channel issue
    result =
      if is_nil(main_channel_id) &amp;&amp; Application.get_env(:wanderer_notifier, :environment) != :test do
        # Log a warning but don&apos;t crash
        AppLogger.startup_warn(&quot;No main channel ID available, skipping startup notification&quot;)
        :ok
      else
        NotificationInterface.send_message(discord_embed)
      end

    case result do
      :ok -&gt;
        AppLogger.startup_info(&quot;Startup notification sent successfully&quot;)

      {:ok, _} -&gt;
        AppLogger.startup_info(&quot;Startup notification sent successfully&quot;)

      {:error, reason} -&gt;
        AppLogger.startup_error(&quot;Failed to send startup notification&quot;, error: inspect(reason))
    end

    {:noreply, state}
  end

  @impl true
  def handle_info(:flush_batch_logs, state) do
    # Flush any remaining batch logs
    WandererNotifier.Logger.Logger.flush_batch_logs()
    {:noreply, state}
  rescue
    e -&gt;
      AppLogger.processor_error(&quot;Error flushing batch logs&quot;, error: Exception.message(e))
      {:noreply, state}
  end

  @impl true
  def terminate(_reason, state) do
    if is_map(state) and Map.get(state, :ws_pid), do: Process.exit(state.ws_pid, :normal)
    :ok
  end

  # Schedule the next maintenance run
  defp schedule_next_run(interval) do
    Process.send_after(self(), :run_maintenance, interval)
  end

  # Handle maintenance errors
  defp handle_maintenance_error(error) do
    AppLogger.scheduler_error(&quot;[Service] Maintenance error: #{inspect(error)}&quot;)
    # Continue with scheduling next run despite error
    schedule_next_run(@default_interval)
  end

  # Run maintenance tasks
  defp run_maintenance do
    # Override in child modules
    :ok
  end

  defp start_zkill_ws(state) do
    # Check if websocket is enabled in config
    if Config.websocket_enabled?() do
      AppLogger.websocket_debug(&quot;Starting WandererNotifier.ZKill.Websocket&quot;)

      case ZKillWebsocket.start_link(self()) do
        {:ok, pid} -&gt;
          AppLogger.websocket_info(&quot; WandererNotifier.ZKill.Websocket ready&quot;)
          %{state | ws_pid: pid}

        {:error, reason} -&gt;
          AppLogger.websocket_error(&quot; Failed to start websocket&quot;, error: inspect(reason))

          # Notify about the failure
          NotificationInterface.send_message(&quot;Failed to start websocket: #{inspect(reason)}&quot;)

          # Return state without websocket
          state
      end
    else
      AppLogger.websocket_debug(&quot;WandererNotifier.ZKill.Websocket disabled by configuration&quot;)
      state
    end
  end

  defp reconnect_zkill_ws(state) do
    # Check if the websocket is enabled in config
    if Config.websocket_enabled?() do
      case ZKillWebsocket.start_link(self()) do
        {:ok, pid} -&gt;
          AppLogger.websocket_info(&quot;Reconnected to WandererNotifier.ZKill.Websocket&quot;,
            pid: inspect(pid)
          )

          %{state | ws_pid: pid}

        {:error, reason} -&gt;
          AppLogger.websocket_error(&quot;Reconnection failed&quot;, error: inspect(reason))
          Process.send_after(self(), :reconnect_ws, Config.websocket_reconnect_delay())
          state
      end
    else
      AppLogger.websocket_info(
        &quot;WandererNotifier.ZKill.Websocket reconnection skipped - disabled by configuration&quot;
      )

      state
    end
  end

  @doc &quot;&quot;&quot;
  Dumps the current tracked systems data for debugging purposes.
  &quot;&quot;&quot;
  def debug_tracked_systems do
    # Get and analyze tracked systems
    tracked_data = collect_tracked_systems_data()

    # Verify test system tracking
    test_system_id = &quot;30000253&quot;
    test_system_data = analyze_test_system(tracked_data.tracked_systems, test_system_id)

    # Return summary of findings
    %{
      tracked_systems_count: tracked_data.system_count,
      raw_systems_count: tracked_data.raw_system_count,
      test_system_found: test_system_data.matches != [],
      test_system_details: test_system_data.matches
    }
  end

  # Collect all tracked systems data
  defp collect_tracked_systems_data do
    # Fetch tracked systems and log count
    tracked_systems =
      case CacheRepo.get(&quot;map:systems&quot;) do
        {:ok, value} -&gt; value
        _ -&gt; []
      end

    system_count = length(tracked_systems)
    AppLogger.maintenance_info(&quot;Found tracked systems&quot;, count: system_count)

    # Fetch raw systems from cache and log count
    raw_systems =
      case CacheRepo.get(&quot;map:systems&quot;) do
        {:ok, value} -&gt; value
        _ -&gt; []
      end

    raw_system_count = if is_list(raw_systems), do: length(raw_systems), else: 0
    AppLogger.cache_info(&quot;Raw map:systems cache data&quot;, count: raw_system_count)

    # Log and analyze system samples if available
    if system_count &gt; 0 do
      sample_systems(tracked_systems, system_count)
    end

    %{
      tracked_systems: tracked_systems,
      system_count: system_count,
      raw_systems: raw_systems,
      raw_system_count: raw_system_count
    }
  end

  # Sample systems for debugging
  defp sample_systems(tracked_systems, system_count) do
    sample = Enum.take(tracked_systems, min(3, system_count))
    AppLogger.maintenance_debug(&quot;Sample system structure&quot;, sample: inspect(sample))

    # Extract and log ID formats for sample systems
    id_formats = extract_id_formats(sample)
    AppLogger.maintenance_debug(&quot;ID formats&quot;, formats: inspect(id_formats))
  end

  # Analyze test system
  defp analyze_test_system(tracked_systems, test_system_id) do
    AppLogger.maintenance_debug(&quot;Checking if system is tracked&quot;, system_id: test_system_id)

    matches = find_test_system(tracked_systems, test_system_id)

    if matches == [] do
      AppLogger.maintenance_debug(&quot;System NOT in tracked systems list&quot;, system_id: test_system_id)
    else
      AppLogger.maintenance_debug(&quot;System IS in tracked systems list&quot;,
        system_id: test_system_id,
        matches: inspect(matches)
      )
    end

    # Check additional cache data
    check_additional_cache_data(test_system_id)

    %{matches: matches}
  end

  # Find test system in tracked systems
  defp find_test_system(tracked_systems, test_system_id) do
    AppLogger.maintenance_debug(&quot;Checking if system is tracked&quot;, system_id: test_system_id)

    Enum.filter(tracked_systems, fn system -&gt;
      system_matches_id?(system, test_system_id)
    end)
  end

  # Check if system matches the test ID
  defp system_matches_id?(%{solar_system_id: id}, test_id) when not is_nil(id),
    do: to_string(id) == test_id

  defp system_matches_id?(%{&quot;solar_system_id&quot; =&gt; id}, test_id) when not is_nil(id),
    do: to_string(id) == test_id

  defp system_matches_id?(%{system_id: id}, test_id) when not is_nil(id),
    do: to_string(id) == test_id

  defp system_matches_id?(%{&quot;system_id&quot; =&gt; id}, test_id) when not is_nil(id),
    do: to_string(id) == test_id

  defp system_matches_id?(id, test_id) when is_integer(id) or is_binary(id),
    do: to_string(id) == test_id

  defp system_matches_id?(_, _), do: false

  # Check additional cache data for test system
  defp check_additional_cache_data(test_system_id) do
    system_ids_key =
      case CacheRepo.get(&quot;map:system_ids&quot;) do
        {:ok, value} -&gt; value
        _ -&gt; nil
      end

    specific_system_key =
      case CacheRepo.get(&quot;map:system:#{test_system_id}&quot;) do
        {:ok, value} -&gt; value
        _ -&gt; nil
      end

    AppLogger.cache_debug(&quot;map:system_ids contents&quot;, contents: inspect(system_ids_key))

    AppLogger.cache_debug(&quot;map:system key contents&quot;,
      key: &quot;map:system:#{test_system_id}&quot;,
      contents: inspect(specific_system_key)
    )
  end

  # Extract ID formats from sample systems
  defp extract_id_formats(sample) do
    Enum.map(sample, fn system -&gt;
      %{
        system: system,
        formats: %{
          raw: system,
          solar_system_id_atom: is_map(system) &amp;&amp; Map.get(system, :solar_system_id),
          solar_system_id_string: is_map(system) &amp;&amp; Map.get(system, &quot;solar_system_id&quot;),
          system_id_atom: is_map(system) &amp;&amp; Map.get(system, :system_id),
          system_id_string: is_map(system) &amp;&amp; Map.get(system, &quot;system_id&quot;)
        }
      }
    end)
  end

  # Helper function to get system name
  defp get_system_name(system_id) do
    case ESIService.get_system_info(system_id) do
      {:ok, system_info} -&gt; Map.get(system_info, &quot;name&quot;)
      {:error, :not_found} -&gt; &quot;Unknown System (ID: #{system_id})&quot;
      _ -&gt; &quot;Unknown System&quot;
    end
  end

  # Helper function to get character name
  defp get_character_name(character_id) do
    case ESIService.get_character_info(character_id) do
      {:ok, character_info} -&gt; Map.get(character_info, &quot;name&quot;)
      _ -&gt; &quot;Unknown Character&quot;
    end
  end

  @doc &quot;&quot;&quot;
  Gets the list of recent kills from the kill processor
  Used for API endpoints.
  &quot;&quot;&quot;
  def get_recent_kills do
    # Forward to the kill processor
    KillmailProcessor.get_recent_kills()
  end

  @doc &quot;&quot;&quot;
  Sends a test kill notification.
  Used for testing kill notifications through the API.
  &quot;&quot;&quot;
  def send_test_kill_notification do
    KillmailProcessor.send_test_kill_notification()
  end

  def start_websocket do
    if Config.websocket_enabled?() do
      AppLogger.api_info(&quot;Starting WebSocket&quot;)

      # Continue with the rest of the implementation...
    else
      AppLogger.api_info(&quot;WebSocket is disabled via configuration&quot;)
      :ok
    end
  end

  def format_system_status_message(
        title,
        description,
        websocket,
        uptime,
        extra,
        status,
        systems_count,
        characters_count
      ) do
    %{
      title: title,
      description: description,
      websocket: websocket,
      uptime: uptime,
      extra: extra,
      status: status,
      systems_count: systems_count,
      characters_count: characters_count
    }
  end
end</file><file path="lib/wanderer_notifier/core/stats.ex">defmodule WandererNotifier.Core.Stats do
  @moduledoc &quot;&quot;&quot;
  Statistics tracking for WandererNotifier.
  Maintains counters and metrics for application monitoring.
  Also tracks first notification flags for feature gating.
  &quot;&quot;&quot;
  use GenServer
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Client API

  @doc &quot;&quot;&quot;
  Starts the Stats GenServer.
  &quot;&quot;&quot;
  def start_link(opts \\ []) do
    AppLogger.startup_debug(&quot;Starting Stats tracking service...&quot;)
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @doc &quot;&quot;&quot;
  Increments the count for a specific notification type.
  &quot;&quot;&quot;
  def increment(type) do
    GenServer.cast(__MODULE__, {:increment, type})
  end

  @doc &quot;&quot;&quot;
  Alias for increment/1, provided for backward compatibility.
  Will be deprecated in the future.
  &quot;&quot;&quot;
  def update(type) do
    increment(type)
  end

  @doc &quot;&quot;&quot;
  Returns the current statistics.
  &quot;&quot;&quot;
  def get_stats do
    GenServer.call(__MODULE__, :get_stats)
  end

  @doc &quot;&quot;&quot;
  Updates the websocket status.
  &quot;&quot;&quot;
  def update_websocket(status) do
    GenServer.cast(__MODULE__, {:update_websocket, status})
  end

  @doc &quot;&quot;&quot;
  Checks if this is the first notification of a specific type since application startup.
  Returns true if it&apos;s the first notification, false otherwise.

  ## Parameters
    - type: The notification type (:kill, :character, or :system)
  &quot;&quot;&quot;
  def is_first_notification?(type) when type in [:kill, :character, :system] do
    GenServer.call(__MODULE__, {:is_first_notification, type})
  end

  @doc &quot;&quot;&quot;
  Marks that the first notification of a specific type has been sent.
  This updates application state so future checks will return false.

  ## Parameters
    - type: The notification type (:kill, :character, or :system)
  &quot;&quot;&quot;
  def mark_notification_sent(type) when type in [:kill, :character, :system] do
    GenServer.cast(__MODULE__, {:mark_notification_sent, type})
  end

  @doc &quot;&quot;&quot;
  Prints a summary of current statistics to the log.
  &quot;&quot;&quot;
  def print_summary do
    stats = get_stats()

    # Format uptime
    uptime = stats.uptime

    # Format notification counts
    notifications = stats.notifications
    total_notifications = notifications.total
    _kills_notified = notifications.kills
    systems_notified = notifications.systems
    characters_notified = notifications.characters

    # Format processing stats
    processing = stats.processing
    kills_processed = processing.kills_processed
    kills_notified = processing.kills_notified

    # Format websocket status
    websocket = stats.websocket
    connected = if websocket.connected, do: &quot;connected&quot;, else: &quot;disconnected&quot;

    last_message =
      case websocket.last_message do
        nil -&gt; &quot;never&quot;
        dt -&gt; &quot;#{DateTime.diff(DateTime.utc_now(), dt)}s ago&quot;
      end

    # Log the summary
    AppLogger.kill_info(&quot; Stats Summary:
    Uptime: #{uptime}
    Notifications: #{total_notifications} total (#{kills_notified} kills, #{systems_notified} systems, #{characters_notified} characters)
    Processing: #{kills_processed} kills processed, #{kills_notified} kills notified
    WebSocket: #{connected}, last message #{last_message}&quot;)
  end

  # Server Implementation

  @impl true
  def init(_opts) do
    AppLogger.startup_debug(&quot;Initializing stats tracking service...&quot;)
    # Initialize the state with default values
    {:ok,
     %{
       websocket: %{
         connected: false,
         connecting: false,
         last_message: nil,
         startup_time: nil,
         reconnects: 0,
         url: nil,
         last_disconnect: nil
       },
       notifications: %{
         total: 0,
         kills: 0,
         systems: 0,
         characters: 0
       },
       processing: %{
         kills_processed: 0,
         kills_notified: 0
       },
       first_notifications: %{
         kill: true,
         character: true,
         system: true
       }
     }}
  end

  @impl true
  def handle_cast({:increment, type}, state) do
    case type do
      :kill_processed -&gt;
        processing = Map.update(state.processing, :kills_processed, 1, &amp;(&amp;1 + 1))
        {:noreply, %{state | processing: processing}}

      :kill_notified -&gt;
        processing = Map.update(state.processing, :kills_notified, 1, &amp;(&amp;1 + 1))
        {:noreply, %{state | processing: processing}}

      _ -&gt;
        notifications = Map.update(state.notifications, type, 1, &amp;(&amp;1 + 1))
        notifications = Map.update(notifications, :total, 1, &amp;(&amp;1 + 1))
        {:noreply, %{state | notifications: notifications}}
    end
  end

  @impl true
  def handle_cast({:update_websocket, status}, state) do
    # Merge the new status with existing websocket state to preserve fields
    # Convert any DateTime fields to ensure proper comparison
    normalized_status = normalize_datetime_fields(status)
    updated_websocket = Map.merge(state.websocket, normalized_status)

    # Log the update for debugging
    AppLogger.websocket_debug(&quot;Updated websocket status&quot;,
      old_status: state.websocket,
      new_status: updated_websocket
    )

    {:noreply, %{state | websocket: updated_websocket}}
  end

  @impl true
  def handle_cast({:mark_notification_sent, type}, state) do
    # Update the first_notifications map to mark this type as sent
    first_notifications = Map.put(state.first_notifications, type, false)
    AppLogger.config_debug(&quot;Marked #{type} notification as sent - no longer first notification&quot;)

    {:noreply, %{state | first_notifications: first_notifications}}
  end

  @impl true
  def handle_call(:get_stats, _from, state) do
    uptime_seconds =
      case state.websocket.startup_time do
        nil -&gt; 0
        startup_time -&gt; DateTime.diff(DateTime.utc_now(), startup_time)
      end

    stats = %{
      uptime: format_uptime(uptime_seconds),
      uptime_seconds: uptime_seconds,
      startup_time: state.websocket.startup_time,
      notifications: state.notifications,
      websocket: state.websocket,
      first_notifications: Map.get(state, :first_notifications, %{}),
      processing: state.processing
    }

    {:reply, stats, state}
  end

  @impl true
  def handle_call({:is_first_notification, type}, _from, state) do
    # Look up the first notification status from the state
    is_first = Map.get(state.first_notifications, type, true)

    {:reply, is_first, state}
  end

  # Helper functions

  defp format_uptime(seconds) do
    days = div(seconds, 86_400)
    seconds = rem(seconds, 86_400)
    hours = div(seconds, 3600)
    seconds = rem(seconds, 3600)
    minutes = div(seconds, 60)
    seconds = rem(seconds, 60)

    cond do
      days &gt; 0 -&gt; &quot;#{days}d #{hours}h #{minutes}m #{seconds}s&quot;
      hours &gt; 0 -&gt; &quot;#{hours}h #{minutes}m #{seconds}s&quot;
      minutes &gt; 0 -&gt; &quot;#{minutes}m #{seconds}s&quot;
      true -&gt; &quot;#{seconds}s&quot;
    end
  end

  # Helper to normalize DateTime fields in the status map
  defp normalize_datetime_fields(status) do
    status
    |&gt; Enum.map(fn
      {key, %DateTime{} = dt} -&gt;
        {key, dt}

      {key, nil} -&gt;
        {key, nil}

      {key, val} when is_integer(val) and key in [:startup_time] -&gt;
        {key, DateTime.from_unix!(val)}

      {key, val} -&gt;
        {key, val}
    end)
    |&gt; Map.new()
  end
end</file><file path="lib/wanderer_notifier/esi/entities/alliance.ex">defmodule WandererNotifier.ESI.Entities.Alliance do
  @moduledoc &quot;&quot;&quot;
  Domain model representing an EVE Online alliance from the ESI API.
  Provides a structured interface for working with alliance data.
  &quot;&quot;&quot;

  @type t :: %__MODULE__{
          alliance_id: integer(),
          name: String.t(),
          ticker: String.t(),
          executor_corporation_id: integer() | nil,
          creator_id: integer() | nil,
          creation_date: DateTime.t() | nil,
          faction_id: integer() | nil
        }

  defstruct [
    :alliance_id,
    :name,
    :ticker,
    :executor_corporation_id,
    :creator_id,
    :creation_date,
    :faction_id
  ]

  @doc &quot;&quot;&quot;
  Creates a new Alliance struct from raw ESI API data.

  ## Parameters
    - data: The raw alliance data from ESI API

  ## Example
      iex&gt; WandererNotifier.ESI.Entities.Alliance.from_esi_data(%{
      ...&gt;   &quot;alliance_id&quot; =&gt; 345678,
      ...&gt;   &quot;name&quot; =&gt; &quot;Test Alliance&quot;,
      ...&gt;   &quot;ticker&quot; =&gt; &quot;TSTA&quot;,
      ...&gt;   &quot;executor_corporation_id&quot; =&gt; 789012,
      ...&gt;   &quot;creator_id&quot; =&gt; 123456,
      ...&gt;   &quot;date_founded&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;,
      ...&gt;   &quot;faction_id&quot; =&gt; 555555
      ...&gt; })
      %WandererNotifier.ESI.Entities.Alliance{
        alliance_id: 345678,
        name: &quot;Test Alliance&quot;,
        ticker: &quot;TSTA&quot;,
        executor_corporation_id: 789012,
        creator_id: 123456,
        creation_date: ~U[2020-01-01 00:00:00Z],
        faction_id: 555555
      }
  &quot;&quot;&quot;
  @spec from_esi_data(map()) :: t()
  def from_esi_data(data) when is_map(data) do
    creation_date = parse_datetime(Map.get(data, &quot;date_founded&quot;))

    %__MODULE__{
      alliance_id: Map.get(data, &quot;alliance_id&quot;),
      name: Map.get(data, &quot;name&quot;),
      ticker: Map.get(data, &quot;ticker&quot;),
      executor_corporation_id: Map.get(data, &quot;executor_corporation_id&quot;),
      creator_id: Map.get(data, &quot;creator_id&quot;),
      creation_date: creation_date,
      faction_id: Map.get(data, &quot;faction_id&quot;)
    }
  end

  @doc &quot;&quot;&quot;
  Converts an Alliance struct to a map suitable for storage or serialization.

  ## Parameters
    - alliance: The Alliance struct to convert

  ## Returns
    A map with string keys containing the alliance data.
  &quot;&quot;&quot;
  @spec to_map(t()) :: map()
  def to_map(%__MODULE__{} = alliance) do
    %{
      &quot;alliance_id&quot; =&gt; alliance.alliance_id,
      &quot;name&quot; =&gt; alliance.name,
      &quot;ticker&quot; =&gt; alliance.ticker,
      &quot;executor_corporation_id&quot; =&gt; alliance.executor_corporation_id,
      &quot;creator_id&quot; =&gt; alliance.creator_id,
      &quot;date_founded&quot; =&gt; format_datetime(alliance.creation_date),
      &quot;faction_id&quot; =&gt; alliance.faction_id
    }
  end

  # Parses an ISO8601 datetime string into a DateTime struct
  defp parse_datetime(nil), do: nil

  defp parse_datetime(dt_string) when is_binary(dt_string) do
    case DateTime.from_iso8601(dt_string) do
      {:ok, dt, _} -&gt; dt
      _ -&gt; nil
    end
  end

  # Formats a DateTime struct as an ISO8601 string
  defp format_datetime(nil), do: nil

  defp format_datetime(%DateTime{} = dt) do
    DateTime.to_iso8601(dt)
  end
end</file><file path="lib/wanderer_notifier/esi/entities/character.ex">defmodule WandererNotifier.ESI.Entities.Character do
  @moduledoc &quot;&quot;&quot;
  Domain model representing an EVE Online character from the ESI API.
  Provides a structured interface for working with character data.
  &quot;&quot;&quot;

  @type t :: %__MODULE__{
          character_id: integer(),
          name: String.t(),
          corporation_id: integer(),
          alliance_id: integer() | nil,
          security_status: float() | nil,
          birthday: DateTime.t() | nil
        }

  defstruct [
    :character_id,
    :name,
    :corporation_id,
    :alliance_id,
    :security_status,
    :birthday
  ]

  @doc &quot;&quot;&quot;
  Creates a new Character struct from raw ESI API data.

  ## Parameters
    - data: The raw character data from ESI API

  ## Example
      iex&gt; WandererNotifier.ESI.Entities.Character.from_esi_data(%{
      ...&gt;   &quot;character_id&quot; =&gt; 123456,
      ...&gt;   &quot;name&quot; =&gt; &quot;Test Character&quot;,
      ...&gt;   &quot;corporation_id&quot; =&gt; 789012,
      ...&gt;   &quot;alliance_id&quot; =&gt; 345678,
      ...&gt;   &quot;security_status&quot; =&gt; 0.5,
      ...&gt;   &quot;birthday&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;
      ...&gt; })
      %WandererNotifier.ESI.Entities.Character{
        character_id: 123456,
        name: &quot;Test Character&quot;,
        corporation_id: 789012,
        alliance_id: 345678,
        security_status: 0.5,
        birthday: ~U[2020-01-01 00:00:00Z]
      }
  &quot;&quot;&quot;
  @spec from_esi_data(map()) :: t()
  def from_esi_data(data) when is_map(data) do
    birthday = parse_datetime(Map.get(data, &quot;birthday&quot;))

    %__MODULE__{
      character_id: Map.get(data, &quot;character_id&quot;),
      name: Map.get(data, &quot;name&quot;),
      corporation_id: Map.get(data, &quot;corporation_id&quot;),
      alliance_id: Map.get(data, &quot;alliance_id&quot;),
      security_status: Map.get(data, &quot;security_status&quot;),
      birthday: birthday
    }
  end

  @doc &quot;&quot;&quot;
  Converts a Character struct to a map suitable for storage or serialization.

  ## Parameters
    - character: The Character struct to convert

  ## Returns
    A map with string keys containing the character data.
  &quot;&quot;&quot;
  @spec to_map(t()) :: map()
  def to_map(%__MODULE__{} = character) do
    %{
      &quot;character_id&quot; =&gt; character.character_id,
      &quot;name&quot; =&gt; character.name,
      &quot;corporation_id&quot; =&gt; character.corporation_id,
      &quot;alliance_id&quot; =&gt; character.alliance_id,
      &quot;security_status&quot; =&gt; character.security_status,
      &quot;birthday&quot; =&gt; format_datetime(character.birthday)
    }
  end

  # Parses an ISO8601 datetime string into a DateTime struct
  defp parse_datetime(nil), do: nil

  defp parse_datetime(dt_string) when is_binary(dt_string) do
    case DateTime.from_iso8601(dt_string) do
      {:ok, dt, _} -&gt; dt
      _ -&gt; nil
    end
  end

  # Formats a DateTime struct as an ISO8601 string
  defp format_datetime(nil), do: nil

  defp format_datetime(%DateTime{} = dt) do
    DateTime.to_iso8601(dt)
  end
end</file><file path="lib/wanderer_notifier/esi/entities/corporation.ex">defmodule WandererNotifier.ESI.Entities.Corporation do
  @moduledoc &quot;&quot;&quot;
  Domain model representing an EVE Online corporation from the ESI API.
  Provides a structured interface for working with corporation data.
  &quot;&quot;&quot;

  @type t :: %__MODULE__{
          corporation_id: integer(),
          name: String.t(),
          ticker: String.t(),
          member_count: integer(),
          alliance_id: integer() | nil,
          description: String.t() | nil,
          founding_date: DateTime.t() | nil
        }

  defstruct [
    :corporation_id,
    :name,
    :ticker,
    :member_count,
    :alliance_id,
    :description,
    :founding_date
  ]

  @doc &quot;&quot;&quot;
  Creates a new Corporation struct from raw ESI API data.

  ## Parameters
    - data: The raw corporation data from ESI API

  ## Example
      iex&gt; WandererNotifier.ESI.Entities.Corporation.from_esi_data(%{
      ...&gt;   &quot;corporation_id&quot; =&gt; 789012,
      ...&gt;   &quot;name&quot; =&gt; &quot;Test Corporation&quot;,
      ...&gt;   &quot;ticker&quot; =&gt; &quot;TSTC&quot;,
      ...&gt;   &quot;member_count&quot; =&gt; 100,
      ...&gt;   &quot;alliance_id&quot; =&gt; 345678,
      ...&gt;   &quot;description&quot; =&gt; &quot;A test corporation&quot;,
      ...&gt;   &quot;date_founded&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;
      ...&gt; })
      %WandererNotifier.ESI.Entities.Corporation{
        corporation_id: 789012,
        name: &quot;Test Corporation&quot;,
        ticker: &quot;TSTC&quot;,
        member_count: 100,
        alliance_id: 345678,
        description: &quot;A test corporation&quot;,
        founding_date: ~U[2020-01-01 00:00:00Z]
      }
  &quot;&quot;&quot;
  @spec from_esi_data(map()) :: t()
  def from_esi_data(data) when is_map(data) do
    founding_date = parse_datetime(Map.get(data, &quot;date_founded&quot;))

    %__MODULE__{
      corporation_id: Map.get(data, &quot;corporation_id&quot;),
      name: Map.get(data, &quot;name&quot;),
      ticker: Map.get(data, &quot;ticker&quot;),
      member_count: Map.get(data, &quot;member_count&quot;),
      alliance_id: Map.get(data, &quot;alliance_id&quot;),
      description: Map.get(data, &quot;description&quot;),
      founding_date: founding_date
    }
  end

  @doc &quot;&quot;&quot;
  Converts a Corporation struct to a map suitable for storage or serialization.

  ## Parameters
    - corporation: The Corporation struct to convert

  ## Returns
    A map with string keys containing the corporation data.
  &quot;&quot;&quot;
  @spec to_map(t()) :: map()
  def to_map(%__MODULE__{} = corporation) do
    %{
      &quot;corporation_id&quot; =&gt; corporation.corporation_id,
      &quot;name&quot; =&gt; corporation.name,
      &quot;ticker&quot; =&gt; corporation.ticker,
      &quot;member_count&quot; =&gt; corporation.member_count,
      &quot;alliance_id&quot; =&gt; corporation.alliance_id,
      &quot;description&quot; =&gt; corporation.description,
      &quot;date_founded&quot; =&gt; format_datetime(corporation.founding_date)
    }
  end

  # Parses an ISO8601 datetime string into a DateTime struct
  defp parse_datetime(nil), do: nil

  defp parse_datetime(dt_string) when is_binary(dt_string) do
    case DateTime.from_iso8601(dt_string) do
      {:ok, dt, _} -&gt; dt
      _ -&gt; nil
    end
  end

  # Formats a DateTime struct as an ISO8601 string
  defp format_datetime(nil), do: nil

  defp format_datetime(%DateTime{} = dt) do
    DateTime.to_iso8601(dt)
  end
end</file><file path="lib/wanderer_notifier/esi/entities/solar_system.ex">defmodule WandererNotifier.ESI.Entities.SolarSystem do
  @moduledoc &quot;&quot;&quot;
  Domain model representing an EVE Online solar system from the ESI API.
  Provides a structured interface for working with solar system data.
  &quot;&quot;&quot;

  @type t :: %__MODULE__{
          system_id: integer(),
          name: String.t(),
          constellation_id: integer(),
          security_status: float(),
          security_class: String.t() | nil,
          position: %{x: float(), y: float(), z: float()} | nil,
          star_id: integer() | nil,
          planets: list(map()) | nil,
          region_id: integer() | nil
        }

  defstruct [
    :system_id,
    :name,
    :constellation_id,
    :security_status,
    :security_class,
    :position,
    :star_id,
    :planets,
    :region_id
  ]

  @doc &quot;&quot;&quot;
  Creates a new SolarSystem struct from raw ESI API data.

  ## Parameters
    - data: The raw solar system data from ESI API

  ## Example
      iex&gt; WandererNotifier.ESI.Entities.SolarSystem.from_esi_data(%{
      ...&gt;   &quot;system_id&quot; =&gt; 30000142,
      ...&gt;   &quot;name&quot; =&gt; &quot;Jita&quot;,
      ...&gt;   &quot;constellation_id&quot; =&gt; 20000020,
      ...&gt;   &quot;security_status&quot; =&gt; 0.9,
      ...&gt;   &quot;security_class&quot; =&gt; &quot;B&quot;,
      ...&gt;   &quot;position&quot; =&gt; %{&quot;x&quot; =&gt; 1.0, &quot;y&quot; =&gt; 2.0, &quot;z&quot; =&gt; 3.0},
      ...&gt;   &quot;star_id&quot; =&gt; 40000001,
      ...&gt;   &quot;planets&quot; =&gt; [%{&quot;planet_id&quot; =&gt; 50000001}],
      ...&gt;   &quot;region_id&quot; =&gt; 10000002
      ...&gt; })
      %WandererNotifier.ESI.Entities.SolarSystem{
        system_id: 30000142,
        name: &quot;Jita&quot;,
        constellation_id: 20000020,
        security_status: 0.9,
        security_class: &quot;B&quot;,
        position: %{x: 1.0, y: 2.0, z: 3.0},
        star_id: 40000001,
        planets: [%{&quot;planet_id&quot; =&gt; 50000001}],
        region_id: 10000002
      }
  &quot;&quot;&quot;
  @spec from_esi_data(map()) :: t()
  def from_esi_data(data) when is_map(data) do
    position =
      if Map.has_key?(data, &quot;position&quot;) do
        pos = Map.get(data, &quot;position&quot;)

        %{
          x: Map.get(pos, &quot;x&quot;, 0.0),
          y: Map.get(pos, &quot;y&quot;, 0.0),
          z: Map.get(pos, &quot;z&quot;, 0.0)
        }
      else
        nil
      end

    %__MODULE__{
      system_id: Map.get(data, &quot;system_id&quot;),
      name: Map.get(data, &quot;name&quot;),
      constellation_id: Map.get(data, &quot;constellation_id&quot;),
      security_status: Map.get(data, &quot;security_status&quot;),
      security_class: Map.get(data, &quot;security_class&quot;),
      position: position,
      star_id: Map.get(data, &quot;star_id&quot;),
      planets: Map.get(data, &quot;planets&quot;),
      region_id: Map.get(data, &quot;region_id&quot;)
    }
  end

  @doc &quot;&quot;&quot;
  Converts a SolarSystem struct to a map suitable for storage or serialization.

  ## Parameters
    - system: The SolarSystem struct to convert

  ## Returns
    A map with string keys containing the solar system data.
  &quot;&quot;&quot;
  @spec to_map(t()) :: map()
  def to_map(%__MODULE__{} = system) do
    position =
      if system.position do
        %{
          &quot;x&quot; =&gt; system.position.x,
          &quot;y&quot; =&gt; system.position.y,
          &quot;z&quot; =&gt; system.position.z
        }
      else
        nil
      end

    %{
      &quot;system_id&quot; =&gt; system.system_id,
      &quot;name&quot; =&gt; system.name,
      &quot;constellation_id&quot; =&gt; system.constellation_id,
      &quot;security_status&quot; =&gt; system.security_status,
      &quot;security_class&quot; =&gt; system.security_class,
      &quot;position&quot; =&gt; position,
      &quot;star_id&quot; =&gt; system.star_id,
      &quot;planets&quot; =&gt; system.planets,
      &quot;region_id&quot; =&gt; system.region_id
    }
  end

  @doc &quot;&quot;&quot;
  Calculates the simplified security status band for a solar system.

  ## Parameters
    - system: The SolarSystem struct or a security status value

  ## Returns
    A string representing the security band (e.g., &quot;High&quot;, &quot;Low&quot;, &quot;Null&quot;)
  &quot;&quot;&quot;
  @spec security_band(t() | float()) :: String.t()
  def security_band(%__MODULE__{security_status: sec_status}) do
    security_band(sec_status)
  end

  def security_band(sec_status) when is_number(sec_status) do
    cond do
      sec_status &gt;= 0.5 -&gt; &quot;High&quot;
      sec_status &gt; 0.0 -&gt; &quot;Low&quot;
      true -&gt; &quot;Null&quot;
    end
  end

  def security_band(_), do: &quot;Unknown&quot;
end</file><file path="lib/wanderer_notifier/esi/client.ex">defmodule WandererNotifier.ESI.Client do
  @moduledoc &quot;&quot;&quot;
  Client for interacting with the EVE Online ESI API.
  &quot;&quot;&quot;

  alias WandererNotifier.HttpClient.Httpoison, as: HttpClient
  alias WandererNotifier.Logger.Logger, as: AppLogger

  @base_url &quot;https://esi.evetech.net/latest&quot;
  @user_agent &quot;WandererNotifier/1.0&quot;

  @doc &quot;&quot;&quot;
  Gets killmail information from ESI.
  &quot;&quot;&quot;
  def get_killmail(kill_id, hash, _opts \\ []) do
    url = &quot;#{@base_url}/killmails/#{kill_id}/#{hash}/&quot;
    headers = default_headers()

    AppLogger.api_debug(&quot;ESI fetching killmail&quot;, %{
      kill_id: kill_id,
      hash: hash,
      method: &quot;get_killmail&quot;
    })

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: status, body: body}} when status in 200..299 -&gt;
        AppLogger.api_debug(&quot;ESI killmail response&quot;, %{
          kill_id: kill_id,
          status: status
        })

        {:ok, body}

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;ESI killmail error response&quot;, %{
          kill_id: kill_id,
          status: status
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ESI killmail failed&quot;, %{
          kill_id: kill_id,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  @doc &quot;&quot;&quot;
  Gets character information from ESI.
  &quot;&quot;&quot;
  def get_character_info(character_id, _opts \\ []) do
    url = &quot;#{@base_url}/characters/#{character_id}/&quot;
    headers = default_headers()

    AppLogger.api_debug(&quot;ESI fetching character info&quot;, %{
      character_id: character_id,
      method: &quot;get_character_info&quot;
    })

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: status, body: body}} when status in 200..299 -&gt;
        {:ok, body}

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;ESI character info error response&quot;, %{
          character_id: character_id,
          status: status
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ESI character info failed&quot;, %{
          character_id: character_id,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  @doc &quot;&quot;&quot;
  Gets corporation information from ESI.
  &quot;&quot;&quot;
  def get_corporation_info(corporation_id, _opts \\ []) do
    url = &quot;#{@base_url}/corporations/#{corporation_id}/&quot;
    headers = default_headers()

    AppLogger.api_debug(&quot;ESI fetching corporation info&quot;, %{
      corporation_id: corporation_id,
      method: &quot;get_corporation_info&quot;
    })

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: status, body: body}} when status in 200..299 -&gt;
        {:ok, body}

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;ESI corporation info error response&quot;, %{
          corporation_id: corporation_id,
          status: status
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ESI corporation info failed&quot;, %{
          corporation_id: corporation_id,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  @doc &quot;&quot;&quot;
  Gets alliance information from ESI.
  &quot;&quot;&quot;
  def get_alliance_info(alliance_id, _opts \\ []) do
    url = &quot;#{@base_url}/alliances/#{alliance_id}/&quot;
    headers = default_headers()

    AppLogger.api_debug(&quot;ESI fetching alliance info&quot;, %{
      alliance_id: alliance_id,
      method: &quot;get_alliance_info&quot;
    })

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: status, body: body}} when status in 200..299 -&gt;
        {:ok, body}

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;ESI alliance info error response&quot;, %{
          alliance_id: alliance_id,
          status: status
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ESI alliance info failed&quot;, %{
          alliance_id: alliance_id,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  @doc &quot;&quot;&quot;
  Gets type information from ESI.
  &quot;&quot;&quot;
  def get_universe_type(type_id, _opts \\ []) do
    url = &quot;#{@base_url}/universe/types/#{type_id}/&quot;
    headers = default_headers()

    AppLogger.api_debug(&quot;ESI fetching type info&quot;, %{
      type_id: type_id,
      method: &quot;get_universe_type&quot;
    })

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: status, body: body}} when status in 200..299 -&gt;
        {:ok, body}

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;ESI type info error response&quot;, %{
          type_id: type_id,
          status: status
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ESI type info failed&quot;, %{
          type_id: type_id,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  @doc &quot;&quot;&quot;
  Searches for inventory types in ESI.
  &quot;&quot;&quot;
  def search_inventory_type(query, strict \\ false) do
    query_params = %{
      &quot;categories&quot; =&gt; &quot;inventory_type&quot;,
      &quot;search&quot; =&gt; query,
      &quot;strict&quot; =&gt; to_string(strict)
    }

    url = &quot;#{@base_url}/search/?#{URI.encode_query(query_params)}&quot;
    headers = default_headers()

    AppLogger.api_debug(&quot;ESI searching inventory type&quot;, %{
      query: query,
      strict: strict,
      method: &quot;search_inventory_type&quot;
    })

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: status, body: body}} when status in 200..299 -&gt;
        {:ok, body}

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;ESI search error response&quot;, %{
          query: query,
          status: status
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ESI search failed&quot;, %{
          query: query,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  @doc &quot;&quot;&quot;
  Gets solar system information from ESI.
  &quot;&quot;&quot;
  def get_solar_system(system_id, _opts \\ []) do
    url = &quot;#{@base_url}/universe/systems/#{system_id}/&quot;
    headers = default_headers()

    AppLogger.api_debug(&quot;ESI fetching solar system&quot;, %{
      system_id: system_id,
      method: &quot;get_solar_system&quot;
    })

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: status, body: body}} when status in 200..299 -&gt;
        {:ok, body}

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;ESI solar system error response&quot;, %{
          system_id: system_id,
          status: status
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ESI solar system failed&quot;, %{
          system_id: system_id,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  @doc &quot;&quot;&quot;
  Gets system kill statistics from ESI.
  &quot;&quot;&quot;
  def get_system_kills(system_id, limit \\ 5) do
    url = &quot;#{@base_url}/universe/system_kills/&quot;
    headers = default_headers()

    AppLogger.api_debug(&quot;ESI fetching system kills&quot;, %{
      system_id: system_id,
      limit: limit,
      method: &quot;get_system_kills&quot;
    })

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: status, body: body}} when status in 200..299 -&gt;
        {:ok, body}

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;ESI system kills error response&quot;, %{
          system_id: system_id,
          status: status
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ESI system kills failed&quot;, %{
          system_id: system_id,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  # Private helper functions

  defp default_headers do
    [
      {&quot;Accept&quot;, &quot;application/json&quot;},
      {&quot;User-Agent&quot;, @user_agent}
    ]
  end
end</file><file path="lib/wanderer_notifier/esi/service_behaviour.ex">defmodule WandererNotifier.ESI.ServiceBehaviour do
  @moduledoc &quot;&quot;&quot;
  Behaviour for the ESI API service.
  &quot;&quot;&quot;

  @type killmail_id :: String.t()
  @type hash :: String.t()
  @type response :: {:ok, map()} | {:error, any()}

  @callback get_killmail(kill_id :: integer(), hash :: String.t()) ::
              {:ok, map()} | {:error, term()}
  @callback get_character_info(character_id :: String.t()) :: response
  @callback get_corporation_info(corporation_id :: String.t() | integer()) :: response
  @callback get_alliance_info(alliance_id :: String.t() | integer()) :: response
  @callback get_system_info(system_id :: integer()) ::
              {:ok, map()} | {:error, term()}
  @callback get_type_info(type_id :: String.t() | integer()) :: response
  @callback get_system(system_id :: integer()) :: response
  @callback get_character(character_id :: integer()) :: {:ok, map()} | {:error, term()}
  @callback get_type(type_id :: integer()) :: {:ok, map()} | {:error, term()}
  @callback get_ship_type_name(ship_type_id :: integer()) :: {:ok, map()} | {:error, term()}
  @callback get_system_kills(system_id :: integer(), limit :: integer()) ::
              {:ok, list(map())} | {:error, term()}
end</file><file path="lib/wanderer_notifier/esi/service_mock.ex">defmodule WandererNotifier.ESI.ServiceMock do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of the ESI service for use in tests.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.ESI.ServiceBehaviour

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_killmail(kill_id, hash) do
    {:ok,
     %{
       &quot;killmail_id&quot; =&gt; kill_id,
       &quot;hash&quot; =&gt; hash,
       &quot;solar_system_id&quot; =&gt; 30_000_142,
       &quot;victim&quot; =&gt; %{&quot;character_id&quot; =&gt; &quot;93300861&quot;, &quot;corporation_id&quot; =&gt; &quot;1000107&quot;},
       &quot;attackers&quot; =&gt; [%{&quot;character_id&quot; =&gt; &quot;93300862&quot;, &quot;corporation_id&quot; =&gt; &quot;1000108&quot;}]
     }}
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_character_info(character_id, _opts \\ []) do
    {:ok,
     %{
       &quot;character_id&quot; =&gt; character_id,
       &quot;name&quot; =&gt; &quot;Test Character #{character_id}&quot;,
       &quot;corporation_id&quot; =&gt; &quot;1000107&quot;
     }}
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_corporation_info(corporation_id, _opts \\ []) do
    {:ok,
     %{
       &quot;corporation_id&quot; =&gt; corporation_id,
       &quot;name&quot; =&gt; &quot;Test Corporation #{corporation_id}&quot;,
       &quot;alliance_id&quot; =&gt; &quot;99000001&quot;
     }}
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_alliance_info(alliance_id, _opts \\ []) do
    {:ok,
     %{
       &quot;alliance_id&quot; =&gt; alliance_id,
       &quot;name&quot; =&gt; &quot;Test Alliance #{alliance_id}&quot;
     }}
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_system_info(system_id, _opts \\ []) do
    {:ok,
     %{
       &quot;system_id&quot; =&gt; system_id,
       &quot;name&quot; =&gt; &quot;Test System #{system_id}&quot;,
       &quot;security_status&quot; =&gt; 0.9,
       &quot;constellation_id&quot; =&gt; 20_000_001,
       &quot;star_id&quot; =&gt; 40_000_001
     }}
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_type_info(type_id, _opts \\ []) do
    {:ok,
     %{
       &quot;type_id&quot; =&gt; type_id,
       &quot;name&quot; =&gt; &quot;Test Ship Type #{type_id}&quot;,
       &quot;group_id&quot; =&gt; 25
     }}
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_system(system_id, _opts \\ []) do
    get_system_info(system_id)
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_character(character_id, opts \\ []) do
    get_character_info(character_id, opts)
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_type(type_id, opts \\ []) do
    get_type_info(type_id, opts)
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_ship_type_name(ship_type_id, _opts \\ []) do
    {:ok, %{&quot;name&quot; =&gt; &quot;Test Ship #{ship_type_id}&quot;}}
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_system_kills(system_id, limit, _opts \\ []) do
    kills =
      Enum.map(1..limit, fn i -&gt;
        %{
          &quot;system_id&quot; =&gt; system_id,
          &quot;ship_kills&quot; =&gt; i,
          &quot;npc_kills&quot; =&gt; i * 2,
          &quot;pod_kills&quot; =&gt; i * 3
        }
      end)

    {:ok, Enum.take(kills, limit)}
  end
end</file><file path="lib/wanderer_notifier/esi/service.ex">defmodule WandererNotifier.ESI.Service do
  @moduledoc &quot;&quot;&quot;
  Service for interacting with EVE Online&apos;s ESI (Swagger Interface) API.
  Provides high-level functions for common ESI operations.
  &quot;&quot;&quot;

  require Logger
  alias WandererNotifier.ESI.Client
  alias WandererNotifier.ESI.Entities.{Character, Corporation, Alliance, SolarSystem}
  alias WandererNotifier.Cache.Keys, as: CacheKeys
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Logger.Logger, as: AppLogger

  @behaviour WandererNotifier.ESI.ServiceBehaviour

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_killmail(kill_id, killmail_hash) do
    cache_key = CacheKeys.killmail(kill_id, killmail_hash)

    case CacheRepo.get(cache_key) do
      {:ok, data} -&gt;
        AppLogger.api_debug(&quot; ESI cache hit for killmail&quot;, kill_id: kill_id)
        {:ok, data}

      {:error, _} -&gt;
        AppLogger.api_debug(&quot; ESI cache miss for killmail&quot;, kill_id: kill_id)

        case Client.get_killmail(kill_id, killmail_hash, retry_opts()) do
          {:ok, data} = result -&gt;
            CacheRepo.put(cache_key, data)
            result

          error -&gt;
            error
        end
    end
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_character_info(character_id, _opts \\ []) do
    cache_key = CacheKeys.character(character_id)

    case CacheRepo.get(cache_key) do
      {:ok, data} -&gt;
        AppLogger.api_debug(&quot; ESI cache hit for character&quot;, character_id: character_id)
        {:ok, data}

      {:error, _} -&gt;
        AppLogger.api_debug(&quot; ESI cache miss for character&quot;, character_id: character_id)

        case Client.get_character_info(character_id, retry_opts()) do
          {:ok, data} = result -&gt;
            CacheRepo.put(cache_key, data)
            result

          error -&gt;
            error
        end
    end
  end

  @doc &quot;&quot;&quot;
  Get character info and return it as a Character struct.

  ## Parameters
    - character_id: The character ID to look up
    - opts: Optional parameters

  ## Returns
    - {:ok, %Character{}} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def get_character_struct(character_id, opts \\ []) do
    with {:ok, data} &lt;- get_character_info(character_id, opts) do
      {:ok, Character.from_esi_data(data)}
    end
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_corporation_info(corporation_id, _opts \\ []) do
    cache_key = CacheKeys.corporation(corporation_id)

    case CacheRepo.get(cache_key) do
      {:ok, data} -&gt;
        AppLogger.api_debug(&quot; ESI cache hit for corporation&quot;, corporation_id: corporation_id)
        {:ok, data}

      {:error, _} -&gt;
        AppLogger.api_debug(&quot; ESI cache miss for corporation&quot;, corporation_id: corporation_id)

        case Client.get_corporation_info(corporation_id, retry_opts()) do
          {:ok, data} = result -&gt;
            CacheRepo.put(cache_key, data)
            result

          error -&gt;
            error
        end
    end
  end

  @doc &quot;&quot;&quot;
  Get corporation info and return it as a Corporation struct.

  ## Parameters
    - corporation_id: The corporation ID to look up
    - opts: Optional parameters

  ## Returns
    - {:ok, %Corporation{}} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def get_corporation_struct(corporation_id, opts \\ []) do
    with {:ok, data} &lt;- get_corporation_info(corporation_id, opts) do
      {:ok, Corporation.from_esi_data(data)}
    end
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_alliance_info(alliance_id, _opts \\ []) do
    cache_key = CacheKeys.alliance(alliance_id)

    case CacheRepo.get(cache_key) do
      {:ok, data} -&gt;
        AppLogger.api_debug(&quot; ESI cache hit for alliance&quot;, alliance_id: alliance_id)
        {:ok, data}

      {:error, _} -&gt;
        AppLogger.api_debug(&quot; ESI cache miss for alliance&quot;, alliance_id: alliance_id)

        case Client.get_alliance_info(alliance_id, retry_opts()) do
          {:ok, data} = result -&gt;
            CacheRepo.put(cache_key, data)
            result

          error -&gt;
            error
        end
    end
  end

  @doc &quot;&quot;&quot;
  Get alliance info and return it as an Alliance struct.

  ## Parameters
    - alliance_id: The alliance ID to look up
    - opts: Optional parameters

  ## Returns
    - {:ok, %Alliance{}} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def get_alliance_struct(alliance_id, opts \\ []) do
    with {:ok, data} &lt;- get_alliance_info(alliance_id, opts) do
      {:ok, Alliance.from_esi_data(data)}
    end
  end

  @impl true
  def get_ship_type_name(ship_type_id, _opts \\ []) do
    cache_key = CacheKeys.ship_type(ship_type_id)

    case CacheRepo.get(cache_key) do
      {:ok, data} -&gt; handle_cache_hit(ship_type_id, data)
      {:error, _} -&gt; handle_cache_miss(ship_type_id, cache_key)
    end
  end

  defp handle_cache_miss(ship_type_id, cache_key) do
    AppLogger.api_debug(&quot; ESI cache miss for ship type&quot;, ship_type_id: ship_type_id)

    case Client.get_universe_type(ship_type_id, retry_opts()) do
      {:ok, type_info} -&gt; process_type_info(type_info, cache_key)
      error -&gt; error
    end
  end

  defp handle_cache_hit(ship_type_id, data) do
    AppLogger.api_debug(&quot; ESI cache hit for ship type&quot;, ship_type_id: ship_type_id)
    {:ok, data}
  end

  defp process_type_info(type_info, cache_key) do
    name = Map.get(type_info, &quot;name&quot;)

    if name do
      result = %{&quot;name&quot; =&gt; name}
      CacheRepo.put(cache_key, result)
      {:ok, result}
    else
      {:error, :name_not_found}
    end
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_type_info(type_id, _opts \\ []) do
    cache_key = CacheKeys.ship_type(type_id)

    case CacheRepo.get(cache_key) do
      {:ok, data} -&gt;
        AppLogger.api_debug(&quot; ESI cache hit for type&quot;, type_id: type_id)
        {:ok, data}

      {:error, _} -&gt;
        AppLogger.api_debug(&quot; ESI cache miss for type&quot;, type_id: type_id)

        case Client.get_universe_type(type_id, retry_opts()) do
          {:ok, data} = result -&gt;
            CacheRepo.put(cache_key, data)
            result

          error -&gt;
            error
        end
    end
  end

  @doc &quot;&quot;&quot;
  Searches for inventory types using the ESI /search/ endpoint.
  &quot;&quot;&quot;
  def search_inventory_type(query, strict \\ true, _opts \\ []) do
    Client.search_inventory_type(query, strict)
  end

  @doc &quot;&quot;&quot;
  Fetches solar system info from ESI given a solar_system_id.
  Expects the response to include a &quot;name&quot; field.
  &quot;&quot;&quot;
  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_system(system_id, _opts \\ []) do
    cache_key = CacheKeys.system(system_id)

    case CacheRepo.get(cache_key) do
      {:ok, data} -&gt;
        AppLogger.api_debug(&quot; ESI cache hit for solar system&quot;, system_id: system_id)
        {:ok, data}

      {:error, _} -&gt;
        AppLogger.api_debug(&quot; ESI cache miss for solar system&quot;, system_id: system_id)

        case Client.get_solar_system(system_id, retry_opts()) do
          {:ok, data} = result -&gt;
            CacheRepo.put(cache_key, data)
            result

          error -&gt;
            error
        end
    end
  end

  @doc &quot;&quot;&quot;
  Get solar system info and return it as a SolarSystem struct.

  ## Parameters
    - system_id: The solar system ID to look up
    - opts: Optional parameters

  ## Returns
    - {:ok, %SolarSystem{}} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def get_system_struct(system_id, opts \\ []) do
    with {:ok, data} &lt;- get_system(system_id, opts) do
      {:ok, SolarSystem.from_esi_data(data)}
    end
  end

  @doc &quot;&quot;&quot;
  Alias for get_system to maintain backward compatibility.
  Fetches solar system info from ESI given a system_id.
  &quot;&quot;&quot;
  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_system_info(system_id, opts \\ []) do
    get_system(system_id, opts)
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_character(character_id, opts \\ []) do
    get_character_info(character_id, opts)
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_type(type_id, opts \\ []) do
    get_type_info(type_id, opts)
  end

  @impl WandererNotifier.ESI.ServiceBehaviour
  def get_system_kills(system_id, limit \\ 50, _opts \\ []) do
    Client.get_system_kills(system_id, limit)
  end

  # Get retry options with default values
  defp retry_opts do
    [
      max_attempts: 3,
      base_timeout: 1000,
      max_timeout: 5000
    ]
  end
end</file><file path="lib/wanderer_notifier/helpers/deduplication_helper.ex">defmodule WandererNotifier.Helpers.DeduplicationHelper do
  @moduledoc &quot;&quot;&quot;
  Helper module for handling deduplication of notifications.
  &quot;&quot;&quot;

  use GenServer
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo

  # Default TTL for deduplication entries (24 hours)
  @dedup_ttl 86_400

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, [], name: __MODULE__)
  end

  @impl true
  def init(_) do
    {:ok, %{}}
  end

  @doc &quot;&quot;&quot;
  Checks if a given ID for a specific type is a duplicate.
  Returns {:ok, :new} if not seen before, {:ok, :duplicate} if already seen,
  or {:error, reason} if there&apos;s an error.
  &quot;&quot;&quot;
  @spec duplicate?(atom(), String.t() | integer()) ::
          {:ok, :new} | {:ok, :duplicate} | {:error, String.t()}
  def duplicate?(type, id) when is_atom(type) and (is_binary(id) or is_integer(id)) do
    cache_key = &quot;#{type}:#{id}&quot;

    try do
      case CacheRepo.get(cache_key) do
        {:ok, _} -&gt;
          {:ok, :duplicate}

        _ -&gt;
          CacheRepo.set(cache_key, true, @dedup_ttl)
          {:ok, :new}
      end
    rescue
      e -&gt; {:error, Exception.message(e)}
    end
  end

  @doc &quot;&quot;&quot;
  Clears a deduplication key from the cache.
  &quot;&quot;&quot;
  def handle_clear_key(key) do
    GenServer.cast(__MODULE__, {:clear_key, key})
  end

  @impl true
  def handle_cast({:clear_key, key}, state) do
    CacheRepo.delete(key)
    {:noreply, state}
  end
end</file><file path="lib/wanderer_notifier/http_client/behaviour.ex">defmodule WandererNotifier.HttpClient.Behaviour do
  @moduledoc &quot;&quot;&quot;
  Behaviour for HTTP clients
  &quot;&quot;&quot;

  @type headers :: [{String.t(), String.t()}]
  @type url :: String.t()
  @type body :: String.t() | map()
  @type options :: keyword()
  @type response :: {:ok, map()} | {:error, term()}
  @type method :: :get | :post | :put | :delete | :head | :options

  @callback get(url :: url, headers :: headers) :: response
  @callback get(url :: url) :: response
  @callback post(url :: url, body :: body, headers :: headers) :: response
  @callback post_json(url :: url, body :: body, headers :: headers, options :: options) ::
              response
  @callback request(
              method :: method,
              url :: url,
              headers :: headers,
              body :: body,
              options :: options
            ) ::
              response
  @callback handle_response(response :: term()) :: response
end</file><file path="lib/wanderer_notifier/http_client/httpoison.ex">defmodule WandererNotifier.HttpClient.Httpoison do
  @moduledoc &quot;&quot;&quot;
  HTTPoison implementation of the HTTP client behavior
  &quot;&quot;&quot;
  @behaviour WandererNotifier.HttpClient.Behaviour

  require Logger

  @default_headers [{&quot;Content-Type&quot;, &quot;application/json&quot;}]

  @impl true
  def get(url, headers \\ @default_headers) do
    HTTPoison.get(url, headers)
    |&gt; handle_response()
  end

  @impl true
  def post(url, body, headers \\ @default_headers) do
    HTTPoison.post(url, body, headers)
    |&gt; handle_response()
  end

  @impl true
  def post_json(url, body, headers \\ @default_headers, options \\ []) do
    encoded_body = Jason.encode!(body)

    HTTPoison.post(url, encoded_body, headers, options)
    |&gt; handle_response()
  end

  @doc &quot;&quot;&quot;
  Makes a generic HTTP request
  &quot;&quot;&quot;
  @impl true
  def request(method, url, headers \\ [], body \\ nil, opts \\ []) do
    # Convert body to JSON if it&apos;s a map and not nil
    payload =
      cond do
        is_nil(body) -&gt; &quot;&quot;
        is_map(body) -&gt; Jason.encode!(body)
        true -&gt; body
      end

    HTTPoison.request(method, url, payload, headers, opts)
    |&gt; handle_response()
  end

  @impl true
  def handle_response(
        {:ok, %HTTPoison.Response{status_code: status, body: body, headers: _headers}}
      )
      when status in 200..299 do
    case Jason.decode(body) do
      {:ok, decoded} -&gt;
        {:ok, %{status_code: status, body: decoded}}

      {:error, _reason} -&gt;
        {:ok, %{status_code: status, body: body}}
    end
  end

  def handle_response(
        {:ok, %HTTPoison.Response{status_code: status, body: body, headers: headers}}
      ) do
    Logger.warning(&quot;Non-2xx response&quot;,
      status: status,
      headers: inspect(headers),
      body: inspect(body)
    )

    {:error, %{status_code: status, body: body}}
  end

  def handle_response({:error, %HTTPoison.Error{reason: reason}}) do
    Logger.error(&quot;HTTP request failed: #{inspect(reason)}&quot;)
    {:error, reason}
  end

  def handle_response(other) do
    {:error, {:unexpected_response, other}}
  end
end</file><file path="lib/wanderer_notifier/killmail/cache.ex">defmodule WandererNotifier.Killmail.Cache do
  @moduledoc &quot;&quot;&quot;
  Manages caching for killmail data.

  - Stores recent kills in the cache repository
  - Provides retrieval methods for cached kills
  - Maintains a list of kill IDs for quick access
  &quot;&quot;&quot;
  alias WandererNotifier.Cache.Keys, as: CacheKeys
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Cache TTL values (in seconds)
  # 1 hour
  @kill_ttl 3600

  # System name cache - process dictionary for performance
  @system_names_cache_key :system_names_cache

  @doc &quot;&quot;&quot;
  Initializes the killmail cache system.
  &quot;&quot;&quot;
  def init do
    # Initialize the system names cache in the process dictionary
    Process.put(@system_names_cache_key, %{})
    AppLogger.kill_debug(&quot;Kill cache initialized&quot;)
    :ok
  end

  @doc &quot;&quot;&quot;
  Caches a killmail for quick access.
  &quot;&quot;&quot;
  def cache_kill(killmail_id, killmail) when is_binary(killmail_id) or is_integer(killmail_id) do
    kill_id = to_string(killmail_id)

    # Cache individual kill
    individual_key = &quot;#{CacheKeys.zkill_recent_kills()}:#{kill_id}&quot;

    AppLogger.cache_debug(&quot;Caching individual kill&quot;, key: individual_key)
    CacheRepo.set(individual_key, killmail, @kill_ttl)

    # Update the recent kills list
    update_recent_kills_list(kill_id)

    :ok
  end

  @doc &quot;&quot;&quot;
  Gets a cached killmail by ID.
  &quot;&quot;&quot;
  def get_kill(kill_id) when is_binary(kill_id) or is_integer(kill_id) do
    id = to_string(kill_id)

    # Get the list of cached kill IDs
    kill_ids =
      case CacheRepo.get(CacheKeys.zkill_recent_kills()) do
        {:ok, ids} -&gt; ids
        _ -&gt; []
      end

    # Check if this kill is in our tracked list
    if id in kill_ids do
      # Get the individual kill data
      key = &quot;#{CacheKeys.zkill_recent_kills()}:#{id}&quot;

      kill_data =
        case CacheRepo.get(key) do
          {:ok, data} -&gt; data
          _ -&gt; nil
        end

      if kill_data do
        {:ok, kill_data}
      else
        {:error, :not_found}
      end
    else
      {:error, :not_cached}
    end
  end

  @doc &quot;&quot;&quot;
  Gets all recent cached kills.
  &quot;&quot;&quot;
  def get_recent_kills do
    # Get the list of cached kill IDs
    kill_ids =
      case CacheRepo.get(CacheKeys.zkill_recent_kills()) do
        {:ok, ids} -&gt; ids
        _ -&gt; []
      end

    # Map through and get each kill
    kills =
      kill_ids
      |&gt; Enum.map(fn id -&gt;
        key = &quot;#{CacheKeys.zkill_recent_kills()}:#{id}&quot;

        {id,
         case CacheRepo.get(key) do
           {:ok, data} -&gt; data
           _ -&gt; nil
         end}
      end)
      |&gt; Enum.filter(fn {_id, kill} -&gt; kill != nil end)
      |&gt; Enum.into(%{})

    {:ok, kills}
  end

  @doc &quot;&quot;&quot;
  Gets all recent cached kills as a list for API consumption.

  ## Returns
  - List of killmails with their IDs
  &quot;&quot;&quot;
  def get_latest_killmails do
    # Get the list of cached kill IDs
    kill_ids =
      case CacheRepo.get(CacheKeys.zkill_recent_kills()) do
        {:ok, ids} -&gt; ids
        _ -&gt; []
      end

    # Map through and get each kill
    kill_ids
    |&gt; Enum.map(fn id -&gt;
      key = &quot;#{CacheKeys.zkill_recent_kills()}:#{id}&quot;

      kill =
        case CacheRepo.get(key) do
          {:ok, data} -&gt; data
          _ -&gt; nil
        end

      if kill do
        Map.put(kill, &quot;id&quot;, id)
      else
        nil
      end
    end)
    |&gt; Enum.reject(&amp;is_nil/1)
  end

  @doc &quot;&quot;&quot;
  Gets a system name from the cache or from the API.

  ## Parameters
  - system_id: The ID of the system to get name for

  ## Returns
  - System name or nil if not found
  &quot;&quot;&quot;
  def get_system_name(_system_id) do
    # This function would be moved here from the main KillProcessor
    # It would handle looking up system names from the cache
    # and falling back to the API if not found
    nil
  end

  # Private functions

  # Helper to update the recent kills list with a new kill ID
  defp update_recent_kills_list(kill_id) do
    # Get current list of kill IDs
    kill_ids =
      case CacheRepo.get(CacheKeys.zkill_recent_kills()) do
        {:ok, ids} -&gt; ids
        _ -&gt; []
      end

    # Add the new kill ID to the list (if not already present)
    updated_ids =
      if kill_id in kill_ids do
        kill_ids
      else
        # Keep only the most recent 100
        [kill_id | kill_ids] |&gt; Enum.take(100)
      end

    # Update the cache
    CacheRepo.set(CacheKeys.zkill_recent_kills(), updated_ids, @kill_ttl)
  end
end</file><file path="lib/wanderer_notifier/killmail/context.ex">defmodule WandererNotifier.Killmail.Context do
  @moduledoc &quot;&quot;&quot;
  Defines the context for killmail processing, containing all necessary information
  for processing a killmail in either historical or realtime mode.
  &quot;&quot;&quot;

  alias WandererNotifier.Killmail.Mode

  @type source :: :zkill_websocket | :zkill_api

  @type t :: %__MODULE__{
          mode: Mode.t(),
          character_id: pos_integer() | nil,
          character_name: String.t() | nil,
          source: source(),
          batch_id: String.t() | nil,
          options: map()
        }

  defstruct [
    :mode,
    :character_id,
    :character_name,
    :source,
    :batch_id,
    :options
  ]

  @doc &quot;&quot;&quot;
  Creates a new context for historical processing.
  &quot;&quot;&quot;
  @spec new_historical(pos_integer(), String.t(), source(), String.t(), map()) :: t()
  def new_historical(character_id, character_name, source, batch_id, options \\ %{}) do
    %__MODULE__{
      mode: Mode.new(:historical),
      character_id: character_id,
      character_name: character_name,
      source: source,
      batch_id: batch_id,
      options: options
    }
  end

  @doc &quot;&quot;&quot;
  Creates a new context for realtime processing.
  &quot;&quot;&quot;
  @spec new_realtime(pos_integer(), String.t(), source(), map()) :: t()
  def new_realtime(character_id, character_name, source, options \\ %{}) do
    %__MODULE__{
      mode: Mode.new(:realtime),
      character_id: character_id,
      character_name: character_name,
      source: source,
      batch_id: nil,
      options: options
    }
  end

  @doc &quot;&quot;&quot;
  Returns true if the context is for historical processing.
  &quot;&quot;&quot;
  @spec historical?(t()) :: boolean()
  def historical?(%__MODULE__{mode: %{mode: :historical}}), do: true
  def historical?(_), do: false

  @doc &quot;&quot;&quot;
  Returns true if the context is for realtime processing.
  &quot;&quot;&quot;
  @spec realtime?(t()) :: boolean()
  def realtime?(%__MODULE__{mode: %{mode: :realtime}}), do: true
  def realtime?(_), do: false
end</file><file path="lib/wanderer_notifier/killmail/enrichment.ex">defmodule WandererNotifier.Killmail.Enrichment do
  @moduledoc &quot;&quot;&quot;
  Handles enrichment of killmail data with additional information from ESI.
  &quot;&quot;&quot;

  alias WandererNotifier.ESI.Client, as: ESIClient
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Killmail.Killmail

  @doc &quot;&quot;&quot;
  Enriches killmail data with additional information from ESI.

  ## Parameters
    - killmail: The killmail data to enrich

  ## Returns
    - {:ok, enriched_killmail} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def enrich_killmail_data(%Killmail{killmail_id: killmail_id, zkb: %{&quot;hash&quot; =&gt; hash}} = killmail) do
    case WandererNotifier.ESI.Service.get_killmail(killmail_id, hash) do
      {:ok, esi_data} -&gt;
        # Attach esi_data to the killmail
        killmail = %Killmail{killmail | esi_data: esi_data}
        AppLogger.kill_info(&quot;Enriching killmail struct&quot;, %{killmail: inspect(killmail, pretty: true)})

        # Extract victim info
        victim_id = get_in(esi_data, [&quot;victim&quot;, &quot;character_id&quot;])
        ship_type_id = get_in(esi_data, [&quot;victim&quot;, &quot;ship_type_id&quot;])
        system_id = Map.get(esi_data, &quot;solar_system_id&quot;)
        system_name =
          case WandererNotifier.ESI.Service.get_system(system_id) do
            {:ok, %{&quot;name&quot; =&gt; name}} -&gt; name
            _ -&gt; nil
          end

        # Enrich attackers
        attackers =
          esi_data
          |&gt; Map.get(&quot;attackers&quot;, [])
          |&gt; Enum.map(fn attacker -&gt;
            character_id = Map.get(attacker, &quot;character_id&quot;)
            corporation_id = Map.get(attacker, &quot;corporation_id&quot;)
            alliance_id = Map.get(attacker, &quot;alliance_id&quot;)
            ship_type_id = Map.get(attacker, &quot;ship_type_id&quot;)
            weapon_type_id = Map.get(attacker, &quot;weapon_type_id&quot;)
            damage_done = Map.get(attacker, &quot;damage_done&quot;)
            final_blow = Map.get(attacker, &quot;final_blow&quot;, false)
            security_status = Map.get(attacker, &quot;security_status&quot;)
            faction_id = Map.get(attacker, &quot;faction_id&quot;)

            # Enrich names (optional, can be async/cached in future)
            character_name =
              case get_character_info(character_id) do
                {:ok, info} -&gt; info[&quot;name&quot;]
                _ -&gt; nil
              end
            corporation_name =
              case WandererNotifier.ESI.Service.get_corporation_info(corporation_id) do
                {:ok, %{&quot;name&quot; =&gt; name}} -&gt; name
                _ -&gt; nil
              end
            alliance_name =
              case WandererNotifier.ESI.Service.get_alliance_info(alliance_id) do
                {:ok, %{&quot;name&quot; =&gt; name}} -&gt; name
                _ -&gt; nil
              end
            ship_type_name =
              case WandererNotifier.ESI.Service.get_type_info(ship_type_id) do
                {:ok, %{&quot;name&quot; =&gt; name}} -&gt; name
                _ -&gt; nil
              end
            weapon_type_name =
              case WandererNotifier.ESI.Service.get_type_info(weapon_type_id) do
                {:ok, %{&quot;name&quot; =&gt; name}} -&gt; name
                _ -&gt; nil
              end

            %{
              character_id: character_id,
              character_name: character_name,
              corporation_id: corporation_id,
              corporation_name: corporation_name,
              alliance_id: alliance_id,
              alliance_name: alliance_name,
              ship_type_id: ship_type_id,
              ship_type_name: ship_type_name,
              weapon_type_id: weapon_type_id,
              weapon_type_name: weapon_type_name,
              damage_done: damage_done,
              final_blow: final_blow,
              security_status: security_status,
              faction_id: faction_id
            }
          end)

        with {:ok, victim_info} &lt;- get_character_info(victim_id),
             {:ok, ship_info} &lt;- get_ship_info(ship_type_id) do
          enriched_killmail = %Killmail{
            killmail
            | victim_name: victim_info[&quot;name&quot;],
              victim_corporation: victim_info[&quot;corporation_id&quot;],
              victim_alliance: Map.get(victim_info, &quot;alliance_id&quot;),
              ship_name: ship_info[&quot;name&quot;],
              system_id: system_id,
              system_name: system_name,
              attackers: attackers
          }

          {:ok, enriched_killmail}
        else
          {:error, reason} -&gt;
            AppLogger.api_error(&quot;Failed to enrich killmail&quot;, %{
              kill_id: killmail_id,
              error: inspect(reason)
            })
            {:error, reason}
        end
      {:error, reason} -&gt;
        AppLogger.kill_warn(&quot;Failed to fetch ESI data for killmail&quot;, %{killmail_id: killmail_id, reason: inspect(reason)})
        {:error, :esi_data_missing}
    end
  end

  # Private helper functions

  defp get_character_info(nil),
    do: {:ok, %{&quot;name&quot; =&gt; &quot;Unknown&quot;, &quot;corporation_id&quot; =&gt; nil, &quot;alliance_id&quot; =&gt; nil}}

  defp get_character_info(character_id) do
    case ESIClient.get_character_info(character_id) do
      {:ok, info} -&gt; {:ok, info}
      {:error, reason} -&gt; {:error, {:character_info_error, reason}}
    end
  end

  defp get_ship_info(ship_type_id) do
    case ESIClient.get_universe_type(ship_type_id) do
      {:ok, info} -&gt; {:ok, info}
      {:error, reason} -&gt; {:error, {:ship_info_error, reason}}
    end
  end
end</file><file path="lib/wanderer_notifier/killmail/killmail.ex">defmodule WandererNotifier.Killmail.Killmail do
  @moduledoc &quot;&quot;&quot;
  Data structure for EVE Online killmails.
  Contains information about ship kills, combining data from zKillboard and ESI.
  &quot;&quot;&quot;
  @enforce_keys [:killmail_id, :zkb]
  defstruct [
    :killmail_id,
    :zkb,
    :esi_data,
    :victim_name,
    :victim_corporation,
    :victim_alliance,
    :ship_name,
    :system_name,
    :system_id,
    :attackers
  ]

  @type t :: %__MODULE__{
          killmail_id: any(),
          zkb: map(),
          esi_data: map() | nil
        }

  @doc &quot;&quot;&quot;
  Implements the Access behaviour to allow accessing the struct like a map.
  This enables syntax like killmail[&quot;victim&quot;] to work.
  &quot;&quot;&quot;
  @behaviour Access

  @impl Access
  def fetch(killmail, key) do
    cond do
      direct_killmail_key?(key) -&gt;
        fetch_direct_property(killmail, key)

      has_esi_data?(killmail) -&gt;
        fetch_from_esi_data(killmail, key)

      true -&gt;
        :error
    end
  end

  # Check if the key is a direct property of the killmail
  defp direct_killmail_key?(key) do
    key in [&quot;killmail_id&quot;, &quot;zkb&quot;, &quot;esi_data&quot;]
  end

  # Check if the killmail has ESI data
  defp has_esi_data?(killmail) do
    not is_nil(killmail.esi_data)
  end

  # Fetch direct property from the killmail
  defp fetch_direct_property(killmail, key) do
    value =
      case key do
        &quot;killmail_id&quot; -&gt; killmail.killmail_id
        &quot;zkb&quot; -&gt; killmail.zkb
        &quot;esi_data&quot; -&gt; killmail.esi_data
      end

    {:ok, value}
  end

  # Fetch a key from the ESI data
  defp fetch_from_esi_data(killmail, key) do
    # Handle special cases for victim and attackers explicitly
    case key do
      &quot;victim&quot; -&gt; Map.fetch(killmail.esi_data, &quot;victim&quot;)
      &quot;attackers&quot; -&gt; Map.fetch(killmail.esi_data, &quot;attackers&quot;)
      _ -&gt; Map.fetch(killmail.esi_data, key)
    end
  end

  @doc &quot;&quot;&quot;
  Helper function to get a value from the killmail.
  Not part of the Access behaviour but useful for convenience.
  &quot;&quot;&quot;
  def get(killmail, key, default \\ nil) do
    case fetch(killmail, key) do
      {:ok, value} -&gt; value
      :error -&gt; default
    end
  end

  @impl Access
  def get_and_update(killmail, key, fun) do
    current_value = get(killmail, key)
    {get_value, new_value} = fun.(current_value)

    new_killmail =
      case key do
        &quot;killmail_id&quot; -&gt;
          %{killmail | killmail_id: new_value}

        &quot;zkb&quot; -&gt;
          %{killmail | zkb: new_value}

        &quot;esi_data&quot; -&gt;
          %{killmail | esi_data: new_value}

        _ -&gt;
          if killmail.esi_data do
            new_esi_data = Map.put(killmail.esi_data, key, new_value)
            %{killmail | esi_data: new_esi_data}
          else
            killmail
          end
      end

    {get_value, new_killmail}
  end

  @impl Access
  def pop(killmail, key) do
    value = get(killmail, key)

    new_killmail =
      case key do
        &quot;killmail_id&quot; -&gt;
          %{killmail | killmail_id: nil}

        &quot;zkb&quot; -&gt;
          %{killmail | zkb: nil}

        &quot;esi_data&quot; -&gt;
          %{killmail | esi_data: nil}

        _ -&gt;
          if killmail.esi_data do
            new_esi_data = Map.delete(killmail.esi_data, key)
            %{killmail | esi_data: new_esi_data}
          else
            killmail
          end
      end

    {value, new_killmail}
  end

  @doc &quot;&quot;&quot;
  Creates a new killmail struct with just ID and ZKB data.
  This is used for scenarios where ESI data isn&apos;t available.
  &quot;&quot;&quot;
  def new(killmail_id, zkb) do
    %__MODULE__{
      killmail_id: killmail_id,
      zkb: zkb,
      esi_data: nil
    }
  end

  @doc &quot;&quot;&quot;
  Creates a new killmail struct with the provided data.
  Overloaded for compatibility with processing/killmail/core.ex
  &quot;&quot;&quot;
  def new(kill_id, zkb, enriched_data) do
    %__MODULE__{
      killmail_id: kill_id,
      zkb: zkb,
      esi_data: enriched_data
    }
  end

  @doc &quot;&quot;&quot;
  Creates a killmail struct from a map.

  ## Parameters
  - map: A map containing killmail data

  ## Returns
  A new %WandererNotifier.Killmail.Killmail{} struct
  &quot;&quot;&quot;
  def from_map(map) when is_map(map) do
    %__MODULE__{
      killmail_id: map[&quot;killmail_id&quot;],
      zkb: map[&quot;zkb&quot;],
      esi_data: map[&quot;esi_data&quot;]
    }
  end

  @doc &quot;&quot;&quot;
  Gets victim information from a killmail.

  ## Parameters
  - killmail: The killmail struct

  ## Returns
  A map with victim data, or nil if not available
  &quot;&quot;&quot;
  def get_victim(killmail) do
    get(killmail, &quot;victim&quot;)
  end

  @doc &quot;&quot;&quot;
  Gets attacker information from a killmail.

  ## Parameters
  - killmail: The killmail struct

  ## Returns
  A list of attacker data maps, or empty list if not available
  &quot;&quot;&quot;
  def get_attacker(killmail) do
    # Return the full list of attackers
    get(killmail, &quot;attackers&quot;) || []
  end

  @doc &quot;&quot;&quot;
  Gets the solar system ID from a killmail.

  ## Parameters
  - killmail: The killmail struct

  ## Returns
  The solar system ID as an integer, or nil if not available
  &quot;&quot;&quot;
  def get_system_id(killmail) do
    get(killmail, &quot;solar_system_id&quot;)
  end

  @doc &quot;&quot;&quot;
  Gets the victim&apos;s ship type ID from a killmail.

  ## Parameters
  - killmail: The killmail struct

  ## Returns
  The ship type ID, or nil if not available
  &quot;&quot;&quot;
  def get_victim_ship_type_id(killmail) do
    victim = get_victim(killmail)
    if victim, do: victim[&quot;ship_type_id&quot;], else: nil
  end

  @doc &quot;&quot;&quot;
  Gets the victim&apos;s character ID from a killmail.

  ## Parameters
  - killmail: The killmail struct

  ## Returns
  The character ID, or nil if not available
  &quot;&quot;&quot;
  def get_victim_character_id(killmail) do
    victim = get_victim(killmail)
    if victim, do: victim[&quot;character_id&quot;], else: nil
  end

  @doc &quot;&quot;&quot;
  Gets the victim&apos;s corporation ID from a killmail.

  ## Parameters
  - killmail: The killmail struct

  ## Returns
  The corporation ID, or nil if not available
  &quot;&quot;&quot;
  def get_victim_corporation_id(killmail) do
    victim = get_victim(killmail)
    if victim, do: victim[&quot;corporation_id&quot;], else: nil
  end

  @doc &quot;&quot;&quot;
  Gets the killmail hash from zKillboard data.

  ## Parameters
  - killmail: The killmail struct

  ## Returns
  The killmail hash, or nil if not available
  &quot;&quot;&quot;
  def get_hash(killmail) do
    if killmail.zkb, do: killmail.zkb[&quot;hash&quot;], else: nil
  end
end</file><file path="lib/wanderer_notifier/killmail/metric_registry.ex">defmodule WandererNotifier.Killmail.MetricRegistry do
  @moduledoc &quot;&quot;&quot;
  Registers metrics-related atoms to prevent &apos;non-existing atom&apos; errors.
  This module ensures that all metric keys used by the Metrics module
  are pre-registered as atoms during application startup.

  IMPORTANT: The metric keys generated here must match those in
  WandererNotifier.Killmail.Metrics@registered_metrics exactly.
  If you add metrics to one module, you must update the other.
  &quot;&quot;&quot;

  alias WandererNotifier.Logger.Logger, as: AppLogger

  # List of processing modes
  @processing_modes [&quot;realtime&quot;, &quot;historical&quot;, &quot;manual&quot;, &quot;batch&quot;]

  # List of metric operations - MUST match the keys in Metrics@registered_metrics
  @metric_operations [
    # Base processing metrics
    &quot;start&quot;,
    &quot;complete&quot;,
    &quot;complete.success&quot;,
    &quot;complete.error&quot;,
    &quot;skipped&quot;,
    &quot;error&quot;,
    # Only the metric name without the mode part
    &quot;persistence&quot;,
    # Notification metrics
    &quot;notification.sent&quot;
  ]

  @doc &quot;&quot;&quot;
  Initializes all atom keys used for metrics.
  Call this function during application startup.
  &quot;&quot;&quot;
  def initialize do
    AppLogger.startup_info(&quot;Initializing metric registry...&quot;)

    # Create all combinations of metric keys
    metric_atoms = build_metric_keys()

    # Count the number of registered atoms
    count = length(metric_atoms)

    AppLogger.startup_info(&quot;Registered metric atoms&quot;, %{
      count: count,
      category: &quot;killmail_metrics&quot;
    })

    # Return the list of registered atoms
    {:ok, metric_atoms}
  end

  @doc &quot;&quot;&quot;
  Returns a list of all registered metric atom keys.
  &quot;&quot;&quot;
  def registered_metrics do
    build_metric_keys()
  end

  # Private function to build all metric keys
  defp build_metric_keys do
    # Add base processing metrics (with killmail.processing prefix)
    processing_metrics =
      for operation &lt;- @metric_operations,
          mode &lt;- @processing_modes,
          !String.starts_with?(operation, &quot;notification.&quot;) do
        if operation == &quot;persistence&quot; do
          # Special case for persistence metrics
          &quot;killmail.#{operation}.#{mode}&quot;
        else
          # Normal processing metrics
          &quot;killmail.processing.#{mode}.#{operation}&quot;
        end
      end

    # Add notification metrics (with killmail.notification prefix)
    notification_metrics =
      for mode &lt;- @processing_modes do
        &quot;killmail.notification.#{mode}.sent&quot;
      end

    # Combine all metrics
    (processing_metrics ++ notification_metrics)
    |&gt; Enum.uniq()
    |&gt; Enum.map(&amp;String.to_atom/1)
  end
end</file><file path="lib/wanderer_notifier/killmail/metrics.ex">defmodule WandererNotifier.Killmail.Metrics do
  @moduledoc &quot;&quot;&quot;
  Metrics collection and reporting for killmail processing.
  &quot;&quot;&quot;

  alias WandererNotifier.Killmail.Context
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Agent name for metrics storage
  @agent_name :killmail_metrics_agent

  # Registered metrics that are allowed to be tracked
  @registered_metrics %{
    # Base processing metrics for all modes
    &quot;killmail.processing.realtime.start&quot; =&gt; :counter,
    &quot;killmail.processing.historical.start&quot; =&gt; :counter,
    &quot;killmail.processing.manual.start&quot; =&gt; :counter,
    &quot;killmail.processing.batch.start&quot; =&gt; :counter,

    # Complete metrics for all modes with success/error variants
    &quot;killmail.processing.realtime.complete&quot; =&gt; :counter,
    &quot;killmail.processing.historical.complete&quot; =&gt; :counter,
    &quot;killmail.processing.manual.complete&quot; =&gt; :counter,
    &quot;killmail.processing.batch.complete&quot; =&gt; :counter,
    &quot;killmail.processing.realtime.complete.success&quot; =&gt; :counter,
    &quot;killmail.processing.historical.complete.success&quot; =&gt; :counter,
    &quot;killmail.processing.manual.complete.success&quot; =&gt; :counter,
    &quot;killmail.processing.batch.complete.success&quot; =&gt; :counter,
    &quot;killmail.processing.realtime.complete.error&quot; =&gt; :counter,
    &quot;killmail.processing.historical.complete.error&quot; =&gt; :counter,
    &quot;killmail.processing.manual.complete.error&quot; =&gt; :counter,
    &quot;killmail.processing.batch.complete.error&quot; =&gt; :counter,

    # Skipped metrics for all modes
    &quot;killmail.processing.realtime.skipped&quot; =&gt; :counter,
    &quot;killmail.processing.historical.skipped&quot; =&gt; :counter,
    &quot;killmail.processing.manual.skipped&quot; =&gt; :counter,
    &quot;killmail.processing.batch.skipped&quot; =&gt; :counter,

    # Error metrics for all modes
    &quot;killmail.processing.realtime.error&quot; =&gt; :counter,
    &quot;killmail.processing.historical.error&quot; =&gt; :counter,
    &quot;killmail.processing.manual.error&quot; =&gt; :counter,
    &quot;killmail.processing.batch.error&quot; =&gt; :counter,

    # Persistence metrics for all modes
    &quot;killmail.persistence.realtime&quot; =&gt; :counter,
    &quot;killmail.persistence.historical&quot; =&gt; :counter,
    &quot;killmail.persistence.manual&quot; =&gt; :counter,
    &quot;killmail.persistence.batch&quot; =&gt; :counter,

    # Notification metrics for all modes
    &quot;killmail.notification.realtime.sent&quot; =&gt; :counter,
    &quot;killmail.notification.historical.sent&quot; =&gt; :counter,
    &quot;killmail.notification.manual.sent&quot; =&gt; :counter,
    &quot;killmail.notification.batch.sent&quot; =&gt; :counter
  }

  @doc &quot;&quot;&quot;
  Required child_spec implementation for supervisor integration.
  &quot;&quot;&quot;
  def child_spec(opts) do
    %{
      id: __MODULE__,
      start: {__MODULE__, :start_link, [opts]},
      type: :worker,
      restart: :permanent,
      shutdown: 500
    }
  end

  @doc &quot;&quot;&quot;
  Initializes the metrics agent.
  Call this during application startup before using any metrics functions.
  &quot;&quot;&quot;
  def start_link(_opts \\ []) do
    # Initialize the agent with the initial state
    initial_state = %{
      counters: %{},
      timestamp: DateTime.utc_now()
    }

    # Start the agent with a name
    result = Agent.start_link(fn -&gt; initial_state end, name: @agent_name)

    # Synchronize with metric registry
    synchronize_registry()

    result
  end

  @doc &quot;&quot;&quot;
  Synchronizes the registered metrics with the metric registry to avoid errors.
  &quot;&quot;&quot;
  def synchronize_registry do
    alias WandererNotifier.Killmail.MetricRegistry

    # Get all registered metrics from the registry
    registry_metrics = MetricRegistry.registered_metrics()

    # Convert atom metrics to strings
    registry_metric_strings = Enum.map(registry_metrics, &amp;Atom.to_string/1)

    # Find metrics that are in the registry but not in @registered_metrics
    missing_from_metrics =
      Enum.filter(registry_metric_strings, fn metric_string -&gt;
        !Map.has_key?(@registered_metrics, metric_string)
      end)

    # Find metrics that are in @registered_metrics but not in registry
    missing_from_registry =
      Enum.filter(Map.keys(@registered_metrics), fn metric_key -&gt;
        !Enum.member?(registry_metric_strings, metric_key)
      end)

    # Log any discrepancies
    cond do
      # Both lists have discrepancies
      !Enum.empty?(missing_from_metrics) &amp;&amp; !Enum.empty?(missing_from_registry) -&gt;
        log_metric_discrepancies(
          missing_from_metrics,
          missing_from_registry,
          &quot;Metrics discrepancies found in both directions&quot;
        )

      # Only registry has metrics that aren&apos;t in @registered_metrics
      !Enum.empty?(missing_from_metrics) -&gt;
        log_metric_discrepancies(
          missing_from_metrics,
          [],
          &quot;Found metrics in registry that aren&apos;t in @registered_metrics map&quot;
        )

      # Only @registered_metrics has metrics that aren&apos;t in registry
      !Enum.empty?(missing_from_registry) -&gt;
        log_metric_discrepancies(
          [],
          missing_from_registry,
          &quot;Found metrics in @registered_metrics that aren&apos;t in registry&quot;
        )

      # Everything is in sync
      true -&gt;
        AppLogger.startup_debug(&quot;Metrics registry is in sync&quot;, %{
          metric_count: length(registry_metric_strings)
        })
    end

    :ok
  end

  # Helper function to log metric discrepancies in a useful way
  defp log_metric_discrepancies(missing_from_metrics, missing_from_registry, message) do
    # Log a summary warning with counts
    AppLogger.startup_warn(message, %{
      missing_from_metrics_count: length(missing_from_metrics),
      missing_from_registry_count: length(missing_from_registry),
      first_few_from_metrics: Enum.take(missing_from_metrics, 3),
      first_few_from_registry: Enum.take(missing_from_registry, 3)
    })

    # Log details about metrics missing from @registered_metrics
    if !Enum.empty?(missing_from_metrics) do
      log_missing_metrics_chunks(missing_from_metrics)
    end

    # Log details about metrics missing from registry
    if !Enum.empty?(missing_from_registry) do
      log_missing_registry_chunks(missing_from_registry)
    end

    # Provide instructions
    log_help_message(missing_from_metrics, missing_from_registry)
  end

  # Helper to log chunks of missing metrics
  defp log_missing_metrics_chunks(missing_metrics) do
    Enum.chunk_every(missing_metrics, 10)
    |&gt; Enum.with_index()
    |&gt; Enum.each(fn {chunk, idx} -&gt;
      # Format for easy copy/paste to add to @registered_metrics
      formatted_metrics = format_metric_chunk(chunk)

      AppLogger.startup_debug(
        &quot;Missing from @registered_metrics (chunk #{idx + 1})&quot;,
        %{metrics_for_copy_paste: &quot;\n    #{formatted_metrics}&quot;}
      )
    end)
  end

  # Format a chunk of metrics using map_join for efficiency
  defp format_metric_chunk(chunk) do
    Enum.map_join(chunk, &quot;,\n    &quot;, fn metric -&gt;
      ~s(&quot;#{metric}&quot; =&gt; :counter)
    end)
  end

  # Helper to log chunks of missing registry items
  defp log_missing_registry_chunks(missing_registry) do
    Enum.chunk_every(missing_registry, 10)
    |&gt; Enum.with_index()
    |&gt; Enum.each(fn {chunk, idx} -&gt;
      AppLogger.startup_debug(
        &quot;Missing from registry (chunk #{idx + 1})&quot;,
        %{metrics: chunk}
      )
    end)
  end

  # Log helpful information for solving the discrepancy
  defp log_help_message(missing_from_metrics, missing_from_registry) do
    cond do
      !Enum.empty?(missing_from_metrics) &amp;&amp; !Enum.empty?(missing_from_registry) -&gt;
        AppLogger.startup_warn(
          &quot;ACTION REQUIRED: Update both modules to sync metrics. &quot; &lt;&gt;
            &quot;Add missing metrics to @registered_metrics and update MetricRegistry.build_metric_keys/0&quot;
        )

      !Enum.empty?(missing_from_metrics) -&gt;
        AppLogger.startup_warn(
          &quot;ACTION REQUIRED: Update @registered_metrics to include metrics from registry&quot;
        )

      !Enum.empty?(missing_from_registry) -&gt;
        AppLogger.startup_warn(
          &quot;ACTION REQUIRED: Update MetricRegistry.build_metric_keys/0 to register all needed metrics&quot;
        )

      true -&gt;
        :ok
    end
  end

  @doc &quot;&quot;&quot;
  Tracks the start of killmail processing.
  &quot;&quot;&quot;
  def track_processing_start(%Context{} = ctx) do
    track_metric(processing_metric(ctx, &quot;start&quot;))
  end

  @doc &quot;&quot;&quot;
  Tracks the completion of killmail processing.
  &quot;&quot;&quot;
  def track_processing_complete(%Context{} = ctx, result) do
    # Track the base completion metric
    track_metric(processing_metric(ctx, &quot;complete&quot;))

    # Also track success or error specifically
    status = if match?({:ok, _}, result), do: &quot;success&quot;, else: &quot;error&quot;
    track_metric(processing_metric(ctx, &quot;complete.#{status}&quot;))
  end

  @doc &quot;&quot;&quot;
  Tracks a skipped killmail.
  &quot;&quot;&quot;
  def track_processing_skipped(%Context{} = ctx) do
    track_metric(processing_metric(ctx, &quot;skipped&quot;))
  end

  @doc &quot;&quot;&quot;
  Tracks a processing error.
  &quot;&quot;&quot;
  def track_processing_error(%Context{} = ctx) do
    track_metric(processing_metric(ctx, &quot;error&quot;))
  end

  @doc &quot;&quot;&quot;
  Tracks a notification being sent.
  &quot;&quot;&quot;
  def track_notification_sent(%Context{} = ctx) do
    mode_name = get_mode_name(ctx)
    track_metric(&quot;killmail.notification.#{mode_name}.sent&quot;)
  end

  @doc &quot;&quot;&quot;
  Tracks a killmail being persisted.
  &quot;&quot;&quot;
  def track_persistence(%Context{} = ctx) do
    mode_name = get_mode_name(ctx)
    track_metric(&quot;killmail.persistence.#{mode_name}&quot;)
  end

  # Helper to build a processing metric name
  defp processing_metric(%Context{} = ctx, operation) do
    mode_name = get_mode_name(ctx)
    &quot;killmail.processing.#{mode_name}.#{operation}&quot;
  end

  # Helper to get the mode name as a string
  defp get_mode_name(%Context{mode: %{mode: mode}}), do: Atom.to_string(mode)
  defp get_mode_name(_), do: &quot;manual&quot;

  # Core tracking function that updates counters
  defp track_metric(metric_name) do
    metric_atom = String.to_atom(metric_name)

    # Check if the metric is registered to avoid atom leaks
    if Map.has_key?(@registered_metrics, metric_name) do
      try do
        Agent.update(@agent_name, fn state -&gt;
          # Update the counter for this metric
          updated_counters =
            Map.update(
              state.counters,
              metric_atom,
              1,
              &amp;(&amp;1 + 1)
            )

          %{state | counters: updated_counters}
        end)
      rescue
        error -&gt;
          AppLogger.error(&quot;Failed to track metric&quot;, %{
            metric: metric_name,
            error: inspect(error)
          })
      end
    else
      AppLogger.error(&quot;Attempted to track unregistered metric&quot;, %{
        metric: metric_name,
        available_metrics: Map.keys(@registered_metrics)
      })
    end
  end

  @doc &quot;&quot;&quot;
  Gets all the current metric values.
  &quot;&quot;&quot;
  def get_metrics do
    try do
      Agent.get(@agent_name, fn state -&gt;
        %{
          counters: state.counters,
          since: state.timestamp
        }
      end)
    rescue
      error -&gt;
        AppLogger.error(&quot;Failed to get metrics&quot;, %{
          error: inspect(error)
        })

        %{
          counters: %{},
          since: DateTime.utc_now(),
          error: inspect(error)
        }
    end
  end

  @doc &quot;&quot;&quot;
  Resets all metrics to zero.
  &quot;&quot;&quot;
  def reset_metrics do
    try do
      Agent.update(@agent_name, fn _state -&gt;
        %{
          counters: %{},
          timestamp: DateTime.utc_now()
        }
      end)
    rescue
      error -&gt;
        AppLogger.error(&quot;Failed to reset metrics&quot;, %{
          error: inspect(error)
        })

        :error
    end
  end
end</file><file path="lib/wanderer_notifier/killmail/mode.ex">defmodule WandererNotifier.Killmail.Mode do
  @moduledoc &quot;&quot;&quot;
  Defines the processing modes for killmail processing.
  &quot;&quot;&quot;

  @type t :: :historical | :realtime

  @type options :: %{
          optional(:batch_size) =&gt; pos_integer(),
          optional(:concurrency) =&gt; pos_integer(),
          optional(:retry_attempts) =&gt; non_neg_integer(),
          optional(:retry_delay) =&gt; pos_integer()
        }

  defstruct [:mode, :options]

  @doc &quot;&quot;&quot;
  Creates a new mode struct with the given mode and options.
  &quot;&quot;&quot;
  @spec new(t(), options()) :: %__MODULE__{}
  def new(mode, options \\ %{}) do
    %__MODULE__{
      mode: mode,
      options: Map.merge(default_options(mode), options)
    }
  end

  @doc &quot;&quot;&quot;
  Returns the default options for a given mode.
  &quot;&quot;&quot;
  @spec default_options(t()) :: options()
  def default_options(:historical) do
    %{
      batch_size: 100,
      concurrency: 5,
      retry_attempts: 3,
      retry_delay: 1000
    }
  end

  def default_options(:realtime) do
    %{
      batch_size: 1,
      concurrency: 1,
      retry_attempts: 3,
      retry_delay: 1000
    }
  end
end</file><file path="lib/wanderer_notifier/killmail/notification.ex">defmodule WandererNotifier.Killmail.Notification do
  @moduledoc &quot;&quot;&quot;
  Handles sending notifications for killmails.
  &quot;&quot;&quot;

  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Notifications.Factory
  alias WandererNotifier.Notifications.KillmailNotification

  @doc &quot;&quot;&quot;
  Sends a notification for a killmail.

  ## Parameters
    - killmail: The killmail data to send a notification for
    - kill_id: The ID of the kill for logging purposes

  ## Returns
    - {:ok, notification_result} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_kill_notification(killmail, kill_id) do
    try do
      # Create the notification using the KillmailNotification module
      notification = KillmailNotification.create(killmail)

      # Send the notification through the factory
      case Factory.send_message(notification) do
        {:ok, :sent} -&gt;
          AppLogger.notification_info(&quot;Kill notification sent successfully&quot;, %{
            kill_id: kill_id,
            victim: killmail.victim_name,
            attacker: killmail.attacker_name
          })

          {:ok, notification}

        {:error, :notifications_disabled} -&gt;
          AppLogger.notification_info(&quot;Kill notification skipped - notifications disabled&quot;, %{
            kill_id: kill_id
          })

          {:ok, :disabled}

        {:error, reason} = error -&gt;
          AppLogger.notification_error(&quot;Failed to send kill notification&quot;, %{
            kill_id: kill_id,
            error: inspect(reason)
          })

          error
      end
    rescue
      e -&gt;
        AppLogger.notification_error(&quot;Exception sending kill notification&quot;, %{
          kill_id: kill_id,
          error: Exception.message(e),
          stacktrace: Exception.format_stacktrace(__STACKTRACE__)
        })

        {:error, :notification_failed}
    end
  end
end</file><file path="lib/wanderer_notifier/killmail/pipeline.ex">defmodule WandererNotifier.Killmail.Pipeline do
  @moduledoc &quot;&quot;&quot;
  Standardized pipeline for processing killmails.
  Handles both realtime and historical processing modes.
  &quot;&quot;&quot;

  alias WandererNotifier.ESI.Service, as: ESIService
  alias WandererNotifier.Core.Stats
  alias WandererNotifier.Killmail.{Context, Killmail, Metrics, Enrichment, Notification}
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Notifications.Determiner.Kill, as: KillDeterminer

  @type killmail :: Killmail.t()
  @type result :: {:ok, killmail()} | {:error, term()}

  @doc &quot;&quot;&quot;
  Process a killmail through the pipeline.
  &quot;&quot;&quot;
  @spec process_killmail(map(), Context.t()) :: result()
  def process_killmail(zkb_data, ctx) do
    Metrics.track_processing_start(ctx)
    Stats.increment(:kill_processed)

    with {:ok, killmail} &lt;- create_killmail(zkb_data),
         {:ok, enriched} &lt;- enrich_killmail(killmail),
         {:ok, tracked} &lt;- check_tracking(enriched),
         {:ok, should_notify, reason} &lt;- check_notification(tracked, ctx),
         {:ok, result} &lt;- maybe_send_notification(tracked, should_notify, ctx) do
      Metrics.track_processing_complete(ctx, {:ok, result})
      log_killmail_outcome(result, ctx, persisted: true, notified: should_notify, reason: reason)
      {:ok, result}
    else
      {:error, {:skipped, reason}} -&gt;
        Metrics.track_processing_skipped(ctx)
        # Log system name and ID for skipped killmails
        system_id = Map.get(zkb_data, &quot;solar_system_id&quot;)
        _killmail_id = Map.get(zkb_data, &quot;killmail_id&quot;)
        _system_name =
          case WandererNotifier.ESI.Service.get_system(system_id) do
            {:ok, %{&quot;name&quot; =&gt; name}} -&gt; name
            _ -&gt; &quot;Unknown&quot;
          end
        log_killmail_outcome(zkb_data, ctx, persisted: false, notified: false, reason: reason)
        {:ok, :skipped}

      error -&gt;
        Metrics.track_processing_error(ctx)
        log_killmail_error(zkb_data, ctx, error)
        error
    end
  end

  @spec create_killmail(map()) :: result()
  defp create_killmail(zkb_data) do
    kill_id = Map.get(zkb_data, &quot;killmail_id&quot;)
    hash = get_in(zkb_data, [&quot;zkb&quot;, &quot;hash&quot;])

    with {:ok, esi_data} &lt;- ESIService.get_killmail(kill_id, hash),
         zkb_map &lt;- Map.get(zkb_data, &quot;zkb&quot;, %{}),
         killmail &lt;- Killmail.new(kill_id, zkb_map, esi_data) do
      {:ok, killmail}
    else
      error -&gt;
        log_killmail_error(zkb_data, nil, error)
        error
    end
  end

  @spec enrich_killmail(killmail()) :: result()
  defp enrich_killmail(killmail) do
    enriched = Enrichment.enrich_killmail_data(killmail)
    {:ok, enriched}
  rescue
    error -&gt;
      stacktrace = __STACKTRACE__
      log_killmail_error(killmail, nil, {error, stacktrace})
      {:error, :enrichment_failed}
  end

  @spec check_tracking(killmail()) :: result()
  defp check_tracking(killmail) do
    case KillDeterminer.should_notify?(killmail) do
      {:ok, %{should_notify: true}} -&gt; {:ok, killmail}
      {:ok, %{should_notify: false, reason: reason}} -&gt; {:error, {:skipped, reason}}
    end
  end

  @spec check_notification(killmail(), Context.t()) :: {:ok, boolean(), String.t()}
  defp check_notification(killmail, ctx) do
    # Only send notifications for realtime processing
    case KillDeterminer.should_notify?(killmail) do
      {:ok, %{should_notify: should_notify, reason: reason}} -&gt;
        should_notify = Context.realtime?(ctx) and should_notify
        {:ok, should_notify, reason}

      error -&gt;
        error
    end
  end

  @spec maybe_send_notification(killmail(), boolean(), Context.t()) :: result()
  defp maybe_send_notification(killmail, true, ctx) do
    case Notification.send_kill_notification(killmail, killmail.killmail_id) do
      {:ok, _} -&gt;
        Metrics.track_notification_sent(ctx)
        {:ok, killmail}

      error -&gt;
        log_killmail_error(killmail, ctx, error)
        error
    end
  end

  defp maybe_send_notification(killmail, false, _ctx) do
    {:ok, killmail}
  end

  # Logging helpers

  defp log_killmail_outcome(killmail, ctx,
         persisted: persisted,
         notified: notified,
         reason: reason
       ) do
    kill_id = get_kill_id(killmail)
    kill_time = Map.get(killmail, &quot;killmail_time&quot;)

    metadata = %{
      kill_id: kill_id,
      kill_time: kill_time,
      character_id: ctx &amp;&amp; ctx.character_id,
      character_name: ctx &amp;&amp; ctx.character_name,
      batch_id: ctx &amp;&amp; ctx.batch_id,
      reason: reason,
      processing_mode: ctx &amp;&amp; ctx.mode &amp;&amp; ctx.mode.mode
    }

    # Determine status and message based on outcomes
    {message, status} = get_log_details(persisted, notified, reason)

    # Add status to metadata and log with appropriate level
    updated_metadata = Map.put(metadata, :status, status)

    # Use debug level for skipped and duplicates, info for others
    if status in [&quot;skipped&quot;, &quot;duplicate&quot;] do
      AppLogger.kill_debug(message, updated_metadata)
    else
      AppLogger.kill_info(message, updated_metadata)
    end
  end

  # Helper function to get log message and status based on outcomes
  defp get_log_details(persisted, notified, reason) do
    case {persisted, notified, reason} do
      {true, true, _} -&gt;
        {&quot;Killmail saved and notified&quot;, &quot;saved_and_notified&quot;}

      {true, false, &quot;Duplicate kill&quot;} -&gt;
        {&quot;Duplicate killmail detected&quot;, &quot;duplicate&quot;}

      {true, false, _} -&gt;
        {&quot;Killmail saved without notification&quot;, &quot;saved&quot;}

      {false, false, _} -&gt;
        {&quot;Killmail processing skipped&quot;, &quot;skipped&quot;}
    end
  end

  defp log_killmail_error(killmail, ctx, error) do
    kill_id = get_kill_id(killmail)
    kill_time = Map.get(killmail, &quot;killmail_time&quot;)

    # Safely extract context values with default fallbacks
    character_id = ctx &amp;&amp; ctx.character_id
    character_name = (ctx &amp;&amp; ctx.character_name) || &quot;unknown&quot;
    batch_id = (ctx &amp;&amp; ctx.batch_id) || &quot;unknown&quot;
    processing_mode = ctx &amp;&amp; ctx.mode &amp;&amp; ctx.mode.mode

    # Create base metadata
    metadata = %{
      kill_id: kill_id,
      kill_time: kill_time,
      character_id: character_id,
      character_name: character_name,
      batch_id: batch_id,
      status: &quot;error&quot;,
      processing_mode: processing_mode
    }

    # Format error information based on error type
    error_info = format_error_info(error)

    # Log the error with formatted information
    AppLogger.kill_error(
      &quot;Killmail processing failed&quot;,
      Map.merge(metadata, error_info)
    )
  end

  # Helper to format error information based on error type
  defp format_error_info({exception, stacktrace}) when is_list(stacktrace) do
    %{
      error: Exception.message(exception),
      stacktrace: Exception.format_stacktrace(stacktrace)
    }
  end

  defp format_error_info({:error, reason}) do
    %{error: inspect(reason)}
  end

  defp format_error_info(error) do
    %{error: inspect(error)}
  end

  # Extract kill ID safely from various data structures
  defp get_kill_id(%{killmail_id: id}) when is_binary(id) or is_integer(id), do: id
  defp get_kill_id(%{&quot;killmail_id&quot; =&gt; id}) when is_binary(id) or is_integer(id), do: id

  defp get_kill_id(map) when is_map(map),
    do: Map.get(map, :killmail_id) || Map.get(map, &quot;killmail_id&quot;)

  defp get_kill_id(_), do: &quot;unknown&quot;
end</file><file path="lib/wanderer_notifier/killmail/processor.ex">defmodule WandererNotifier.Killmail.Processor do
  @moduledoc &quot;&quot;&quot;
  Handles processing of killmail data and scheduling of killmail-related tasks.
  &quot;&quot;&quot;

  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Killmail.Enrichment
  alias WandererNotifier.Killmail.Killmail
  alias WandererNotifier.Killmail.Cache, as: KillmailCache
  alias WandererNotifier.Notifications.KillmailNotification

  @doc &quot;&quot;&quot;
  Initializes the killmail processor.
  &quot;&quot;&quot;
  def init do
    AppLogger.info(&quot;Initializing killmail processor&quot;)
    :ok
  end

  @doc &quot;&quot;&quot;
  Schedules killmail-related tasks.
  &quot;&quot;&quot;
  def schedule_tasks do
    AppLogger.info(&quot;Scheduling killmail tasks&quot;)
    :ok
  end

  @doc &quot;&quot;&quot;
  Processes a ZKillboard websocket message.

  ## Parameters
    - message: The message to process
    - state: The current state

  ## Returns
    - new_state
  &quot;&quot;&quot;
  def process_zkill_message(message, state) do
    case decode_zkill_message(message) do
      {:ok, kill_data} -&gt;
        # Early exit if not relevant
        case WandererNotifier.Notifications.Determiner.Kill.should_notify?(kill_data) do
          {:ok, %{should_notify: true}} -&gt;
            process_kill_data(kill_data, state)

          {:ok, %{should_notify: false, reason: reason}} -&gt;
            system_id = Map.get(kill_data, &quot;solar_system_id&quot;)
            killmail_id = Map.get(kill_data, &quot;killmail_id&quot;)
            system_name =
              case WandererNotifier.ESI.Service.get_system(system_id) do
                {:ok, %{&quot;name&quot; =&gt; name}} -&gt; name
                _ -&gt; &quot;Unknown&quot;
              end

            AppLogger.processor_info(
              &quot;Skipping killmail: #{reason} (killmail_id=#{killmail_id}, system_id=#{system_id}, system_name=#{system_name})&quot;
            )
            state

          _ -&gt;
            AppLogger.processor_error(
              &quot;Skipping killmail: unexpected response from determine_should_notify&quot;
            )

            state
        end

      {:error, reason} -&gt;
        AppLogger.error(&quot;Failed to decode ZKill message&quot;, %{
          error: inspect(reason),
          message: inspect(message)
        })

        state
    end
  end

  @doc &quot;&quot;&quot;
  Logs killmail processing statistics.
  &quot;&quot;&quot;
  def log_stats do
    AppLogger.info(&quot;Logging killmail stats&quot;)
    :ok
  end

  @doc &quot;&quot;&quot;
  Gets recent kills from the cache.

  ## Returns
    - {:ok, kills} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def get_recent_kills do
    KillmailCache.get_recent_kills()
  end

  @doc &quot;&quot;&quot;
  Sends a test kill notification.

  ## Returns
    - :ok on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_test_kill_notification do
    killmail = get_test_killmail()

    case Enrichment.enrich_killmail_data(killmail) do
      {:ok, enriched_kill} -&gt;
        KillmailNotification.send_kill_notification(enriched_kill, :test)

      {:error, reason} -&gt;
        AppLogger.error(&quot;Failed to enrich test killmail&quot;, error: inspect(reason))
        {:error, reason}
    end
  end

  # Private helper functions

  defp decode_zkill_message(message) do
    case Jason.decode(message) do
      {:ok, decoded} -&gt; {:ok, decoded}
      error -&gt; error
    end
  end

  defp process_kill_data(kill_data, state) do
    killmail = Killmail.from_map(kill_data)

    case Enrichment.enrich_killmail_data(killmail) do
      {:ok, enriched_kill} -&gt;
        KillmailNotification.send_kill_notification(enriched_kill, :zkill)
        state

      {:error, reason} -&gt;
        AppLogger.error(&quot;Failed to enrich killmail&quot;, error: inspect(reason))
        {:error, reason}
    end
  end

  defp get_test_killmail do
    # Create a test killmail for testing notifications
    %Killmail{
      killmail_id: 12345,
      zkb: %{
        &quot;hash&quot; =&gt; &quot;abc123&quot;
      },
      esi_data: %{
        &quot;killmail_time&quot; =&gt; DateTime.utc_now() |&gt; DateTime.to_iso8601(),
        &quot;solar_system_id&quot; =&gt; 30_000_142,
        &quot;victim&quot; =&gt; %{
          &quot;character_id&quot; =&gt; 98765,
          &quot;ship_type_id&quot; =&gt; 587
        },
        &quot;attackers&quot; =&gt; [
          %{
            &quot;character_id&quot; =&gt; 54321,
            &quot;ship_type_id&quot; =&gt; 587,
            &quot;final_blow&quot; =&gt; true
          }
        ]
      }
    }
  end
end</file><file path="lib/wanderer_notifier/killmail/zkill_client.ex">defmodule WandererNotifier.Killmail.ZKillClient do
  @moduledoc &quot;&quot;&quot;
  Client for interacting with the ZKillboard API.
  &quot;&quot;&quot;

  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.HttpClient.Httpoison, as: HttpClient

  @base_url &quot;https://zkillboard.com/api&quot;
  @user_agent &quot;WandererNotifier/1.0&quot;
  @rate_limit_ms 1000
  @max_retries 3
  @retry_backoff_ms 2000

  @doc &quot;&quot;&quot;
  Gets a single killmail by its ID.
  &quot;&quot;&quot;
  def get_single_killmail(kill_id) do
    AppLogger.api_debug(&quot;ZKill requesting single killmail&quot;, %{
      kill_id: kill_id,
      method: &quot;get_single_killmail&quot;
    })

    url = &quot;#{@base_url}/killID/#{kill_id}/&quot;
    headers = build_headers()

    :timer.sleep(@rate_limit_ms)

    make_request_with_retry(fn -&gt;
      with {:ok, body} &lt;- make_http_request(url, headers),
           {:ok, decoded} &lt;- decode_killmail_response(body, kill_id) do
        validate_killmail_format(decoded, kill_id)
      end
    end)
  end

  @doc &quot;&quot;&quot;
  Gets recent kills with an optional limit.
  &quot;&quot;&quot;
  def get_recent_kills(limit \\ 10) do
    url = &quot;#{@base_url}/recent/&quot;
    headers = build_headers()

    AppLogger.api_info(&quot;ZKill requesting recent kills&quot;, %{
      limit: limit,
      method: &quot;get_recent_kills&quot;
    })

    :timer.sleep(@rate_limit_ms)

    with {:ok, body} &lt;- make_http_request(url, headers),
         {:ok, kills} &lt;- decode_kills_response(body) do
      {:ok, Enum.take(kills, limit)}
    end
  end

  @doc &quot;&quot;&quot;
  Gets kills for a specific system with an optional limit.
  &quot;&quot;&quot;
  def get_system_kills(system_id, limit \\ 5) do
    url = &quot;#{@base_url}/systemID/#{system_id}/&quot;
    headers = build_headers()

    AppLogger.api_info(&quot;ZKill requesting system kills&quot;, %{
      system_id: system_id,
      limit: limit,
      method: &quot;get_system_kills&quot;
    })

    :timer.sleep(@rate_limit_ms)

    with {:ok, body} &lt;- make_http_request(url, headers),
         {:ok, kills} &lt;- decode_kills_response(body) do
      {:ok, Enum.take(kills, limit)}
    end
  end

  @doc &quot;&quot;&quot;
  Gets kills for a specific character.

  ## Parameters
    - character_id: The character ID to fetch kills for
    - date_range: Map with :start and :end DateTime (optional)
    - limit: Maximum number of kills to fetch (default: 100)
  &quot;&quot;&quot;
  def get_character_kills(character_id, date_range \\ nil, limit \\ 100) do
    url = build_character_kills_url(character_id, date_range)
    headers = build_headers()

    date_range_info =
      if date_range,
        do: %{
          start_time: date_range.start &amp;&amp; DateTime.to_iso8601(date_range.start),
          end_time: date_range.end &amp;&amp; DateTime.to_iso8601(date_range.end)
        },
        else: %{date_range: &quot;none&quot;}

    AppLogger.api_info(
      &quot;ZKill requesting character kills&quot;,
      Map.merge(
        %{
          character_id: character_id,
          limit: limit,
          method: &quot;get_character_kills&quot;,
          url: url
        },
        date_range_info
      )
    )

    :timer.sleep(@rate_limit_ms)

    with {:ok, body} &lt;- make_http_request(url, headers),
         {:ok, kills} &lt;- decode_kills_response(body) do
      kill_count = length(kills)
      limited_kills = Enum.take(kills, limit)

      AppLogger.api_debug(&quot;ZKill character kills retrieved&quot;, %{
        character_id: character_id,
        total_kills: kill_count,
        limited_kills: length(limited_kills)
      })

      {:ok, limited_kills}
    end
  end

  defp build_headers do
    [
      {&quot;Accept&quot;, &quot;application/json&quot;},
      {&quot;User-Agent&quot;, @user_agent},
      {&quot;Cache-Control&quot;, &quot;no-cache&quot;}
    ]
  end

  defp make_http_request(url, headers) do
    case HttpClient.get(url, headers) do
      {:ok, %{status_code: 200, body: body}} -&gt;
        {:ok, body}

      {:ok, %{status_code: status, body: body}} -&gt;
        AppLogger.api_error(&quot;ZKill HTTP error&quot;, %{
          status: status,
          body_sample: String.slice(body || &quot;&quot;, 0, 200),
          url: url
        })

        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;ZKill HTTP request failed&quot;, %{
          error: inspect(reason),
          url: url
        })

        {:error, reason}
    end
  end

  defp decode_killmail_response(body, kill_id) do
    case Jason.decode(body) do
      {:ok, response} -&gt;
        handle_decoded_response(response, kill_id)

      {:error, reason} -&gt;
        handle_decode_error(reason, body, kill_id)
    end
  end

  # Handle different types of successful response formats
  defp handle_decoded_response(response, kill_id) do
    cond do
      # Single killmail map
      is_map(response) -&gt;
        {:ok, response}

      # Single killmail in a list
      is_list(response) &amp;&amp; length(response) == 1 -&gt;
        [killmail] = response
        {:ok, killmail}

      # Empty list - no killmail found
      is_list(response) &amp;&amp; response == [] -&gt;
        log_zkill_warning(kill_id, &quot;empty_response&quot;, &quot;No killmail found&quot;)
        {:error, {:domain_error, :zkill, {:not_found, kill_id}}}

      # Multiple killmails - unexpected but we can take the first one
      is_list(response) -&gt;
        log_zkill_warning(
          kill_id,
          &quot;multiple_killmails&quot;,
          &quot;Multiple killmails returned for single ID&quot;,
          %{count: length(response)}
        )

        [killmail | _] = response
        {:ok, killmail}

      # Boolean or other unexpected formats
      true -&gt;
        format_type = typeof(response)

        log_zkill_warning(kill_id, &quot;unexpected_format&quot;, &quot;Unexpected response format&quot;, %{
          format_type: format_type
        })

        {:error, {:domain_error, :zkill, {:unexpected_format, format_type}}}
    end
  end

  defp handle_decode_error(reason, body, kill_id) do
    AppLogger.api_error(&quot;ZKill JSON decode error&quot;, %{
      error: inspect(reason),
      body_sample: String.slice(body || &quot;&quot;, 0, 200),
      kill_id: kill_id
    })

    {:error, {:json_decode_error, reason}}
  end

  defp decode_kills_response(body) do
    case Jason.decode(body) do
      {:ok, kills} when is_list(kills) -&gt;
        {:ok, kills}

      {:ok, _non_list} -&gt;
        {:error, {:domain_error, :zkill, :invalid_kills_format}}

      {:error, reason} -&gt;
        {:error, {:json_decode_error, reason}}
    end
  end

  defp build_character_kills_url(character_id, date_range) do
    base = &quot;#{@base_url}/characterID/#{character_id}/&quot;

    case date_range do
      nil -&gt;
        base

      %{start: start_time, end: end_time} when not is_nil(start_time) and not is_nil(end_time) -&gt;
        start_str = DateTime.to_date(start_time) |&gt; Date.to_iso8601()
        end_str = DateTime.to_date(end_time) |&gt; Date.to_iso8601()
        &quot;#{base}startTime/#{start_str}/endTime/#{end_str}/&quot;

      _ -&gt;
        base
    end
  end

  defp make_request_with_retry(request_fn, retries \\ 0) do
    case request_fn.() do
      {:ok, result} -&gt;
        {:ok, result}

      {:error, _reason} when retries &lt; @max_retries -&gt;
        :timer.sleep(@retry_backoff_ms * (retries + 1))
        make_request_with_retry(request_fn, retries + 1)

      {:error, reason} -&gt;
        {:error, reason}
    end
  end

  defp log_zkill_warning(kill_id, type, message, extra_fields \\ %{}) do
    AppLogger.api_warn(
      &quot;ZKill #{message}&quot;,
      Map.merge(
        %{
          kill_id: kill_id,
          warning_type: type
        },
        extra_fields
      )
    )
  end

  defp typeof(term) when is_nil(term), do: &quot;nil&quot;
  defp typeof(term) when is_binary(term), do: &quot;string&quot;
  defp typeof(term) when is_boolean(term), do: &quot;boolean&quot;
  defp typeof(term) when is_number(term), do: &quot;number&quot;
  defp typeof(term) when is_map(term), do: &quot;map&quot;
  defp typeof(term) when is_list(term), do: &quot;list&quot;
  defp typeof(term) when is_atom(term), do: &quot;atom&quot;
  defp typeof(_term), do: &quot;unknown&quot;

  defp validate_killmail_format(killmail, _kill_id), do: {:ok, killmail}
end</file><file path="lib/wanderer_notifier/license/client.ex">defmodule WandererNotifier.License.Client do
  @moduledoc &quot;&quot;&quot;
  Client for interacting with the License Manager API.
  Provides functions for validating licenses and bots.
  &quot;&quot;&quot;
  require Logger
  alias WandererNotifier.HttpClient.Httpoison, as: HttpClient
  alias WandererNotifier.Config
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Define the behaviour callbacks
  @callback validate_bot(String.t(), String.t()) :: {:ok, map()} | {:error, atom()}

  @doc &quot;&quot;&quot;
  Validates a bot by calling the license manager API.

  ## Parameters
  - `notifier_api_token`: The API token for the notifier.
  - `license_key`: The license key to validate.

  ## Returns
  - `{:ok, data}` if the bot was validated successfully.
  - `{:error, reason}` if the validation failed.
  &quot;&quot;&quot;
  def validate_bot(notifier_api_token, license_key) do
    url = &quot;#{Config.license_manager_api_url()}/api/validate_bot&quot;

    # Log minimal request information without exposing sensitive data
    AppLogger.api_info(&quot;Making license validation request to License Manager API&quot;)

    # Set up request parameters
    headers = build_auth_headers(notifier_api_token)
    body = %{&quot;license_key&quot; =&gt; license_key}

    AppLogger.api_debug(&quot;Sending HTTP request for bot validation&quot;, endpoint: &quot;validate_bot&quot;)

    # Make the API request and process the response
    make_validation_request(url, body, headers)
  end

  # Build authorization headers for API requests
  defp build_auth_headers(api_token) do
    [
      {&quot;Content-Type&quot;, &quot;application/json&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;},
      {&quot;Authorization&quot;, &quot;Bearer #{api_token}&quot;}
    ]
  end

  # Make the actual API request for validation
  defp make_validation_request(url, body, headers) do
    case HttpClient.post_json(url, body, headers,
           label: &quot;LicenseManager.validate_bot&quot;,
           debug: true,
           timeout: 5000
         ) do
      {:ok, %{status_code: _status, body: decoded}} -&gt;
        process_successful_validation(decoded)

      {:error, :connect_timeout} -&gt;
        AppLogger.api_error(&quot;License Manager API request timed out&quot;)
        {:error, :request_failed}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;License Manager API request failed&quot;, error: inspect(reason))
        {:error, :request_failed}
    end
  end

  # Process a successful validation response
  defp process_successful_validation(decoded) do
    # Additional logging for easier debugging without exposing sensitive data
    license_valid = decoded[&quot;license_valid&quot;] || false

    log_validation_result(license_valid, decoded[&quot;message&quot;])

    # Ensure the response contains both formats for compatibility
    enhanced_response = Map.merge(decoded, %{&quot;valid&quot; =&gt; license_valid})
    {:ok, enhanced_response}
  end

  # Log the validation result based on validity
  defp log_validation_result(true, _message) do
    AppLogger.api_info(&quot;License and bot validation successful&quot;, license_valid: true)
  end

  defp log_validation_result(false, message) do
    error_msg = message || &quot;License is not valid&quot;

    AppLogger.api_warn(&quot;License and bot validation failed&quot;,
      reason: error_msg,
      license_valid: false
    )
  end

  @doc &quot;&quot;&quot;
  Validates a license key by calling the license manager API.

  ## Parameters
  - `license_key`: The license key to validate.
  - `notifier_api_token`: The API token for the notifier.

  ## Returns
  - `{:ok, data}` if the license was validated successfully.
  - `{:error, reason}` if the validation failed.
  &quot;&quot;&quot;
  def validate_license(license_key, notifier_api_token) do
    url = &quot;#{Config.license_manager_api_url()}/api/validate_license&quot;
    AppLogger.api_info(&quot;Making license validation request to License Manager API&quot;)

    # Prepare request parameters
    headers = build_auth_headers(notifier_api_token)
    body = %{&quot;license_key&quot; =&gt; license_key}

    AppLogger.api_debug(&quot;Sending HTTP request for license validation&quot;,
      endpoint: &quot;validate_license&quot;
    )

    # Make the request with error handling
    safely_make_license_request(url, body, headers)
  end

  # Make the license validation request with error handling
  defp safely_make_license_request(url, body, headers) do
    make_license_validation_request(url, body, headers)
  rescue
    e -&gt;
      AppLogger.api_error(&quot;Exception during license validation&quot;,
        exception: inspect(e),
        stacktrace: Exception.format_stacktrace(__STACKTRACE__)
      )

      {:error, &quot;Exception: #{inspect(e)}&quot;}
  end

  # Make the actual HTTP request for license validation
  defp make_license_validation_request(url, body, headers) do
    request_options = [
      label: &quot;LicenseManager.validate_license&quot;,
      timeout: 2500,
      max_retries: 1,
      debug: true
    ]

    case HttpClient.post_json(url, body, headers, request_options) do
      {:ok, %{status_code: _status, body: decoded}} -&gt;
        process_decoded_license_data(decoded)

      {:error, :timeout} -&gt;
        AppLogger.api_error(&quot;License Manager API request timed out&quot;)
        {:error, &quot;Request timed out&quot;}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;License Manager API request failed&quot;, error: inspect(reason))
        {:error, &quot;Request failed: #{inspect(reason)}&quot;}
    end
  end

  # Process decoded license data based on its format
  defp process_decoded_license_data(decoded) do
    cond do
      Map.has_key?(decoded, &quot;license_valid&quot;) -&gt;
        process_license_valid_format(decoded)

      Map.has_key?(decoded, &quot;valid&quot;) -&gt;
        process_valid_format(decoded)

      true -&gt;
        process_unknown_format(decoded)
    end
  end

  # Handle the license_valid format (from validate_bot endpoint)
  defp process_license_valid_format(decoded) do
    license_valid = decoded[&quot;license_valid&quot;]
    log_license_valid_result(license_valid, decoded[&quot;message&quot;])

    # Map to expected format for backward compatibility
    {:ok, Map.merge(decoded, %{&quot;valid&quot; =&gt; license_valid})}
  end

  # Handle the valid format (from validate_license endpoint)
  defp process_valid_format(decoded) do
    valid = decoded[&quot;valid&quot;]
    bot_assigned = decoded[&quot;bot_assigned&quot;] || false

    log_valid_format_result(valid, bot_assigned, decoded[&quot;message&quot;])
    {:ok, decoded}
  end

  # Handle unknown response format
  defp process_unknown_format(decoded) do
    AppLogger.api_warn(&quot;Unrecognized license validation response format&quot;,
      response: inspect(decoded)
    )

    {:ok,
     Map.merge(decoded, %{
       &quot;valid&quot; =&gt; false,
       &quot;message&quot; =&gt; &quot;Unrecognized response format&quot;
     })}
  end

  # Log license_valid format results
  defp log_license_valid_result(true, _) do
    AppLogger.api_info(&quot;License validation successful&quot;, license_valid: true)
  end

  defp log_license_valid_result(false, message) do
    error_msg = message || &quot;License not valid&quot;
    AppLogger.api_warn(&quot;License validation failed&quot;, reason: error_msg, license_valid: false)
  end

  # Log valid format results
  defp log_valid_format_result(true, true, _) do
    AppLogger.api_info(&quot;License validation successful&quot;, license_valid: true, bot_assigned: true)
  end

  defp log_valid_format_result(true, false, _) do
    AppLogger.api_warn(&quot;License validation partial&quot;,
      license_valid: true,
      bot_assigned: false,
      reason: &quot;License is valid but bot is not assigned&quot;
    )
  end

  defp log_valid_format_result(false, _, message) do
    error_msg = message || &quot;License not valid&quot;
    AppLogger.api_warn(&quot;License validation failed&quot;, reason: error_msg, license_valid: false)
  end
end</file><file path="lib/wanderer_notifier/license/service.ex">defmodule WandererNotifier.License.Service do
  @moduledoc &quot;&quot;&quot;
  License management for WandererNotifier.
  Handles license validation and feature access control.
  &quot;&quot;&quot;
  use GenServer
  alias WandererNotifier.Config
  alias WandererNotifier.License.Client, as: LicenseClient
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Define the behaviour callbacks
  @callback validate() :: boolean()
  @callback status() :: map()

  # Client API

  @doc &quot;&quot;&quot;
  Starts the License GenServer.
  &quot;&quot;&quot;
  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @doc &quot;&quot;&quot;
  Validates the license key.
  Returns a map with license status information.
  &quot;&quot;&quot;
  def validate do
    # Safely validate with fallback to a complete default state
    case GenServer.call(__MODULE__, :validate, 5000) do
      result when is_map(result) and is_map_key(result, :valid) -&gt;
        # Proper result received
        result

      unexpected_result -&gt;
        # Create a safe default state
        AppLogger.config_error(
          &quot;Unexpected result from license validation: #{inspect(unexpected_result)}&quot;
        )

        %{
          valid: false,
          bot_assigned: false,
          details: nil,
          error: :unexpected_result,
          error_message: &quot;Unexpected validation result&quot;,
          last_validated: :os.system_time(:second)
        }
    end
  rescue
    e -&gt;
      AppLogger.config_error(&quot;Error in license validation: #{inspect(e)}&quot;)

      %{
        valid: false,
        bot_assigned: false,
        details: nil,
        error: :exception,
        error_message: &quot;License validation error: #{inspect(e)}&quot;,
        last_validated: :os.system_time(:second)
      }
  catch
    :exit, {:timeout, _} -&gt;
      AppLogger.config_error(&quot;License validation timed out&quot;)

      %{
        valid: false,
        bot_assigned: false,
        details: nil,
        error: :timeout,
        error_message: &quot;License validation timed out&quot;,
        last_validated: :os.system_time(:second)
      }

    type, reason -&gt;
      AppLogger.config_error(&quot;License validation error: #{inspect(type)}, #{inspect(reason)}&quot;)

      %{
        valid: false,
        bot_assigned: false,
        details: nil,
        error: type,
        error_message: &quot;License validation error: #{inspect(reason)}&quot;,
        last_validated: :os.system_time(:second)
      }
  end

  @doc &quot;&quot;&quot;
  Returns the current license status.
  &quot;&quot;&quot;
  def status do
    %{
      valid: valid?(),
      bot_assigned: bot_assigned?()
    }
  end

  @doc &quot;&quot;&quot;
  Checks if a specific feature is enabled.
  &quot;&quot;&quot;
  def feature_enabled?(feature) do
    GenServer.call(__MODULE__, {:feature_enabled, feature})
  end

  @doc &quot;&quot;&quot;
  Validates the API token.
  The token should be a non-empty string.
  &quot;&quot;&quot;
  def validate_token do
    token = Config.notifier_api_token()

    # Add detailed debug logging
    AppLogger.config_info(
      &quot;License validation - token check (redacted): #{if token, do: &quot;[REDACTED]&quot;, else: &quot;nil&quot;}&quot;
    )

    AppLogger.config_info(&quot;License validation - environment: #{Config.get_env(:environment)}&quot;)

    # Basic validation - ensure token exists and is a non-empty string
    is_valid = is_binary(token) &amp;&amp; String.trim(token) != &quot;&quot;

    if !is_valid do
      AppLogger.config_warn(&quot;License validation warning: Invalid notifier API token&quot;)
    end

    is_valid
  end

  @doc &quot;&quot;&quot;
  Gets the license key from configuration.
  &quot;&quot;&quot;
  def get_license_key do
    Config.get_env(:license_key)
  end

  @doc &quot;&quot;&quot;
  Gets the license manager URL from configuration.
  &quot;&quot;&quot;
  def get_license_manager_url do
    Config.get_env(:license_manager_url)
  end

  @doc &quot;&quot;&quot;
  Checks if the current license is valid.
  &quot;&quot;&quot;
  def check_license do
    if valid?() do
      {:ok, :valid}
    else
      {:error, :invalid_license}
    end
  end

  # Private helper to check if license is valid
  defp valid? do
    bot_assigned?() &amp;&amp; license_key_valid?()
  end

  # Private helper to check if bot token is assigned
  defp bot_assigned? do
    case Config.get_env(:bot_token) do
      nil -&gt; false
      &quot;&quot; -&gt; false
      _ -&gt; true
    end
  end

  # Private helper to check if license key is valid
  defp license_key_valid? do
    case Config.get_env(:license_key) do
      nil -&gt; false
      &quot;&quot; -&gt; false
      _ -&gt; true
    end
  end

  # Server Implementation

  @impl true
  def init(_opts) do
    schedule_refresh()
    # Initialize state with all necessary keys to avoid KeyError
    initial_state = %{
      valid: false,
      bot_assigned: false,
      details: nil,
      error: nil,
      error_message: nil,
      last_validated: :os.system_time(:second)
    }

    {:ok, initial_state, {:continue, :initial_validation}}
  end

  @impl true
  def handle_continue(:initial_validation, _state) do
    # Perform initial license validation at startup
    new_state = do_validate()

    if new_state.valid do
      AppLogger.config_info(
        &quot;License validated successfully: #{new_state.details[&quot;status&quot;] || &quot;valid&quot;}&quot;
      )
    else
      error_msg = new_state.error_message || &quot;No error message provided&quot;
      AppLogger.config_warn(&quot;License validation warning: #{error_msg}&quot;)
    end

    {:noreply, new_state}
  rescue
    e -&gt;
      AppLogger.config_error(
        &quot;License validation failed, continuing with invalid license state: #{inspect(e)}&quot;
      )

      # Return invalid license state but don&apos;t crash
      invalid_state = %{
        valid: false,
        bot_assigned: false,
        details: nil,
        error: :exception,
        error_message: &quot;License validation error: #{inspect(e)}&quot;,
        last_validated: :os.system_time(:second)
      }

      {:noreply, invalid_state}
  end

  @impl true
  def handle_call(:validate, _from, _state) do
    AppLogger.config_info(&quot;Validating license...&quot;)

    # Get the license key from configuration
    license_key = Config.license_key()

    # Get the API token from configuration
    notifier_api_token = Config.api_token()

    # Validate the license with a timeout - use validate_bot for consistency with init/startup
    validation_result =
      Task.await(
        Task.async(fn -&gt;
          # Use validate_bot for consistency with init/startup validation
          LicenseClient.validate_bot(notifier_api_token, license_key)
        end),
        3000
      )

    # Process the validation result
    {valid, bot_assigned, details, error, error_message} =
      case validation_result do
        {:ok, response} -&gt;
          # Extract validation details from response
          {
            response[&quot;valid&quot;] || false,
            response[&quot;bot_assigned&quot;] || false,
            response,
            nil,
            nil
          }

        {:error, reason} -&gt;
          # Handle validation error
          {
            false,
            false,
            nil,
            :validation_error,
            &quot;License validation failed: #{inspect(reason)}&quot;
          }
      end

    # Update state with validation results
    new_state = %{
      valid: valid,
      bot_assigned: bot_assigned,
      details: details,
      error: error,
      error_message: error_message,
      last_validated: :os.system_time(:second)
    }

    # Return the validation result and new state
    {:reply, new_state, new_state}
  catch
    :exit, {:timeout, _} -&gt;
      AppLogger.config_error(&quot;License validation HTTP request timed out&quot;)

      error_state = %{
        valid: false,
        bot_assigned: false,
        details: nil,
        error: :timeout,
        error_message: &quot;License validation timed out&quot;,
        last_validated: :os.system_time(:second)
      }

      {:reply, error_state, error_state}

    type, reason -&gt;
      AppLogger.config_error(
        &quot;License validation HTTP error: #{inspect(type)}, #{inspect(reason)}&quot;
      )

      error_state = %{
        valid: false,
        bot_assigned: false,
        details: nil,
        error: :http_error,
        error_message: &quot;License validation error: #{inspect(reason)}&quot;,
        last_validated: :os.system_time(:second)
      }

      {:reply, error_state, error_state}
  end

  @impl true
  def handle_call(:status, _from, state) do
    # Make sure we return a safe and complete state
    safe_state = ensure_complete_state(state)
    {:reply, safe_state, safe_state}
  end

  @impl true
  def handle_call({:feature_enabled, feature}, _from, state) do
    is_enabled = check_feature_enabled(feature, state)
    {:reply, is_enabled, state}
  end

  @impl true
  def handle_call(:valid, _from, state) do
    # Return if license is valid (has been validated)
    {:reply, state.validated, state}
  end

  @impl true
  def handle_call(:premium, _from, state) do
    # Since we no longer have premium licenses, always return false
    # This is kept for backward compatibility
    AppLogger.config_debug(&quot;Premium check: not premium (premium tier removed)&quot;)
    {:reply, false, state}
  end

  @impl true
  def handle_call({:set_status, status}, _from, state) do
    # Update license status
    {:reply, :ok, Map.put(state, :validated, status)}
  end

  @impl true
  def handle_info(:refresh, _state) do
    schedule_refresh()
    new_state = do_validate()
    {:noreply, new_state}
  end

  # Helper function to check if a feature is enabled based on state
  defp check_feature_enabled(feature, state) do
    case state do
      %{valid: true, details: details}
      when is_map(details) and is_map_key(details, &quot;features&quot;) -&gt;
        check_features_list(feature, details[&quot;features&quot;])

      _ -&gt;
        AppLogger.config_debug(&quot;Feature check: #{feature} - disabled (invalid license)&quot;)
        false
    end
  end

  # Helper function to check if a feature is in the features list
  defp check_features_list(feature, features) do
    if is_list(features) do
      enabled = Enum.member?(features, to_string(feature))

      AppLogger.config_debug(
        &quot;Feature check: #{feature} - #{if enabled, do: &quot;enabled&quot;, else: &quot;disabled&quot;}&quot;
      )

      enabled
    else
      AppLogger.config_debug(&quot;Feature check: #{feature} - disabled (features not a list)&quot;)
      false
    end
  end

  defp schedule_refresh do
    Process.send_after(self(), :refresh, Config.license_refresh_interval())
  end

  defp do_validate do
    license_key = Config.license_key()
    notifier_api_token = Config.api_token()

    # Validate the license with the license manager
    case LicenseClient.validate_bot(notifier_api_token, license_key) do
      {:ok, response} -&gt;
        # Check if the license is valid from the response
        license_valid = response[&quot;license_valid&quot;] || false
        # Extract error message if provided
        message = response[&quot;message&quot;]

        if license_valid do
          AppLogger.config_info(&quot;License and bot validation successful&quot;)
          # If valid, return success state
          %{
            valid: true,
            bot_assigned: true,
            details: response,
            error: nil,
            error_message: nil,
            last_validated: :os.system_time(:second)
          }
        else
          # For invalid license, return error state with message
          error_msg = message || &quot;License is not valid&quot;
          AppLogger.config_error(&quot;License validation failed - #{error_msg}&quot;)

          %{
            valid: false,
            bot_assigned: false,
            details: response,
            error: :invalid_license,
            error_message: error_msg,
            last_validated: :os.system_time(:second)
          }
        end

      {:error, reason} -&gt;
        error_message = error_reason_to_message(reason)
        AppLogger.config_error(&quot;License/bot validation failed: #{error_message}&quot;)

        %{
          valid: false,
          bot_assigned: false,
          error: reason,
          error_message: error_message,
          details: nil,
          last_validated: :os.system_time(:second)
        }
    end
  end

  # Helper function to convert error reasons to human-readable messages
  defp error_reason_to_message(reason) when is_atom(reason), do: &quot;License server error: #{reason}&quot;
  defp error_reason_to_message(reason) when is_binary(reason), do: reason
  defp error_reason_to_message(reason), do: &quot;Unknown error: #{inspect(reason)}&quot;

  # Helper to ensure the state has all required fields
  defp ensure_complete_state(state) do
    defaults = %{
      valid: false,
      bot_assigned: false,
      details: nil,
      error: nil,
      error_message: nil,
      last_validated: :os.system_time(:second)
    }

    # Merge defaults with existing state, but ensure we have all keys
    Map.merge(defaults, Map.take(state || %{}, Map.keys(defaults)))
  end
end</file><file path="lib/wanderer_notifier/logger/logger.ex">defmodule WandererNotifier.Logger.Logger do
  @moduledoc &quot;&quot;&quot;
  Enhanced and unified logging utility for WandererNotifier.

  This module serves as the central logging API for the entire application, providing:

  1. Consistent logging patterns with category-specific helpers
  2. Structured metadata handling that works reliably with both maps and keyword lists
  3. Key-value logging for configuration values and flags
  4. Batch logging support for high-volume events
  5. Startup phase tracking and logging

  ## Basic Usage

  Simple logging with categories:

  ```elixir
  # Basic logging
  Logger.info(&quot;Simple message&quot;)

  # Category-specific logging
  Logger.api_info(&quot;API request received&quot;)
  Logger.cache_debug(&quot;Cache miss&quot;, key: &quot;users:123&quot;)

  # Key-value logging (ideal for flags and configuration)
  Logger.startup_kv(&quot;Status messages disabled&quot;, disabled_flag)
  ```

  ## Batch Logging

  For high-volume events, use batch logging to reduce log noise:

  ```elixir
  # Initialize batch logger
  Logger.init_batch_logger()

  # Count events (will be logged in batches)
  Logger.count_batch_event(:kill_received, %{system_id: &quot;12345&quot;})

  # Force flush when needed
  Logger.flush_batch_logs()
  ```

  ## Startup Tracking

  Track application startup phases:

  ```elixir
  # Initialize at application start
  Logger.init_startup_tracker()

  # Track phases
  Logger.begin_startup_phase(:dependencies, &quot;Loading dependencies&quot;)

  # Record events
  Logger.record_startup_event(:feature_status, %{feature: &quot;websocket&quot;, enabled: true}, true)

  # Complete startup
  Logger.complete_startup()
  ```

  ## Metadata

  All logging functions accept metadata as the last argument. This can be a keyword list or map:

  ```elixir
  Logger.info(&quot;Processing item&quot;, item_id: 123, status: &quot;pending&quot;)
  ```

  Metadata is properly normalized regardless of format (map or keyword list).
  &quot;&quot;&quot;

  require Logger

  # Category constants
  @category_api :api
  @category_websocket :websocket
  @category_kill :kill
  @category_cache :cache
  @category_startup :startup
  @category_config :config
  @category_maintenance :maintenance
  @category_scheduler :scheduler
  @category_processor :processor
  @category_notification :notification

  # Level constants
  @level_debug :debug
  @level_info :info
  @level_warn :warning
  @level_error :error

  # Batch logging state
  # 5 seconds
  @batch_log_interval 5_000

  def debug(message), do: Logger.debug(message)

  def debug(message, metadata), do: Logger.debug(message, metadata)

  def info(message), do: Logger.info(message)

  def info(message, metadata), do: Logger.info(message, metadata)

  def warn(message), do: Logger.warning(message, [])

  def warn(message, metadata), do: Logger.warning(message, metadata)

  def error(message), do: Logger.error(message)

  def error(message, metadata), do: Logger.error(message, metadata)

  def api_error(message, metadata \\ [])
  def api_error(message, metadata), do: Logger.error(&quot;[API] #{message}&quot;, metadata)
  def api_info(message, metadata \\ []), do: log(@level_info, @category_api, message, metadata)

  def processor_debug(message, metadata \\ [])

  def processor_debug(message, metadata),
    do: log(@level_debug, @category_processor, message, metadata)

  def processor_info(message, metadata \\ [])

  def processor_info(message, metadata),
    do: log(@level_info, @category_processor, message, metadata)

  def processor_warn(message, metadata \\ [])

  def processor_warn(message, metadata),
    do: log(@level_warn, @category_processor, message, metadata)

  def processor_error(message, metadata \\ [])

  def processor_error(message, metadata),
    do: log(@level_error, @category_processor, message, metadata)

  def notification_debug(message, metadata \\ [])

  def notification_debug(message, metadata),
    do: log(@level_debug, @category_notification, message, metadata)

  def notification_info(message, metadata \\ [])

  def notification_info(message, metadata),
    do: log(@level_info, @category_notification, message, metadata)

  def notification_warn(message, metadata \\ [])

  def notification_warn(message, metadata),
    do: log(@level_warn, @category_notification, message, metadata)

  def notification_error(message, metadata \\ [])

  def notification_error(message, metadata),
    do: log(@level_error, @category_notification, message, metadata)

  def log(level, category, message, metadata \\ []) do
    # Process and prepare metadata
    metadata_with_diagnostics = prepare_metadata(metadata, category)

    # Format message with category prefix
    formatted_message = &quot;[#{category}] #{message}&quot;

    # For debugging, add metadata keys if env var is set
    enhanced_message = maybe_add_debug_metadata(formatted_message, metadata_with_diagnostics)

    # Log at the specified level
    Logger.log(level, enhanced_message, metadata_with_diagnostics)
  end

  # Processes metadata to ensure proper format and adds diagnostics
  defp prepare_metadata(metadata, category) do
    # Convert to proper format
    converted_metadata = convert_metadata_to_keyword_list(metadata)

    # Add original type info
    metadata_with_type = add_metadata_type_info(metadata, converted_metadata)

    # Add category with proper formatting for visibility in the logs
    # Category will be printed as [CATEGORY=API] for better readability
    metadata_with_category = Keyword.put(metadata_with_type, :category, category)

    # Merge with Logger context, but ensure our category takes precedence
    Logger.metadata()
    # Remove existing category if present
    |&gt; Keyword.delete(:category)
    # Add our metadata with correct category
    |&gt; Keyword.merge(metadata_with_category)
  end

  # Adds metadata type information for debugging
  defp add_metadata_type_info(original_metadata, converted_metadata) do
    orig_type = determine_metadata_type(original_metadata)
    Keyword.put(converted_metadata, :orig_metadata_type, orig_type)
  end

  # Determines the type of the original metadata
  defp determine_metadata_type(metadata) do
    cond do
      is_map(metadata) -&gt;
        &quot;map&quot;

      is_list(metadata) &amp;&amp; metadata == [] -&gt;
        &quot;empty_list&quot;

      is_list(metadata) &amp;&amp; Enum.all?(metadata, &amp;is_tuple/1) &amp;&amp;
          Enum.all?(metadata, fn {k, _v} -&gt; is_atom(k) end) -&gt;
        &quot;keyword_list&quot;

      is_list(metadata) -&gt;
        &quot;non_keyword_list&quot;

      true -&gt;
        &quot;other_type:#{typeof(metadata)}&quot;
    end
  end

  # Formats the log message with all metadata included
  defp maybe_add_debug_metadata(message, metadata) do
    # Format all metadata fields for the log message
    all_metadata = extract_metadata_for_debug(metadata, :full)

    message_with_data =
      if all_metadata != &quot;&quot;, do: &quot;#{message} (#{all_metadata})&quot;, else: message

    message_with_data
  end

  # Extracts and formats metadata for logging - shows both keys and values
  defp extract_metadata_for_debug(metadata, :full) do
    metadata
    |&gt; Enum.reject(fn {k, _v} -&gt;
      k in [:_metadata_source, :_metadata_warning, :_original_data, :_caller, :orig_metadata_type]
    end)
    |&gt; Enum.map_join(&quot;, &quot;, fn {k, v} -&gt;
      formatted_value = format_value_for_debug(v)
      &quot;#{k}=#{formatted_value}&quot;
    end)
  end

  # Formats different value types for debug output
  defp format_value_for_debug(value) when is_binary(value),
    do: &quot;\&quot;#{String.slice(value, 0, 100)}\&quot;&quot;

  defp format_value_for_debug(value) when is_list(value), do: &quot;list[#{length(value)}]&quot;
  defp format_value_for_debug(value) when is_map(value), do: &quot;map{#{map_size(value)}}&quot;
  defp format_value_for_debug(value), do: inspect(value, limit: 10)

  # Helper to convert metadata to keyword list
  defp convert_metadata_to_keyword_list(metadata) when is_map(metadata) do
    # Map is converted to keyword list
    map_metadata = Enum.map(metadata, fn {k, v} -&gt; {to_atom(k), v} end)
    # Add diagnostics to show this was a map
    Keyword.put(map_metadata, :_metadata_source, &quot;map&quot;)
  end

  defp convert_metadata_to_keyword_list(metadata) when is_list(metadata) do
    cond do
      # Valid keyword list
      Enum.all?(metadata, &amp;is_tuple/1) &amp;&amp; Enum.all?(metadata, fn {k, _v} -&gt; is_atom(k) end) -&gt;
        # Add diagnostics to show this was a keyword list
        Keyword.put(metadata, :_metadata_source, &quot;keyword_list&quot;)

      # Empty list
      metadata == [] -&gt;
        # Convert empty list to empty map with diagnostic
        [
          _metadata_source: &quot;empty_list&quot;,
          _metadata_warning: &quot;Empty list converted to keyword list&quot;
        ]

      # Non-keyword list (the problematic case)
      true -&gt;
        # Get caller information for debugging
        caller = get_caller_info()

        # Log warning about non-keyword list with detailed caller information
        Logger.warning(
          &quot;[LOGGER] Non-keyword list passed as metadata! Convert to map. List: #{inspect(metadata)}\nCaller: #{caller}&quot;
        )

        # Convert the non-keyword list to a map with indices as keys, then to keyword list
        converted_data =
          metadata
          |&gt; Enum.with_index()
          |&gt; Enum.map(fn {value, index} -&gt; {&quot;item_#{index}&quot;, value} end)
          |&gt; Enum.into(%{})
          |&gt; Enum.map(fn {k, v} -&gt; {to_atom(k), v} end)

        # Add diagnostics about the conversion
        converted_data
        |&gt; Keyword.put(:_metadata_source, &quot;invalid_list_converted&quot;)
        |&gt; Keyword.put(:_metadata_warning, &quot;Non-keyword list converted to keyword list&quot;)
        |&gt; Keyword.put(:_original_data, inspect(metadata))
        |&gt; Keyword.put(:_caller, caller)
    end
  end

  # Handle any other metadata type
  defp convert_metadata_to_keyword_list(metadata) do
    caller = get_caller_info()

    Logger.warning(
      &quot;[LOGGER] Invalid metadata type #{inspect(metadata)} (#{inspect(typeof(metadata))})\nCaller: #{caller}&quot;
    )

    [
      _metadata_source: &quot;invalid_type&quot;,
      _metadata_warning: &quot;Invalid metadata type converted to keyword list&quot;,
      _original_type: inspect(typeof(metadata)),
      _original_data: inspect(metadata),
      _caller: caller
    ]
  end

  # Helper to get type of value
  defp typeof(value) when is_binary(value), do: &quot;string&quot;
  defp typeof(value) when is_boolean(value), do: &quot;boolean&quot;
  defp typeof(value) when is_integer(value), do: &quot;integer&quot;
  defp typeof(value) when is_float(value), do: &quot;float&quot;
  defp typeof(value) when is_list(value), do: &quot;list&quot;
  defp typeof(value) when is_map(value), do: &quot;map&quot;
  defp typeof(value) when is_tuple(value), do: &quot;tuple&quot;
  defp typeof(value) when is_atom(value), do: &quot;atom&quot;
  defp typeof(value) when is_function(value), do: &quot;function&quot;
  defp typeof(value) when is_pid(value), do: &quot;pid&quot;
  defp typeof(value) when is_reference(value), do: &quot;reference&quot;
  defp typeof(value) when is_port(value), do: &quot;port&quot;
  defp typeof(_value), do: &quot;unknown&quot;

  # Get detailed caller information
  defp get_caller_info do
    case Process.info(self(), :current_stacktrace) do
      {:current_stacktrace, stacktrace} -&gt;
        format_stacktrace(stacktrace)

      _ -&gt;
        &quot;unknown caller&quot;
    end
  end

  # Format the caller information to show file and line
  defp format_stacktrace(stacktrace) do
    # Filter out Logger frames to focus on the actual caller
    relevant_frames =
      stacktrace
      |&gt; Enum.drop_while(fn {mod, _fun, _args, _loc} -&gt;
        String.contains?(inspect(mod), &quot;Logger&quot;) ||
          String.contains?(inspect(mod), &quot;WandererNotifier.Logger.Logger&quot;)
      end)
      # Take first 3 relevant frames
      |&gt; Enum.take(3)

    case relevant_frames do
      [] -&gt;
        &quot;unknown caller&quot;

      frames -&gt;
        Enum.map_join(frames, &quot;\n  &quot;, fn {mod, fun, args, location} -&gt;
          file = Keyword.get(location, :file, &quot;unknown&quot;)
          line = Keyword.get(location, :line, &quot;?&quot;)
          &quot;#{inspect(mod)}.#{fun}/#{length(args)} at #{file}:#{line}&quot;
        end)
    end
  end

  # Convert string or atom keys to atoms safely
  defp to_atom(key) when is_atom(key), do: key

  defp to_atom(key) when is_binary(key) do
    String.to_existing_atom(key)
  rescue
    ArgumentError -&gt; String.to_atom(key)
  end

  # API category helpers
  def api_debug(message, metadata \\ []), do: log(@level_debug, @category_api, message, metadata)

  def api_warn(message, metadata \\ []), do: log(@level_warn, @category_api, message, metadata)

  # WebSocket category helpers
  def websocket_debug(message, metadata \\ []),
    do: log(@level_debug, @category_websocket, message, metadata)

  def websocket_info(message, metadata \\ []),
    do: log(@level_info, @category_websocket, message, metadata)

  def websocket_warn(message, metadata \\ []),
    do: log(@level_warn, @category_websocket, message, metadata)

  def websocket_error(message, metadata \\ []),
    do: log(@level_error, @category_websocket, message, metadata)

  # Kill processing category helpers
  def kill_debug(message, metadata \\ []),
    do: log(@level_debug, @category_kill, message, metadata)

  def kill_info(message, metadata \\ []),
    do: log(@level_info, @category_kill, message, metadata)

  def kill_warn(message, metadata \\ []),
    do: log(@level_warn, @category_kill, message, metadata)

  def kill_error(message, metadata \\ []),
    do: log(@level_error, @category_kill, message, metadata)

  # Cache category helpers
  def cache_debug(message, metadata \\ []),
    do: log(@level_debug, @category_cache, message, metadata)

  def cache_info(message, metadata \\ []),
    do: log(@level_info, @category_cache, message, metadata)

  def cache_warn(message, metadata \\ []),
    do: log(@level_warn, @category_cache, message, metadata)

  def cache_error(message, metadata \\ []),
    do: log(@level_error, @category_cache, message, metadata)

  # Startup/Config helpers
  def startup_info(message, metadata \\ []),
    do: log(@level_info, @category_startup, message, metadata)

  def startup_debug(message, metadata \\ []),
    do: log(@level_debug, @category_startup, message, metadata)

  def startup_warn(message, metadata \\ []),
    do: log(@level_warn, @category_startup, message, metadata)

  def startup_error(message, metadata \\ []),
    do: log(@level_error, @category_startup, message, metadata)

  def config_info(message, metadata \\ []),
    do: log(@level_info, @category_config, message, metadata)

  def config_warn(message, metadata \\ []),
    do: log(@level_warn, @category_config, message, metadata)

  def config_error(message, metadata \\ []),
    do: log(@level_error, @category_config, message, metadata)

  def config_debug(message, metadata \\ []) do
    if should_log_debug?() do
      log(:debug, &quot;CONFIG&quot;, message, metadata)
    end
  end

  # Maintenance category helpers
  def maintenance_debug(message, metadata \\ []),
    do: log(@level_debug, @category_maintenance, message, metadata)

  def maintenance_info(message, metadata \\ []),
    do: log(@level_info, @category_maintenance, message, metadata)

  def maintenance_warn(message, metadata \\ []),
    do: log(@level_warn, @category_maintenance, message, metadata)

  def maintenance_error(message, metadata \\ []),
    do: log(@level_error, @category_maintenance, message, metadata)

  # Scheduler category helpers
  def scheduler_debug(message, metadata \\ []),
    do: log(@level_debug, @category_scheduler, message, metadata)

  def scheduler_info(message, metadata \\ []),
    do: log(@level_info, @category_scheduler, message, metadata)

  def scheduler_warn(message, metadata \\ []),
    do: log(@level_warn, @category_scheduler, message, metadata)

  def scheduler_error(message, metadata \\ []),
    do: log(@level_error, @category_scheduler, message, metadata)

  def scheduler_log(level, message, metadata \\ [])
      when level in [:debug, :info, :warning, :warn, :error] do
    # Normalize :warning to :warn for consistency
    normalized_level = if level == :warning, do: :warn, else: level
    log(normalized_level, @category_scheduler, message, metadata)
  end

  # Kill processing category
  # Use kill_warn consistently instead of kill_warning
  def kill_warning(message, metadata \\ []),
    do: kill_warn(message, metadata)

  def set_context(metadata) do
    # Convert to keyword list and normalize
    normalized_metadata = convert_metadata_to_keyword_list(metadata)

    # Set the metadata for the current process
    Logger.metadata(normalized_metadata)
  end

  def with_trace_id(metadata \\ []) do
    trace_id = generate_trace_id()

    # Normalize metadata and add trace_id
    normalized_metadata =
      metadata
      |&gt; convert_metadata_to_keyword_list()
      |&gt; Keyword.put(:trace_id, trace_id)

    # Set context with the new metadata
    set_context(normalized_metadata)

    # Return the trace ID for reference
    trace_id
  end

  def generate_trace_id do
    # Generate a unique trace ID
    :crypto.strong_rand_bytes(8) |&gt; Base.encode16(case: :lower)
  end

  def exception(level, category, message, exception, metadata \\ []) do
    # Create enhanced metadata with exception details
    enhanced_metadata =
      metadata
      |&gt; convert_metadata_to_keyword_list()
      |&gt; Keyword.put(:exception, Exception.message(exception))
      |&gt; Keyword.put(:stacktrace, get_exception_stacktrace(exception))

    # Log with enhanced metadata
    log(level, category, message, enhanced_metadata)
  end

  # Helper to get a stacktrace for an exception
  defp get_exception_stacktrace(_exception) do
    case Process.info(self(), :current_stacktrace) do
      {:current_stacktrace, stacktrace} -&gt;
        Exception.format_stacktrace(stacktrace)

      _ -&gt;
        &quot;No stacktrace available&quot;
    end
  end

  def log_kv(level, category, message, value) do
    # Create metadata from the value
    metadata = %{value: value}

    # Log with the extracted metadata
    log(level, category, message, metadata)
  end

  def log_full_data(level, category, message, data, metadata \\ []) do
    # Create enhanced metadata with full data
    enhanced_metadata =
      metadata
      |&gt; convert_metadata_to_keyword_list()
      |&gt; Keyword.put(:full_data, data)

    # Log with enhanced metadata
    log(level, category, message, enhanced_metadata)
  end

  def info_kv(category, message, value), do: log_kv(@level_info, category, message, value)

  def debug_kv(category, message, value), do: log_kv(@level_debug, category, message, value)

  def warn_kv(category, message, value), do: log_kv(@level_warn, category, message, value)

  def error_kv(category, message, value), do: log_kv(@level_error, category, message, value)

  def config_kv(message, value), do: info_kv(@category_config, message, value)

  def startup_kv(message, value), do: info_kv(@category_startup, message, value)

  def cache_kv(message, value), do: info_kv(@category_cache, message, value)

  def websocket_kv(message, value), do: info_kv(@category_websocket, message, value)

  def api_kv(message, value), do: info_kv(@category_api, message, value)

  def maintenance_kv(message, value), do: info_kv(@category_maintenance, message, value)

  # ------------------------------------------------------------
  # Batch Logging Support
  # ------------------------------------------------------------

  def init_batch_logger do
    # Log that batch logging is being initialized
    debug(&quot;Initializing batch logger&quot;)

    # Schedule periodic flush
    Process.send_after(self(), :flush_batch_logs, @batch_log_interval)

    :ok
  end

  def count_batch_event(_category, _details, _log_immediately \\ false) do
    # For now, just log immediately with a batch indicator
    # log(@level_info, category, &quot;Batch event&quot;, Map.merge(details, %{batch: true}))
    :ok
  end

  def flush_batch_logs do
    debug(&quot;Flushing all batch logs&quot;)
    :ok
  end

  def flush_batch_category(category) do
    debug(&quot;Flushing batch logs for category: #{category}&quot;)
    :ok
  end

  def handle_batch_flush(_state) do
    flush_batch_logs()
    Process.send_after(self(), :flush_batch_logs, @batch_log_interval)
    :ok
  end

  # ------------------------------------------------------------
  # Startup Tracking Support
  # ------------------------------------------------------------

  def init_startup_tracker do
    debug(&quot;Initializing startup tracker&quot;)
    :ok
  end

  def begin_startup_phase(phase, message) do
    info(&quot;[Startup] Beginning phase: #{phase}&quot;, %{
      phase: phase,
      message: message,
      timestamp: DateTime.utc_now()
    })

    :ok
  end

  def record_startup_event(type, details, force_log \\ false) do
    level = if force_log, do: @level_info, else: @level_debug

    log(
      level,
      @category_startup,
      &quot;Startup event: #{type}&quot;,
      Map.merge(details, %{event_type: type})
    )

    :ok
  end

  def record_startup_error(message, details) do
    error(&quot;[Startup] #{message}&quot;, details)
    :ok
  end

  def complete_startup do
    info(&quot;[Startup] Application startup complete&quot;, %{timestamp: DateTime.utc_now()})
    :ok
  end

  def log_startup_state_change(type, message, details) do
    info(&quot;[Startup] State change: #{type} - #{message}&quot;, details)
    :ok
  end

  defp should_log_debug? do
    WandererNotifier.Config.debug_logging_enabled?()
  end

  def log_with_timing(level, category, metadata \\ [], fun) do
    start_time = :os.system_time(:microsecond)
    result = fun.()
    end_time = :os.system_time(:microsecond)
    duration_us = end_time - start_time

    # Add timing information to metadata
    metadata_with_timing =
      Keyword.put(convert_metadata_to_keyword_list(metadata), :duration_us, duration_us)

    # Log the operation with timing information
    log(level, category, &quot;Operation completed&quot;, metadata_with_timing)

    # Return the original result
    result
  end
end</file><file path="lib/wanderer_notifier/map/clients/characters_client.ex">defmodule WandererNotifier.Map.Clients.CharactersClient do
  @moduledoc &quot;&quot;&quot;
    Client for retrieving and processing character data from the map API.
    {
    &quot;data&quot;: [
      {
        &quot;id&quot;: &quot;4712b7b0-37a0-42a6-91ba-1a5bf747d1a0&quot;,
        &quot;character&quot;: {
          &quot;name&quot;: &quot;Nimby Karen&quot;,
          &quot;alliance_id&quot;: null,
          &quot;alliance_ticker&quot;: null,
          &quot;corporation_id&quot;: 98801377,
          &quot;corporation_ticker&quot;: &quot;SAL.T&quot;,
          &quot;eve_id&quot;: &quot;2123019188&quot;
        },
        &quot;inserted_at&quot;: &quot;2025-01-01T03:32:51.041452Z&quot;,
        &quot;updated_at&quot;: &quot;2025-01-01T03:32:51.044408Z&quot;,
        &quot;tracked&quot;: true,
        &quot;character_id&quot;: &quot;90ff63d4-28f3-4071-8717-da1d0d39990e&quot;,
        &quot;map_id&quot;: &quot;678c43cf-f71f-4e14-932d-0545465cdff0&quot;
      },
      {
        &quot;id&quot;: &quot;0962d53a-4419-4f3c-80f5-fac41e618181&quot;,
        &quot;character&quot;: {
          &quot;name&quot;: &quot;Dismas November&quot;,
          &quot;alliance_id&quot;: null,
          &quot;alliance_ticker&quot;: null,
          &quot;corporation_id&quot;: 98434706,
          &quot;corporation_ticker&quot;: &quot;DISHL&quot;,
          &quot;eve_id&quot;: &quot;2120970663&quot;
        },
        &quot;inserted_at&quot;: &quot;2025-01-01T01:59:31.031640Z&quot;,
        &quot;updated_at&quot;: &quot;2025-01-01T01:59:31.031640Z&quot;,
        &quot;tracked&quot;: true,
        &quot;character_id&quot;: &quot;e630f39f-8027-4963-a522-ebe1bb45a3b5&quot;,
        &quot;map_id&quot;: &quot;678c43cf-f71f-4e14-932d-0545465cdff0&quot;
      },
    ]
   }
  &quot;&quot;&quot;

  alias WandererNotifier.HttpClient.Httpoison, as: HttpClient
  alias WandererNotifier.Cache.Keys, as: CacheKeys
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Config

  @doc &quot;&quot;&quot;
  Updates tracked character information from the map API.

  ## Parameters
    - cached_characters: List of cached characters for comparison

  ## Returns
    - {:ok, characters} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def update_tracked_characters(cached_characters) do
    base_url = Config.base_map_url()
    url = &quot;#{base_url}/api/map/characters?slug=#{Config.map_slug()}&quot;
    headers = get_auth_headers()

    AppLogger.api_debug(&quot;[CharactersClient] Fetching characters&quot;, url: url, headers: headers)

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: 200, body: body}} -&gt;
        handle_character_response(body, cached_characters)

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot; Failed to fetch characters&quot;, status: status)
        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot; Failed to fetch characters&quot;, error: inspect(reason))
        {:error, {:http_error, reason}}
    end
  end

  @doc &quot;&quot;&quot;
  Retrieves character activity data from the map API.

  ## Parameters
    - slug: Optional map slug override
    - days: Number of days of data to get (default 1)

  ## Returns
    - {:ok, data} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  @spec get_character_activity(String.t() | nil, integer()) ::
          {:ok, list(map())} | {:error, term()}
  def get_character_activity(slug \\ nil, days \\ 1) do
    base_url = Config.base_map_url()
    url = build_activity_url(base_url, slug, days)
    headers = get_auth_headers()

    case HttpClient.get(url, headers) do
      {:ok, %{status_code: 200, body: body}} -&gt;
        handle_activity_response(body)

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot; Failed to fetch character activity&quot;, status: status)
        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot; Failed to fetch character activity&quot;, error: inspect(reason))
        {:error, {:http_error, reason}}
    end
  end

  @doc &quot;&quot;&quot;
  Handles successful character response from the API.
  Parses the JSON, validates the data, and processes the characters.

  ## Parameters
    - body: Raw JSON response body
    - cached_characters: Optional list of cached characters for comparison

  ## Returns
    - {:ok, [Character.t()]} on success with a list of Character structs
    - {:error, {:json_parse_error, reason}} if JSON parsing fails
  &quot;&quot;&quot;
  @spec handle_character_response(String.t(), [Character.t()] | nil) ::
          {:ok, [Character.t()]} | {:error, {:json_parse_error, term()}}
  def handle_character_response(body, cached_characters) when is_binary(body) do
    case Jason.decode(body) do
      {:ok, data} -&gt; process_tracked_characters(data, cached_characters)
      {:error, error} -&gt; {:error, {:json_decode_error, error}}
    end
  end

  def handle_character_response(body, cached_characters) when is_map(body) do
    process_tracked_characters(body, cached_characters)
  end

  def handle_activity_response(body) when is_binary(body) do
    case Jason.decode(body) do
      {:ok, data} -&gt; {:ok, data}
      {:error, error} -&gt; {:error, {:json_decode_error, error}}
    end
  end

  def handle_activity_response(body) when is_map(body), do: {:ok, body}

  # Private helper functions

  defp process_tracked_characters(tracked_characters, cached_characters) do
    if !(is_map(tracked_characters) and Map.has_key?(tracked_characters, &quot;data&quot;)) do
      raise ArgumentError,
            &quot;Expected tracked_characters to be a map with a &apos;data&apos; field, got: #{inspect(tracked_characters)}&quot;
    end

    character_list = Map.get(tracked_characters, &quot;data&quot;)

    # Cache the characters
    cache_ttl = Config.characters_cache_ttl()
    CacheRepo.set(CacheKeys.character_list(), character_list, cache_ttl)

    # Notify about new characters if we have cached data to compare against
    if cached_characters do
      notify_new_tracked_characters(character_list, cached_characters)
    end

    {:ok, character_list}
  end

  defp notify_new_tracked_characters(new_characters, cached_characters) do
    # Convert cached characters to a set of EVE IDs for efficient lookup
    cached_ids =
      MapSet.new(cached_characters || [], fn c -&gt;
        case c do
          %{&quot;character&quot; =&gt; %{&quot;eve_id&quot; =&gt; eve_id}} -&gt; eve_id
          %{:character =&gt; %{eve_id: eve_id}} -&gt; eve_id
          _ -&gt; nil
        end
      end)

    # Find characters that aren&apos;t in the cached set
    new_characters
    |&gt; Enum.reject(fn c -&gt;
      eve_id =
        case c do
          %{&quot;character&quot; =&gt; %{&quot;eve_id&quot; =&gt; id}} -&gt; id
          %{:character =&gt; %{eve_id: id}} -&gt; id
          _ -&gt; nil
        end

      eve_id in cached_ids
    end)
    |&gt; Enum.each(&amp;send_new_character_notification/1)
  end

  defp send_new_character_notification(character_map) do
    character_struct = WandererNotifier.Map.MapCharacter.new(character_map)

    WandererNotifier.Notifiers.Discord.Notifier.send_new_tracked_character_notification(
      character_struct
    )
  end

  defp get_auth_headers do
    api_key = Config.map_token()
    AppLogger.api_debug(&quot;[CharactersClient] Fetching characters&quot;, api_key: api_key)
    [{&quot;Authorization&quot;, &quot;Bearer #{api_key}&quot;}]
  end

  defp build_activity_url(base_url, nil, days),
    do: &quot;#{base_url}/map/characters/activity?days=#{days}&quot;

  defp build_activity_url(base_url, slug, days),
    do: &quot;#{base_url}/map/characters/#{slug}/activity?days=#{days}&quot;
end</file><file path="lib/wanderer_notifier/map/clients/client.ex">defmodule WandererNotifier.Map.Clients.Client do
  @moduledoc &quot;&quot;&quot;
  Client for interacting with the Wanderer map API.

  This module provides a simplified facade over the specific client modules
  for different map API endpoints, handling feature checks and error management.
  &quot;&quot;&quot;

  alias WandererNotifier.Map.Clients.SystemsClient
  alias WandererNotifier.Map.Clients.CharactersClient
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Logger.Logger, as: AppLogger

  @doc &quot;&quot;&quot;
  Updates system information from the map API.

  ## Returns
    - {:ok, systems} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def update_systems do
    if WandererNotifier.Config.system_tracking_enabled?() do
      SystemsClient.update_systems()
    else
      AppLogger.api_debug(&quot;[Map.Client] System tracking disabled due to license restrictions&quot;)
      {:error, :feature_disabled}
    end
  rescue
    e -&gt;
      AppLogger.api_error(&quot;[Map.Client] Error in update_systems: #{inspect(e)}&quot;)

      AppLogger.api_error(
        &quot;[Map.Client] Stacktrace: #{inspect(Process.info(self(), :current_stacktrace))}&quot;
      )

      {:error, {:exception, e}}
  end

  @doc &quot;&quot;&quot;
  Updates system information from the map API, comparing with cached systems.

  ## Parameters
    - cached_systems: List of previously cached systems for comparison

  ## Returns
    - {:ok, systems} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def update_systems_with_cache(cached_systems) do
    if WandererNotifier.Config.system_tracking_enabled?() do
      # Updated to work with new SystemsClient module that returns MapSystem structs
      case SystemsClient.update_systems(cached_systems) do
        {:ok, systems} -&gt; {:ok, systems}
        error -&gt; error
      end
    else
      AppLogger.api_debug(&quot;[Map.Client] System tracking disabled due to license restrictions&quot;)
      {:error, :feature_disabled}
    end
  rescue
    e -&gt;
      AppLogger.api_error(&quot;[Map.Client] Error in update_systems_with_cache: #{inspect(e)}&quot;)

      AppLogger.api_error(
        &quot;[Map.Client] Stacktrace: #{inspect(Process.info(self(), :current_stacktrace))}&quot;
      )

      {:error, {:exception, e}}
  end

  @doc &quot;&quot;&quot;
  Updates tracked character information from the map API.

  ## Parameters
    - cached_characters: Optional list of cached characters for comparison

  ## Returns
    - {:ok, characters} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def update_tracked_characters(cached_characters \\ nil) do
    AppLogger.api_debug(&quot;Starting character update&quot;)
    current_characters = cached_characters || CacheRepo.get(&quot;map:characters&quot;) || []
    current_characters_list = ensure_list(current_characters)

    CharactersClient.update_tracked_characters(current_characters_list)
  end

  # Helper function to ensure we&apos;re working with a list
  defp ensure_list(nil), do: []
  defp ensure_list(list) when is_list(list), do: list
  defp ensure_list({:ok, list}) when is_list(list), do: list
  defp ensure_list(_), do: []
end</file><file path="lib/wanderer_notifier/map/clients/systems_client.ex">defmodule WandererNotifier.Map.Clients.SystemsClient do
  @moduledoc &quot;&quot;&quot;
  Client for retrieving and processing system data from the map API.
  Uses structured data types and consistent parsing to simplify the logic.
    &quot;data&quot;: [
    {
      &quot;id&quot;: &quot;e93be5e8-27ac-46c8-8e06-48c497338710&quot;,
      &quot;name&quot;: &quot;J123111&quot;,
      &quot;status&quot;: 0,
      &quot;tag&quot;: null,
      &quot;visible&quot;: true,
      &quot;description&quot;: null,
      &quot;labels&quot;: &quot;{\&quot;customLabel\&quot;:\&quot;\&quot;,\&quot;labels\&quot;:[]}&quot;,
      &quot;inserted_at&quot;: &quot;2025-01-01T17:02:15.911255Z&quot;,
      &quot;updated_at&quot;: &quot;2025-05-02T00:11:31.721497Z&quot;,
      &quot;locked&quot;: false,
      &quot;map_id&quot;: &quot;678c43cf-f71f-4e14-932d-0545465cdff0&quot;,
      &quot;solar_system_id&quot;: 31000133,
      &quot;custom_name&quot;: null,
      &quot;position_x&quot;: 360,
      &quot;position_y&quot;: 0,
      &quot;temporary_name&quot;: null,
      &quot;original_name&quot;: &quot;J123111&quot;
    },
    {
      &quot;id&quot;: &quot;d04017f7-8ee3-4016-965a-f07bd1116fe3&quot;,
      &quot;name&quot;: &quot;12&quot;,
      &quot;status&quot;: 0,
      &quot;tag&quot;: null,
      &quot;visible&quot;: true,
      &quot;description&quot;: null,
      &quot;labels&quot;: &quot;{\&quot;customLabel\&quot;:\&quot;\&quot;,\&quot;labels\&quot;:[]}&quot;,
      &quot;inserted_at&quot;: &quot;2025-02-03T05:08:52.973940Z&quot;,
      &quot;updated_at&quot;: &quot;2025-05-02T16:09:04.730231Z&quot;,
      &quot;locked&quot;: false,
      &quot;map_id&quot;: &quot;678c43cf-f71f-4e14-932d-0545465cdff0&quot;,
      &quot;solar_system_id&quot;: 31000611,
      &quot;custom_name&quot;: null,
      &quot;position_x&quot;: 476,
      &quot;position_y&quot;: 1275,
      &quot;temporary_name&quot;: &quot;12&quot;,
      &quot;original_name&quot;: &quot;J115734&quot;
    },
  ]
  }
  &quot;&quot;&quot;

  # alias the HTTPoison-based implementation under the name HttpClient
  alias WandererNotifier.HttpClient.Httpoison, as: HttpClient

  alias WandererNotifier.{
    Config,
    Cache.Keys,
    Cache.CachexImpl,
    Map.MapSystem,
    Logger.Logger
  }

  @doc &quot;&quot;&quot;
  Fetch, decode, process, notify (unless suppressed), and cache systems.

  Returns:
    - {:ok, new_systems, all_systems}
    - {:error, reason}
  &quot;&quot;&quot;
  def update_systems(opts \\ []) do
    fetch()
    |&gt; parse()
    |&gt; to_structs()
    |&gt; filter_systems()
    |&gt; detect_and_notify(opts)
    |&gt; cache_and_return()
  rescue
    e -&gt; handle_failure(e)
  end

  # 1) Fetch raw response
  defp fetch do
    url     = &quot;#{Config.base_map_url()}/api/map/systems?slug=#{Config.map_slug()}&quot;
    headers = [{&quot;Authorization&quot;, &quot;Bearer #{Config.map_token()}&quot;}]
    HttpClient.get(url, headers)
  end

  # 2) Parse HTTP result into a flat list of maps
  defp parse({:ok, %{body: %{&quot;data&quot; =&gt; data}}}),    do: {:ok, data}
  defp parse({:ok, %{body: %{&quot;systems&quot; =&gt; data}}}), do: {:ok, data}
  defp parse({:ok, %{body: body}}) when is_binary(body) do
    case Jason.decode(body) do
      {:ok, %{&quot;data&quot; =&gt; d}} when is_list(d) -&gt; {:ok, d}
      {:ok, l} when is_list(l)              -&gt; {:ok, l}
      err                                   -&gt; err
    end
  end
  defp parse(err) do
    Logger.api_error(&quot;Unexpected HTTP result&quot;, result: inspect(err))
    {:error, :http_error}
  end

  # 3) Map raw maps into our MapSystem structs
  defp to_structs({:ok, data}) do
    data
    |&gt; Enum.map(&amp;MapSystem.new/1)
    |&gt; then(&amp;{:ok, &amp;1})
  rescue
    e -&gt;
      Logger.api_error(&quot;Failed to build structs&quot;, error: Exception.message(e))
      {:error, :struct_build_failed}
  end
  defp to_structs(err), do: err

  # 4) Optionally filter out K-space
  defp filter_systems({:ok, systems}) do
    filtered =
      if Config.track_kspace_systems?() do
        systems
      else
        Enum.reject(systems, &amp;kspace?/1)
      end

    {:ok, filtered}
  end
  defp filter_systems(err), do: err

  # 5) Compare against cache, send notifications for new ones (unless suppressed)
  defp detect_and_notify({:ok, systems}, opts) do
    {:ok, cached_systems} = CachexImpl.get(Keys.map_systems()) |&gt; unwrap_cache()

    # build a MapSet of cached IDs
    cached_ids =
      MapSet.new(cached_systems, fn sys -&gt;
        sys.solar_system_id
      end)

    new_systems =
      Enum.reject(systems, fn sys -&gt;
        sys.solar_system_id in cached_ids
      end)

    unless Keyword.get(opts, :suppress_notifications, false) do
      Enum.each(new_systems, &amp;notify/1)
    end

    {:ok, new_systems, systems}
  end
  defp detect_and_notify(err, _), do: err

  # 6) Write to cache and return successful tuple
  defp cache_and_return({:ok, new, all}) do
    CachexImpl.put(Keys.map_systems(), all)
    {:ok, new, all}
  end
  defp cache_and_return(err), do: err

  # Notification helper
  defp notify(system) do
    enriched =
      case WandererNotifier.Map.SystemStaticInfo.enrich_system(system) do
        {:ok, e} -&gt; e
        _        -&gt; system
      end

    WandererNotifier.Notifiers.Discord.Notifier.send_new_system_notification(enriched)
  rescue
    e -&gt;
      Logger.api_error(&quot;Notification failed&quot;,
        error: Exception.message(e),
        system: inspect(system)
      )
  end

  # Simple K-space detector (works whether system is a struct or map)
  defp kspace?(system) do
    Map.get(system, :system_class) in [&quot;K&quot;, &quot;HS&quot;, &quot;LS&quot;, &quot;NS&quot;]
  end

  # Unified fallback on any crash
  defp handle_failure(error) do
    Logger.api_error(&quot;SystemsClient failed&quot;, error: Exception.message(error))

    case CachexImpl.get(Keys.map_systems()) do
      {:ok, systems} -&gt; {:ok, [], systems}
      _              -&gt; {:ok, [], []}
    end
  end

  # Cachex returns {:ok, val} or {:error, _}, so normalize
  defp unwrap_cache({:ok, val}), do: {:ok, val}
  defp unwrap_cache(_),        do: {:ok, []}
end</file><file path="lib/wanderer_notifier/map/map_character.ex">defmodule WandererNotifier.Map.MapCharacter do
  @moduledoc &quot;&quot;&quot;
  Struct and functions for managing tracked character data from the map API.

  This module standardizes the representation of characters from the map API,
  ensuring consistent field names and handling of optional fields.

  ## Core Principles
  - Single Source of Truth: Character struct is the canonical representation
  - Early Conversion: API responses are converted to structs immediately
  - No Silent Renaming: Field names are preserved consistently
  - Clear Contracts: Each function has explicit input/output contracts
  - Explicit Error Handling: Validation errors are raised explicitly

  Implements the Access behaviour to allow map-like access with [&quot;key&quot;] syntax.

  ## Map API Response Structure
  ```json
  &quot;data&quot;: [
    {
      &quot;id&quot;: &quot;4712b7b0-37a0-42a6-91ba-1a5bf747d1a0&quot;,
      &quot;character&quot;: {
        &quot;name&quot;: &quot;Nimby Karen&quot;,
        &quot;alliance_id&quot;: null,
        &quot;alliance_ticker&quot;: null,
        &quot;corporation_id&quot;: 1000167,
        &quot;corporation_ticker&quot;: &quot;SWA&quot;,
        &quot;eve_id&quot;: &quot;2123019188&quot;
      },
      &quot;inserted_at&quot;: &quot;2025-01-01T03:32:51.041452Z&quot;,
      &quot;updated_at&quot;: &quot;2025-01-01T03:32:51.044408Z&quot;,
      &quot;tracked&quot;: true,
      &quot;map_id&quot;: &quot;678c43cf-f71f-4e14-932d-0545465cdff0&quot;,
      &quot;character_id&quot;: &quot;90ff63d4-28f3-4071-8717-da1d0d39990e&quot;
    }
  ]
  ```

  IMPORTANT: Note that the character data is nested under the &quot;character&quot; key, and
  eve_id is specifically inside this nested structure. The map_response[&quot;character_id&quot;]
  at the top level is a UUID and not the EVE Online ID.
  &quot;&quot;&quot;
  @behaviour Access
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Utilities.MapUtil

  @typedoc &quot;Type representing a tracked character&quot;
  @type t :: %__MODULE__{
          # EVE Online character ID (primary identifier)
          character_id: String.t(),
          # Character name
          name: String.t(),
          # Corporation ID
          corporation_id: integer() | nil,
          # Corporation ticker (used as name)
          corporation_ticker: String.t() | nil,
          # Alliance ID
          alliance_id: integer() | nil,
          # Alliance ticker (used as name)
          alliance_ticker: String.t() | nil,
          # Whether character is being tracked
          tracked: boolean()
        }

  defstruct [
    :character_id,
    :name,
    :corporation_id,
    :corporation_ticker,
    :alliance_id,
    :alliance_ticker,
    :tracked
  ]

  # Implement Access behaviour methods to allow map-like access

  @doc &quot;&quot;&quot;
  Implements the Access behaviour fetch method.
  Allows accessing fields with map[&quot;key&quot;] syntax.

  ## Examples
      iex&gt; character = %Character{character_id: &quot;123&quot;, name: &quot;Test&quot;}
      iex&gt; character[&quot;character_id&quot;]
      &quot;123&quot;
      iex&gt; character[&quot;name&quot;]
      &quot;Test&quot;
  &quot;&quot;&quot;
  @spec fetch(t(), atom() | String.t()) :: {:ok, any()} | :error
  def fetch(struct, key) when is_atom(key) do
    Map.fetch(Map.from_struct(struct), key)
  end

  def fetch(struct, key) when is_binary(key) do
    # Handle special field name conversions
    case key do
      # No longer needed - eve_id is only used at map API conversion point
      &quot;id&quot; -&gt;
        {:ok, struct.character_id}

      &quot;corporationID&quot; -&gt;
        {:ok, struct.corporation_id}

      &quot;corporationName&quot; -&gt;
        {:ok, struct.corporation_ticker}

      &quot;allianceID&quot; -&gt;
        {:ok, struct.alliance_id}

      &quot;allianceName&quot; -&gt;
        {:ok, struct.alliance_ticker}

      # For any other field, try to convert to atom
      _ -&gt;
        atom_key = String.to_existing_atom(key)
        Map.fetch(Map.from_struct(struct), atom_key)
    end
  rescue
    ArgumentError -&gt; :error
  end

  @doc &quot;&quot;&quot;
  Implements the Access behaviour get method.

  ## Examples
      iex&gt; character = %Character{character_id: &quot;123&quot;, name: &quot;Test&quot;}
      iex&gt; character[&quot;missing_key&quot;, :default]
      :default
  &quot;&quot;&quot;
  @spec get(t(), atom() | String.t(), any()) :: any()
  def get(struct, key, default \\ nil) do
    case fetch(struct, key) do
      {:ok, value} -&gt; value
      :error -&gt; default
    end
  end

  @doc &quot;&quot;&quot;
  Implements the Access behaviour get_and_update method.
  Not fully implemented since structs are intended to be immutable.
  &quot;&quot;&quot;
  @spec get_and_update(t(), any(), (any() -&gt; {any(), any()})) :: {any(), t()}
  def get_and_update(_struct, _key, _fun) do
    raise &quot;get_and_update not implemented for immutable Character struct&quot;
  end

  @doc &quot;&quot;&quot;
  Implements the Access behaviour pop method.
  Not fully implemented since structs are intended to be immutable.
  &quot;&quot;&quot;
  @spec pop(t(), any()) :: {any(), t()}
  def pop(_struct, _key) do
    raise &quot;pop not implemented for immutable Character struct&quot;
  end

  # Extract character name from character data (nested structure)
  defp extract_character_name(character_data, _map_response) do
    character_data[&quot;name&quot;]
  end

  # Extract corporation ID from character data (nested structure)
  defp extract_corporation_id(character_data, _map_response) do
    parse_integer(character_data[&quot;corporation_id&quot;])
  end

  # Extract corporation ticker from character data (nested structure)
  defp extract_corporation_ticker(character_data, _map_response) do
    character_data[&quot;corporation_ticker&quot;]
  end

  # Extract alliance ID from character data (nested structure)
  defp extract_alliance_id(character_data, _map_response) do
    parse_integer(character_data[&quot;alliance_id&quot;])
  end

  # Extract alliance ticker from character data (nested structure)
  defp extract_alliance_ticker(character_data, _map_response) do
    character_data[&quot;alliance_ticker&quot;]
  end

  # Validate required fields are present
  defp validate_required_fields(character_id, name) do
    if !(character_id &amp;&amp; name) do
      AppLogger.processor_error(
        &quot;Missing required character fields&quot;,
        character_id: inspect(character_id),
        name: inspect(name)
      )

      raise ArgumentError,
            &quot;Missing required fields for Character: character_id and name are required&quot;
    end
  end

  @spec new(map()) :: t()
  def new(map_response) when is_map(map_response) do
    # Extract nested character data if present
    character_data = Map.get(map_response, &quot;character&quot;, %{})

    # Character data processing can be verbose - only log rarely
    # Add random logging to reduce verbosity (only log ~5% of character data processing)
    if :rand.uniform(100) &lt;= 5 do
      AppLogger.processor_debug(&quot;Processing character data&quot;,
        raw_character: inspect(character_data),
        map_response: inspect(map_response)
      )
    end

    # Extract character_id (EVE ID) from nested structure
    eve_id =
      case character_data do
        # Character data is a nested object with an eve_id field
        %{&quot;eve_id&quot; =&gt; eve_id} when is_binary(eve_id) -&gt;
          eve_id

        # Character data contains eve_id as integer
        %{&quot;eve_id&quot; =&gt; eve_id} when is_integer(eve_id) -&gt;
          Integer.to_string(eve_id)

        # Empty or missing eve_id - try other fields
        _ -&gt;
          nil
      end

    # Fallback to character_id in the map_response if eve_id is not available
    character_id = eve_id || Map.get(map_response, &quot;character_id&quot;)

    # Extract character name from nested structure
    name = extract_character_name(character_data, map_response)

    # Validate required fields
    validate_required_fields(character_id, name)

    # Extract other fields
    corporation_id = extract_corporation_id(character_data, map_response)
    corporation_ticker = extract_corporation_ticker(character_data, map_response)
    alliance_id = extract_alliance_id(character_data, map_response)
    alliance_ticker = extract_alliance_ticker(character_data, map_response)

    # Get tracked status
    tracked = Map.get(map_response, &quot;tracked&quot;, false)

    # Create the character struct
    %__MODULE__{
      character_id: character_id,
      name: name,
      corporation_id: corporation_id,
      corporation_ticker: corporation_ticker,
      alliance_id: alliance_id,
      alliance_ticker: alliance_ticker,
      tracked: tracked
    }
  end

  @doc &quot;&quot;&quot;
  Creates a character struct from a map with direct field mappings.
  Used for simpler maps that don&apos;t have nested character data.

  ## Examples
      iex&gt; simple_map = %{
      ...&gt;   &quot;character_id&quot; =&gt; &quot;123&quot;,
      ...&gt;   &quot;name&quot; =&gt; &quot;Test Character&quot;,
      ...&gt;   &quot;corporation_id&quot; =&gt; 456,
      ...&gt;   &quot;corporation_ticker&quot; =&gt; &quot;CORP&quot;
      ...&gt; }
      iex&gt; Character.from_map(simple_map)
      %Character{
        character_id: &quot;123&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: 456,
        corporation_ticker: &quot;CORP&quot;,
        alliance_id: nil,
        alliance_ticker: nil,
        tracked: false
      }
  &quot;&quot;&quot;
  @spec from_map(map()) :: t()
  def from_map(map) when is_map(map) do
    # Define field mappings for extraction
    field_mappings = [
      {:character_id, [&quot;character_id&quot;, &quot;eve_id&quot;, :character_id, :eve_id]},
      {:name, [&quot;name&quot;, &quot;character_name&quot;, :name, :character_name]},
      {:corporation_id, [&quot;corporation_id&quot;, &quot;corporationID&quot;, :corporation_id, :corporationID]},
      {:corporation_ticker,
       [&quot;corporation_ticker&quot;, &quot;corporationName&quot;, :corporation_ticker, :corporationName]},
      {:alliance_id, [&quot;alliance_id&quot;, &quot;allianceID&quot;, :alliance_id, :allianceID]},
      {:alliance_ticker, [&quot;alliance_ticker&quot;, &quot;allianceName&quot;, :alliance_ticker, :allianceName]},
      {:tracked, [&quot;tracked&quot;, :tracked], false}
    ]

    # Extract fields using MapUtil
    attrs = MapUtil.extract_map(map, field_mappings)

    # Ensure character_id is a string
    attrs =
      if is_integer(attrs.character_id) do
        Map.put(attrs, :character_id, Integer.to_string(attrs.character_id))
      else
        attrs
      end

    # Ensure corporation_id is an integer if present
    attrs =
      if is_binary(attrs.corporation_id) do
        Map.put(attrs, :corporation_id, parse_integer(attrs.corporation_id))
      else
        attrs
      end

    # Ensure alliance_id is an integer if present
    attrs =
      if is_binary(attrs.alliance_id) do
        Map.put(attrs, :alliance_id, parse_integer(attrs.alliance_id))
      else
        attrs
      end

    struct(__MODULE__, attrs)
  end

  # Convert string to integer, handling nil and other values gracefully
  defp parse_integer(nil), do: nil
  defp parse_integer(val) when is_integer(val), do: val

  defp parse_integer(val) when is_binary(val) do
    case Integer.parse(val) do
      {int, _} -&gt; int
      :error -&gt; nil
    end
  end

  defp parse_integer(_), do: nil

  @doc &quot;&quot;&quot;
  Ensures the given value is a list of Character structs.

  ## Parameters
    - input: Can be nil, a Character struct, a list of Character structs,
            or a tuple containing a list of Character structs

  ## Returns
    - A list of Character structs, or empty list if the input is invalid
  &quot;&quot;&quot;
  @spec ensure_list(nil | t() | [t()] | {:ok, [t()]}) :: [t()]
  def ensure_list(nil), do: []
  def ensure_list(char) when is_struct(char, __MODULE__), do: [char]

  def ensure_list(chars) when is_list(chars) do
    Enum.filter(chars, &amp;is_struct(&amp;1, __MODULE__))
  end

  def ensure_list({:ok, chars}) when is_list(chars), do: ensure_list(chars)
  def ensure_list(_), do: []

  @doc &quot;&quot;&quot;
  Checks if a character has corporation information.

  ## Parameters
    - character: The character struct to check

  ## Returns
    - true if the character has corporation data, false otherwise
  &quot;&quot;&quot;
  @spec has_corporation?(t()) :: boolean()
  def has_corporation?(%__MODULE__{} = character) do
    not is_nil(character.corporation_id) and not is_nil(character.corporation_ticker)
  end

  def has_corporation?(_), do: false
end</file><file path="lib/wanderer_notifier/map/map_system.ex">defmodule WandererNotifier.Map.MapSystem do
  @moduledoc &quot;&quot;&quot;
  Struct for representing a system in the map context.
  Provides functionality for system type checking and name formatting.

  ## Fields
  - solar_system_id: Unique identifier for the system
  - name: Current name of the system
  - original_name: Original name before any renaming
  - system_type: Type of system (e.g., wormhole, k-space)
  - type_description: Detailed description of the system type
  - class_title: System class (e.g., C1, C2, etc.)
  - effect_name: Name of the system&apos;s effect if any
  - is_shattered: Whether the system is shattered
  - locked: Whether the system is locked
  - region_name: Name of the region containing the system
  - static_details: List of static wormhole connections
  - sun_type_id: Type ID of the system&apos;s sun
  - id: Alternative identifier for the system
  &quot;&quot;&quot;

  @enforce_keys [:solar_system_id, :name]
  defstruct [
    :solar_system_id,
    :name,
    :original_name,
    :system_type,
    :type_description,
    :class_title,
    :effect_name,
    :is_shattered,
    :locked,
    :region_name,
    :static_details,
    :sun_type_id,
    :id
  ]

  @type t :: %__MODULE__{
          solar_system_id: String.t() | integer(),
          name: String.t(),
          original_name: String.t() | nil,
          system_type: String.t() | atom() | nil,
          type_description: String.t() | nil,
          class_title: String.t() | nil,
          effect_name: String.t() | nil,
          is_shattered: boolean() | nil,
          locked: boolean() | nil,
          region_name: String.t() | nil,
          static_details: list() | nil,
          sun_type_id: integer() | nil,
          id: String.t() | integer() | nil
        }

  @doc &quot;&quot;&quot;
  Creates a new MapSystem struct from a map of attributes.

  ## Parameters
    - attrs: Map containing system attributes. Must include a string &apos;id&apos; key.

  ## Returns
    - %MapSystem{} struct

  ## Raises
    - ArgumentError if &apos;id&apos; key is missing or not a string (enforces correct API format)
  &quot;&quot;&quot;
  @spec new(map()) :: t()
  def new(attrs) when is_map(attrs) do
    system_id = Map.get(attrs, &quot;id&quot;)
    name = Map.get(attrs, &quot;name&quot;)
    solar_system_id = Map.get(attrs, &quot;solar_system_id&quot;)

    if !(is_binary(system_id) and is_binary(name) and not is_nil(solar_system_id)) do
      raise ArgumentError,
            &quot;MapSystem.new/1 expects a map with string &apos;id&apos;, string &apos;name&apos;, and non-nil &apos;solar_system_id&apos;. Got: #{inspect(attrs)}&quot;
    end

    struct(__MODULE__, %{
      system_id: system_id,
      name: name,
      solar_system_id: solar_system_id,
      original_name: Map.get(attrs, &quot;original_name&quot;),
      system_type: Map.get(attrs, &quot;system_type&quot;),
      type_description: Map.get(attrs, &quot;type_description&quot;),
      class_title: Map.get(attrs, &quot;class_title&quot;),
      effect_name: Map.get(attrs, &quot;effect_name&quot;),
      is_shattered: Map.get(attrs, &quot;is_shattered&quot;),
      locked: Map.get(attrs, &quot;locked&quot;),
      region_name: Map.get(attrs, &quot;region_name&quot;),
      static_details: Map.get(attrs, &quot;static_details&quot;),
      sun_type_id: Map.get(attrs, &quot;sun_type_id&quot;),
      id: system_id
    })
  end

  @doc &quot;&quot;&quot;
  Checks if a system is a wormhole system.

  ## Parameters
    - system: MapSystem struct to check

  ## Returns
    - true if the system is a wormhole system
    - false otherwise
  &quot;&quot;&quot;
  @spec is_wormhole?(t()) :: boolean()
  def is_wormhole?(%__MODULE__{system_type: type}) do
    type in [:wormhole, &quot;wormhole&quot;, &quot;Wormhole&quot;]
  end

  @doc &quot;&quot;&quot;
  Formats the display name of a system by combining its name, class, and effect.

  ## Parameters
    - system: MapSystem struct to format

  ## Returns
    - String containing the formatted display name
  &quot;&quot;&quot;
  @spec format_display_name(t()) :: String.t()
  def format_display_name(%__MODULE__{name: name, class_title: class, effect_name: effect}) do
    [name, class, effect]
    |&gt; Enum.reject(&amp;is_nil/1)
    |&gt; Enum.join(&quot; &quot;)
  end

  @doc &quot;&quot;&quot;
  Updates a MapSystem struct with static info from a map.

  ## Parameters
    - system: MapSystem struct to update
    - static_info: Map containing static information to merge

  ## Returns
    - Updated MapSystem struct
  &quot;&quot;&quot;
  @spec update_with_static_info(t(), map()) :: t()
  def update_with_static_info(system, static_info) do
    struct(__MODULE__, Map.merge(Map.from_struct(system), static_info))
  end
end</file><file path="lib/wanderer_notifier/map/system_static_info.ex">defmodule WandererNotifier.Map.SystemStaticInfo do
  @moduledoc &quot;&quot;&quot;
  Client for fetching static information about EVE systems from the map API.
  Provides clean access to detailed system information for wormholes and other systems.

  Example wormhole system response:
  ```json
  {
    &quot;data&quot;: {
      &quot;statics&quot;: [
        &quot;C247&quot;,
        &quot;P060&quot;
      ],
      &quot;security&quot;: &quot;-1.0&quot;,
      &quot;class_title&quot;: &quot;C4&quot;,
      &quot;constellation_id&quot;: 21000172,
      &quot;constellation_name&quot;: &quot;D-C00172&quot;,
      &quot;effect_name&quot;: null,
      &quot;effect_power&quot;: 4,
      &quot;is_shattered&quot;: false,
      &quot;region_id&quot;: 11000018,
      &quot;region_name&quot;: &quot;D-R00018&quot;,
      &quot;solar_system_id&quot;: 31001503,
      &quot;solar_system_name&quot;: &quot;J155416&quot;,
      &quot;solar_system_name_lc&quot;: &quot;j155416&quot;,
      &quot;sun_type_id&quot;: 45032,
      &quot;system_class&quot;: 4,
      &quot;triglavian_invasion_status&quot;: &quot;Normal&quot;,
      &quot;type_description&quot;: &quot;Class 4&quot;,
      &quot;wandering&quot;: [
        &quot;S047&quot;,
        &quot;N290&quot;,
        &quot;K329&quot;
      ],
      &quot;static_details&quot;: [
        {
          &quot;name&quot;: &quot;C247&quot;,
          &quot;destination&quot;: {
            &quot;id&quot;: &quot;c3&quot;,
            &quot;name&quot;: &quot;Class 3&quot;,
            &quot;short_name&quot;: &quot;C3&quot;
          },
          &quot;properties&quot;: {
            &quot;lifetime&quot;: &quot;16&quot;,
            &quot;mass_regeneration&quot;: 0,
            &quot;max_jump_mass&quot;: 300000000,
            &quot;max_mass&quot;: 2000000000
          }
        },
        {
          &quot;name&quot;: &quot;P060&quot;,
          &quot;destination&quot;: {
            &quot;id&quot;: &quot;c1&quot;,
            &quot;name&quot;: &quot;Class 1&quot;,
            &quot;short_name&quot;: &quot;C1&quot;
          },
          &quot;properties&quot;: {
            &quot;lifetime&quot;: &quot;16&quot;,
            &quot;mass_regeneration&quot;: 0,
            &quot;max_jump_mass&quot;: 62000000,
            &quot;max_mass&quot;: 500000000
          }
        }
      ]
    }
  }
  &quot;&quot;&quot;

  alias WandererNotifier.HttpClient.Httpoison, as: HttpClient
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Config

  @doc &quot;&quot;&quot;
  Fetches static information for a specific solar system.
  Uses a more robust approach with proper validation and timeouts.

  ## Parameters
    - solar_system_id: The ID of the solar system to fetch information for

  ## Returns
    - {:ok, static_info} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def get_system_static_info(solar_system_id) do
    case fetch_system_static_info(solar_system_id) do
      {:ok, static_info} -&gt;
        {:ok, static_info}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;[SystemStaticInfo] Failed to get static info&quot;, %{
          system_id: solar_system_id,
          error: inspect(reason)
        })

        {:error, reason}
    end
  end

  # Private helper functions

  defp fetch_system_static_info(solar_system_id) do
    AppLogger.api_debug(&quot;[SystemStaticInfo] Building URL&quot;,
      system_id: solar_system_id
    )

    base_url = Config.base_map_url()
    url = &quot;#{base_url}/api/common/system-static-info?id=#{solar_system_id}&quot;
    headers = get_auth_headers()

    AppLogger.api_debug(&quot;[SystemStaticInfo] Making request&quot;,
      url: url,
      headers: headers
    )

    # Make API request and process
    make_static_info_request(url, headers)
  end

  # Make the actual API request for static info
  defp make_static_info_request(url, headers) do
    case HttpClient.get(url, headers) do
      {:ok, %{status_code: 200, body: body}} when is_map(body) -&gt;
        {:ok, body}

      {:ok, %{status_code: 200, body: body}} when is_binary(body) -&gt;
        case Jason.decode(body) do
          {:ok, parsed_response} -&gt; {:ok, parsed_response}
          {:error, reason} -&gt;
            AppLogger.api_error(&quot;[SystemStaticInfo] Failed to parse JSON&quot;, error: inspect(reason))
            {:error, {:json_parse_error, reason}}
        end

      {:ok, %{status_code: status}} -&gt;
        AppLogger.api_error(&quot;[SystemStaticInfo] HTTP error&quot;, status: status)
        {:error, {:http_error, status}}

      {:error, reason} -&gt;
        AppLogger.api_error(&quot;[SystemStaticInfo] Request failed&quot;, error: inspect(reason))
        {:error, reason}
    end
  end

  @doc &quot;&quot;&quot;
  Enriches a MapSystem with static information.

  ## Parameters
    - system: A WandererNotifier.Map.MapSystem struct

  ## Returns
    - {:ok, enhanced_system} on success with enriched data
    - {:ok, system} on failure but returns the original system
  &quot;&quot;&quot;
  def enrich_system(system) do
    alias WandererNotifier.Map.MapSystem

    try do
      AppLogger.api_info(&quot;[SystemStaticInfo] Starting system enrichment&quot;,
        system: inspect(system, pretty: true, limit: 1000)
      )

      # Only try to enrich if the system has a valid ID
      if system.solar_system_id &amp;&amp; system.solar_system_id &gt; 0 do
        # Try to get static info with proper error handling
        result = get_system_static_info(system.solar_system_id)
        AppLogger.api_debug(&quot;[SystemStaticInfo] get_system_static_info result (FULL RAW)&quot;,
          system_id: system.solar_system_id,
          raw_result: inspect(result, pretty: true, limit: 2000)
        )
        AppLogger.api_debug(&quot;[SystemStaticInfo] get_system_static_info result&quot;,
          system_id: system.solar_system_id,
          result: inspect(result, pretty: true, limit: 1000)
        )
        case result do
          {:ok, static_info} -&gt;
            # Merge only the inner data map if present
            data_to_merge =
              case static_info do
                %{&quot;data&quot; =&gt; data_map} when is_map(data_map) -&gt; data_map
                other -&gt; other
              end
            AppLogger.api_debug(&quot;[SystemStaticInfo] Got static info for enrichment&quot;,
              system_name: system.name,
              static_info_keys: Map.keys(data_to_merge),
              static_info: inspect(data_to_merge, pretty: true, limit: 1000)
            )

            # Update the map system with static information
            enhanced_system = MapSystem.update_with_static_info(system, data_to_merge)

            # Convert &quot;security&quot; to :security_status (float) and add to struct
            security_status =
              case Map.get(data_to_merge, &quot;security&quot;) do
                nil -&gt; 0.0
                val when is_binary(val) -&gt;
                  case Float.parse(val) do
                    {f, _} -&gt; f
                    :error -&gt; 0.0
                  end
                val when is_number(val) -&gt; val
                _ -&gt; 0.0
              end
            enhanced_system = Map.put(enhanced_system, :security_status, security_status)

            # Map expected string keys to atom keys, handling optional fields
            expected_fields = [
              :statics, :effect_name, :class_title, :effect_power, :is_shattered, :region_id,
              :region_name, :system_class, :triglavian_invasion_status, :type_description,
              :constellation_id, :constellation_name, :static_details, :sun_type_id
            ]
            enhanced_system = Enum.reduce(expected_fields, enhanced_system, fn field, acc -&gt;
              string_key = Atom.to_string(field)
              value = Map.get(data_to_merge, string_key)
              # For statics and static_details, default to [] if not present
              default = if field in [:statics, :static_details], do: [], else: nil
              Map.put(acc, field, (if value == nil, do: default, else: value))
            end)

            AppLogger.api_debug(&quot;[SystemStaticInfo] Enriched system result&quot;,
              enriched_system: inspect(enhanced_system, pretty: true, limit: 1000)
            )
            {:ok, enhanced_system}

          {:error, reason} -&gt;
            # Log error but continue with original system
            AppLogger.api_warn(
              &quot;[SystemStaticInfo] Could not enrich system&quot;,
              system_name: system.name,
              error: inspect(reason),
              system: inspect(system, pretty: true, limit: 1000)
            )

            # Return original system - IMPORTANT: Don&apos;t error out!
            AppLogger.api_debug(&quot;[SystemStaticInfo] Returning original system after enrichment failure&quot;,
              system: inspect(system, pretty: true, limit: 1000)
            )
            {:ok, system}
        end
      else
        # Invalid system ID - log and return original
        AppLogger.api_warn(
          &quot;[SystemStaticInfo] Cannot enrich system with invalid ID&quot;,
          system_name: system.name,
          system_id: system.solar_system_id,
          system: inspect(system, pretty: true, limit: 1000)
        )

        # Still return original system
        AppLogger.api_debug(&quot;[SystemStaticInfo] Returning original system due to invalid ID&quot;,
          system: inspect(system, pretty: true, limit: 1000)
        )
        {:ok, system}
      end
    rescue
      e -&gt;
        log_message = [
          &quot;[SystemStaticInfo] Exception during system enrichment:&quot;,
          &quot;Error: #{Exception.message(e)}&quot;,
          &quot;System: #{inspect(system, pretty: true, limit: 1000)}&quot;,
          &quot;Stacktrace:\n#{Exception.format_stacktrace(__STACKTRACE__)}&quot;
        ] |&gt; Enum.join(&quot;\n&quot;)

        AppLogger.api_error(log_message)
        {:ok, system}
    end
  end

  defp get_auth_headers do
    api_key = Config.map_token()
    [{&quot;Authorization&quot;, &quot;Bearer #{api_key}&quot;}]
  end
end</file><file path="lib/wanderer_notifier/notifications/determiner/character.ex">defmodule WandererNotifier.Notifications.Determiner.Character do
  @moduledoc &quot;&quot;&quot;
  Determines whether character notifications should be sent.
  Handles all character-related notification decision logic.
  &quot;&quot;&quot;

  require Logger
  alias WandererNotifier.Config
  alias WandererNotifier.Cache.Keys, as: CacheKeys
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Helpers.DeduplicationHelper
  alias WandererNotifier.Logger.Logger, as: AppLogger

  @doc &quot;&quot;&quot;
  Determines if a notification should be sent for a character.

  ## Parameters
    - character_id: The ID of the character to check
    - character_data: The character data to check

  ## Returns
    - true if a notification should be sent
    - false otherwise
  &quot;&quot;&quot;
  def should_notify?(character_id, character_data) when is_map(character_data) do
    with true &lt;- Config.character_notifications_enabled?(),
         true &lt;- tracked_character?(character_id),
         true &lt;- character_changed?(character_id, character_data) do
      check_deduplication_and_decide(character_id)
    else
      false -&gt; false
      _ -&gt; false
    end
  end

  def should_notify?(_, _), do: false

  @doc &quot;&quot;&quot;
  Checks if a character is being tracked.

  ## Parameters
    - character_id: The ID of the character to check

  ## Returns
    - true if the character is tracked
    - false otherwise
  &quot;&quot;&quot;
  def tracked_character?(character_id) when is_integer(character_id) do
    character_id_str = Integer.to_string(character_id)
    tracked_character?(character_id_str)
  end

  def tracked_character?(character_id_str) when is_binary(character_id_str) do
    # Get the current list of tracked characters from the cache
    case CacheRepo.get(CacheKeys.character_list()) do
      {:ok, characters} when is_list(characters) -&gt;
        Enum.any?(characters, fn char -&gt;
          id = Map.get(char, :character_id) || Map.get(char, &quot;character_id&quot;)
          to_string(id) == character_id_str
        end)

      _ -&gt;
        false
    end
  end

  def tracked_character?(_), do: false

  @doc &quot;&quot;&quot;
  Checks if a character&apos;s data has changed from what&apos;s in cache.

  ## Parameters
    - character_id: The ID of the character to check
    - character_data: The new character data to compare against cache

  ## Returns
    - true if the character data has changed
    - false otherwise
  &quot;&quot;&quot;
  def character_changed?(character_id, character_data) when is_map(character_data) do
    # Get cached character data
    cache_key = CacheKeys.character(character_id)

    cached_data =
      case CacheRepo.get(cache_key) do
        {:ok, value} -&gt; value
        _ -&gt; nil
      end

    # Compare relevant fields
    case cached_data do
      nil -&gt;
        # No cached data, consider it changed
        true

      cached when is_map(cached) -&gt;
        # Compare relevant fields
        changed?(cached, character_data, [
          &quot;character_name&quot;,
          &quot;corporation_id&quot;,
          &quot;corporation_name&quot;,
          &quot;alliance_id&quot;,
          &quot;alliance_name&quot;,
          &quot;security_status&quot;,
          &quot;ship_type_id&quot;,
          &quot;ship_name&quot;,
          &quot;location_id&quot;,
          &quot;location_name&quot;
        ])

      _ -&gt;
        # Invalid cache data, consider it changed
        true
    end
  end

  def character_changed?(_, _), do: false

  # Check if any of the specified fields have changed
  defp changed?(old_data, new_data, fields) do
    Enum.any?(fields, fn field -&gt;
      old_value = Map.get(old_data, field)
      new_value = Map.get(new_data, field)
      old_value != new_value
    end)
  end

  # Apply deduplication check and decide whether to send notification
  defp check_deduplication_and_decide(character_id) do
    case DeduplicationHelper.duplicate?(:character, character_id) do
      {:ok, :new} -&gt;
        # Not a duplicate, allow sending
        true

      {:ok, :duplicate} -&gt;
        # Duplicate, skip notification
        false

      {:error, reason} -&gt;
        # Error during deduplication check - default to allowing
        AppLogger.processor_warn(
          &quot;Deduplication check failed, allowing notification by default&quot;,
          %{
            character_id: character_id,
            error: inspect(reason)
          }
        )

        true
    end
  end
end</file><file path="lib/wanderer_notifier/notifications/determiner/kill.ex">defmodule WandererNotifier.Notifications.Determiner.Kill do
  @moduledoc &quot;&quot;&quot;
  Determines whether kill notifications should be sent.
  Handles all kill-related notification decision logic.
  &quot;&quot;&quot;

  alias WandererNotifier.Config
  alias WandererNotifier.Cache.Keys, as: CacheKeys
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Killmail.Killmail
  alias WandererNotifier.Helpers.DeduplicationHelper
  @doc &quot;&quot;&quot;
  Determines if a notification should be sent for a kill.

  ## Parameters
    - killmail: The killmail to check

  ## Returns
    - {:ok, %{should_notify: boolean(), reason: String.t()}} with tracking information
  &quot;&quot;&quot;
  def should_notify?(killmail) do
    system_id = get_kill_system_id(killmail)
    kill_id = get_kill_id(killmail)

    with true &lt;- check_notifications_enabled(kill_id),
         true &lt;- check_tracking(system_id, killmail) do
      check_deduplication_and_decide(kill_id)
    else
      false -&gt; {:ok, %{should_notify: false, reason: &quot;Not tracked by any character or system&quot;}}
      _ -&gt; {:ok, %{should_notify: false, reason: &quot;Notifications disabled&quot;}}
    end
  end

  defp check_notifications_enabled(_kill_id) do
    notifications_enabled = Config.notifications_enabled?()
    system_notifications_enabled = Config.system_notifications_enabled?()
    notifications_enabled &amp;&amp; system_notifications_enabled
  end

  defp check_tracking(system_id, killmail) do
    is_tracked_system = tracked_system?(system_id)
    has_tracked_char = has_tracked_character?(killmail)
    is_tracked_system || has_tracked_char
  end

  defp check_deduplication_and_decide(kill_id) do
    case DeduplicationHelper.duplicate?(:kill, kill_id) do
      {:ok, :new} -&gt; {:ok, %{should_notify: true, reason: nil}}
      {:ok, :duplicate} -&gt; {:ok, %{should_notify: false, reason: &quot;Duplicate kill&quot;}}
      {:error, _reason} -&gt; {:ok, %{should_notify: true, reason: nil}}
    end
  end

  # Get kill ID from killmail
  defp get_kill_id(killmail) do
    case killmail do
      %Killmail{killmail_id: id} when not is_nil(id) -&gt; id
      %{killmail_id: id} when not is_nil(id) -&gt; id
      %{&quot;killmail_id&quot; =&gt; id} when not is_nil(id) -&gt; id
      _ -&gt; &quot;unknown&quot;
    end
  end

  @doc &quot;&quot;&quot;
  Gets the system ID from a kill.
  &quot;&quot;&quot;
  def get_kill_system_id(kill) do
    extract_system_id(kill)
  end

  # Private helper functions to extract system ID from different data structures
  defp extract_system_id(kill) when is_struct(kill, Killmail) do
    case kill.esi_data do
      nil -&gt;
        &quot;unknown&quot;

      esi_data -&gt;
        case Map.get(esi_data, &quot;solar_system_id&quot;) do
          nil -&gt; &quot;unknown&quot;
          id when is_integer(id) -&gt; to_string(id)
          id when is_binary(id) -&gt; id
          _ -&gt; &quot;unknown&quot;
        end
    end
  end

  defp extract_system_id(kill) when is_map(kill) do
    extract_system_id_from_map(kill)
  end

  defp extract_system_id(_), do: &quot;unknown&quot;

  defp extract_system_id_from_map(kill) do
    Map.get(kill, &quot;solar_system_id&quot;, &quot;unknown&quot;)
  end

  @doc &quot;&quot;&quot;
  Checks if a system is being tracked.

  ## Parameters
    - system_id: The ID of the system to check

  ## Returns
    - true if the system is tracked
    - false otherwise
  &quot;&quot;&quot;
  def tracked_system?(system_id) when is_integer(system_id), do: tracked_system?(to_string(system_id))

  def tracked_system?(system_id_str) when is_binary(system_id_str) do
    result = CacheRepo.get(CacheKeys.map_systems())
    case result do
      {:ok, systems} when is_list(systems) -&gt;
        Enum.any?(systems, fn system -&gt;
          id = Map.get(system, :solar_system_id) || Map.get(system, &quot;solar_system_id&quot;)
          to_string(id) == system_id_str
        end)
      _ -&gt; false
    end
  end

  def tracked_system?(_), do: false

  @doc &quot;&quot;&quot;
  Checks if a killmail involves a tracked character (as victim or attacker).

  ## Parameters
    - killmail: The killmail data to check

  ## Returns
    - true if the killmail involves a tracked character
    - false otherwise
  &quot;&quot;&quot;
  def has_tracked_character?(killmail) do
    kill_data = extract_kill_data(killmail)
    all_character_ids = get_all_tracked_character_ids()

    # Check if victim is tracked
    victim_tracked = check_victim_tracked(kill_data, all_character_ids)

    if victim_tracked do
      true
    else
      check_attackers_tracked(kill_data, all_character_ids)
    end
  end

  # Extract kill data from various killmail formats
  defp extract_kill_data(killmail) do
    case killmail do
      %Killmail{esi_data: esi_data} when is_map(esi_data) -&gt; esi_data
      kill when is_map(kill) -&gt; kill
      _ -&gt; %{}
    end
  end

  # Get all tracked character IDs
  defp get_all_tracked_character_ids do
    case CacheRepo.get(CacheKeys.character_list()) do
      {:ok, all_characters} when is_list(all_characters) -&gt;
        Enum.map(all_characters, fn char -&gt;
          character_id = Map.get(char, &quot;character_id&quot;) || Map.get(char, :character_id)
          if character_id, do: to_string(character_id), else: nil
        end)
        |&gt; Enum.reject(&amp;is_nil/1)

      _ -&gt;
        []
    end
  end

  # Extract victim ID from kill data
  defp extract_victim_id(kill_data) do
    victim = Map.get(kill_data, &quot;victim&quot;) || Map.get(kill_data, :victim) || %{}
    victim_id = Map.get(victim, &quot;character_id&quot;) || Map.get(victim, :character_id)
    if victim_id, do: to_string(victim_id), else: nil
  end

  # Check if victim is tracked through direct cache lookup
  defp check_direct_victim_tracking(victim_id_str) do
    direct_cache_key = CacheKeys.tracked_character(victim_id_str)

    tracked =
      case CacheRepo.get(direct_cache_key) do
        {:ok, _} -&gt; true
        _ -&gt; false
      end

    tracked
  end

  # Check if the victim in this kill is being tracked
  defp check_victim_tracked(kill_data, all_character_ids) do
    victim_id_str = extract_victim_id(kill_data)
    victim_tracked = victim_id_str &amp;&amp; Enum.member?(all_character_ids, victim_id_str)

    if !victim_tracked &amp;&amp; victim_id_str do
      check_direct_victim_tracking(victim_id_str)
    else
      victim_tracked
    end
  end

  # Extract attackers from kill data
  defp extract_attackers(kill_data) do
    Map.get(kill_data, &quot;attackers&quot;) || Map.get(kill_data, :attackers) || []
  end

  # Check if any attacker is tracked
  defp check_attackers_tracked(kill_data, all_character_ids) do
    attackers = extract_attackers(kill_data)

    if attacker_in_tracked_list?(attackers, all_character_ids) do
      true
    else
      attacker_directly_tracked?(attackers)
    end
  end

  # Check if any attacker is in our tracked characters list
  defp attacker_in_tracked_list?(attackers, all_character_ids) do
    attackers
    |&gt; Enum.map(&amp;extract_attacker_id/1)
    |&gt; Enum.reject(&amp;is_nil/1)
    |&gt; Enum.any?(fn attacker_id -&gt; Enum.member?(all_character_ids, attacker_id) end)
  end

  # Extract attacker ID from attacker data
  defp extract_attacker_id(attacker) do
    attacker_id = Map.get(attacker, &quot;character_id&quot;) || Map.get(attacker, :character_id)
    if attacker_id, do: to_string(attacker_id), else: nil
  end

  # Check if any attacker is directly tracked
  defp attacker_directly_tracked?(attackers) do
    attackers
    |&gt; Enum.map(&amp;extract_attacker_id/1)
    |&gt; Enum.reject(&amp;is_nil/1)
    |&gt; Enum.any?(&amp;check_direct_victim_tracking/1)
  end

  @doc &quot;&quot;&quot;
  Determines if a kill is in a tracked system.

  ## Parameters
    - killmail: The killmail to check

  ## Returns
    - true if the kill happened in a tracked system
    - false otherwise
  &quot;&quot;&quot;
  def tracked_in_system?(killmail) do
    system_id = get_kill_system_id(killmail)
    tracked_system?(system_id)
  end

  @doc &quot;&quot;&quot;
  Gets the list of tracked characters involved in a kill.

  ## Parameters
    - killmail: The killmail to check

  ## Returns
    - List of tracked character IDs involved in the kill
  &quot;&quot;&quot;
  def get_tracked_characters(killmail) do
    # Extract all character IDs from the killmail
    all_character_ids = extract_all_character_ids(killmail)

    # Filter to only include tracked characters
    Enum.filter(all_character_ids, fn char_id -&gt; tracked_character?(char_id) end)
  end

  @doc &quot;&quot;&quot;
  Determines if tracked characters are victims in a kill.

  ## Parameters
    - killmail: The killmail to check
    - tracked_characters: List of tracked character IDs

  ## Returns
    - true if any tracked character is a victim
    - false if all tracked characters are attackers
  &quot;&quot;&quot;
  def are_tracked_characters_victims?(killmail, tracked_characters) do
    # Get the victim character ID
    victim_character_id = get_victim_character_id(killmail)

    # Check if any tracked character is the victim
    Enum.member?(tracked_characters, victim_character_id)
  end

  # Helper function to extract all character IDs from a killmail
  defp extract_all_character_ids(killmail) do
    # Get victim character ID
    victim_id = get_victim_character_id(killmail)
    victim_ids = if victim_id, do: [victim_id], else: []

    # Get attacker character IDs
    attacker_ids = get_attacker_character_ids(killmail)

    # Combine and remove duplicates
    (victim_ids ++ attacker_ids) |&gt; Enum.uniq()
  end

  # Helper function to get the victim character ID
  defp get_victim_character_id(killmail) when is_nil(killmail), do: nil

  defp get_victim_character_id(killmail) do
    esi_data = Map.get(killmail, :esi_data, %{})
    victim = Map.get(esi_data, &quot;victim&quot;, %{})
    Map.get(victim, &quot;character_id&quot;)
  end

  # Helper function to get attacker character IDs
  defp get_attacker_character_ids(killmail) do
    esi_data = Map.get(killmail, :esi_data, %{})
    attackers = Map.get(esi_data, &quot;attackers&quot;, [])

    Enum.map(attackers, fn attacker -&gt;
      Map.get(attacker, &quot;character_id&quot;)
    end)
    |&gt; Enum.filter(fn id -&gt; not is_nil(id) end)
  end

  @doc &quot;&quot;&quot;
  Checks if a character is being tracked.

  ## Parameters
    - character_id: The ID of the character to check

  ## Returns
    - true if the character is tracked
    - false otherwise
  &quot;&quot;&quot;
  def tracked_character?(character_id) when is_integer(character_id), do: tracked_character?(to_string(character_id))

  def tracked_character?(character_id_str) when is_binary(character_id_str) do
    result = CacheRepo.get(CacheKeys.character_list())
    case result do
      {:ok, characters} when is_list(characters) -&gt;
        Enum.any?(characters, fn char -&gt;
          id = Map.get(char, :character_id) || Map.get(char, &quot;character_id&quot;)
          to_string(id) == character_id_str
        end)
      _ -&gt; false
    end
  end

  def tracked_character?(_), do: false

  # defp typeof(val) do
  #   cond do
  #     is_integer(val) -&gt; :integer
  #     is_binary(val) -&gt; :binary
  #     is_atom(val) -&gt; :atom
  #     is_float(val) -&gt; :float
  #     is_list(val) -&gt; :list
  #     is_map(val) -&gt; :map
  #     true -&gt; :unknown
  #   end
  # end
end</file><file path="lib/wanderer_notifier/notifications/formatters/base.ex">defmodule WandererNotifier.Notifications.Formatters.Base do
  @moduledoc &quot;&quot;&quot;
  Base formatting utilities for notifications.
  Provides common formatting functions used across different notification types.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Extracts a character ID from different data formats.
  &quot;&quot;&quot;
  def extract_character_id(character_data) when is_map(character_data) do
    cond do
      # Notification format
      Map.has_key?(character_data, &quot;character_id&quot;) -&gt;
        character_data[&quot;character_id&quot;]

      # Standard API format
      get_in(character_data, [&quot;character&quot;, &quot;character_id&quot;]) -&gt;
        get_in(character_data, [&quot;character&quot;, &quot;character_id&quot;])

      # No character ID found
      true -&gt;
        nil
    end
  end

  @doc &quot;&quot;&quot;
  Extracts a character name from different data formats.
  &quot;&quot;&quot;
  def extract_character_name(character_data) when is_map(character_data) do
    cond do
      # Notification format
      Map.has_key?(character_data, &quot;character_name&quot;) -&gt;
        character_data[&quot;character_name&quot;]

      # Standard API format
      get_in(character_data, [&quot;character&quot;, &quot;name&quot;]) -&gt;
        get_in(character_data, [&quot;character&quot;, &quot;name&quot;])

      # No character name found
      true -&gt;
        &quot;Unknown Character&quot;
    end
  end

  @doc &quot;&quot;&quot;
  Extracts a corporation ID from different data formats.
  &quot;&quot;&quot;
  def extract_corporation_id(character_data) when is_map(character_data) do
    cond do
      # Notification format
      Map.has_key?(character_data, &quot;corporation_id&quot;) -&gt;
        character_data[&quot;corporation_id&quot;]

      # Standard API format
      get_in(character_data, [&quot;character&quot;, &quot;corporation_id&quot;]) -&gt;
        get_in(character_data, [&quot;character&quot;, &quot;corporation_id&quot;])

      # No corporation ID found
      true -&gt;
        nil
    end
  end

  @doc &quot;&quot;&quot;
  Extracts a corporation name from different data formats.
  &quot;&quot;&quot;
  def extract_corporation_name(character_data) when is_map(character_data) do
    cond do
      # Notification format
      Map.has_key?(character_data, &quot;corporation_name&quot;) -&gt;
        character_data[&quot;corporation_name&quot;]

      # Standard API format with ticker
      get_in(character_data, [&quot;character&quot;, &quot;corporation_ticker&quot;]) -&gt;
        get_in(character_data, [&quot;character&quot;, &quot;corporation_ticker&quot;])

      # No corporation name found
      true -&gt;
        &quot;Unknown Corporation&quot;
    end
  end

  @doc &quot;&quot;&quot;
  Formats a list of statics for display.
  &quot;&quot;&quot;
  def format_statics_list(statics) when is_binary(statics) do
    # Already formatted string
    statics
  end

  def format_statics_list(statics) when is_list(statics) do
    cond do
      # List with destination info
      Enum.all?(statics, &amp;(is_map(&amp;1) and Map.has_key?(&amp;1, &quot;destination&quot;))) -&gt;
        Enum.map_join(statics, &quot;, &quot;, fn
          %{&quot;name&quot; =&gt; name, &quot;destination&quot; =&gt; %{&quot;short_name&quot; =&gt; short_name}} -&gt;
            &quot;#{name} (#{short_name})&quot;
        end)

      # Simple string list
      Enum.all?(statics, &amp;is_binary/1) -&gt;
        Enum.join(statics, &quot;, &quot;)

      true -&gt;
        &quot;&quot;
    end
  end

  def format_statics_list(_), do: &quot;&quot;

  @doc &quot;&quot;&quot;
  Formats a security status value with color coding.
  &quot;&quot;&quot;
  def format_security_status(security_status) when is_number(security_status) do
    # Round to 1 decimal place
    rounded = Float.round(security_status, 1)

    # Format with color based on value
    cond do
      rounded &gt;= 0.5 -&gt; &quot;#{rounded} (High)&quot;
      rounded &gt; 0.0 -&gt; &quot;#{rounded} (Low)&quot;
      true -&gt; &quot;#{rounded} (Null)&quot;
    end
  end

  def format_security_status(security_status) when is_binary(security_status) do
    # Convert string to float and then format
    case Float.parse(security_status) do
      {value, _} -&gt; format_security_status(value)
      :error -&gt; &quot;Unknown&quot;
    end
  end

  @doc &quot;&quot;&quot;
  Formats ISK value in a compact way.
  &quot;&quot;&quot;
  def format_compact_isk_value(value) when is_number(value) do
    cond do
      value &gt;= 1_000_000_000 -&gt; &quot;#{Float.round(value / 1_000_000_000, 1)}B ISK&quot;
      value &gt;= 1_000_000 -&gt; &quot;#{Float.round(value / 1_000_000, 1)}M ISK&quot;
      value &gt;= 1_000 -&gt; &quot;#{Float.round(value / 1_000, 1)}K ISK&quot;
      true -&gt; &quot;#{Float.round(value, 1)} ISK&quot;
    end
  end

  def format_compact_isk_value(_), do: &quot;Unknown Value&quot;
end</file><file path="lib/wanderer_notifier/notifications/formatters/embed.ex">defmodule WandererNotifier.Notifications.Formatters.Embed do
  @moduledoc &quot;&quot;&quot;
  Generic embed formatting utilities.
  Provides functions for creating and manipulating embed structures.
  &quot;&quot;&quot;

  # Color constants for notifications
  # Default blue
  @default_color 0x3498DB
  # Green
  @success_color 0x2ECC71
  # Orange
  @warning_color 0xF39C12
  # Red
  @error_color 0xE74C3C
  # Blue
  @info_color 0x3498DB

  # Wormhole and security colors
  # Blue for Pulsar
  @wormhole_color 0x428BCA
  # Green for highsec
  @highsec_color 0x5CB85C
  # Yellow/orange for lowsec
  @lowsec_color 0xE28A0D
  # Red for nullsec
  @nullsec_color 0xD9534F

  @doc &quot;&quot;&quot;
  Returns a standardized set of colors for notification embeds.

  ## Returns
    - A map with color constants for various notification types
  &quot;&quot;&quot;
  def colors do
    %{
      default: @default_color,
      success: @success_color,
      warning: @warning_color,
      error: @error_color,
      info: @info_color,
      wormhole: @wormhole_color,
      highsec: @highsec_color,
      lowsec: @lowsec_color,
      nullsec: @nullsec_color
    }
  end

  @doc &quot;&quot;&quot;
  Converts a color in one format to Discord format.

  ## Parameters
    - color: The color to convert (atom, integer, or hex string)

  ## Returns
    - The color in Discord format (integer)
  &quot;&quot;&quot;
  def convert_color(color) when is_atom(color) do
    Map.get(colors(), color, @default_color)
  end

  def convert_color(color) when is_integer(color), do: color

  def convert_color(&quot;#&quot; &lt;&gt; hex) do
    {color, _} = Integer.parse(hex, 16)
    color
  end

  def convert_color(_color), do: @default_color

  @doc &quot;&quot;&quot;
  Adds a field to an embed map if the value is available.

  ## Parameters
  - embed: The embed map to update
  - name: The name of the field
  - value: The value of the field (or nil)
  - inline: Whether the field should be displayed inline

  ## Returns
  The updated embed map with the field added if value is not nil
  &quot;&quot;&quot;
  def add_field_if_available(embed, name, value, inline \\ true)
  def add_field_if_available(embed, _name, nil, _inline), do: embed
  def add_field_if_available(embed, _name, &quot;&quot;, _inline), do: embed

  def add_field_if_available(embed, name, value, inline) do
    # Ensure the fields key exists
    embed = Map.put_new(embed, :fields, [])

    # Add the new field
    Map.update!(embed, :fields, fn fields -&gt;
      fields ++ [%{name: name, value: to_string(value), inline: inline}]
    end)
  end

  @doc &quot;&quot;&quot;
  Creates a basic embed structure.

  ## Parameters
  - title: The title of the embed
  - description: The description of the embed
  - color: The color of the embed (atom, integer, or hex string)

  ## Returns
  - A basic embed structure
  &quot;&quot;&quot;
  def create_basic_embed(title, description, color) do
    %{
      title: title,
      description: description,
      color: convert_color(color),
      timestamp: DateTime.utc_now() |&gt; DateTime.to_iso8601(),
      fields: []
    }
  end

  @doc &quot;&quot;&quot;
  Adds an author to an embed.

  ## Parameters
  - embed: The embed to update
  - name: The author&apos;s name
  - icon_url: Optional URL for the author&apos;s icon
  - url: Optional URL for the author&apos;s name to link to

  ## Returns
  - The updated embed
  &quot;&quot;&quot;
  def add_author(embed, name, icon_url \\ nil, url \\ nil) do
    author = %{name: name}
    author = if icon_url, do: Map.put(author, :icon_url, icon_url), else: author
    author = if url, do: Map.put(author, :url, url), else: author

    Map.put(embed, :author, author)
  end

  @doc &quot;&quot;&quot;
  Adds a thumbnail to an embed.

  ## Parameters
  - embed: The embed to update
  - url: The URL of the thumbnail image

  ## Returns
  - The updated embed
  &quot;&quot;&quot;
  def add_thumbnail(embed, url) when is_binary(url) do
    Map.put(embed, :thumbnail, %{url: url})
  end

  def add_thumbnail(embed, _), do: embed

  @doc &quot;&quot;&quot;
  Adds a footer to an embed.

  ## Parameters
  - embed: The embed to update
  - text: The footer text
  - icon_url: Optional URL for the footer icon

  ## Returns
  - The updated embed
  &quot;&quot;&quot;
  def add_footer(embed, text, icon_url \\ nil) do
    footer = %{text: text}
    footer = if icon_url, do: Map.put(footer, :icon_url, icon_url), else: footer

    Map.put(embed, :footer, footer)
  end
end</file><file path="lib/wanderer_notifier/notifications/formatters/kill.ex">defmodule WandererNotifier.Notifications.Formatters.Kill do
  @moduledoc &quot;&quot;&quot;
  Formats kill notifications for delivery.
  Handles all kill-related notification formatting logic.
  &quot;&quot;&quot;

  alias WandererNotifier.Notifications.Formatters.{Base, Embed}

  @doc &quot;&quot;&quot;
  Formats a kill notification into a Discord-compatible format.

  ## Parameters
    - notification_data: Map containing the kill notification data
      Required keys:
        - :killmail - The killmail data
        - :character_id - The character ID that triggered the notification
        - :character_name - The character name that triggered the notification
        - :corporation_id - The corporation ID that triggered the notification
        - :corporation_name - The corporation name that triggered the notification

  ## Returns
    - {:ok, formatted_notification} on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def format(notification_data) do
    try do
      formatted = %{
        content: build_content(notification_data),
        embeds: build_embeds(notification_data),
        components: build_components(notification_data)
      }

      {:ok, formatted}
    rescue
      e -&gt;
        require Logger
        Logger.error(&quot;Failed to format kill notification: #{inspect(e)}&quot;)
        {:error, &quot;Failed to format kill notification&quot;}
    end
  end

  # Private Functions

  defp build_content(%{character_name: character_name}) do
    &quot;#{character_name} has been involved in a kill!&quot;
  end

  defp build_embeds(%{killmail: killmail} = data) do
    victim = get_in(killmail, [&quot;victim&quot;])
    attacker = get_in(killmail, [&quot;attackers&quot;]) |&gt; List.first()

    embed =
      Embed.create_basic_embed(
        &quot;Killmail Report&quot;,
        build_description(killmail),
        determine_color(victim)
      )
      |&gt; add_victim_fields(victim)
      |&gt; add_attacker_fields(attacker)
      |&gt; add_value_fields(killmail)
      |&gt; add_location_fields(killmail)
      |&gt; add_metadata(data)

    [embed]
  end

  defp build_components(_notification_data) do
    # No components needed for kill notifications currently
    []
  end

  defp build_description(killmail) do
    victim_name = get_in(killmail, [&quot;victim&quot;, &quot;character_name&quot;]) || &quot;Unknown&quot;
    ship_type = get_in(killmail, [&quot;victim&quot;, &quot;ship_type&quot;, &quot;name&quot;]) || &quot;Unknown Ship&quot;

    &quot;#{victim_name} lost their #{ship_type}&quot;
  end

  defp determine_color(victim) do
    case get_in(victim, [&quot;position&quot;, &quot;security_status&quot;]) do
      sec when is_number(sec) and sec &gt;= 0.5 -&gt; :highsec
      sec when is_number(sec) and sec &gt; 0.0 -&gt; :lowsec
      sec when is_number(sec) and sec &lt;= 0.0 -&gt; :nullsec
      _ -&gt; :default
    end
  end

  defp add_victim_fields(embed, victim) do
    embed
    |&gt; Embed.add_field_if_available(&quot;Victim&quot;, victim[&quot;character_name&quot;])
    |&gt; Embed.add_field_if_available(&quot;Corporation&quot;, victim[&quot;corporation_name&quot;])
    |&gt; Embed.add_field_if_available(&quot;Alliance&quot;, victim[&quot;alliance_name&quot;])
    |&gt; Embed.add_field_if_available(&quot;Ship&quot;, get_in(victim, [&quot;ship_type&quot;, &quot;name&quot;]))
  end

  defp add_attacker_fields(embed, attacker) do
    embed
    |&gt; Embed.add_field_if_available(&quot;Final Blow&quot;, attacker[&quot;character_name&quot;])
    |&gt; Embed.add_field_if_available(&quot;Corporation&quot;, attacker[&quot;corporation_name&quot;])
    |&gt; Embed.add_field_if_available(&quot;Alliance&quot;, attacker[&quot;alliance_name&quot;])
    |&gt; Embed.add_field_if_available(&quot;Ship&quot;, get_in(attacker, [&quot;ship_type&quot;, &quot;name&quot;]))
    |&gt; Embed.add_field_if_available(&quot;Weapon&quot;, get_in(attacker, [&quot;weapon_type&quot;, &quot;name&quot;]))
  end

  defp add_value_fields(embed, killmail) do
    total_value = get_in(killmail, [&quot;zkb&quot;, &quot;totalValue&quot;]) || 0

    embed
    |&gt; Embed.add_field_if_available(
      &quot;Total Value&quot;,
      Base.format_compact_isk_value(total_value)
    )
  end

  defp add_location_fields(embed, killmail) do
    solar_system = get_in(killmail, [&quot;solar_system&quot;, &quot;name&quot;]) || &quot;Unknown&quot;
    security_status = get_in(killmail, [&quot;solar_system&quot;, &quot;security_status&quot;]) || 0.0

    formatted_security = Base.format_security_status(security_status)

    embed
    |&gt; Embed.add_field_if_available(&quot;System&quot;, solar_system)
    |&gt; Embed.add_field_if_available(&quot;Security&quot;, formatted_security)
  end

  defp add_metadata(embed, %{character_name: name, corporation_name: corp}) do
    embed
    |&gt; Embed.add_author(name)
    |&gt; Embed.add_footer(&quot;#{corp} Kill Notification&quot;)
  end
end</file><file path="lib/wanderer_notifier/notifications/behaviour.ex">defmodule WandererNotifier.Notifications.Behaviour do
  @moduledoc &quot;&quot;&quot;
  Defines the behaviour for notification handling.
  This includes both determination of what needs to be notified and formatting of notifications.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Determines if a notification should be sent based on the given context.
  Returns {:ok, notification_data} if a notification should be sent, {:ok, nil} if not.
  &quot;&quot;&quot;
  @callback determine(context :: map()) :: {:ok, map() | nil} | {:error, any()}

  @doc &quot;&quot;&quot;
  Formats a notification for delivery.
  Takes notification data and returns a formatted notification ready for delivery.
  &quot;&quot;&quot;
  @callback format(notification_data :: map()) :: {:ok, map()} | {:error, any()}
end</file><file path="lib/wanderer_notifier/notifications/factory_behaviour.ex">defmodule WandererNotifier.Notifications.FactoryBehaviour do
  @moduledoc &quot;&quot;&quot;
  Defines the behaviour for notification factories in the WandererNotifier application.
  &quot;&quot;&quot;

  @callback notify(type :: atom(), data :: map()) :: :ok | {:error, term()}
end</file><file path="lib/wanderer_notifier/notifications/factory.ex">defmodule WandererNotifier.Notifications.Factory do
  @moduledoc &quot;&quot;&quot;
  Factory for creating and sending notifications.
  Implements the NotificationsFactoryBehaviour and provides a unified interface
  for sending notifications of various types.
  &quot;&quot;&quot;

  require Logger
  alias WandererNotifier.Config
  alias WandererNotifier.Notifiers.Discord.Notifier, as: DiscordNotifier
  alias WandererNotifier.Notifiers.TestNotifier

  @behaviour WandererNotifier.Notifications.FactoryBehaviour

  @doc &quot;&quot;&quot;
  Sends a notification using the appropriate notifier based on the current configuration.

  This function implements the FactoryBehaviour callback and handles all notification types.

  ## Parameters
  - type: The type of notification to send (e.g. :send_discord_embed)
  - data: The data to include in the notification (content varies based on type)

  ## Returns
  - {:ok, result} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  @impl WandererNotifier.Notifications.FactoryBehaviour
  def notify(type, data) do
    if Config.notifications_enabled?() do
      do_notify(get_notifier(), type, data)
    else
      {:error, :notifications_disabled}
    end
  end

  @doc &quot;&quot;&quot;
  Gets the appropriate notifier based on the current configuration.
  &quot;&quot;&quot;
  def get_notifier do
    if Config.test_mode_enabled?() do
      TestNotifier
    else
      DiscordNotifier
    end
  end

  defp do_notify(notifier, :send_system_kill_discord_embed, [embed]) do
    # Get the channel ID for system kill notifications
    channel_id = Config.discord_system_kill_channel_id()

    if is_nil(channel_id) do
      # Fall back to main channel if no dedicated channel is configured
      notifier.send_notification(:send_discord_embed, [embed])
    else
      # Send to the system kill channel
      notifier.send_notification(:send_discord_embed_to_channel, [channel_id, embed])
    end
  end

  defp do_notify(notifier, :send_character_kill_discord_embed, [embed]) do
    # Get the channel ID for character kill notifications
    channel_id = Config.discord_character_kill_channel_id()

    if is_nil(channel_id) do
      # Fall back to main channel if no dedicated channel is configured
      notifier.send_notification(:send_discord_embed, [embed])
    else
      # Send to the character kill channel
      notifier.send_notification(:send_discord_embed_to_channel, [channel_id, embed])
    end
  end

  defp do_notify(notifier, type, data) do
    notifier.send_notification(type, data)
  end

  @doc &quot;&quot;&quot;
  Sends a system activity notification.

  ## Parameters
  - embed: The formatted embed to send

  ## Returns
  - {:ok, result} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_system_activity_notification(embed) do
    notify(:send_system_activity_discord_embed, [embed])
  end

  @doc &quot;&quot;&quot;
  Sends a character activity notification.

  ## Parameters
  - embed: The formatted embed to send

  ## Returns
  - {:ok, result} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_character_activity_notification(embed) do
    notify(:send_character_activity_discord_embed, [embed])
  end

  @doc &quot;&quot;&quot;
  Sends a plain text message notification.

  ## Parameters
  - message: The text message to send

  ## Returns
  - {:ok, result} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_message(message) do
    notify(:send_message, [message])
  end

  @doc &quot;&quot;&quot;
  Sends a system notification.

  ## Parameters
  - embed: The formatted embed to send

  ## Returns
  - {:ok, result} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_system_notification(embed) do
    notify(:send_system_discord_embed, [embed])
  end
end</file><file path="lib/wanderer_notifier/notifications/interface.ex">defmodule WandererNotifier.Notifications.Interface do
  @moduledoc &quot;&quot;&quot;
  Standardized interface for creating and sending notifications.

  This module provides a clean, consistent API for sending various types of notifications
  throughout the application, abstracting away the underlying notification mechanism.
  &quot;&quot;&quot;

  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Notifications.Factory
  alias WandererNotifier.Notifiers.Formatters.Structured, as: StructuredFormatter
  alias WandererNotifier.Notifications.Determiner.Character, as: CharacterDeterminer
  alias WandererNotifier.Notifications.Determiner.Kill, as: KillDeterminer
  alias WandererNotifier.Notifications.KillmailNotification

  @doc &quot;&quot;&quot;
  Sends a kill notification.

  Determines if a notification should be sent and manages both system and character notifications.

  ## Parameters
  - enriched_killmail: The enriched killmail data to send notification for
  - kill_id: The ID of the kill
  - bypass_dedup: Whether to bypass deduplication checks (default: false)

  ## Returns
  - {:ok, kill_id} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_kill_notification(enriched_killmail, kill_id, bypass_dedup \\ false) do
    KillmailNotification.send_kill_notification(enriched_killmail, kill_id, bypass_dedup)
  end

  @doc &quot;&quot;&quot;
  Checks if a notification should be sent for a given kill.

  ## Parameters
  - killmail: The killmail to check

  ## Returns
  - true if a notification should be sent
  - false otherwise
  &quot;&quot;&quot;
  def should_notify_kill?(killmail) do
    KillDeterminer.should_notify?(killmail)
  end

  @doc &quot;&quot;&quot;
  Checks if a notification should be sent for a given character.

  ## Parameters
  - character_id: The character ID to check
  - character_details: Optional map with character details for performance optimization

  ## Returns
  - true if a notification should be sent
  - false otherwise
  &quot;&quot;&quot;
  def should_notify_character?(character_id, character_details \\ nil) do
    CharacterDeterminer.should_notify?(character_id, character_details)
  end

  @doc &quot;&quot;&quot;
  Sends a test kill notification.

  Uses recent data to send a test notification.

  ## Returns
  - {:ok, kill_id} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_test_kill_notification do
    KillmailNotification.send_test()
  end

  @doc &quot;&quot;&quot;
  Sends a system activity notification.

  ## Parameters
  - system_id: The system ID
  - activity_data: Map containing activity details

  ## Returns
  - {:ok, result} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_system_activity_notification(system_id, activity_data) do
    # Format the system activity data into a structured format
    generic_notification =
      StructuredFormatter.format_system_activity_notification(
        system_id,
        activity_data
      )

    # Convert to Discord format
    discord_format = StructuredFormatter.to_discord_format(generic_notification)

    # Send notification
    Factory.send_system_activity_notification(discord_format)
  end

  @doc &quot;&quot;&quot;
  Sends a character activity notification.

  ## Parameters
  - character_id: The character ID
  - activity_data: Map containing activity details

  ## Returns
  - {:ok, result} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_character_activity_notification(character_id, activity_data) do
    # Format the character activity data into a structured format
    generic_notification =
      StructuredFormatter.format_character_activity_notification(
        character_id,
        activity_data
      )

    # Convert to Discord format
    discord_format = StructuredFormatter.to_discord_format(generic_notification)

    # Send notification
    Factory.send_character_activity_notification(discord_format)
  end

  @doc &quot;&quot;&quot;
  Sends a plain text message notification.

  ## Parameters
  - message: The text message to send

  ## Returns
  - {:ok, result} on success
  - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_message(message) do
    case message do
      msg when is_binary(msg) -&gt;
        AppLogger.notification_info(&quot;Sending message notification&quot;, %{
          message_length: String.length(msg)
        })

        Factory.send_message(msg)

      embed when is_map(embed) -&gt;
        AppLogger.notification_info(&quot;Sending embed notification&quot;, %{
          title: Map.get(embed, :title) || Map.get(embed, &quot;title&quot;),
          description: Map.get(embed, :description) || Map.get(embed, &quot;description&quot;)
        })

        Factory.send_message(embed)

      _ -&gt;
        AppLogger.notification_error(&quot;Unknown message type for notification&quot;, %{
          type: inspect(message)
        })

        {:error, :invalid_message_type}
    end
  end
end</file><file path="lib/wanderer_notifier/notifications/killmail_notification.ex">defmodule WandererNotifier.Notifications.KillmailNotification do
  @moduledoc &quot;&quot;&quot;
  Specialized module for processing kill notifications.
  Encapsulates all the notification handling logic for kills.
  &quot;&quot;&quot;

  alias WandererNotifier.Cache.Keys, as: CacheKeys
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Notifications.Determiner.Kill, as: KillDeterminer
  alias WandererNotifier.Notifications.Factory
  alias WandererNotifier.Notifiers.Formatters.Structured, as: StructuredFormatter

  @doc &quot;&quot;&quot;
  Creates a notification from a killmail.

  ## Parameters
  - killmail: The killmail struct to create a notification from

  ## Returns
  - A formatted notification ready to be sent
  &quot;&quot;&quot;
  def create(killmail) do
    # Format the kill notification using the StructuredFormatter
    StructuredFormatter.format_kill_notification(killmail)
  end

  @doc &quot;&quot;&quot;
  Determines if a kill notification should be sent and sends it.

  ## Parameters
  - killmail: The killmail struct to process
  - system_id: Optional system ID (will extract from killmail if not provided)

  ## Returns
  - true if a notification was sent
  - false if notification was skipped
  &quot;&quot;&quot;
  def should_notify_kill?(killmail, _system_id \\ nil) do
    # Delegate to the KillDeterminer module for notification logic
    KillDeterminer.should_notify?(killmail)
  end

  @doc &quot;&quot;&quot;
  Sends a kill notification.
  &quot;&quot;&quot;
  def send_kill_notification(enriched_killmail, kill_id, _bypass_dedup \\ false) do
    AppLogger.kill_info(&quot;Sending kill notification&quot;, %{kill_id: kill_id})

    # Check if the kill is relevant for system and/or character channels
    has_tracked_system = KillDeterminer.tracked_in_system?(enriched_killmail)
    tracked_characters = KillDeterminer.get_tracked_characters(enriched_killmail)
    has_tracked_characters = length(tracked_characters) &gt; 0

    # Log what was detected
    log_notification_relevance(
      kill_id,
      has_tracked_system,
      has_tracked_characters,
      tracked_characters
    )

    # Send notifications to appropriate channels
    system_result = process_system_notification(enriched_killmail, kill_id, has_tracked_system)

    character_result =
      process_character_notification(
        enriched_killmail,
        kill_id,
        has_tracked_characters,
        tracked_characters
      )

    # Return combined result
    combine_notification_results(system_result, character_result, kill_id)
  end

  # Log relevance information for debugging
  defp log_notification_relevance(
         kill_id,
         has_tracked_system,
         has_tracked_characters,
         tracked_characters
       ) do
    AppLogger.kill_debug(&quot;Notification relevance&quot;, %{
      kill_id: kill_id,
      has_tracked_system: has_tracked_system,
      has_tracked_characters: has_tracked_characters,
      num_tracked_characters: length(tracked_characters)
    })
  end

  # Process system notification if needed
  defp process_system_notification(enriched_killmail, kill_id, has_tracked_system) do
    if has_tracked_system do
      # Prepare system notification
      system_generic_notification =
        StructuredFormatter.format_kill_notification(enriched_killmail)

      system_discord_format = StructuredFormatter.to_discord_format(system_generic_notification)

      # Send system notification
      send_system_notification(system_discord_format, kill_id)
    else
      {:ok, :skipped_system}
    end
  end

  # Process character notification if needed
  defp process_character_notification(
         enriched_killmail,
         kill_id,
         has_tracked_characters,
         tracked_characters
       ) do
    if has_tracked_characters do
      # Determine if tracked characters are victims or attackers
      are_victims =
        KillDeterminer.are_tracked_characters_victims?(enriched_killmail, tracked_characters)

      # Prepare character notification with appropriate color
      character_generic_notification =
        StructuredFormatter.format_character_kill_notification(
          enriched_killmail,
          tracked_characters,
          are_victims
        )

      character_discord_format =
        StructuredFormatter.to_discord_format(character_generic_notification)

      # Send character notification
      send_character_notification(character_discord_format, kill_id)
    else
      {:ok, :skipped_character}
    end
  end

  # Send system notification and handle result
  defp send_system_notification(notification, kill_id) do
    case Factory.send_message(notification) do
      {:ok, :sent} -&gt;
        AppLogger.kill_info(&quot;System kill notification sent&quot;, %{kill_id: kill_id})
        {:ok, :system_sent}

      {:error, reason} = error -&gt;
        AppLogger.kill_error(&quot;Failed to send system kill notification&quot;, %{
          kill_id: kill_id,
          error: inspect(reason)
        })

        error
    end
  end

  # Send character notification and handle result
  defp send_character_notification(notification, kill_id) do
    case Factory.send_message(notification) do
      {:ok, :sent} -&gt;
        AppLogger.kill_info(&quot;Character kill notification sent&quot;, %{kill_id: kill_id})
        {:ok, :character_sent}

      {:error, reason} = error -&gt;
        AppLogger.kill_error(&quot;Failed to send character kill notification&quot;, %{
          kill_id: kill_id,
          error: inspect(reason)
        })

        error
    end
  end

  # Combine results from system and character notifications
  defp combine_notification_results(system_result, character_result, kill_id) do
    case {system_result, character_result} do
      {{:ok, _}, {:ok, _}} -&gt;
        AppLogger.kill_info(&quot;All kill notifications sent successfully&quot;, %{kill_id: kill_id})
        {:ok, :all_sent}

      {{:ok, _}, {:error, reason}} -&gt;
        AppLogger.kill_error(&quot;Character notification failed but system notification succeeded&quot;, %{
          kill_id: kill_id,
          error: inspect(reason)
        })

        {:error, reason}

      {{:error, reason}, {:ok, _}} -&gt;
        AppLogger.kill_error(&quot;System notification failed but character notification succeeded&quot;, %{
          kill_id: kill_id,
          error: inspect(reason)
        })

        {:error, reason}

      {{:error, reason}, {:error, _}} -&gt;
        AppLogger.kill_error(&quot;Both notifications failed&quot;, %{
          kill_id: kill_id,
          error: inspect(reason)
        })

        {:error, reason}

      {{:ok, :skipped_system}, {:ok, :skipped_character}} -&gt;
        AppLogger.kill_info(&quot;No notifications needed&quot;, %{kill_id: kill_id})
        {:ok, :skipped}

      {result_a, result_b} -&gt;
        AppLogger.kill_info(&quot;Mixed notification results&quot;, %{
          kill_id: kill_id,
          system_result: inspect(result_a),
          character_result: inspect(result_b)
        })

        {:ok, :partial}
    end
  end

  # Ensure we have a proper Data.Killmail struct
  defp ensure_data_killmail(killmail) do
    if is_struct(killmail, WandererNotifier.Killmail.Killmail) do
      killmail
    else
      # Try to convert map to struct
      if is_map(killmail) do
        struct(WandererNotifier.Killmail.Killmail, Map.delete(killmail, :__struct__))
      else
        # Fallback empty struct with required fields
        %WandererNotifier.Killmail.Killmail{
          killmail_id: &quot;unknown&quot;,
          zkb: %{}
        }
      end
    end
  end

  # Validate killmail has essential data
  defp validate_killmail_data(killmail) do
    cond do
      is_nil(killmail.esi_data) -&gt;
        {:error, &quot;Missing ESI data&quot;}

      is_nil(killmail.killmail_id) -&gt;
        {:error, &quot;Missing killmail ID&quot;}

      true -&gt;
        :ok
    end
  end

  @doc &quot;&quot;&quot;
  Sends a test kill notification using recent data.
  &quot;&quot;&quot;
  def send_test do
    AppLogger.kill_info(&quot;Sending test kill notification...&quot;)

    # Get recent kills using proper cache key
    recent_kills_result = CacheRepo.get(CacheKeys.zkill_recent_kills())

    recent_kills =
      case recent_kills_result do
        {:ok, kills} -&gt; kills
        _ -&gt; []
      end

    AppLogger.kill_debug(&quot;Found #{length(recent_kills)} recent kills in shared cache repository&quot;)

    if recent_kills == [] do
      AppLogger.kill_warn(&quot;No recent kills found in shared cache repository&quot;)
      {:error, :no_recent_kills}
    else
      # Get the first kill
      recent_kill = List.first(recent_kills)

      # Extract kill_id regardless of struct type
      kill_id = extract_kill_id(recent_kill)

      # Log what we&apos;re using for testing
      AppLogger.kill_debug(&quot;Using kill data for test notification with kill_id: #{kill_id}&quot;)

      # Create a Data.Killmail struct if needed
      killmail = ensure_data_killmail(recent_kill)

      # Make sure to enrich the killmail data before sending notification
      # This will try to get real data from APIs first
      case WandererNotifier.Killmail.Enrichment.enrich_killmail_data(killmail) do
        {:ok, enriched_kill} -&gt;
          # Validate essential data is present - fail if not
          case validate_killmail_data(enriched_kill) do
            :ok -&gt;
              # Use the normal notification flow but bypass deduplication
              AppLogger.kill_info(
                &quot;TEST NOTIFICATION: Using normal notification flow for test kill notification&quot;
              )

              send_kill_notification(enriched_kill, kill_id, true)
              {:ok, kill_id}

            {:error, reason} -&gt;
              # Data validation failed, return error
              error_message = &quot;Cannot send test notification: #{reason}&quot;
              AppLogger.kill_error(error_message)

              # Notify the user through Discord
              Factory.send_message(error_message)

              {:error, error_message}
          end

        {:error, reason} -&gt;
          # Data enrichment failed, return error
          error_message = &quot;Cannot send test notification: #{reason}&quot;
          AppLogger.kill_error(error_message)

          # Notify the user through Discord
          Factory.send_message(error_message)

          {:error, error_message}
      end
    end
  end

  # Extract kill_id from various killmail formats
  defp extract_kill_id(killmail) do
    cond do
      is_map(killmail) &amp;&amp; Map.has_key?(killmail, :killmail_id) -&gt;
        killmail.killmail_id

      is_map(killmail) &amp;&amp; Map.has_key?(killmail, &quot;killmail_id&quot;) -&gt;
        killmail[&quot;killmail_id&quot;]

      true -&gt;
        &quot;unknown&quot;
    end
  end
end</file><file path="lib/wanderer_notifier/notifications/utils.ex">defmodule WandererNotifier.Notifications.Utils do
  @moduledoc &quot;&quot;&quot;
  Utility functions for notification formatting and data extraction.
  &quot;&quot;&quot;
  alias WandererNotifier.Map.MapCharacter
  alias WandererNotifier.Utilities.CharacterUtils

  @doc &quot;&quot;&quot;
  Adds a field to an embed map if the value is available.

  ## Parameters
  - embed: The embed map to update
  - name: The name of the field
  - value: The value of the field (or nil)
  - inline: Whether the field should be displayed inline

  ## Returns
  The updated embed map with the field added if value is not nil
  &quot;&quot;&quot;
  @spec add_field_if_available(map(), String.t(), any(), boolean()) :: map()
  def add_field_if_available(embed, name, value, inline \\ true)
  def add_field_if_available(embed, _name, nil, _inline), do: embed
  def add_field_if_available(embed, _name, &quot;&quot;, _inline), do: embed

  def add_field_if_available(embed, name, value, inline) do
    # Ensure the fields key exists
    embed = Map.put_new(embed, :fields, [])

    # Add the new field
    Map.update!(embed, :fields, fn fields -&gt;
      fields ++ [%{name: name, value: to_string(value), inline: inline}]
    end)
  end

  @doc &quot;&quot;&quot;
  Adds a security status field to an embed if the security status is available.

  ## Parameters
  - embed: The embed map to update
  - security_status: The security status value (or nil)

  ## Returns
  The updated embed map with the security status field added if available
  &quot;&quot;&quot;
  @spec add_security_field(map(), float() | nil) :: map()
  def add_security_field(embed, nil), do: embed

  def add_security_field(embed, security_status) when is_number(security_status) do
    # Format the security status
    formatted_security = format_security_status(security_status)

    # Add the field
    add_field_if_available(embed, &quot;Security&quot;, formatted_security)
  end

  @doc &quot;&quot;&quot;
  Formats a security status value with color coding.

  ## Parameters
  - security_status: The security status value

  ## Returns
  A formatted string with the security status
  &quot;&quot;&quot;
  @spec format_security_status(float() | String.t()) :: String.t()
  def format_security_status(security_status) when is_number(security_status) do
    # Round to 1 decimal place
    rounded = Float.round(security_status, 1)

    # Format with color based on value
    cond do
      rounded &gt;= 0.5 -&gt; &quot;#{rounded} (High)&quot;
      rounded &gt; 0.0 -&gt; &quot;#{rounded} (Low)&quot;
      true -&gt; &quot;#{rounded} (Null)&quot;
    end
  end

  def format_security_status(security_status) when is_binary(security_status) do
    # Convert string to float and then format
    case Float.parse(security_status) do
      {value, _} -&gt; format_security_status(value)
      :error -&gt; &quot;Unknown&quot;
    end
  end

  @doc &quot;&quot;&quot;
  Extracts a character ID from a Character struct.
  Delegates to CharacterUtils.
  &quot;&quot;&quot;
  @spec extract_character_id(MapCharacter.t()) :: String.t()
  defdelegate extract_character_id(character), to: CharacterUtils

  @doc &quot;&quot;&quot;
  Extracts a character name from a Character struct.
  Delegates to CharacterUtils.
  &quot;&quot;&quot;
  @spec extract_character_name(MapCharacter.t()) :: String.t()
  defdelegate extract_character_name(character), to: CharacterUtils

  @doc &quot;&quot;&quot;
  Extracts a corporation name from a Character struct.
  Delegates to CharacterUtils.
  &quot;&quot;&quot;
  @spec extract_corporation_name(MapCharacter.t()) :: String.t()
  defdelegate extract_corporation_name(character), to: CharacterUtils
end</file><file path="lib/wanderer_notifier/notifiers/discord/behaviour.ex">defmodule WandererNotifier.Notifiers.Discord.Behaviour do
  @moduledoc &quot;&quot;&quot;
  Defines the behaviour for Discord notification implementations.
  &quot;&quot;&quot;

  @doc &quot;Sends a notification&quot;
  @callback notify(notification :: map()) :: :ok | {:error, term()}

  @doc &quot;Sends a message to Discord&quot;
  @callback send_message(message :: String.t(), channel :: atom()) :: :ok | {:error, term()}

  @doc &quot;Sends an embed to Discord&quot;
  @callback send_embed(
              title :: String.t(),
              description :: String.t(),
              color :: integer(),
              fields :: list(),
              channel :: atom()
            ) :: :ok | {:error, term()}

  @doc &quot;Sends a file to Discord&quot;
  @callback send_file(
              filename :: String.t(),
              file_data :: binary(),
              title :: String.t(),
              description :: String.t(),
              channel :: atom()
            ) :: :ok | {:error, term()}

  @doc &quot;Sends an image embed to Discord&quot;
  @callback send_image_embed(
              title :: String.t(),
              description :: String.t(),
              image_url :: String.t(),
              color :: integer(),
              channel :: atom()
            ) :: :ok | {:error, term()}

  @doc &quot;Sends an enriched kill embed&quot;
  @callback send_enriched_kill_embed(killmail :: struct(), kill_id :: integer()) ::
              :ok | {:error, term()}

  @doc &quot;Sends a new system notification&quot;
  @callback send_new_system_notification(system :: struct()) :: :ok | {:error, term()}

  @doc &quot;Sends a new tracked character notification&quot;
  @callback send_new_tracked_character_notification(character :: struct()) ::
              :ok | {:error, term()}

  @doc &quot;Sends a kill notification&quot;
  @callback send_kill_notification(kill_data :: map()) :: :ok | {:error, term()}
end</file><file path="lib/wanderer_notifier/notifiers/discord/component_builder.ex">defmodule WandererNotifier.Notifiers.Discord.ComponentBuilder do
  @moduledoc &quot;&quot;&quot;
  Builds Discord message components like buttons and action rows.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Creates an action row for kill-related actions.
  &quot;&quot;&quot;
  def kill_action_row(kill_id) do
    %{
      # Action Row
      type: 1,
      components: [
        build_zkill_button(kill_id),
        build_info_button(kill_id)
      ]
    }
  end

  @doc &quot;&quot;&quot;
  Creates a button that links to zKillboard.
  &quot;&quot;&quot;
  def build_zkill_button(kill_id) do
    %{
      # Button
      type: 2,
      # Link style
      style: 5,
      label: &quot;View on zKillboard&quot;,
      url: &quot;https://zkillboard.com/kill/#{kill_id}/&quot;
    }
  end

  @doc &quot;&quot;&quot;
  Creates an info button for additional kill details.
  &quot;&quot;&quot;
  def build_info_button(kill_id) do
    %{
      # Button
      type: 2,
      # Primary style
      style: 1,
      label: &quot;More Info&quot;,
      custom_id: &quot;kill_info_#{kill_id}&quot;
    }
  end

  @doc &quot;&quot;&quot;
  Creates an action row for system-related actions.
  &quot;&quot;&quot;
  def system_action_row(system_id) do
    %{
      # Action Row
      type: 1,
      components: [
        build_dotlan_button(system_id),
        build_system_info_button(system_id)
      ]
    }
  end

  @doc &quot;&quot;&quot;
  Creates a button that links to DOTLAN.
  &quot;&quot;&quot;
  def build_dotlan_button(system_id) do
    %{
      # Button
      type: 2,
      # Link style
      style: 5,
      label: &quot;View on DOTLAN&quot;,
      url: &quot;https://evemaps.dotlan.net/system/#{system_id}&quot;
    }
  end

  @doc &quot;&quot;&quot;
  Creates an info button for additional system details.
  &quot;&quot;&quot;
  def build_system_info_button(system_id) do
    %{
      # Button
      type: 2,
      # Primary style
      style: 1,
      label: &quot;System Info&quot;,
      custom_id: &quot;system_info_#{system_id}&quot;
    }
  end

  @doc &quot;&quot;&quot;
  Creates an action row for character-related actions.
  &quot;&quot;&quot;
  def character_action_row(character_id) do
    %{
      # Action Row
      type: 1,
      components: [
        build_zkill_character_button(character_id),
        build_character_info_button(character_id)
      ]
    }
  end

  @doc &quot;&quot;&quot;
  Creates a button that links to a character&apos;s zKillboard page.
  &quot;&quot;&quot;
  def build_zkill_character_button(character_id) do
    %{
      # Button
      type: 2,
      # Link style
      style: 5,
      label: &quot;View on zKillboard&quot;,
      url: &quot;https://zkillboard.com/character/#{character_id}/&quot;
    }
  end

  @doc &quot;&quot;&quot;
  Creates an info button for additional character details.
  &quot;&quot;&quot;
  def build_character_info_button(character_id) do
    %{
      # Button
      type: 2,
      # Primary style
      style: 1,
      label: &quot;Character Info&quot;,
      custom_id: &quot;character_info_#{character_id}&quot;
    }
  end
end</file><file path="lib/wanderer_notifier/notifiers/discord/constants.ex">defmodule WandererNotifier.Notifiers.Discord.Constants do
  @moduledoc &quot;&quot;&quot;
  Constants used in Discord notifications.
  &quot;&quot;&quot;

  # Discord color codes
  def colors do
    %{
      default: 0x3498DB,
      success: 0x2ECC71,
      warning: 0xF1C40F,
      error: 0xE74C3C,
      info: 0x3498DB,
      highsec: 0x2ECC71,
      lowsec: 0xF1C40F,
      nullsec: 0xE74C3C,
      wormhole: 0x9B59B6
    }
  end

  # Discord embed limits
  def embed_limits do
    %{
      title: 256,
      description: 4096,
      fields: 25,
      field_name: 256,
      field_value: 1024,
      footer_text: 2048,
      author_name: 256,
      total: 6000
    }
  end

  # Discord message limits
  def message_limits do
    %{
      content: 2000,
      embeds: 10,
      files: 10,
      # 8MB
      file_size: 8_388_608
    }
  end

  # Discord component limits
  def component_limits do
    %{
      action_rows: 5,
      buttons_per_row: 5,
      select_menu_options: 25,
      custom_id: 100
    }
  end

  # Discord rate limits
  def rate_limits do
    %{
      messages_per_second: 5,
      messages_per_minute: 120,
      webhook_per_second: 30
    }
  end
end</file><file path="lib/wanderer_notifier/notifiers/discord/feature_flags.ex">defmodule WandererNotifier.Notifiers.Discord.FeatureFlags do
  @moduledoc &quot;&quot;&quot;
  Feature flags for Discord notification functionality.
  &quot;&quot;&quot;

  alias WandererNotifier.Config

  @doc &quot;&quot;&quot;
  Checks if interactive components are enabled.
  &quot;&quot;&quot;
  def components_enabled? do
    Config.feature_enabled?(:discord_components)
  end

  @doc &quot;&quot;&quot;
  Checks if rich embeds are enabled.
  &quot;&quot;&quot;
  def rich_embeds_enabled? do
    Config.feature_enabled?(:discord_rich_embeds)
  end

  @doc &quot;&quot;&quot;
  Checks if file attachments are enabled.
  &quot;&quot;&quot;
  def file_attachments_enabled? do
    Config.feature_enabled?(:discord_file_attachments)
  end

  @doc &quot;&quot;&quot;
  Checks if message components are enabled.
  &quot;&quot;&quot;
  def message_components_enabled? do
    Config.feature_enabled?(:discord_message_components)
  end

  @doc &quot;&quot;&quot;
  Checks if thread creation is enabled.
  &quot;&quot;&quot;
  def thread_creation_enabled? do
    Config.feature_enabled?(:discord_thread_creation)
  end

  @doc &quot;&quot;&quot;
  Checks if reactions are enabled.
  &quot;&quot;&quot;
  def reactions_enabled? do
    Config.feature_enabled?(:discord_reactions)
  end

  @doc &quot;&quot;&quot;
  Checks if message editing is enabled.
  &quot;&quot;&quot;
  def message_editing_enabled? do
    Config.feature_enabled?(:discord_message_editing)
  end

  @doc &quot;&quot;&quot;
  Checks if message deletion is enabled.
  &quot;&quot;&quot;
  def message_deletion_enabled? do
    Config.feature_enabled?(:discord_message_deletion)
  end
end</file><file path="lib/wanderer_notifier/notifiers/discord/neo_client.ex">defmodule WandererNotifier.Notifiers.Discord.NeoClient do
  @moduledoc &quot;&quot;&quot;
  Nostrum-based Discord client implementation.
  Leverages the Nostrum library for interaction with Discord API and event handling.
  &quot;&quot;&quot;
  use Nostrum.Consumer

  alias Nostrum.Api.Message
  alias Nostrum.Struct.Embed
  alias WandererNotifier.Config
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # -- ENVIRONMENT AND CONFIGURATION HELPERS --

  defp env do
    Application.get_env(:wanderer_notifier, :env, :prod)
  end

  @doc &quot;&quot;&quot;
  Gets the configured Discord channel ID as an integer.
  &quot;&quot;&quot;
  def channel_id do
    normalize_channel_id(Config.discord_channel_id())
  end

  # -- MESSAGING API --

  @doc &quot;&quot;&quot;
  Sends an embed message to Discord using Nostrum.

  ## Parameters
    - embed: A map containing the embed data
    - override_channel_id: Optional channel ID to override the default

  ## Returns
    - :ok on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_embed(embed, override_channel_id \\ nil) do
    if env() == :test do
      log_test_embed(embed)
    else
      target_channel = resolve_target_channel(override_channel_id)
      send_embed_to_channel(embed, target_channel)
    end
  end

  # Log test mode embed without sending
  defp log_test_embed(embed) do
    AppLogger.api_info(&quot;TEST MODE: Would send embed to Discord via Nostrum&quot;,
      embed: inspect(embed)
    )

    :ok
  end

  # Resolve the target channel ID
  defp resolve_target_channel(override_channel_id) do
    if is_nil(override_channel_id) do
      channel_id()
    else
      normalize_channel_id(override_channel_id)
    end
  end

  # Send embed to the specified channel
  defp send_embed_to_channel(embed, nil) do
    AppLogger.api_error(&quot;Failed to send embed: nil channel ID&quot;, embed: inspect(embed))
    {:error, :nil_channel_id}
  end

  defp send_embed_to_channel(embed, target_channel) do
    # Convert to Nostrum.Struct.Embed
    discord_embed = convert_to_nostrum_embed(embed)
    # Use Nostrum.Api.Message.create with embeds (plural) as an array
    case Message.create(target_channel, embeds: [discord_embed]) do
      {:ok, _message} -&gt;
        :ok

      {:error, %{status_code: 429, response: response}} -&gt;
        retry_after = get_retry_after(response)
        AppLogger.api_error(&quot;Discord rate limit hit via Nostrum&quot;, retry_after: retry_after)
        {:error, {:rate_limited, retry_after}}

      {:error, error} -&gt;
        AppLogger.api_error(&quot;Failed to send embed via Nostrum&quot;, error: inspect(error))
        {:error, error}
    end
  end

  @doc &quot;&quot;&quot;
  Sends a message with components to Discord using Nostrum.

  ## Parameters
    - embed: A map containing the embed data
    - components: A list of component rows (buttons, select menus, etc.)
    - override_channel_id: Optional channel ID to override the default

  ## Returns
    - :ok on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_message_with_components(embed, components, override_channel_id \\ nil) do
    if env() == :test do
      log_test_message_with_components(embed, components)
    else
      target_channel = resolve_target_channel(override_channel_id)
      send_message_with_components_to_channel(embed, components, target_channel)
    end
  end

  # Log test mode message with components without sending
  defp log_test_message_with_components(embed, components) do
    AppLogger.api_info(&quot;TEST MODE: Would send message with components via Nostrum&quot;,
      embed: inspect(embed),
      components: inspect(components)
    )

    :ok
  end

  # Send message with components to the specified channel
  defp send_message_with_components_to_channel(_embed, _components, nil) do
    AppLogger.api_error(&quot;Failed to send message with components: nil channel ID&quot;)
    {:error, :nil_channel_id}
  end

  defp send_message_with_components_to_channel(embed, components, target_channel) do
    # Convert to Nostrum structs
    discord_embed = convert_to_nostrum_embed(embed)
    discord_components = components
    # Log detailed info about what we&apos;re sending
    AppLogger.api_debug(&quot;Sending message with components via Nostrum&quot;,
      channel_id: target_channel,
      embed_type: typeof(discord_embed)
    )

    case Message.create(target_channel,
           embeds: [discord_embed],
           components: discord_components
         ) do
      {:ok, _message} -&gt;
        :ok

      {:error, %{status_code: 429, response: response}} -&gt;
        retry_after = get_retry_after(response)
        AppLogger.api_error(&quot;Discord rate limit hit via Nostrum&quot;, retry_after: retry_after)
        {:error, {:rate_limited, retry_after}}

      {:error, error} -&gt;
        AppLogger.api_error(&quot;Failed to send message with components via Nostrum&quot;,
          error: inspect(error)
        )

        {:error, error}
    end
  end

  @doc &quot;&quot;&quot;
  Sends a simple text message to Discord using Nostrum.

  ## Parameters
    - message: The text message to send
    - override_channel_id: Optional channel ID to override the default

  ## Returns
    - :ok on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_message(message, override_channel_id \\ nil) do
    if env() == :test do
      log_test_message(message)
    else
      target_channel = resolve_target_channel(override_channel_id)
      send_message_to_channel(message, target_channel)
    end
  end

  # Log test mode message without sending
  defp log_test_message(message) do
    AppLogger.api_info(&quot;TEST MODE: Would send message via Nostrum&quot;, message: message)
    :ok
  end

  # Send message to the specified channel
  defp send_message_to_channel(_message, nil) do
    AppLogger.api_error(&quot;Failed to send message: nil channel ID&quot;)
    {:error, :nil_channel_id}
  end

  defp send_message_to_channel(message, target_channel) do
    AppLogger.api_debug(&quot;Sending text message via Nostrum&quot;,
      channel_id: target_channel,
      message_length: String.length(message)
    )

    case Message.create(target_channel, content: message) do
      {:ok, _message} -&gt;
        :ok

      {:error, %{status_code: 429, response: response}} -&gt;
        retry_after = get_retry_after(response)
        AppLogger.api_error(&quot;Discord rate limit hit via Nostrum&quot;, retry_after: retry_after)
        {:error, {:rate_limited, retry_after}}

      {:error, error} -&gt;
        AppLogger.api_error(&quot;Failed to send message via Nostrum&quot;, error: inspect(error))
        {:error, error}
    end
  end

  # -- FILE HANDLING --

  @doc &quot;&quot;&quot;
  Sends a file to Discord with an optional title and description using Nostrum.

  ## Parameters
    - filename: The name of the file to send
    - file_data: The binary content of the file
    - title: The title for the Discord embed (optional)
    - description: The description for the Discord embed (optional)
    - override_channel_id: Optional channel ID to override the default
    - custom_embed: A custom embed to use instead of the default one (optional)

  ## Returns
    - :ok on success
    - {:error, reason} on failure
  &quot;&quot;&quot;
  def send_file(
        filename,
        file_data,
        title \\ nil,
        description \\ nil,
        override_channel_id \\ nil,
        custom_embed \\ nil
      ) do
    AppLogger.api_info(&quot;Sending file to Discord via Nostrum&quot;, filename: filename)

    if env() == :test do
      log_test_file(filename, title, description)
    else
      target_channel = resolve_target_channel(override_channel_id)
      send_file_to_channel(filename, file_data, title, description, target_channel, custom_embed)
    end
  end

  # Log test mode file without sending
  defp log_test_file(filename, title, description) do
    AppLogger.api_info(&quot;TEST MODE: Would send file to Discord via Nostrum&quot;,
      filename: filename,
      title: title,
      description: description
    )

    :ok
  end

  # Send file to the specified channel
  defp send_file_to_channel(_filename, _file_data, _title, _description, nil, _custom_embed) do
    AppLogger.api_error(&quot;Failed to send file: nil channel ID&quot;)
    {:error, :nil_channel_id}
  end

  defp send_file_to_channel(filename, file_data, title, description, target_channel, custom_embed) do
    # Create the embed (use custom if provided, otherwise create default)
    embed = create_file_embed(filename, title, description, custom_embed)

    AppLogger.api_debug(&quot;Sending file with embed via Nostrum&quot;,
      channel_id: target_channel,
      filename: filename,
      embed: inspect(embed)
    )

    case Message.create(target_channel,
           file: %{name: filename, body: file_data},
           embeds: [embed]
         ) do
      {:ok, _message} -&gt;
        :ok

      {:error, %{status_code: 429, response: response}} -&gt;
        retry_after = get_retry_after(response)
        AppLogger.api_error(&quot;Discord rate limit hit via Nostrum&quot;, retry_after: retry_after)
        {:error, {:rate_limited, retry_after}}

      {:error, error} -&gt;
        AppLogger.api_error(&quot;Failed to send file via Nostrum&quot;, error: inspect(error))
        {:error, error}
    end
  end

  # Create embed for file upload
  defp create_file_embed(filename, title, description, custom_embed) do
    if custom_embed do
      embed = convert_to_nostrum_embed(custom_embed)
      %{embed | image: %{url: &quot;attachment://#{filename}&quot;}}
    else
      %Embed{
        title: title,
        description: description,
        timestamp: DateTime.utc_now(),
        color: 3_447_003,
        image: %{url: &quot;attachment://#{filename}&quot;}
      }
    end
  end

  # -- EVENT HANDLING --

  @doc &quot;&quot;&quot;
  Handle interaction events from Discord.
  This allows responding to button clicks, select menu choices, etc.
  &quot;&quot;&quot;
  @impl true
  def handle_event({:INTERACTION_CREATE, interaction, _ws_state}) do
    AppLogger.api_info(&quot;Received Discord interaction&quot;,
      type: interaction.type,
      guild_id: interaction.guild_id,
      channel_id: interaction.channel_id
    )

    :noop
  end

  @impl true
  def handle_event(_event) do
    :noop
  end

  # -- HELPERS --

  defp normalize_channel_id(channel_id) do
    case channel_id do
      channel_id when is_binary(channel_id) -&gt; String.to_integer(channel_id)
      channel_id when is_integer(channel_id) -&gt; channel_id
      nil -&gt; nil
    end
  end

  defp typeof(term) when is_binary(term), do: &quot;string&quot;
  defp typeof(term) when is_boolean(term), do: &quot;boolean&quot;
  defp typeof(term) when is_integer(term), do: &quot;integer&quot;
  defp typeof(term) when is_float(term), do: &quot;float&quot;
  defp typeof(term) when is_map(term), do: &quot;map&quot;
  defp typeof(term) when is_list(term), do: &quot;list&quot;
  defp typeof(term) when is_atom(term), do: &quot;atom&quot;
  defp typeof(term) when is_tuple(term), do: &quot;tuple&quot;
  defp typeof(term) when is_function(term), do: &quot;function&quot;
  defp typeof(term) when is_pid(term), do: &quot;pid&quot;
  defp typeof(term) when is_reference(term), do: &quot;reference&quot;
  defp typeof(term) when is_struct(term), do: &quot;struct:#{term.__struct__}&quot;
  defp typeof(_), do: &quot;unknown&quot;

  defp convert_to_nostrum_embed(embed) when is_map(embed) do
    %Embed{
      title: get_field_with_fallback(embed, :title, &quot;title&quot;),
      description: get_field_with_fallback(embed, :description, &quot;description&quot;),
      url: get_field_with_fallback(embed, :url, &quot;url&quot;),
      timestamp: get_field_with_fallback(embed, :timestamp, &quot;timestamp&quot;),
      color: get_field_with_fallback(embed, :color, &quot;color&quot;),
      footer: extract_footer(embed),
      image: extract_image(embed),
      thumbnail: get_thumbnail_with_fallback(embed),
      author: extract_author(embed),
      fields: extract_fields(embed)
    }
  end

  # Extract fields from the embed
  defp extract_fields(embed) do
    Map.get(embed, &quot;fields&quot;, [])
    |&gt; Enum.map(fn field -&gt;
      %Embed.Field{
        name: Map.get(field, &quot;name&quot;, &quot;&quot;),
        value: Map.get(field, &quot;value&quot;, &quot;&quot;),
        inline: Map.get(field, &quot;inline&quot;, false)
      }
    end)
  end

  # Extract footer from the embed
  defp extract_footer(embed) do
    case get_field_with_fallback(embed, :footer, &quot;footer&quot;) do
      nil -&gt; nil
      footer_map when is_map(footer_map) -&gt; build_footer(footer_map)
    end
  end

  # Build a footer struct from a map
  defp build_footer(footer_map) do
    %Embed.Footer{
      text: get_field_with_fallback(footer_map, :text, &quot;text&quot;, &quot;&quot;),
      icon_url: get_field_with_fallback(footer_map, :icon_url, &quot;icon_url&quot;)
    }
  end

  # Extract author from the embed
  defp extract_author(embed) do
    case Map.get(embed, &quot;author&quot;) do
      nil -&gt; nil
      author_map when is_map(author_map) -&gt; build_author(author_map)
    end
  end

  # Build an author struct from a map
  defp build_author(author_map) do
    %Embed.Author{
      name: get_field_with_fallback(author_map, :name, &quot;name&quot;, &quot;&quot;),
      url: get_field_with_fallback(author_map, :url, &quot;url&quot;),
      icon_url: get_field_with_fallback(author_map, :icon_url, &quot;icon_url&quot;)
    }
  end

  # Get a field with fallback from atom or string keys
  defp get_field_with_fallback(map, atom_key, string_key, default \\ nil) do
    cond do
      Map.has_key?(map, atom_key) -&gt; Map.get(map, atom_key)
      Map.has_key?(map, string_key) -&gt; Map.get(map, string_key)
      true -&gt; default
    end
  end

  # Apply system notification thumbnail fallback if needed
  defp get_thumbnail_with_fallback(embed) do
    thumbnail = extract_thumbnail(embed)
    # If this is a sun type notification with no thumbnail, use a hardcoded URL
    if is_nil(thumbnail) &amp;&amp; Map.get(embed, &quot;title&quot;, &quot;&quot;) =~ &quot;System Notification&quot; do
      %Embed.Thumbnail{url: &quot;https://images.evetech.net/types/45041/icon?size=64&quot;}
    else
      thumbnail
    end
  end

  # Extract thumbnail from the embed
  defp extract_thumbnail(embed) do
    thumbnail = Map.get(embed, &quot;thumbnail&quot;)
    # Try different formats in order of likelihood
    cond do
      valid_thumbnail = extract_thumbnail_from_map(thumbnail) -&gt;
        valid_thumbnail

      valid_url = extract_valid_url(thumbnail) -&gt;
        %Embed.Thumbnail{url: valid_url}

      valid_url = extract_valid_url(Map.get(embed, &quot;thumbnail_url&quot;)) -&gt;
        %Embed.Thumbnail{url: valid_url}

      valid_url = extract_valid_url(Map.get(embed, &quot;icon_url&quot;)) -&gt;
        %Embed.Thumbnail{url: valid_url}

      true -&gt;
        extract_thumbnail_from_icon_field(embed)
    end
  end

  # Extract thumbnail from a map with url key
  defp extract_thumbnail_from_map(thumbnail) when is_map(thumbnail) do
    cond do
      valid_url = extract_valid_url(Map.get(thumbnail, :url)) -&gt;
        %Embed.Thumbnail{url: valid_url}

      valid_url = extract_valid_url(Map.get(thumbnail, &quot;url&quot;)) -&gt;
        %Embed.Thumbnail{url: valid_url}

      true -&gt;
        nil
    end
  end

  defp extract_thumbnail_from_map(_), do: nil

  # Check for icon field and extract thumbnail
  defp extract_thumbnail_from_icon_field(embed) do
    if Map.has_key?(embed, &quot;icon&quot;) do
      icon = Map.get(embed, &quot;icon&quot;)

      if is_map(icon) &amp;&amp; Map.has_key?(icon, &quot;url&quot;) do
        %Embed.Thumbnail{url: icon[&quot;url&quot;]}
      else
        nil
      end
    else
      nil
    end
  end

  # Validate URL is not empty
  defp extract_valid_url(url) when is_binary(url) do
    trimmed = String.trim(url)
    if trimmed != &quot;&quot;, do: trimmed, else: nil
  end

  defp extract_valid_url(_), do: nil

  # Extract image from embed
  defp extract_image(embed) do
    image = get_field_with_fallback(embed, :image, &quot;image&quot;)

    case extract_image_from_map(image) do
      {:ok, url} -&gt;
        %Embed.Image{url: url}

      {:error, _} -&gt;
        cond do
          valid_url = extract_valid_url(image) -&gt;
            %Embed.Image{url: valid_url}

          valid_url = extract_valid_url(get_field_with_fallback(embed, :image_url, &quot;image_url&quot;)) -&gt;
            %Embed.Image{url: valid_url}

          true -&gt;
            nil
        end
    end
  end

  # Extract image data from a map structure
  defp extract_image_from_map(data) when is_map(data) do
    if Map.has_key?(data, &quot;image&quot;) and is_map(data[&quot;image&quot;]) and
         Map.has_key?(data[&quot;image&quot;], &quot;url&quot;) do
      {:ok, data[&quot;image&quot;][&quot;url&quot;]}
    else
      {:error, &quot;No image URL found in map&quot;}
    end
  end

  defp extract_image_from_map(_), do: {:error, &quot;Data is not a map&quot;}

  defp get_retry_after(%{&quot;retry_after&quot; =&gt; retry_after}) when is_number(retry_after) do
    round(retry_after * 1000)
  end

  defp get_retry_after(%{&quot;retry_after&quot; =&gt; retry_after}) when is_binary(retry_after) do
    case Float.parse(retry_after) do
      {value, _} -&gt; round(value * 1000)
      :error -&gt; 5000
    end
  end

  defp get_retry_after(_) do
    5000
  end
end</file><file path="lib/wanderer_notifier/notifiers/discord/notifier.ex">defmodule WandererNotifier.Notifiers.Discord.Notifier do
  @moduledoc &quot;&quot;&quot;
  Discord notification service.
  Handles sending notifications to Discord using the Nostrum client.
  &quot;&quot;&quot;
  require Logger
  alias WandererNotifier.ESI.Service, as: ESIService
  alias WandererNotifier.Core.Stats
  alias WandererNotifier.Killmail.Killmail
  alias WandererNotifier.Map.MapSystem
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Notifications.Determiner.Character, as: CharacterDeterminer
  alias WandererNotifier.Notifiers.Discord.ComponentBuilder
  alias WandererNotifier.Notifiers.Discord.FeatureFlags
  alias WandererNotifier.Notifiers.Discord.NeoClient
  alias WandererNotifier.Notifiers.Formatters.Structured, as: StructuredFormatter

  # Default embed colors
  @default_embed_color 0x3498DB

  # -- ENVIRONMENT AND CONFIGURATION HELPERS --

  defp env, do: Application.get_env(:wanderer_notifier, :env)

  # Helper function to handle test mode logging and response
  defp handle_test_mode(log_message) do
    # Always log in test mode for test assertions
    Logger.info(log_message)
    :ok
  end

  # -- MESSAGE SENDING --

  def send_message(message, _feature \\ nil) do
    AppLogger.processor_info(&quot;Discord message requested&quot;)

    if env() == :test do
      handle_test_mode(&quot;DISCORD MOCK: #{inspect(message)}&quot;)
    else
      case message do
        msg when is_binary(msg) -&gt;
          AppLogger.processor_info(&quot;Sending Discord message&quot;,
            client: &quot;Nostrum&quot;,
            message_length: String.length(msg)
          )

          NeoClient.send_message(msg)

        embed when is_map(embed) -&gt;
          AppLogger.processor_info(&quot;Sending Discord embed&quot;,
            client: &quot;Nostrum&quot;,
            title: Map.get(embed, :title) || Map.get(embed, &quot;title&quot;),
            description: Map.get(embed, :description) || Map.get(embed, &quot;description&quot;)
          )

          NeoClient.send_embed(embed)

        _ -&gt;
          AppLogger.processor_error(&quot;Unknown message type for Discord notification&quot;,
            type: inspect(message)
          )

          {:error, :invalid_message_type}
      end
    end
  end

  def send_embed(title, description, url \\ nil, color \\ @default_embed_color, _feature \\ nil) do
    AppLogger.processor_info(&quot;Discord embed requested&quot;,
      title: title,
      url: url || &quot;nil&quot;
    )

    if env() == :test do
      handle_test_mode(&quot;DISCORD MOCK: #{title} - #{description}&quot;)
    else
      # Build embed payload
      embed = build_embed_payload(title, description, url, color)

      # For Nostrum, we just need the embed object from the payload
      discord_embed = embed[&quot;embeds&quot;] |&gt; List.first()
      NeoClient.send_embed(discord_embed)
    end
  end

  defp build_embed_payload(title, description, url, color) do
    embed = %{
      &quot;title&quot; =&gt; title,
      &quot;description&quot; =&gt; description,
      &quot;color&quot; =&gt; color
    }

    # Add URL if provided
    embed =
      if url do
        Map.put(embed, &quot;url&quot;, url)
      else
        embed
      end

    # Return final payload with embed
    %{&quot;embeds&quot; =&gt; [embed]}
  end

  def send_file(filename, file_data, title \\ nil, description \\ nil, _feature \\ nil) do
    AppLogger.processor_info(&quot;Sending file to Discord&quot;,
      filename: filename,
      title: title
    )

    if env() == :test do
      handle_test_mode(&quot;DISCORD MOCK: #{filename} - #{title || &quot;No title&quot;}&quot;)
    else
      NeoClient.send_file(filename, file_data, title, description)
    end
  end

  def send_image_embed(
        title,
        description,
        image_url,
        color \\ @default_embed_color,
        _feature \\ nil
      ) do
    AppLogger.processor_info(&quot;Sending image embed to Discord&quot;,
      title: title,
      image_url: image_url || &quot;nil&quot;
    )

    if env() == :test do
      handle_test_mode(&quot;DISCORD MOCK: #{title} - #{description} with image: #{image_url}&quot;)
    else
      embed = %{
        &quot;title&quot; =&gt; title,
        &quot;description&quot; =&gt; description,
        &quot;color&quot; =&gt; color,
        &quot;image&quot; =&gt; %{
          &quot;url&quot; =&gt; image_url
        }
      }

      AppLogger.processor_info(&quot;Discord image embed payload built, sending to Discord API&quot;)
      NeoClient.send_embed(embed)
    end
  end

  def send_enriched_kill_embed(killmail, kill_id) when is_struct(killmail, Killmail) do
    AppLogger.processor_debug(&quot;Preparing to format killmail for Discord&quot;, kill_id: kill_id)

    # Ensure the killmail has a system name if system_id is present
    enriched_killmail = enrich_with_system_name(killmail)

    # Format the kill notification
    formatted_embed = StructuredFormatter.format_kill_notification(enriched_killmail)

    # Only add components if the feature flag is enabled
    enhanced_notification =
      if FeatureFlags.components_enabled?() do
        # Add interactive components based on the killmail
        components = [ComponentBuilder.kill_action_row(kill_id)]

        AppLogger.processor_debug(&quot;Adding interactive components to kill notification&quot;,
          kill_id: kill_id
        )

        # Add components to the notification
        Map.put(formatted_embed, :components, components)
      else
        # Use standard format without components
        AppLogger.processor_debug(
          &quot;Using standard embed format for kill notification (components disabled)&quot;,
          kill_id: kill_id
        )

        formatted_embed
      end

    send_to_discord(enhanced_notification, &quot;kill&quot;)
  end

  def send_kill_notification(kill_data) do
    # Log the received kill data for debugging
    AppLogger.processor_debug(&quot;Kill notification received&quot;,
      data_type: typeof(kill_data)
    )

    # Ensure we have a Killmail struct
    killmail =
      if is_struct(kill_data, Killmail),
        do: kill_data,
        else: struct(Killmail, Map.from_struct(kill_data))

    # Delegate to the enriched killmail notification function
    send_killmail_notification(killmail)
  end

  def send_new_tracked_character_notification(character)
      when is_struct(character, WandererNotifier.Map.MapCharacter) do
    if env() == :test do
      handle_test_mode(&quot;DISCORD MOCK: Character ID #{character.character_id}&quot;)
    else
      # Extract character ID for deduplication check
      character_id = character.character_id

      # Check if this character should trigger a notification
      if CharacterDeterminer.should_notify?(character_id, character) do
        # This is not a duplicate, proceed with notification
        AppLogger.processor_info(&quot;Processing new character notification&quot;,
          character_name: character.name,
          character_id: character.character_id
        )

        # Create notification with StructuredFormatter
        generic_notification = StructuredFormatter.format_character_notification(character)
        send_to_discord(generic_notification, :character_tracking)

        # Record stats
        Stats.increment(:characters)
      else
        # This is a duplicate or doesn&apos;t meet criteria, skip notification
        AppLogger.processor_debug(&quot;Skipping character notification&quot;,
          character_name: character.name,
          character_id: character.character_id
        )

        :ok
      end
    end
  end

  def send_new_system_notification(system) do
    AppLogger.processor_info(
      &quot;[NEW_SYSTEM_NOTIFICATION] Processing system notification request (detailed)&quot;,
      system_type: typeof(system),
      system_preview: inspect(system, pretty: true, limit: 1000)
    )

    try do
      system_id = extract_system_id(system)
      system_name = extract_system_name(system)
      AppLogger.processor_info(
        &quot;[NEW_SYSTEM_NOTIFICATION] Extracted system details (detailed)&quot;,
        system_id: system_id,
        system_name: system_name,
        system_struct: inspect(system, pretty: true, limit: 1000)
      )

      # Assume system is already enriched; do not enrich here
      enriched_system = system
      AppLogger.processor_info(&quot;[NEW_SYSTEM_NOTIFICATION] MapSystem struct (detailed)&quot;, enriched_system: inspect(enriched_system, pretty: true, limit: 1000))

      generic_notification = StructuredFormatter.format_system_notification(enriched_system)
      AppLogger.processor_info(&quot;[NEW_SYSTEM_NOTIFICATION] Formatted notification payload&quot;, payload: inspect(generic_notification, pretty: true, limit: 1000))

      send_to_discord(generic_notification, :system_tracking)
      Stats.increment(:systems)
      {:ok, :sent}
    rescue
      e -&gt;
        AppLogger.processor_error(&quot;[NEW_SYSTEM_NOTIFICATION] Exception in send_new_system_notification (detailed)&quot;,
          error: Exception.message(e),
          system: inspect(system, pretty: true, limit: 1000),
          stacktrace: Exception.format_stacktrace(__STACKTRACE__)
        )
        {:error, e}
    end
  end

  def send_notification(type, data) do
    case type do
      :send_discord_embed -&gt;
        [embed] = data
        NeoClient.send_embed(embed, nil)

      :send_discord_embed_to_channel -&gt;
        [channel_id, embed] = data
        NeoClient.send_embed(embed, channel_id)

      :send_message -&gt;
        [message] = data
        send_message(message)

      _ -&gt;
        AppLogger.processor_warn(&quot;Unknown notification type&quot;, type: type)
        {:error, :unknown_notification_type}
    end
  end

  # -- PRIVATE HELPERS --

  # Helper to determine type of value for logging
  defp typeof(term) when is_binary(term), do: &quot;string&quot;
  defp typeof(term) when is_boolean(term), do: &quot;boolean&quot;
  defp typeof(term) when is_integer(term), do: &quot;integer&quot;
  defp typeof(term) when is_float(term), do: &quot;float&quot;
  defp typeof(term) when is_map(term), do: &quot;map&quot;
  defp typeof(term) when is_list(term), do: &quot;list&quot;
  defp typeof(term) when is_atom(term), do: &quot;atom&quot;
  defp typeof(term) when is_tuple(term), do: &quot;tuple&quot;
  defp typeof(term) when is_function(term), do: &quot;function&quot;
  defp typeof(term) when is_pid(term), do: &quot;pid&quot;
  defp typeof(term) when is_reference(term), do: &quot;reference&quot;
  defp typeof(term) when is_struct(term), do: &quot;struct:#{term.__struct__}&quot;
  defp typeof(_), do: &quot;unknown&quot;

  # Send formatted notification to Discord
  defp send_to_discord(formatted_notification, feature) do
    # Skip actual sending in test mode
    if env() == :test do
      handle_test_mode(&quot;DISCORD MOCK: #{inspect(feature)}&quot;)
    else
      # Convert to Discord format
      discord_embed = StructuredFormatter.to_discord_format(formatted_notification)

      # Check if components are available
      components = Map.get(formatted_notification, :components, [])
      use_components = components != [] &amp;&amp; FeatureFlags.components_enabled?()

      if use_components do
        # If components are enabled, use enhanced format
        AppLogger.processor_info(&quot;Using Discord components for #{feature} notification&quot;)
        NeoClient.send_message_with_components(discord_embed, components, nil)
      else
        # Otherwise use standard embed
        AppLogger.processor_info(&quot;Using standard embeds for #{feature} notification&quot;)
        NeoClient.send_embed(discord_embed, nil)
      end
    end
  end

  # Ensure the killmail has a system name if missing
  defp enrich_with_system_name(%Killmail{} = killmail) do
    # Get system_id from the esi_data
    system_id = get_system_id_from_killmail(killmail)

    # Check if we need to get the system name
    if system_id do
      # Get system name using the same approach as in kill_processor
      system_name = get_system_name(system_id)

      AppLogger.processor_debug(&quot;Enriching killmail with system name&quot;,
        system_id: system_id,
        system_name: system_name
      )

      # Add system name to esi_data
      new_esi_data = Map.put(killmail.esi_data || %{}, &quot;solar_system_name&quot;, system_name)
      %{killmail | esi_data: new_esi_data}
    else
      killmail
    end
  end

  # Get system ID from killmail
  defp get_system_id_from_killmail(%Killmail{} = killmail) do
    if killmail.esi_data do
      Map.get(killmail.esi_data, &quot;solar_system_id&quot;)
    else
      nil
    end
  end

  # Helper function to get system name with caching
  defp get_system_name(nil), do: nil

  defp get_system_name(system_id) do
    case ESIService.get_system_info(system_id) do
      {:ok, system_info} -&gt; Map.get(system_info, &quot;name&quot;)
      {:error, :not_found} -&gt; &quot;Unknown-#{system_id}&quot;
      _ -&gt; nil
    end
  end

  # Send killmail notification
  defp send_killmail_notification(killmail) do
    if env() == :test do
      handle_test_mode(&quot;DISCORD MOCK: Killmail ID #{killmail.killmail_id}&quot;)
    else
      # Create notification with StructuredFormatter
      AppLogger.processor_info(&quot;Formatting killmail notification&quot;)
      notification = StructuredFormatter.format_kill_notification(killmail)

      # Send notification
      send_to_discord(notification, :killmail)
    end
  end

  # Extract system ID from killmail
  defp extract_system_id(%MapSystem{solar_system_id: id}) when not is_nil(id), do: id

  defp extract_system_id(_), do: nil

  # Extract system name from system data
  defp extract_system_name(system) do
    extract_field_value(system, [:name, &quot;name&quot;], &quot;Unknown System&quot;)
  end

  # Helper to extract a field with a default value
  defp extract_field_value(system, field_names, default) do
    Enum.find_value(field_names, default, fn field -&gt;
      cond do
        is_struct(system) &amp;&amp; Map.has_key?(system, field) -&gt; Map.get(system, field)
        is_map(system) &amp;&amp; Map.has_key?(system, field) -&gt; Map.get(system, field)
        true -&gt; nil
      end
    end)
  end
end</file><file path="lib/wanderer_notifier/notifiers/formatters/structured.ex">defmodule WandererNotifier.Notifiers.Formatters.Structured do
  @moduledoc &quot;&quot;&quot;
  Structured notification formatting utilities for Discord notifications.

  This module provides standardized formatting specifically designed to work with
  the domain data structures like Character, MapSystem, and Killmail.
  It eliminates the complex extraction logic of the original formatter by relying
  on the structured data provided by these schemas.
  &quot;&quot;&quot;

  alias WandererNotifier.Map.MapCharacter
  alias WandererNotifier.Killmail.Killmail
  alias WandererNotifier.Map.MapSystem
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Cache.{CachexImpl, Keys}
  alias WandererNotifier.Notifiers.Discord.Constants

  # Get colors from Constants
  defp colors, do: Constants.colors()

  @doc &quot;&quot;&quot;
  Creates a standard formatted kill notification embed/attachment from a Killmail struct.
  Returns data in a generic format that can be converted to platform-specific format.

  ## Parameters
    - killmail: The Killmail struct

  ## Returns
    - A generic structured map that can be converted to platform-specific format
  &quot;&quot;&quot;
  def format_kill_notification(%Killmail{} = killmail) do
    # Log the structure of the killmail for debugging
    log_killmail_data(killmail)

    # Extract basic kill information
    kill_id = killmail.killmail_id
    kill_time = Map.get(killmail.esi_data || %{}, &quot;killmail_time&quot;)

    # Extract victim information
    victim_info = extract_victim_info(killmail)

    # Extract system, value and attackers info
    kill_context = extract_kill_context(killmail)

    # Final blow details
    final_blow_details = get_final_blow_details(killmail)

    # Build notification fields
    fields = build_kill_notification_fields(killmail, kill_context)

    # Build a platform-agnostic structure
    build_kill_notification(
      kill_id,
      kill_time,
      victim_info,
      kill_context,
      final_blow_details,
      fields
    )
  end

  @doc &quot;&quot;&quot;
  Creates a standard formatted character notification embed/attachment from a Character struct.
  Returns data in a generic format that can be converted to platform-specific format.

  ## Parameters
    - character: The Character struct

  ## Returns
    - A generic structured map that can be converted to platform-specific format
  &quot;&quot;&quot;
  def format_character_notification(%MapCharacter{} = character) do
    # Log the character data for debugging
    log_character_data(character)

    # Extract basic character information
    character_info = extract_character_info(character)

    # Build notification fields
    fields = build_character_notification_fields(character_info)

    # Build a platform-agnostic structure
    build_character_notification(character_info, fields)
  end

  @doc &quot;&quot;&quot;
  Creates a standard formatted system notification embed/attachment from a MapSystem struct.
  Returns data in a generic format that can be converted to platform-specific format.

  ## Parameters
    - system: The MapSystem struct

  ## Returns
    - A generic structured map that can be converted to platform-specific format
  &quot;&quot;&quot;
  def format_system_notification(%MapSystem{} = system) do
    # Log the system data for debugging
    log_system_data(system)

    # Extract basic system information
    system_info = extract_system_info(system)

    # Build notification fields
    fields = build_system_notification_fields(system_info)

    # Build a platform-agnostic structure
    build_system_notification(system_info, fields)
  end

  @doc &quot;&quot;&quot;
  Formats a character kill notification into a generic format.
  &quot;&quot;&quot;
  def format_character_kill_notification(killmail, character_id, character_name) do
    %{
      title: &quot;Character Kill Report: #{character_name}&quot;,
      description: build_character_kill_description(killmail, character_id),
      url: &quot;https://zkillboard.com/kill/#{killmail.killmail_id}/&quot;,
      color: Constants.colors().info,
      fields: build_character_kill_fields(killmail, character_id)
    }
  end

  @doc &quot;&quot;&quot;
  Formats a system activity notification into a generic format.
  &quot;&quot;&quot;
  def format_system_activity_notification(system, activity_data) do
    %{
      title: &quot;System Activity Update: #{system.name}&quot;,
      description: build_system_activity_description(activity_data),
      color: Constants.colors().warning,
      fields: build_system_activity_fields(activity_data)
    }
  end

  @doc &quot;&quot;&quot;
  Formats a character activity notification into a generic format.
  &quot;&quot;&quot;
  def format_character_activity_notification(character, activity_data) do
    %{
      title: &quot;Character Activity Update: #{character.name}&quot;,
      description: build_character_activity_description(activity_data),
      color: Constants.colors().info,
      fields: build_character_activity_fields(activity_data)
    }
  end

  @doc &quot;&quot;&quot;
  Converts a generic notification to Discord format.
  &quot;&quot;&quot;
  def to_discord_format(generic_notification) do
    color = Map.get(generic_notification, :color, Constants.colors().default)

    %{
      title: generic_notification.title,
      description: generic_notification.description,
      url: Map.get(generic_notification, :url),
      color: color,
      fields: Map.get(generic_notification, :fields, []),
      footer: Map.get(generic_notification, :footer),
      thumbnail: Map.get(generic_notification, :thumbnail)
    }
  end

  # Private helper functions

  defp log_killmail_data(killmail) do
    AppLogger.processor_debug(
      &quot;[StructuredFormatter] Formatting killmail: #{inspect(killmail, limit: 200)}&quot;
    )
  end

  defp log_character_data(character) do
    AppLogger.processor_debug(
      &quot;[StructuredFormatter] Formatting character: #{inspect(character, limit: 200)}&quot;
    )
  end

  defp log_system_data(system) do
    AppLogger.processor_debug(
      &quot;[StructuredFormatter] Formatting system: #{inspect(system, limit: 200)}&quot;
    )
  end

  defp extract_victim_info(killmail) do
    victim = Killmail.get_victim(killmail) || %{}

    victim_name = killmail.victim_name || Map.get(victim, &quot;character_name&quot;, &quot;Unknown Pilot&quot;)
    victim_ship = killmail.ship_name || Map.get(victim, &quot;ship_type_name&quot;, &quot;Unknown Ship&quot;)
    victim_corp = killmail.victim_corporation || Map.get(victim, &quot;corporation_name&quot;, &quot;Unknown Corp&quot;)
    victim_alliance = killmail.victim_alliance || Map.get(victim, &quot;alliance_name&quot;)
    victim_ship_type_id = Map.get(victim, &quot;ship_type_id&quot;)
    victim_character_id = Map.get(victim, &quot;character_id&quot;)

    %{
      name: victim_name,
      ship: victim_ship,
      corp: victim_corp,
      alliance: victim_alliance,
      ship_type_id: victim_ship_type_id,
      character_id: victim_character_id
    }
  end

  defp extract_kill_context(killmail) do
    system_name = killmail.system_name || Map.get(killmail.esi_data || %{}, &quot;solar_system_name&quot;, &quot;Unknown System&quot;)
    system_id = killmail.system_id || Map.get(killmail.esi_data || %{}, &quot;solar_system_id&quot;)

    security_status = get_system_security_status(system_id)
    security_formatted = format_security_status(security_status)

    zkb = killmail.zkb || %{}
    kill_value = Map.get(zkb, &quot;totalValue&quot;, 0)
    formatted_value = format_isk_value(kill_value)

    attackers = Map.get(killmail.esi_data || %{}, &quot;attackers&quot;, [])
    attackers_count = length(attackers)

    %{
      system_name: system_name,
      system_id: system_id,
      security_status: security_status,
      security_formatted: security_formatted,
      formatted_value: formatted_value,
      attackers_count: attackers_count,
      is_npc_kill: Map.get(zkb, &quot;npc&quot;, false) == true
    }
  end

  defp get_system_security_status(system_id) when is_integer(system_id) do
    case CachexImpl.get(Keys.system_key(system_id)) do
      {:ok, system_data} -&gt; Map.get(system_data, &quot;security_status&quot;, 0.0)
      _ -&gt; 0.0
    end
  end

  defp get_system_security_status(_), do: 0.0

  defp extract_character_info(character) do
    %{
      name: character.name,
      character_id: character.character_id,
      corporation_name: character.corporation_name,
      alliance_name: character.alliance_name,
      security_status: character.security_status,
      last_location: character.last_location,
      ship_type: character.ship_type
    }
  end

  defp extract_system_info(system) do
    %{
      name: system.name,
      system_id: system.solar_system_id,
      region_name: system.region_name,
      security_status: system.security_status,
      class_title: system.class_title,
      effect_name: system.effect_name,
      is_shattered: system.is_shattered,
      statics: system.statics
    }
  end

  defp get_final_blow_details(killmail) do
    final_blow =
      (killmail.attackers || [])
      |&gt; Enum.find(&amp;(&amp;1[:final_blow] == true))

    case final_blow do
      nil -&gt;
        %{
          name: &quot;Unknown&quot;,
          ship: &quot;Unknown Ship&quot;,
          corp: &quot;Unknown Corp&quot;,
          alliance: nil,
          ship_type_id: nil,
          character_id: nil,
          weapon: &quot;Unknown Weapon&quot;
        }

      attacker -&gt;
        %{
          name: attacker[:character_name] || &quot;Unknown&quot;,
          ship: attacker[:ship_type_name] || &quot;Unknown Ship&quot;,
          corp: attacker[:corporation_name] || &quot;Unknown Corp&quot;,
          alliance: attacker[:alliance_name],
          ship_type_id: attacker[:ship_type_id],
          character_id: attacker[:character_id],
          weapon: attacker[:weapon_type_name] || &quot;Unknown Weapon&quot;
        }
    end
  end

  defp build_kill_notification_fields(_killmail, kill_context) do
    [
      %{
        name: &quot;System&quot;,
        value: &quot;#{kill_context.system_name} (#{kill_context.security_formatted})&quot;,
        inline: true
      },
      %{
        name: &quot;Attackers&quot;,
        value: &quot;#{kill_context.attackers_count}&quot;,
        inline: true
      },
      %{
        name: &quot;Value&quot;,
        value: kill_context.formatted_value,
        inline: true
      }
    ]
  end

  defp build_kill_notification(
         kill_id,
         kill_time,
         victim_info,
         kill_context,
         _final_blow_details,
         fields
       ) do
    %{
      title: &quot;Kill Report: #{victim_info.name}&quot;,
      description:
        &quot;#{victim_info.name} lost their #{victim_info.ship} in #{kill_context.system_name} (#{kill_context.security_formatted})&quot;,
      url: &quot;https://zkillboard.com/kill/#{kill_id}/&quot;,
      timestamp: kill_time,
      color: get_notification_color(kill_context.security_status),
      fields: fields,
      footer: %{
        text: &quot;Value: #{kill_context.formatted_value} ISK&quot;
      }
    }
  end

  defp build_character_notification_fields(character_info) do
    [
      %{
        name: &quot;Character&quot;,
        value: format_character_details(character_info),
        inline: true
      },
      %{
        name: &quot;Corporation&quot;,
        value: format_corporation_details(character_info),
        inline: true
      },
      %{
        name: &quot;Location&quot;,
        value: format_character_location(character_info),
        inline: true
      }
    ]
  end

  defp build_system_notification_fields(system_info) do
    [
      %{
        name: &quot;System&quot;,
        value: format_system_details(system_info),
        inline: true
      },
      %{
        name: &quot;Region&quot;,
        value: format_region_details(system_info),
        inline: true
      },
      %{
        name: &quot;Properties&quot;,
        value: format_system_properties(system_info),
        inline: true
      }
    ]
  end

  defp build_character_notification(character_info, fields) do
    title = &quot;New Character Tracked: #{character_info.name}&quot;
    description = &quot;A new character has been added to tracking&quot;

    color =
      case character_info.security_status do
        sec when is_number(sec) and sec &gt;= 5.0 -&gt; colors().highsec
        sec when is_number(sec) and sec &gt; 0.0 -&gt; colors().lowsec
        sec when is_number(sec) and sec &lt;= 0.0 -&gt; colors().nullsec
        _ -&gt; colors().default
      end

    %{
      title: title,
      description: description,
      url: &quot;https://zkillboard.com/character/#{character_info.character_id}/&quot;,
      color: color,
      fields: fields,
      footer: %{
        text: &quot;Character Tracking&quot;
      },
      thumbnail: %{
        url: get_character_image_url(character_info.character_id)
      }
    }
  end

  defp build_system_notification(system_info, fields) do
    title = &quot;New System Tracked: #{system_info.name}&quot;
    description = &quot;A new system has been added to tracking&quot;

    color =
      case system_info do
        %{class_title: class} when not is_nil(class) -&gt; colors().wormhole
        %{security_status: sec} when is_number(sec) and sec &gt;= 0.5 -&gt; colors().highsec
        %{security_status: sec} when is_number(sec) and sec &gt; 0.0 -&gt; colors().lowsec
        %{security_status: sec} when is_number(sec) and sec &lt;= 0.0 -&gt; colors().nullsec
        _ -&gt; colors().default
      end

    %{
      title: title,
      description: description,
      color: color,
      fields: fields,
      footer: %{
        text: &quot;System Tracking&quot;
      },
      thumbnail: %{
        url: get_system_image_url(system_info)
      }
    }
  end

  defp format_character_details(%{name: name, security_status: security}) do
    security_text = format_security_status(security)
    &quot;Name: #{name}\nSecurity: #{security_text}&quot;
  end

  defp format_corporation_details(%{corporation_name: corp, alliance_name: alliance}) do
    alliance_text = if alliance, do: &quot;\nAlliance: #{alliance}&quot;, else: &quot;&quot;
    &quot;Corporation: #{corp}#{alliance_text}&quot;
  end

  defp format_character_location(%{last_location: location, ship_type: ship}) do
    ship_text = if ship, do: &quot;\nShip: #{ship}&quot;, else: &quot;&quot;
    &quot;Location: #{location || &quot;Unknown&quot;}#{ship_text}&quot;
  end

  defp format_system_details(%{name: name, security_status: security, class_title: class}) do
    class_text = if class, do: &quot;\nClass: #{class}&quot;, else: &quot;&quot;
    &quot;Name: #{name}\nSecurity: #{format_security_status(security)}#{class_text}&quot;
  end

  defp format_region_details(%{region_name: region}) do
    &quot;Region: #{region || &quot;Unknown&quot;}&quot;
  end

  defp format_system_properties(%{effect_name: effect, is_shattered: shattered, statics: statics}) do
    effect_text = if effect, do: &quot;Effect: #{effect}\n&quot;, else: &quot;&quot;
    shattered_text = if shattered, do: &quot;Shattered System\n&quot;, else: &quot;&quot;
    statics_text = if statics, do: &quot;Statics: #{Enum.join(statics, &quot;, &quot;)}&quot;, else: &quot;&quot;

    &quot;#{effect_text}#{shattered_text}#{statics_text}&quot;
    |&gt; String.trim()
  end

  defp format_security_status(security_status) when is_float(security_status) do
    cond do
      security_status &gt;= 0.5 -&gt; &quot;High Sec&quot;
      security_status &gt; 0.0 -&gt; &quot;Low Sec&quot;
      true -&gt; &quot;Null Sec&quot;
    end
  end

  defp format_isk_value(value) when is_number(value) do
    cond do
      value &gt;= 1_000_000_000 -&gt; &quot;#{Float.round(value / 1_000_000_000, 1)}B&quot;
      value &gt;= 1_000_000 -&gt; &quot;#{Float.round(value / 1_000_000, 1)}M&quot;
      value &gt;= 1_000 -&gt; &quot;#{Float.round(value / 1_000, 1)}K&quot;
      true -&gt; &quot;#{Float.round(value, 0)}&quot;
    end
  end

  defp get_character_image_url(nil), do: &quot;https://images.evetech.net/characters/1/portrait&quot;

  defp get_character_image_url(character_id),
    do: &quot;https://images.evetech.net/characters/#{character_id}/portrait&quot;

  defp get_system_image_url(%{class_title: class}) when not is_nil(class),
    do: &quot;https://images.evetech.net/types/30881/render&quot;

  defp get_system_image_url(%{security_status: sec}) when is_number(sec) and sec &gt;= 0.5,
    do: &quot;https://images.evetech.net/types/30882/render&quot;

  defp get_system_image_url(%{security_status: sec}) when is_number(sec) and sec &gt; 0.0,
    do: &quot;https://images.evetech.net/types/30883/render&quot;

  defp get_system_image_url(%{security_status: sec}) when is_number(sec) and sec &lt;= 0.0,
    do: &quot;https://images.evetech.net/types/30884/render&quot;

  defp get_system_image_url(_), do: &quot;https://images.evetech.net/types/30885/render&quot;

  defp get_notification_color(%{security_status: sec}) when is_number(sec) do
    case sec do
      sec when sec &gt;= 0.5 -&gt; colors().highsec
      sec when sec &gt; 0.0 -&gt; colors().lowsec
      sec when sec &lt;= 0.0 -&gt; colors().nullsec
      _ -&gt; colors().default
    end
  end

  defp get_notification_color(_), do: colors().default

  defp build_character_kill_description(killmail, character_id) do
    victim = Map.get(killmail.esi_data || %{}, &quot;victim&quot;, %{})
    attacker_info = find_character_in_attackers(killmail, character_id)

    case {victim[&quot;character_id&quot;] == character_id, attacker_info} do
      {true, _} -&gt; &quot;Lost a ship&quot;
      {false, nil} -&gt; &quot;Was involved in a kill&quot;
      {false, info} -&gt; &quot;Got a kill (#{info[&quot;damage_done&quot;]} damage)&quot;
    end
  end

  defp find_character_in_attackers(killmail, character_id) do
    attackers = Map.get(killmail.esi_data || %{}, &quot;attackers&quot;, [])
    Enum.find(attackers, &amp;(Map.get(&amp;1, &quot;character_id&quot;) == character_id))
  end

  defp build_character_kill_fields(killmail, character_id) do
    victim = Map.get(killmail.esi_data || %{}, &quot;victim&quot;, %{})
    attacker_info = find_character_in_attackers(killmail, character_id)

    case {victim[&quot;character_id&quot;] == character_id, attacker_info} do
      {true, _} -&gt; build_victim_fields(victim)
      {false, info} when is_map(info) -&gt; build_attacker_fields(info)
      _ -&gt; []
    end
  end

  defp build_victim_fields(victim) do
    [
      %{
        name: &quot;Ship Lost&quot;,
        value: victim[&quot;ship_type_name&quot;] || &quot;Unknown Ship&quot;,
        inline: true
      }
    ]
  end

  defp build_attacker_fields(attacker) do
    [
      %{
        name: &quot;Ship Used&quot;,
        value: attacker[&quot;ship_type_name&quot;] || &quot;Unknown Ship&quot;,
        inline: true
      },
      %{
        name: &quot;Damage Done&quot;,
        value: &quot;#{attacker[&quot;damage_done&quot;]}&quot;,
        inline: true
      }
    ]
  end

  defp build_system_activity_description(activity_data) do
    kills = Map.get(activity_data, &quot;kills&quot;, 0)
    jumps = Map.get(activity_data, &quot;jumps&quot;, 0)
    &quot;Activity in the last hour: #{kills} kills, #{jumps} jumps&quot;
  end

  defp build_system_activity_fields(activity_data) do
    [
      %{
        name: &quot;Kills&quot;,
        value: &quot;#{Map.get(activity_data, &quot;kills&quot;, 0)}&quot;,
        inline: true
      },
      %{
        name: &quot;Jumps&quot;,
        value: &quot;#{Map.get(activity_data, &quot;jumps&quot;, 0)}&quot;,
        inline: true
      }
    ]
  end

  defp build_character_activity_description(activity_data) do
    kills = Map.get(activity_data, &quot;kills&quot;, 0)
    losses = Map.get(activity_data, &quot;losses&quot;, 0)
    &quot;Activity in the last hour: #{kills} kills, #{losses} losses&quot;
  end

  defp build_character_activity_fields(activity_data) do
    [
      %{
        name: &quot;Kills&quot;,
        value: &quot;#{Map.get(activity_data, &quot;kills&quot;, 0)}&quot;,
        inline: true
      },
      %{
        name: &quot;Losses&quot;,
        value: &quot;#{Map.get(activity_data, &quot;losses&quot;, 0)}&quot;,
        inline: true
      }
    ]
  end

  def format_system_status_message(
        title,
        description,
        websocket,
        uptime,
        extra,
        status,
        systems_count,
        characters_count
      ) do
    %{
      title: title,
      description: description,
      websocket: websocket,
      uptime: uptime,
      extra: extra,
      status: status,
      systems_count: systems_count,
      characters_count: characters_count
    }
  end
end</file><file path="lib/wanderer_notifier/notifiers/helpers/deduplication.ex">defmodule WandererNotifier.Notifiers.Helpers.Deduplication do
  @moduledoc &quot;&quot;&quot;
  Helper module for preventing duplicate notifications in WandererNotifier.
  Uses ETS for fast lookups and automatic expiration of entries.
  &quot;&quot;&quot;
  use GenServer
  require Logger
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # TTL for deduplication entries - 12 hours by default for better protection against restarts
  @dedup_ttl 12 * 60 * 60 * 1000

  # ETS table name for deduplication
  @dedup_table :notification_deduplication

  # Client API

  @doc &quot;&quot;&quot;
  Starts the deduplication helper GenServer.
  &quot;&quot;&quot;
  def start_link(_opts) do
    GenServer.start_link(__MODULE__, [], name: __MODULE__)
  end

  @doc &quot;&quot;&quot;
  Checks if a notification for a system with the given ID was recently sent.
  If not, marks the system as notified.

  Returns:
  - `{:ok, :new}` if this is a new notification (not a duplicate)
  - `{:ok, :duplicate}` if this is a duplicate notification
  &quot;&quot;&quot;
  def check_system_notification(system_id) do
    GenServer.call(__MODULE__, {:check_system, system_id})
  end

  @doc &quot;&quot;&quot;
  Checks if a notification for a character with the given ID was recently sent.
  If not, marks the character as notified.

  Returns:
  - `{:ok, :new}` if this is a new notification (not a duplicate)
  - `{:ok, :duplicate}` if this is a duplicate notification
  &quot;&quot;&quot;
  def check_and_mark_character(character_id)
      when is_binary(character_id) or is_integer(character_id) do
    character_id_str = to_string(character_id)
    key = &quot;character:#{character_id_str}&quot;

    # Log more details about the character deduplication check
    AppLogger.cache_debug(&quot;Checking character deduplication&quot;, character_id: character_id_str)

    check_and_mark(key)
  end

  @doc &quot;&quot;&quot;
  Checks if a notification for a system with the given ID was recently sent.
  If not, marks the system as notified.

  Returns:
  - `{:ok, :new}` if this is a new notification (not a duplicate)
  - `{:ok, :duplicate}` if this is a duplicate notification
  &quot;&quot;&quot;
  def check_and_mark_system(system_id) when is_binary(system_id) or is_integer(system_id) do
    system_id_str = to_string(system_id)
    key = &quot;system:#{system_id_str}&quot;

    # Log more details about the system deduplication check
    AppLogger.cache_debug(&quot;Checking system deduplication&quot;, system_id: system_id_str)

    check_and_mark(key)
  end

  @doc &quot;&quot;&quot;
  Checks if a notification for a kill with the given ID was recently sent.
  If not, marks the kill as notified.

  Returns:
  - `{:ok, :new}` if this is a new notification (not a duplicate)
  - `{:ok, :duplicate}` if this is a duplicate notification
  &quot;&quot;&quot;
  def check_and_mark_kill(kill_id) when is_binary(kill_id) or is_integer(kill_id) do
    kill_id_str = to_string(kill_id)
    key = &quot;kill:#{kill_id_str}&quot;

    # Log detailed debugging information for kill notifications
    AppLogger.kill_info(&quot;Checking kill deduplication&quot;, kill_id: kill_id_str)

    # Check in the ETS table
    result = check_and_mark(key)

    # Log the result with more details
    case result do
      {:ok, :new} -&gt;
        AppLogger.kill_info(&quot;Kill is new, notification allowed&quot;, kill_id: kill_id_str)

      {:ok, :duplicate} -&gt;
        AppLogger.kill_debug(&quot;Kill is a duplicate, notification skipped&quot;, kill_id: kill_id_str)

      _ -&gt;
        AppLogger.kill_warn(&quot;Unexpected result for kill check&quot;, result: inspect(result))
    end

    result
  end

  @doc &quot;&quot;&quot;
  Checks if a generic notification with the given key was recently sent.
  If not, marks the key as notified.

  Returns:
  - `{:ok, :new}` if this is a new notification (not seen before)
  - `{:ok, :duplicate}` if this is a duplicate notification (already seen)
  &quot;&quot;&quot;
  def check_and_mark(key) do
    # Make sure the table exists before trying to use it
    if :ets.info(@dedup_table) == :undefined do
      AppLogger.cache_error(&quot;ETS table doesn&apos;t exist, creating it now&quot;)
      create_dedup_table()
    end

    AppLogger.cache_debug(&quot;[Deduplication] Checking key&quot;, key: key)

    # Look up the key in the ETS table
    case :ets.lookup(@dedup_table, key) do
      [] -&gt;
        # Not in table, insert and return :new
        AppLogger.cache_info(&quot;[Deduplication] Key not found, marking as new&quot;, key: key)
        :ets.insert(@dedup_table, {key, :os.system_time(:millisecond)})
        # Schedule deletion after TTL
        if Process.whereis(__MODULE__) do
          Process.send_after(__MODULE__, {:clear_dedup_key, key}, @dedup_ttl)
        end

        {:ok, :new}

      [{^key, timestamp}] -&gt;
        # Already in table, return :duplicate
        age = :os.system_time(:millisecond) - timestamp

        AppLogger.cache_info(&quot;[Deduplication] Key found (duplicate)&quot;,
          key: key,
          age_ms: age
        )

        {:ok, :duplicate}
    end
  rescue
    e -&gt;
      AppLogger.cache_error(&quot;Error in deduplication check&quot;,
        error: inspect(e),
        key: key,
        stacktrace: inspect(Process.info(self(), :current_stacktrace))
      )

      # If there&apos;s an error, allow the notification to proceed
      {:ok, :new}
  end

  @doc &quot;&quot;&quot;
  Handles the expiration message for a deduplication key.
  &quot;&quot;&quot;
  def handle_clear_key(key) do
    AppLogger.cache_debug(&quot;Clearing expired deduplication key&quot;, key: key)
    :ets.delete(@dedup_table, key)
    :ok
  end

  @doc &quot;&quot;&quot;
  Clears all deduplication entries (mainly for testing).
  &quot;&quot;&quot;
  def clear_all do
    if :ets.info(@dedup_table) != :undefined do
      :ets.delete_all_objects(@dedup_table)
      AppLogger.cache_info(&quot;Cleared all deduplication entries&quot;)
    end

    :ok
  end

  # Create the ETS table if it doesn&apos;t exist
  defp create_dedup_table do
    :ets.new(@dedup_table, [
      :named_table,
      :set,
      :public,
      read_concurrency: true,
      write_concurrency: true
    ])

    AppLogger.cache_info(&quot;Created new deduplication table&quot;)
  end

  # Server callbacks

  @impl true
  def init(_) do
    # Create the ETS table on startup
    create_dedup_table()
    {:ok, %{}}
  end

  @impl true
  def handle_call({:check_system, system_id}, _from, state) do
    result = check_and_mark_system(system_id)
    {:reply, result, state}
  end

  @impl true
  def handle_info({:clear_dedup_key, key}, state) do
    handle_clear_key(key)
    {:noreply, state}
  end

  @impl true
  def handle_info(_, state), do: {:noreply, state}
end</file><file path="lib/wanderer_notifier/notifiers/helpers/test_notifications.ex">defmodule WandererNotifier.Notifiers.Helpers.TestNotifications do
  @moduledoc &quot;&quot;&quot;
  Helper module for sending test notifications.
  &quot;&quot;&quot;

  alias WandererNotifier.ESI.Service, as: ESIService
  alias WandererNotifier.Core.Stats
  alias WandererNotifier.Cache.Keys, as: CacheKeys
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
  alias WandererNotifier.Killmail.Killmail
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Notifiers.Discord.Notifier, as: NotificationInterface
  alias WandererNotifier.Notifiers.Formatters.Structured, as: StructuredFormatter
  alias WandererNotifier.Killmail.ZKillClient

  @doc &quot;&quot;&quot;
  Sends a test system notification.
  &quot;&quot;&quot;
  def send_test_system_notification do
    AppLogger.info(&quot;Sending test system notification...&quot;)

    # Get a system from the cache for testing
    # case SystemsClient.get_system_for_notification() do
    #   {:ok, system} -&gt;
    #     # Format the notification
    #     generic_notification = StructuredFormatter.format_system_notification(system)

    #     # Send notification
    #     case NotificationInterface.send_message(generic_notification) do
    #       :ok -&gt;
    #         AppLogger.info(&quot;Test system notification sent successfully&quot;)
    #         Stats.increment(:systems)
    #         {:ok, &quot;Test system notification sent successfully&quot;}

    #       {:error, reason} -&gt;
    #         AppLogger.error(&quot;Failed to send test system notification: #{inspect(reason)}&quot;)
    #         {:error, reason}
    #     end

    #   {:error, :no_systems_in_cache} -&gt;
    #     error_msg = &quot;No systems found in cache for test notification&quot;
    #     AppLogger.error(error_msg)
    #     {:error, error_msg}

    #   {:error, reason} -&gt;
    #     AppLogger.error(&quot;Failed to get system for test notification: #{inspect(reason)}&quot;)
    #     {:error, reason}
    # end
  end

  @doc &quot;&quot;&quot;
  Sends a test kill notification.
  &quot;&quot;&quot;
  def send_test_kill_notification do
    # Get recent kills from ZKill
    case get_recent_kill() do
      {:ok, {kill_id, kill_data, hash}} -&gt;
        process_kill_notification(kill_id, kill_data, hash)

      {:error, reason} -&gt;
        handle_error(&quot;Failed to get recent kills&quot;, reason)
    end
  end

  # Get the most recent kill from ZKill
  defp get_recent_kill do
    case ZKillClient.get_recent_kills(1) do
      {:ok, [kill | _]} -&gt;
        kill_id = kill[&quot;killmail_id&quot;]
        hash = get_in(kill, [&quot;zkb&quot;, &quot;hash&quot;])
        AppLogger.kill_info(&quot;TEST NOTIFICATION: Using kill #{kill_id} for test notification&quot;)
        {:ok, {kill_id, kill, hash}}

      {:error, reason} -&gt;
        {:error, reason}
    end
  end

  # Process a kill notification with the given kill data
  defp process_kill_notification(kill_id, kill_data, hash) do
    case get_enriched_killmail(kill_id, kill_data, hash) do
      {:ok, enriched_kill} -&gt;
        send_kill_notification(enriched_kill, kill_id)

      {:error, reason} -&gt;
        handle_error(&quot;Failed to get ESI data for kill #{kill_id}&quot;, reason)
    end
  end

  # Get and enrich killmail data
  defp get_enriched_killmail(kill_id, kill_data, hash) do
    case ESIService.get_killmail(kill_id, hash) do
      {:ok, esi_data} -&gt;
        # Create a Killmail struct with both ZKill and ESI data
        killmail = %Killmail{
          killmail_id: kill_id,
          zkb: kill_data[&quot;zkb&quot;],
          esi_data: esi_data
        }

        # Enrich the killmail data
        enriched_kill = WandererNotifier.Killmail.Enrichment.enrich_killmail_data(killmail)

        AppLogger.kill_debug(
          &quot;TEST NOTIFICATION: Enriched killmail data: #{inspect(enriched_kill)}&quot;
        )

        {:ok, enriched_kill}

      {:error, reason} -&gt;
        {:error, reason}
    end
  end

  # Send the actual kill notification
  defp send_kill_notification(enriched_kill, kill_id) do
    case validate_killmail_data(enriched_kill) do
      :ok -&gt;
        AppLogger.kill_info(
          &quot;TEST NOTIFICATION: Using normal notification flow for test kill notification&quot;
        )

        send_formatted_notification(enriched_kill, kill_id)

      {:error, reason} -&gt;
        handle_error(&quot;Cannot send test notification&quot;, reason)
    end
  end

  # Format and send the notification
  defp send_formatted_notification(enriched_kill, kill_id) do
    # Format the notification
    generic_notification = StructuredFormatter.format_kill_notification(enriched_kill)

    # Send notification
    case NotificationInterface.send_message(generic_notification) do
      :ok -&gt;
        AppLogger.kill_info(&quot;Test kill notification sent successfully&quot;)
        Stats.increment(:kills)
        {:ok, kill_id}

      {:error, reason} -&gt;
        handle_error(&quot;Failed to send kill notification&quot;, reason)
    end
  end

  # Handle errors consistently
  defp handle_error(message, reason) do
    error_message = &quot;#{message}: #{inspect(reason)}&quot;
    AppLogger.kill_error(error_message)
    NotificationInterface.send_message(error_message)
    {:error, error_message}
  end

  @doc &quot;&quot;&quot;
  Sends a test character notification.
  &quot;&quot;&quot;
  def send_test_character_notification do
    case CacheRepo.get(CacheKeys.character_list()) do
      {:ok, [character | _]} when not is_nil(character) -&gt;
        generic_notification = StructuredFormatter.format_character_notification(character)

        case NotificationInterface.send_message(generic_notification) do
          :ok -&gt;
            AppLogger.notification_info(&quot;Test character notification sent successfully&quot;)
            :ok

          {:error, reason} -&gt;
            AppLogger.notification_error(&quot;Failed to send test character notification&quot;,
              error: inspect(reason)
            )

            {:error, reason}
        end

      {:ok, []} -&gt;
        AppLogger.notification_warn(&quot;No characters found in cache for test notification&quot;)
        {:error, :no_characters}

      _ -&gt;
        AppLogger.notification_error(
          &quot;Failed to fetch characters from cache for test notification&quot;
        )

        {:error, :cache_error}
    end
  end

  # Validate killmail has all required data for notification
  defp validate_killmail_data(killmail) do
    # For Data.Killmail struct
    if is_struct(killmail, WandererNotifier.Killmail.Killmail) do
      # Check victim data
      victim = Map.get(killmail.esi_data || %{}, &quot;victim&quot;) || %{}

      # Check system name
      esi_data = killmail.esi_data || %{}
      system_name = Map.get(esi_data, &quot;solar_system_name&quot;)

      # Check ZKB data
      zkb = killmail.zkb || %{}

      cond do
        victim == %{} -&gt;
          {:error, &quot;Missing victim data&quot;}

        is_nil(system_name) -&gt;
          {:error, &quot;Missing system name&quot;}

        zkb == %{} -&gt;
          {:error, &quot;Missing ZKB data&quot;}

        true -&gt;
          :ok
      end
    else
      {:error, &quot;Invalid killmail struct&quot;}
    end
  end
end</file><file path="lib/wanderer_notifier/notifiers/behaviour.ex">defmodule WandererNotifier.Notifiers.Behaviour do
  @moduledoc &quot;&quot;&quot;
  Defines the behaviour for notification delivery.
  This includes sending notifications through various channels (e.g., Discord).
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Sends a notification through the specified channel.
  Takes formatted notification data and delivers it.
  &quot;&quot;&quot;
  @callback notify(notification :: map()) :: :ok | {:error, any()}

  @doc &quot;&quot;&quot;
  Initializes the notifier with the given configuration.
  &quot;&quot;&quot;
  @callback init(config :: map()) :: :ok | {:error, any()}

  @doc &quot;&quot;&quot;
  Returns the configuration for the notifier.
  &quot;&quot;&quot;
  @callback get_config() :: map()

  @optional_callbacks [init: 1, get_config: 0]
end</file><file path="lib/wanderer_notifier/notifiers/test.ex">defmodule WandererNotifier.Notifiers.Test do
  @moduledoc &quot;&quot;&quot;
  Test notifier for use in test environment.
  This module is the single source of truth for test notifications.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Notifiers.Discord.Behaviour

  alias WandererNotifier.Logger.Logger, as: AppLogger

  @impl WandererNotifier.Notifiers.Discord.Behaviour
  def send_message(message, _feature \\ nil) do
    AppLogger.processor_debug(&quot;[TEST] Message&quot;, message: message)
    :ok
  end

  @impl WandererNotifier.Notifiers.Discord.Behaviour
  def send_embed(title, description, url \\ nil, color \\ nil, _feature \\ nil) do
    AppLogger.processor_debug(&quot;[TEST] Embed&quot;,
      title: title,
      description: description,
      url: url,
      color: color
    )

    :ok
  end

  @impl WandererNotifier.Notifiers.Discord.Behaviour
  def send_file(filename, file_data, title \\ nil, description \\ nil, _feature \\ nil) do
    AppLogger.processor_debug(&quot;[TEST] File&quot;,
      filename: filename,
      file_size: byte_size(file_data),
      title: title || &quot;No title&quot;,
      description: description || &quot;No description&quot;
    )

    :ok
  end

  @impl WandererNotifier.Notifiers.Discord.Behaviour
  def send_image_embed(title, description, image_url, color \\ nil, _feature \\ nil) do
    AppLogger.processor_debug(&quot;[TEST] Image embed&quot;,
      title: title,
      description: description,
      image_url: image_url,
      color: color
    )

    :ok
  end

  @impl WandererNotifier.Notifiers.Discord.Behaviour
  def send_enriched_kill_embed(killmail, kill_id) do
    AppLogger.processor_debug(&quot;[TEST] Enriched kill&quot;,
      kill_id: kill_id,
      killmail: inspect(killmail, limit: 50)
    )

    :ok
  end

  @impl WandererNotifier.Notifiers.Discord.Behaviour
  def send_new_system_notification(system) do
    system_id = Map.get(system, &quot;system_id&quot;) || Map.get(system, :system_id)
    system_name = Map.get(system, &quot;name&quot;) || Map.get(system, :name)

    AppLogger.processor_debug(&quot;[TEST] New system&quot;,
      system_id: system_id,
      system_name: system_name
    )

    :ok
  end

  @impl WandererNotifier.Notifiers.Discord.Behaviour
  def send_new_tracked_character_notification(character) do
    char_id = Map.get(character, &quot;character_id&quot;) || Map.get(character, :character_id)
    char_name = Map.get(character, &quot;name&quot;) || Map.get(character, :name)

    AppLogger.processor_debug(&quot;[TEST] New character&quot;,
      character_id: char_id,
      character_name: char_name
    )

    :ok
  end

  @impl WandererNotifier.Notifiers.Discord.Behaviour
  def send_kill_notification(kill_data) do
    kill_id = Map.get(kill_data, &quot;killmail_id&quot;) || Map.get(kill_data, :killmail_id) || &quot;unknown&quot;
    AppLogger.processor_debug(&quot;[TEST] Kill notification&quot;, kill_id: kill_id)
    :ok
  end

  @doc &quot;&quot;&quot;
  Sends a test notification for an activity chart.
  &quot;&quot;&quot;
  def send_activity_chart_notification(chart_info) do
    AppLogger.processor_debug(&quot;[TEST] Activity chart&quot;, chart_info: inspect(chart_info))
    :ok
  end

  @impl true
  def notify(_msg), do: :ok
end</file><file path="lib/wanderer_notifier/schedulers/character_update_scheduler.ex">defmodule WandererNotifier.Schedulers.CharacterUpdateScheduler do
  @moduledoc &quot;&quot;&quot;
  Scheduler responsible for periodic character updates from the map.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Schedulers.Scheduler

  @impl true
  def config, do: %{type: :interval, spec: WandererNotifier.Config.character_update_scheduler_interval()}

  @impl true
  def run do
    # Core job logic from previous implementation
    if WandererNotifier.Config.character_tracking_enabled?() ||
         WandererNotifier.Config.tracked_characters_notifications_enabled?() ||
         WandererNotifier.Config.tracked_characters_notifications_enabled?() do
      update_tracked_characters()
      :ok
    else
      :ok
    end
  end

  defp update_tracked_characters do
    alias WandererNotifier.Map.Clients.Client
    alias WandererNotifier.Cache.Keys, as: CacheKeys
    alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
    alias WandererNotifier.Logger.Logger, as: AppLogger

    primed? = CacheRepo.get(:character_list_primed) == {:ok, true}
    cached_characters = CacheRepo.get(CacheKeys.character_list())
    cached_characters_safe = ensure_list(cached_characters)

    task =
      Task.async(fn -&gt;
        try do
          Client.update_tracked_characters(cached_characters_safe)
        rescue
          e -&gt;
            AppLogger.maintenance_error(&quot; Exception in character update task&quot;,
              error: Exception.message(e),
              stacktrace: inspect(Process.info(self(), :current_stacktrace))
            )
            {:error, :exception}
        end
      end)

    case Task.yield(task, 10_000) do
      {:ok, {:ok, characters}} -&gt;
        AppLogger.maintenance_info(
          &quot; Characters updated: #{length(ensure_list(characters))} characters synchronized&quot;
        )
        if primed? do
          handle_successful_character_update(characters)
        else
          CacheRepo.put(:character_list_primed, true)
        end
      {:ok, {:error, :feature_disabled}} -&gt;
        :ok
      {:ok, {:error, reason}} -&gt;
        AppLogger.maintenance_error(&quot; Character update failed&quot;, error: inspect(reason))
      nil -&gt;
        Task.shutdown(task, :brutal_kill)
        AppLogger.maintenance_error(&quot; Character update timed out after 10 seconds&quot;)
      {:exit, reason} -&gt;
        AppLogger.maintenance_error(&quot; Character update crashed&quot;, reason: inspect(reason))
    end
  end

  defp ensure_list(nil), do: []
  defp ensure_list(list) when is_list(list), do: list
  defp ensure_list({:ok, list}) when is_list(list), do: list
  defp ensure_list({:error, _}), do: []
  defp ensure_list(_), do: []

  defp handle_successful_character_update(characters) do
    alias WandererNotifier.Cache.Keys, as: CacheKeys
    alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
    alias WandererNotifier.Logger.Logger, as: AppLogger
    characters_list = ensure_list(characters)
    verify_and_update_characters_cache(characters_list)
    :ok
  end

  defp verify_and_update_characters_cache(characters) do
    alias WandererNotifier.Cache.Keys, as: CacheKeys
    alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
    alias WandererNotifier.Logger.Logger, as: AppLogger
    task =
      Task.async(fn -&gt;
        try do
          _perform_character_cache_verification(characters)
        rescue
          e -&gt;
            AppLogger.maintenance_error(&quot; Character cache verification failed&quot;,
              error: Exception.message(e)
            )
        end
      end)
    case Task.yield(task, 5_000) do
      {:ok, _} -&gt; :ok
      nil -&gt;
        Task.shutdown(task, :brutal_kill)
        AppLogger.maintenance_error(&quot; Character cache verification timed out after 5 seconds&quot;)
    end
  end

  defp _perform_character_cache_verification(characters) do
    alias WandererNotifier.Cache.Keys, as: CacheKeys
    alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
    characters_list = ensure_list(characters)
    updated_cache = CacheRepo.get(CacheKeys.character_list())
    cache_list = ensure_list(updated_cache)
    if cache_list == [] do
      cache_ttl = 60_000 # TODO: Replace with Config.characters_cache_ttl/0 if/when available
      CacheRepo.set(CacheKeys.character_list(), characters_list, cache_ttl)
    end
  end
end</file><file path="lib/wanderer_notifier/schedulers/registry.ex">defmodule WandererNotifier.Schedulers.Registry do
  @moduledoc &quot;&quot;&quot;
  Finds all modules under WandererNotifier.Schedulers that implement the behaviour.
  &quot;&quot;&quot;

  def all_schedulers do
    :application.get_key(:wanderer_notifier, :modules)
    |&gt; elem(1)
    |&gt; Enum.filter(&amp;String.starts_with?(Atom.to_string(&amp;1), &quot;Elixir.WandererNotifier.Schedulers.&quot;))
    |&gt; Enum.filter(&amp;implements_scheduler?/1)
  end

  defp implements_scheduler?(mod) do
    behaviours = mod.module_info(:attributes)[:behaviour] || []
    WandererNotifier.Schedulers.Scheduler in behaviours
  end
end</file><file path="lib/wanderer_notifier/schedulers/scheduler.ex">defmodule WandererNotifier.Schedulers.Scheduler do
  @moduledoc &quot;&quot;&quot;
  Behaviour for all background jobs.

  Each scheduler implements:
    - `config/0` returning %{type: :cron | :interval, spec: String.t()}
    - `run/0` which executes the job.
  &quot;&quot;&quot;

  @type config :: %{type: :cron | :interval, spec: String.t()}

  @callback config() :: config()
  @callback run() :: :ok | {:error, term()}
end</file><file path="lib/wanderer_notifier/schedulers/service_status_scheduler.ex">defmodule WandererNotifier.Schedulers.ServiceStatusScheduler do
  @moduledoc &quot;&quot;&quot;
  Scheduler responsible for generating periodic service status reports.
  &quot;&quot;&quot;
  alias WandererNotifier.Logger.Logger, as: AppLogger

  @behaviour WandererNotifier.Schedulers.Scheduler

  @impl true
  def config, do: %{type: :interval, spec: WandererNotifier.Config.service_status_interval()}

  @impl true
  def run do
    generate_service_status_report()
    :ok
  end

  defp generate_service_status_report do
    alias WandererNotifier.Logger.Logger, as: AppLogger
    alias WandererNotifier.Notifiers.Helpers.Deduplication

    uptime_seconds = calculate_uptime()
    days = div(uptime_seconds, 86_400)
    hours = div(rem(uptime_seconds, 86_400), 3600)
    minutes = div(rem(uptime_seconds, 3600), 60)
    seconds = rem(uptime_seconds, 60)
    formatted_uptime = &quot;#{days}d #{hours}h #{minutes}m #{seconds}s&quot;
    current_day = div(:os.system_time(:second), 86_400)
    dedup_key = &quot;status_report:#{current_day}&quot;

    case Deduplication.check_and_mark(dedup_key) do
      {:ok, :new} -&gt;
        AppLogger.maintenance_info(&quot;Service status report&quot;,
          uptime: formatted_uptime,
          status: &quot;operational&quot;
        )
      {:ok, :duplicate} -&gt;
        AppLogger.maintenance_info(&quot;Service status notification skipped (duplicate)&quot;,
          action: &quot;skipping_duplicate&quot;
        )
    end
  rescue
    e -&gt;
      AppLogger.maintenance_error(&quot;Error generating service status report&quot;,
        error: Exception.message(e)
      )
  end

  defp calculate_uptime do
    case :erlang.statistics(:wall_clock) do
      {total_wall_clock, _} -&gt;
        div(total_wall_clock, 1000)
      _ -&gt;
        0
    end
  end
end</file><file path="lib/wanderer_notifier/schedulers/supervisor.ex">defmodule WandererNotifier.Schedulers.Supervisor do
  @moduledoc &quot;&quot;&quot;
  Supervisor for all scheduler modules. Dynamically starts all discovered schedulers.
  &quot;&quot;&quot;

  use Supervisor
  alias WandererNotifier.Schedulers.Registry

  def start_link(_opts \\ []) do
    Supervisor.start_link(__MODULE__, [], name: __MODULE__)
  end

  @impl true
  def init(_) do
    children =
      Registry.all_schedulers()
      |&gt; Enum.map(&amp;scheduler_child_spec/1)

    Supervisor.init(children, strategy: :one_for_one)
  end

  defp scheduler_child_spec(mod) do
    %{
      id: mod,
      start: {Task, :start_link, [fn -&gt; start_scheduler(mod) end]},
      restart: :permanent
    }
  end

  def start_scheduler(mod) do
    %{type: type, spec: spec} = mod.config()

    case type do
      :interval -&gt;
        :timer.send_interval(spec, {:run, mod})
        loop(mod)
    end
  end

  defp loop(mod) do
    receive do
      {:run, ^mod} -&gt;
        execute(mod)
        loop(mod)
    end
  end

  defp execute(mod) do
    start = System.monotonic_time()
    case mod.run() do
      :ok -&gt;
        :telemetry.execute([:wanderer_notifier, :scheduler, :success], %{}, %{module: mod})
      {:error, reason} -&gt;
        :telemetry.execute([
          :wanderer_notifier, :scheduler, :failure
        ], %{}, %{module: mod, error: inspect(reason)})
    end
    duration = System.monotonic_time() - start
    :telemetry.execute([
      :wanderer_notifier, :scheduler, :duration
    ], %{duration: duration}, %{module: mod})
  end

  def child_spec(opts) do
    %{
      id: __MODULE__,
      start: {__MODULE__, :start_link, [opts]},
      type: :supervisor,
      restart: :permanent,
      shutdown: 500
    }
  end
end</file><file path="lib/wanderer_notifier/schedulers/system_update_scheduler.ex">defmodule WandererNotifier.Schedulers.SystemUpdateScheduler do
  @moduledoc &quot;&quot;&quot;
  Scheduler responsible for periodic system updates from the map.
  &quot;&quot;&quot;
  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Map.Clients.SystemsClient
  alias WandererNotifier.Cache.CachexImpl, as: CacheRepo

  @behaviour WandererNotifier.Schedulers.Scheduler

  @impl true
  def config do
    interval = WandererNotifier.Config.system_update_scheduler_interval()
    %{type: :interval, spec: interval}
  end

  @impl true
  def run do
    update_tracked_systems()
    :ok
  end

  defp update_tracked_systems do
    primed? = CacheRepo.get(:map_systems_primed) == {:ok, true}
    task =
      Task.async(fn -&gt;
        try do
          SystemsClient.update_systems(suppress_notifications: !primed?)
        rescue
          e -&gt;
            AppLogger.api_error(&quot; Exception in system update task&quot;,
              error: Exception.message(e),
              stacktrace: inspect(Process.info(self(), :current_stacktrace))
            )
            {:error, :exception}
        end
      end)

    case Task.yield(task, 10_000) do
      {:ok, { :ok, _new_systems, all_systems }} -&gt;
        AppLogger.api_info(&quot; Systems updated: #{length(ensure_list(all_systems))} systems synchronized&quot;)
        if primed? do
          handle_successful_system_update(all_systems)
        else
          CacheRepo.put(:map_systems_primed, true)
        end
      {:ok, { :error, reason }} -&gt;
        AppLogger.api_error(&quot; System update failed&quot;, error: inspect(reason))
      nil -&gt;
        Task.shutdown(task, :brutal_kill)
        AppLogger.api_error(&quot; System update timed out after 10 seconds&quot;)
      {:exit, reason} -&gt;
        AppLogger.api_error(&quot; System update crashed&quot;, reason: inspect(reason))
    end
  end

  defp ensure_list(nil), do: []
  defp ensure_list(list) when is_list(list), do: list
  defp ensure_list({:ok, list}) when is_list(list), do: list
  defp ensure_list({:error, _}), do: []
  defp ensure_list(_), do: []

  defp handle_successful_system_update(systems) do
    systems_list = ensure_list(systems)
    verify_and_update_systems_cache(systems_list)
    :ok
  end

  defp verify_and_update_systems_cache(systems) do

    task =
      Task.async(fn -&gt;
        try do
          _perform_system_cache_verification(systems)
        rescue
          e -&gt;
            AppLogger.api_error(&quot; System cache verification failed&quot;, error: Exception.message(e))
        end
      end)
    case Task.yield(task, 5_000) do
      {:ok, _} -&gt; :ok
      nil -&gt;
        Task.shutdown(task, :brutal_kill)
        AppLogger.api_error(&quot; System cache verification timed out after 5 seconds&quot;)
    end
  end

  defp _perform_system_cache_verification(systems) do
    alias WandererNotifier.Cache.CachexImpl, as: CacheRepo
    systems_list = ensure_list(systems)
    updated_cache = CacheRepo.get(:system_list)
    cache_list = ensure_list(updated_cache)
    if cache_list == [] do
      cache_ttl = 60_000 # TODO: Replace with Config.systems_cache_ttl/0 if/when available
      CacheRepo.set(:system_list, systems_list, cache_ttl)
    end
  end
end</file><file path="lib/wanderer_notifier/utilities/character_utils.ex">defmodule WandererNotifier.Utilities.CharacterUtils do
  @moduledoc &quot;&quot;&quot;
  Utility functions for working with Character data.
  Provides helper functions for extracting and formatting character information.
  &quot;&quot;&quot;

  alias WandererNotifier.Map.MapCharacter

  @doc &quot;&quot;&quot;
  Extracts a character ID from a Character struct.
  No fallbacks to maps supported.

  Returns the ID as a string.
  &quot;&quot;&quot;
  @spec extract_character_id(MapCharacter.t()) :: String.t()
  def extract_character_id(%MapCharacter{} = character) do
    character.character_id
  end

  @doc &quot;&quot;&quot;
  Extracts a character name from a Character struct.
  No fallbacks to maps supported.

  Returns the name as a string.
  &quot;&quot;&quot;
  @spec extract_character_name(MapCharacter.t()) :: String.t()
  def extract_character_name(%MapCharacter{} = character) do
    character.name
  end

  @doc &quot;&quot;&quot;
  Extracts a corporation name from a Character struct.
  No fallbacks to maps supported.

  Returns the corporation ticker as a string.
  &quot;&quot;&quot;
  @spec extract_corporation_name(MapCharacter.t()) :: String.t()
  def extract_corporation_name(%MapCharacter{} = character) do
    character.corporation_ticker
  end

  @doc &quot;&quot;&quot;
  Adds a field to an embed map if the value is available.

  ## Parameters
  - embed: The embed map to update
  - name: The name of the field
  - value: The value of the field (or nil)
  - inline: Whether the field should be displayed inline

  ## Returns
  The updated embed map with the field added if value is not nil
  &quot;&quot;&quot;
  @spec add_field_if_available(map(), String.t(), any(), boolean()) :: map()
  def add_field_if_available(embed, name, value, inline \\ true)
  def add_field_if_available(embed, _name, nil, _inline), do: embed
  def add_field_if_available(embed, _name, &quot;&quot;, _inline), do: embed

  def add_field_if_available(embed, name, value, inline) do
    # Ensure the fields key exists
    embed = Map.put_new(embed, :fields, [])

    # Add the new field
    Map.update!(embed, :fields, fn fields -&gt;
      fields ++ [%{name: name, value: to_string(value), inline: inline}]
    end)
  end
end</file><file path="lib/wanderer_notifier/utilities/datetime_util.ex">defmodule WandererNotifier.Utilities.DateTimeUtil do
  @moduledoc &quot;&quot;&quot;
  Utility functions for parsing and formatting datetime values consistently across the application.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Safely parses an ISO 8601 datetime string into a DateTime struct.

  ## Parameters
    - `datetime` - Can be a string in ISO 8601 format, a DateTime struct, or nil

  ## Returns
    - A DateTime struct if parsing was successful
    - The original DateTime if a DateTime was passed
    - nil if parsing failed or nil was passed

  ## Examples
      iex&gt; parse_datetime(&quot;2023-05-01T15:30:45Z&quot;)
      ~U[2023-05-01 15:30:45Z]

      iex&gt; parse_datetime(~U[2023-05-01 15:30:45Z])
      ~U[2023-05-01 15:30:45Z]

      iex&gt; parse_datetime(nil)
      nil

      iex&gt; parse_datetime(&quot;invalid&quot;)
      nil
  &quot;&quot;&quot;
  @spec parse_datetime(String.t() | DateTime.t() | nil) :: DateTime.t() | nil
  def parse_datetime(nil), do: nil
  def parse_datetime(%DateTime{} = dt), do: dt

  def parse_datetime(datetime) when is_binary(datetime) do
    case DateTime.from_iso8601(datetime) do
      {:ok, datetime, _} -&gt; datetime
      _error -&gt; nil
    end
  end

  def parse_datetime(_), do: nil
end</file><file path="lib/wanderer_notifier/utilities/debug.ex">defmodule WandererNotifier.Utilities.Debug do
  @moduledoc &quot;&quot;&quot;
  Debug utilities for WandererNotifier. Only for development use.
  &quot;&quot;&quot;

  alias WandererNotifier.HttpClient.Httpoison, as: HttpClient
  alias WandererNotifier.Map.Clients.Client, as: MapClient
  alias WandererNotifier.Config, as: AppConfig
  alias WandererNotifier.Logger.Logger, as: AppLogger

  @doc &quot;&quot;&quot;
  Manually trigger character tracking update.
  &quot;&quot;&quot;
  def trigger_character_tracking_update do
    AppLogger.processor_warn(&quot;DEBUG: Manually triggering character tracking update&quot;)
    result = MapClient.update_tracked_characters()
    AppLogger.processor_warn(&quot;DEBUG: Character tracking update result: #{inspect(result)}&quot;)
    result
  end

  @doc &quot;&quot;&quot;
  Print current feature flags configuration.
  &quot;&quot;&quot;
  def print_feature_flags do
    feature_flags = Application.get_env(:wanderer_notifier, :features, %{})
    AppLogger.processor_warn(&quot;DEBUG: Current feature flags: #{inspect(feature_flags)}&quot;)

    # Check character tracking specifically
    tracking_enabled = AppConfig.character_tracking_enabled?()
    AppLogger.processor_warn(&quot;DEBUG: Character tracking enabled? #{tracking_enabled}&quot;)

    feature_flags
  end

  @doc &quot;&quot;&quot;
  Check map URL configuration.
  &quot;&quot;&quot;
  def check_map_config do
    url_with_name = Application.get_env(:wanderer_notifier, :map_url_with_name)
    url = Application.get_env(:wanderer_notifier, :map_url)
    name = Application.get_env(:wanderer_notifier, :map_name)
    token = Application.get_env(:wanderer_notifier, :map_token)

    # Check Config module access
    core_url = AppConfig.base_map_url()
    core_name = AppConfig.map_name()
    core_token = AppConfig.map_token()

    # Get map settings from Debug config module
    debug_settings = AppConfig.map_debug_settings()

    %{
      env: %{
        map_url_with_name: url_with_name,
        map_url: url,
        map_name: name,
        map_token: token
      },
      config: %{
        map_url: core_url,
        map_name: core_name,
        map_token: core_token
      },
      debug_config: debug_settings
    }
  end

  @doc &quot;&quot;&quot;
  Test characters endpoint directly.
  &quot;&quot;&quot;
  def test_characters_endpoint do
    # Get map URL components
    config = check_map_config()

    # Build URL directly
    uri = URI.parse(config.env.map_url_with_name || &quot;&quot;)
    base_url = &quot;#{uri.scheme}://#{uri.host}#{if uri.port, do: &quot;:#{uri.port}&quot;, else: &quot;&quot;}&quot;
    slug = uri.path |&gt; String.trim(&quot;/&quot;) |&gt; String.split(&quot;/&quot;) |&gt; List.last() || &quot;&quot;
    url = &quot;#{base_url}/api/map/characters?slug=#{URI.encode_www_form(slug)}&quot;

    # Build headers
    headers = [
      {&quot;Authorization&quot;, &quot;Bearer #{config.env.map_token}&quot;},
      {&quot;Content-Type&quot;, &quot;application/json&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;}
    ]

    # Make request
    result = HttpClient.get(url, headers)

    %{
      url: url,
      headers: headers,
      result: result
    }
  end

  @doc &quot;&quot;&quot;
  Directly test characters API endpoint with full debug information.
  &quot;&quot;&quot;
  def direct_test_characters_api do
    alias WandererNotifier.HttpClient.Httpoison, as: HttpClient
    # Updated to new path
    alias WandererNotifier.Config, as: AppConfig

    # Build the URL and headers directly
    base_url = Application.get_env(:wanderer_notifier, :map_url)
    token = Application.get_env(:wanderer_notifier, :map_token)
    url = base_url &lt;&gt; &quot;/api/map/characters&quot;

    headers = [
      {&quot;Authorization&quot;, &quot;Bearer #{token}&quot;},
      {&quot;Content-Type&quot;, &quot;application/json&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;}
    ]

    # Make direct API call with full debug
    response =
      case url do
        url when is_binary(url) and url != &quot;&quot; -&gt;
          IO.puts(&quot;Making request to URL: #{url}&quot;)
          IO.puts(&quot;With headers: #{inspect(headers)}&quot;)
          HttpClient.get(url, headers)

        _ -&gt;
          IO.puts(&quot;URL builder error: #{inspect(url)}&quot;)
          {:error, :invalid_url}
      end

    # Get map settings from Debug config
    debug_settings = AppConfig.map_debug_settings()

    # Return complete debug info
    %{
      url_result: url,
      headers: headers,
      response: response,
      config: %{
        map_url: AppConfig.map_url_with_name(),
        map_name: AppConfig.map_name(),
        map_token: AppConfig.map_token(),
        debug_settings: debug_settings
      }
    }
  end
end</file><file path="lib/wanderer_notifier/utilities/list_utils.ex">defmodule WandererNotifier.Utilities.ListUtils do
  @moduledoc &quot;&quot;&quot;
  Utility functions for working with lists and collections.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Ensures a value is converted to a list.

  Handles multiple input types:
  - nil -&gt; Returns an empty list
  - List -&gt; Returns the list unchanged
  - {:ok, list} -&gt; Extracts and returns the list
  - {:error, _} -&gt; Returns an empty list
  - Other values -&gt; Returns an empty list

  ## Examples

      iex&gt; ensure_list(nil)
      []

      iex&gt; ensure_list([1, 2, 3])
      [1, 2, 3]

      iex&gt; ensure_list({:ok, [1, 2, 3]})
      [1, 2, 3]

      iex&gt; ensure_list({:error, &quot;some error&quot;})
      []
  &quot;&quot;&quot;
  @spec ensure_list(list() | {:ok, list()} | {:error, any()} | nil) :: list()
  def ensure_list(nil), do: []
  def ensure_list(list) when is_list(list), do: list
  def ensure_list({:ok, list}) when is_list(list), do: list
  def ensure_list({:error, _}), do: []
  def ensure_list(_), do: []
end</file><file path="lib/wanderer_notifier/utilities/map_util.ex">defmodule WandererNotifier.Utilities.MapUtil do
  @moduledoc &quot;&quot;&quot;
  Utility functions for working with maps consistently across the application.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Gets a value from a map trying multiple possible keys.
  Useful for handling maps with string or atom keys, or different naming conventions.

  ## Parameters
    - `map` - The map to search in
    - `keys` - List of keys to try

  ## Returns
    - The value of the first key that exists in the map
    - nil if none of the keys exist

  ## Examples
      iex&gt; get_value(%{&quot;name&quot; =&gt; &quot;John&quot;}, [&quot;name&quot;, :name])
      &quot;John&quot;

      iex&gt; get_value(%{name: &quot;John&quot;}, [&quot;name&quot;, :name])
      &quot;John&quot;

      iex&gt; get_value(%{}, [&quot;name&quot;, :name])
      nil

      iex&gt; get_value(%{&quot;user_id&quot; =&gt; 123}, [&quot;id&quot;, &quot;user_id&quot;, :id, :user_id])
      123
  &quot;&quot;&quot;
  @spec get_value(map(), list(String.t() | atom())) :: any()
  def get_value(map, keys) when is_map(map) and is_list(keys) do
    Enum.find_value(keys, fn key -&gt; Map.get(map, key) end)
  end

  @doc &quot;&quot;&quot;
  Safely extracts values from a map using a list of key paths, and constructs a struct.

  ## Parameters
    - `map` - Source map
    - `module` - Module name for the struct to create
    - `mappings` - List of {dest_key, key_paths} tuples, where key_paths is a list of possible keys to try

  ## Returns
    - A struct of the specified module with values extracted from the map

  ## Examples
      iex&gt; extract_to_struct(%{&quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30}, MyModule, [
      ...&gt;   {:name, [&quot;name&quot;, :name]},
      ...&gt;   {:age, [&quot;age&quot;, :age]}
      ...&gt; ])
      %MyModule{name: &quot;John&quot;, age: 30}
  &quot;&quot;&quot;
  @spec extract_to_struct(map(), module(), list({atom(), list(String.t() | atom())})) :: struct()
  def extract_to_struct(map, module, mappings)
      when is_map(map) and is_atom(module) and is_list(mappings) do
    attrs =
      Enum.reduce(mappings, %{}, fn {dest_key, key_paths}, acc -&gt;
        Map.put(acc, dest_key, get_value(map, key_paths))
      end)

    struct(module, attrs)
  end

  @doc &quot;&quot;&quot;
  Extracts data from a map using specified field mappings.
  Similar to extract_to_struct but returns a map instead of a struct.

  ## Parameters
    - `map` - Source map
    - `field_mappings` - List of {dest_key, key_paths, default_value} tuples
      or {dest_key, key_paths} if no default value is needed

  ## Returns
    - A map with extracted values

  ## Examples
      iex&gt; extract_map(%{&quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30}, [
      ...&gt;   {:name, [&quot;name&quot;, :name]},
      ...&gt;   {:age, [&quot;age&quot;, :age], 0},
      ...&gt;   {:email, [&quot;email&quot;, :email], nil}
      ...&gt; ])
      %{name: &quot;John&quot;, age: 30, email: nil}
  &quot;&quot;&quot;
  @spec extract_map(
          map(),
          list({atom(), list(String.t() | atom())} | {atom(), list(String.t() | atom()), any()})
        ) :: map()
  def extract_map(map, field_mappings) when is_map(map) and is_list(field_mappings) do
    Enum.reduce(field_mappings, %{}, fn
      # With default value
      {dest_key, key_paths, default}, acc when is_list(key_paths) -&gt;
        value = get_value(map, key_paths) || default
        Map.put(acc, dest_key, value)

      # Without default value
      {dest_key, key_paths}, acc when is_list(key_paths) -&gt;
        Map.put(acc, dest_key, get_value(map, key_paths))
    end)
  end

  @doc &quot;&quot;&quot;
  Converts a map with potentially mixed string/atom keys to one with only atom keys.

  ## Parameters
    - `map` - Source map with string or atom keys
    - `opts` - Options list:
      - `:recursive` - Whether to recursively convert nested maps (default: false)

  ## Returns
    - A new map with atom keys

  ## Examples
      iex&gt; atomize_keys(%{&quot;name&quot; =&gt; &quot;John&quot;, :age =&gt; 30})
      %{name: &quot;John&quot;, age: 30}
  &quot;&quot;&quot;
  @spec atomize_keys(map(), keyword()) :: map()
  def atomize_keys(map, opts \\ []) when is_map(map) do
    recursive = Keyword.get(opts, :recursive, false)

    Enum.reduce(map, %{}, fn
      # Atom key
      {key, value}, acc when is_atom(key) -&gt;
        if recursive and is_map(value) do
          Map.put(acc, key, atomize_keys(value, opts))
        else
          Map.put(acc, key, value)
        end

      # String key
      {key, value}, acc when is_binary(key) -&gt;
        atom_key = String.to_atom(key)

        if recursive and is_map(value) do
          Map.put(acc, atom_key, atomize_keys(value, opts))
        else
          Map.put(acc, atom_key, value)
        end
    end)
  end
end</file><file path="lib/wanderer_notifier/utilities/number_human.ex">defmodule WandererNotifier.Utilities.NumberHuman do
  @moduledoc &quot;&quot;&quot;
  Utility module for formatting numbers in a human-readable way.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Converts a number to a human-readable string with appropriate suffix.

  ## Examples
      iex&gt; number_to_human(1234)
      &quot;1.2K&quot;

      iex&gt; number_to_human(1234567)
      &quot;1.2M&quot;

      iex&gt; number_to_human(1234567890)
      &quot;1.2B&quot;
  &quot;&quot;&quot;
  def number_to_human(number) when is_number(number) do
    cond do
      number &gt;= 1_000_000_000 -&gt; &quot;#{Float.round(number / 1_000_000_000, 1)}B&quot;
      number &gt;= 1_000_000 -&gt; &quot;#{Float.round(number / 1_000_000, 1)}M&quot;
      number &gt;= 1_000 -&gt; &quot;#{Float.round(number / 1_000, 1)}K&quot;
      true -&gt; &quot;#{number}&quot;
    end
  end

  def number_to_human(_), do: &quot;0&quot;
end</file><file path="lib/wanderer_notifier/utilities/time_helpers.ex">defmodule WandererNotifier.Utilities.TimeHelpers do
  @moduledoc &quot;&quot;&quot;
  Common time-related utility functions.
  Used across the application for consistent time formatting and manipulation.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Formats uptime in seconds into a human-readable string.

  ## Examples
      iex&gt; TimeHelpers.format_uptime(3665)
      &quot;1h 1m 5s&quot;
      iex&gt; TimeHelpers.format_uptime(90061)
      &quot;1d 1h 1m 1s&quot;
  &quot;&quot;&quot;
  def format_uptime(seconds) when is_integer(seconds) do
    days = div(seconds, 86_400)
    seconds = rem(seconds, 86_400)
    hours = div(seconds, 3600)
    seconds = rem(seconds, 3600)
    minutes = div(seconds, 60)
    seconds = rem(seconds, 60)

    cond do
      days &gt; 0 -&gt; &quot;#{days}d #{hours}h #{minutes}m #{seconds}s&quot;
      hours &gt; 0 -&gt; &quot;#{hours}h #{minutes}m #{seconds}s&quot;
      minutes &gt; 0 -&gt; &quot;#{minutes}m #{seconds}s&quot;
      true -&gt; &quot;#{seconds}s&quot;
    end
  end

  def format_uptime(_), do: &quot;Unknown&quot;

  @doc &quot;&quot;&quot;
  Formats a DateTime into a human-readable string.

  ## Examples
      iex&gt; TimeHelpers.format_datetime(~U[2024-03-31 10:00:00Z])
      &quot;2024-03-31 10:00:00 UTC&quot;
  &quot;&quot;&quot;
  def format_datetime(%DateTime{} = dt) do
    Calendar.strftime(dt, &quot;%Y-%m-%d %H:%M:%S %Z&quot;)
  end

  def format_datetime(_), do: &quot;Unknown&quot;

  @doc &quot;&quot;&quot;
  Returns the current timestamp in milliseconds since epoch.
  &quot;&quot;&quot;
  def current_timestamp_ms do
    :os.system_time(:millisecond)
  end

  @doc &quot;&quot;&quot;
  Converts a timestamp in milliseconds to a DateTime.

  ## Examples
      iex&gt; TimeHelpers.ms_to_datetime(1711872000000)
      ~U[2024-03-31 10:00:00Z]
  &quot;&quot;&quot;
  def ms_to_datetime(timestamp) when is_integer(timestamp) do
    DateTime.from_unix!(div(timestamp, 1000))
  end

  def ms_to_datetime(_), do: nil
end</file><file path="lib/wanderer_notifier/utilities/type_helpers.ex">defmodule WandererNotifier.Utilities.TypeHelpers do
  @moduledoc &quot;&quot;&quot;
  Common type-related utility functions.
  Used across the application for consistent type checking and formatting.
  &quot;&quot;&quot;

  @doc &quot;&quot;&quot;
  Returns a string representation of a term&apos;s type.
  More detailed than Elixir&apos;s built-in typeof, includes struct names.

  ## Examples
      iex&gt; TypeHelpers.typeof(&quot;hello&quot;)
      &quot;string&quot;
      iex&gt; TypeHelpers.typeof(%MyApp.User{})
      &quot;struct:MyApp.User&quot;
  &quot;&quot;&quot;
  def typeof(nil), do: &quot;nil&quot;
  def typeof(term) when is_binary(term), do: &quot;string&quot;
  def typeof(term) when is_boolean(term), do: &quot;boolean&quot;
  def typeof(term) when is_integer(term), do: &quot;integer&quot;
  def typeof(term) when is_float(term), do: &quot;float&quot;
  def typeof(term) when is_map(term) and not is_struct(term), do: &quot;map&quot;
  def typeof(term) when is_list(term), do: &quot;list&quot;
  def typeof(term) when is_atom(term), do: &quot;atom&quot;
  def typeof(term) when is_function(term), do: &quot;function&quot;
  def typeof(term) when is_pid(term), do: &quot;pid&quot;
  def typeof(term) when is_reference(term), do: &quot;reference&quot;
  def typeof(term) when is_tuple(term), do: &quot;tuple&quot;
  def typeof(term) when is_struct(term), do: &quot;struct:#{term.__struct__}&quot;
  def typeof(_), do: &quot;unknown&quot;

  @doc &quot;&quot;&quot;
  Checks if a term is a struct of a specific type.

  ## Examples
      iex&gt; TypeHelpers.struct_of?(%User{}, User)
      true
      iex&gt; TypeHelpers.struct_of?(%{}, User)
      false
  &quot;&quot;&quot;
  def struct_of?(term, module) when is_atom(module) do
    is_struct(term) and term.__struct__ == module
  end

  def struct_of?(_, _), do: false

  @doc &quot;&quot;&quot;
  Safely extracts a value from a map or struct using a list of possible keys.
  Returns the first found value or the default.

  ## Examples
      iex&gt; TypeHelpers.extract_field_value(%{name: &quot;John&quot;}, [:name, &quot;name&quot;], &quot;Unknown&quot;)
      &quot;John&quot;
      iex&gt; TypeHelpers.extract_field_value(%{&quot;age&quot; =&gt; 30}, [:age, &quot;age&quot;], 0)
      30
  &quot;&quot;&quot;
  def extract_field_value(data, field_names, default \\ nil) do
    Enum.find_value(field_names, default, fn field -&gt;
      cond do
        is_struct(data) and Map.has_key?(data, field) -&gt; Map.get(data, field)
        is_map(data) and Map.has_key?(data, field) -&gt; Map.get(data, field)
        true -&gt; nil
      end
    end)
  end
end</file><file path="lib/wanderer_notifier/web/router.ex">defmodule WandererNotifier.Web.Router do
  @moduledoc &quot;&quot;&quot;
  Web router for the WandererNotifier dashboard.
  &quot;&quot;&quot;
  use Plug.Router
  import Plug.Conn

  alias WandererNotifier.Api.Controllers.{
    HealthController,
    NotificationController,
    WebController
  }

  # Basic request logging
  plug(Plug.Logger)

  # Serve static assets with specific paths first
  plug(Plug.Static,
    at: &quot;/assets&quot;,
    from: {:wanderer_notifier, &quot;priv/static/app/assets&quot;},
    headers: %{
      &quot;access-control-allow-origin&quot; =&gt; &quot;*&quot;,
      &quot;cache-control&quot; =&gt; &quot;public, max-age=0&quot;
    }
  )

  # Serve specific static files
  plug(Plug.Static,
    at: &quot;/&quot;,
    from: :wanderer_notifier,
    only: ~w(favicon.ico robots.txt)
  )

  # Parse request body for JSON API endpoints
  plug(Plug.Parsers,
    parsers: [:json],
    pass: [&quot;application/json&quot;],
    json_decoder: Jason
  )

  # Enable routing
  plug(:match)
  plug(:dispatch)

  # Health check endpoint
  forward(&quot;/health&quot;, to: HealthController)

  # API Routes
  forward(&quot;/api/health&quot;, to: HealthController)
  forward(&quot;/api/notifications&quot;, to: NotificationController)
  forward(&quot;/api/debug&quot;, to: WebController)

  # React app routes
  get &quot;/schedulers&quot; do
    send_file(conn, 200, &quot;priv/static/app/index.html&quot;)
  end

  get &quot;/charts&quot; do
    send_file(conn, 200, &quot;priv/static/app/index.html&quot;)
  end

  get &quot;/kill-comparison&quot; do
    send_file(conn, 200, &quot;priv/static/app/index.html&quot;)
  end

  # Catch-all route for SPA
  get &quot;/*path&quot; do
    send_file(conn, 200, &quot;priv/static/app/index.html&quot;)
  end

  # 404 handler
  match _ do
    send_resp(conn, 404, &quot;Not found&quot;)
  end
end</file><file path="lib/wanderer_notifier/web/server.ex">defmodule WandererNotifier.Web.Server do
  @moduledoc &quot;&quot;&quot;
  Web server for the WandererNotifier dashboard.
  &quot;&quot;&quot;
  use GenServer
  require Logger

  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Web.Router
  # Client API

  @doc &quot;&quot;&quot;
  Starts the web server.
  &quot;&quot;&quot;
  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  # Server Implementation

  @impl true
  def init(_opts) do
    # Get port from configuration
    port = WandererNotifier.Config.port()

    AppLogger.startup_debug(&quot;Starting web server&quot;, port: port)

    case start_server(port) do
      {:ok, pid} -&gt;
        AppLogger.startup_info(&quot; Web server ready on port #{port}&quot;)
        {:ok, %{server_pid: pid, port: port}}

      {:error, reason} -&gt;
        AppLogger.startup_error(&quot; Failed to start web server&quot;, error: inspect(reason))
        {:stop, reason}
    end
  end

  @impl true
  def terminate(_reason, %{server_pid: pid}) do
    AppLogger.startup_debug(&quot;Stopping web server&quot;)

    if Process.alive?(pid) do
      Process.exit(pid, :normal)
    end

    :ok
  end

  # Helper functions

  defp start_server(port) when is_integer(port) do
    Plug.Cowboy.http(Router, [], port: port, ip: {0, 0, 0, 0})
  end
end</file><file path="lib/wanderer_notifier/zkill/websocket.ex">defmodule WandererNotifier.ZKill.Websocket do
  @moduledoc &quot;&quot;&quot;
  WebSocket client for zKillboard&apos;s WebSocket API.

  - Immediately subscribes upon connection by scheduling a :subscribe message
  - Uses heartbeat (pong) response after receiving a ping
  - Returns {:reconnect, state} on disconnect to leverage built-in auto-reconnect
  &quot;&quot;&quot;
  use WebSockex
  alias WandererNotifier.Core.Stats
  alias WandererNotifier.Logger.Logger, as: AppLogger

  def init_batch_logging do
    AppLogger.init_batch_logger()
  end

  def get_config do
    Application.get_env(:wanderer_notifier, :websocket, [])
  end

  def default_url, do: get_config()[:url] || &quot;wss://zkillboard.com/websocket/&quot;
  def max_reconnects, do: get_config()[:max_reconnects] || 20
  def reconnect_window, do: get_config()[:reconnect_window] || 3600

  def start_link(parent, url \\ nil) do
    init_batch_logging()
    url = url || default_url()
    AppLogger.websocket_info(&quot;Starting WebSocket connection&quot;, url: url)

    case WebSockex.start_link(
           url,
           __MODULE__,
           %{
             parent: parent,
             connected: false,
             reconnects: 0,
             reconnect_history: [],
             circuit_open: false,
             last_circuit_reset: System.os_time(:second),
             url: url,
             startup_time: System.os_time(:second)
           },
           retry_initial_connection: true
         ) do
      {:ok, pid} -&gt;
        AppLogger.websocket_info(&quot; WebSocket connected successfully&quot;)
        {:ok, pid}

      {:error, reason} -&gt;
        AppLogger.websocket_error(&quot; Connection failed&quot;, error: inspect(reason))
        {:error, reason}
    end
  end

  def init(state) do
    AppLogger.websocket_info(&quot;Initializing WebSocket client&quot;, url: state.url)

    state =
      Map.merge(state, %{
        max_reconnects: max_reconnects(),
        reconnect_window: reconnect_window()
      })

    update_startup_status()
    Process.send_after(self(), :check_heartbeat, 60_000)
    {:ok, state}
  end

  defp update_startup_status do
    Stats.update_websocket(%{
      connected: false,
      connecting: true,
      startup_time: DateTime.utc_now(),
      last_message: nil,
      reconnects: 0,
      url: default_url()
    })

    :ok
  rescue
    e -&gt;
      AppLogger.websocket_warn(&quot;Stats service not ready for status update&quot;,
        error: Exception.message(e)
      )

      :ok
  catch
    kind, error -&gt;
      AppLogger.websocket_warn(&quot;Stats service not ready for status update&quot;, error: {kind, error})
      :ok
  end

  @impl true
  def handle_connect(_conn, state) do
    AppLogger.websocket_info(&quot;Connected to killstream websocket&quot;)
    now = DateTime.utc_now()
    startup_time = state.startup_time || System.os_time(:second)
    new_state = %{state | connected: true, startup_time: startup_time}

    Stats.update_websocket(%{
      connected: true,
      connecting: false,
      last_message: now,
      startup_time: DateTime.from_unix!(startup_time),
      reconnects: new_state.reconnects,
      url: new_state.url,
      last_disconnect: nil
    })

    Process.send_after(self(), :subscribe, 100)
    {:ok, new_state}
  end

  @impl true
  def handle_info(:subscribe, state) do
    msg = Jason.encode!(%{&quot;action&quot; =&gt; &quot;sub&quot;, &quot;channel&quot; =&gt; &quot;killstream&quot;})
    AppLogger.websocket_info(&quot;Subscribing to killstream channel&quot;)
    {:reply, {:text, msg}, state}
  end

  @impl true
  def handle_info(:check_heartbeat, state) do
    stats = Stats.get_stats()
    last_message_time = stats.websocket.last_message
    now = DateTime.utc_now()

    no_messages =
      case last_message_time do
        nil -&gt; true
        time -&gt; DateTime.diff(now, time, :second) &gt; 300
      end

    if no_messages &amp;&amp; state.connected do
      AppLogger.websocket_warn(&quot;No messages received in over 5 minutes&quot;,
        status: &quot;connection_stale&quot;
      )

      AppLogger.websocket_debug(&quot;Sending manual ping to test connection&quot;)

      case WebSockex.send_frame(self(), :ping) do
        :ok -&gt;
          AppLogger.websocket_debug(&quot;Manual ping sent successfully&quot;)

        {:error, reason} -&gt;
          AppLogger.websocket_error(&quot;Failed to send manual ping&quot;, error: inspect(reason))
          Process.send_after(self(), :force_reconnect, 1000)
      end
    else
      AppLogger.count_batch_event(:websocket_heartbeat, %{status: &quot;ok&quot;})
    end

    Process.send_after(self(), :check_heartbeat, 60_000)
    {:ok, state}
  end

  @impl true
  def handle_info(:force_reconnect, state) do
    AppLogger.websocket_warn(&quot;Forcing reconnection&quot;, reason: &quot;heartbeat_failure&quot;)
    {:close, state}
  end

  @impl true
  def handle_frame(frame, state) do
    case frame do
      {:text, raw_msg} -&gt;
        process_text_frame(raw_msg, state)

      {:binary, data} -&gt;
        AppLogger.count_batch_event(:websocket_binary_frame, %{size_bytes: byte_size(data)})
        {:ok, state}

      {:ping, ping_frame} -&gt;
        handle_ping_frame(ping_frame, state)

      _ -&gt;
        AppLogger.websocket_debug(&quot;Received unexpected frame type&quot;, frame: inspect(frame))
        {:ok, state}
    end
  rescue
    e -&gt;
      AppLogger.websocket_error(&quot;Error processing frame&quot;,
        error: Exception.message(e),
        stacktrace: Exception.format_stacktrace(__STACKTRACE__)
      )

      {:ok, state}
  end

  defp handle_ping_frame(ping_frame, state) do
    is_standard = ping_frame == &quot;ping&quot;

    if is_standard do
      AppLogger.count_batch_event(:websocket_ping, %{format: &quot;standard&quot;})
    else
      AppLogger.websocket_debug(&quot;Received non-standard ping&quot;, content: inspect(ping_frame))
    end

    payload = Jason.encode!(%{&quot;action&quot; =&gt; &quot;pong&quot;})
    {:reply, {:text, payload}, state}
  end

  defp process_text_frame(raw_msg, state) do
    now = DateTime.utc_now()

    try do
      current_stats = Stats.get_stats()

      Stats.update_websocket(%{
        connected: true,
        connecting: false,
        last_message: now,
        startup_time: current_stats.websocket.startup_time || state.startup_time,
        reconnects: state.reconnects,
        url: state.url
      })
    rescue
      e -&gt;
        AppLogger.websocket_error(&quot;Failed to update websocket status&quot;,
          error: Exception.message(e),
          stacktrace: Exception.format_stacktrace(__STACKTRACE__)
        )
    end

    case Jason.decode(raw_msg, keys: :strings) do
      {:ok, json_data} -&gt;
        message_type = classify_message_type(json_data)
        AppLogger.count_batch_event(:websocket_message, %{type: message_type})

        if is_pid(state.parent) and Process.alive?(state.parent) do
          send(state.parent, {:zkill_message, raw_msg})
          {:ok, state}
        else
          AppLogger.websocket_warn(&quot;Parent process unavailable, message dropped&quot;)
          {:ok, state}
        end

      {:error, decode_err} -&gt;
        AppLogger.websocket_error(&quot;Error decoding JSON frame&quot;,
          error: inspect(decode_err),
          raw_message: String.slice(raw_msg, 0, 100)
        )

        {:ok, state}
    end
  end

  defp classify_message_type(json_data) when is_map(json_data) do
    cond do
      Map.has_key?(json_data, &quot;action&quot;) &amp;&amp; json_data[&quot;action&quot;] == &quot;tqStatus&quot; -&gt;
        &quot;tq_status&quot;

      Map.has_key?(json_data, &quot;zkb&quot;) -&gt;
        &quot;killmail&quot;

      Map.has_key?(json_data, &quot;killmail_id&quot;) -&gt;
        &quot;killmail&quot;

      true -&gt;
        &quot;unknown&quot;
    end
  end

  defp classify_message_type(_), do: &quot;invalid&quot;

  @impl true
  def handle_disconnect(disconnect_map, state) do
    new_state =
      state
      |&gt; increment_reconnect_count
      |&gt; check_circuit_breaker

    if new_state.circuit_open do
      AppLogger.websocket_error(&quot;Circuit breaker open, reconnection stopped&quot;,
        reason: inspect(disconnect_map),
        reconnect_count: new_state.reconnects
      )

      Stats.update_websocket(%{
        connected: false,
        connecting: false,
        last_message: state.last_message,
        startup_time: state.startup_time,
        reconnects: new_state.reconnects,
        url: state.url,
        last_disconnect: DateTime.utc_now()
      })

      {:error, new_state}
    else
      delay = calculate_reconnect_delay(new_state.reconnects)

      AppLogger.websocket_warn(&quot;Disconnected, reconnecting&quot;,
        reason: inspect(disconnect_map),
        reconnect_attempts: new_state.reconnects,
        delay_ms: delay
      )

      Stats.update_websocket(%{
        connected: false,
        connecting: true,
        last_message: state.last_message,
        startup_time: state.startup_time,
        reconnects: new_state.reconnects,
        url: state.url,
        last_disconnect: DateTime.utc_now()
      })

      {:reconnect, %{new_state | connected: false}}
    end
  end

  defp increment_reconnect_count(state) do
    current_time = System.os_time(:second)
    new_history = [current_time | state.reconnect_history]
    window_start = current_time - state.reconnect_window
    filtered_history = Enum.filter(new_history, fn time -&gt; time &gt;= window_start end)
    %{state | reconnects: state.reconnects + 1, reconnect_history: filtered_history}
  end

  defp check_circuit_breaker(state) do
    current_time = System.os_time(:second)
    recent_reconnects = Enum.count(state.reconnect_history)
    time_since_reset = current_time - state.last_circuit_reset

    should_open_circuit =
      recent_reconnects &gt;= max_reconnects() &amp;&amp;
        time_since_reset &gt;= 600

    if should_open_circuit do
      AppLogger.websocket_error(&quot;Circuit breaker triggered&quot;,
        reconnect_count: recent_reconnects,
        minutes_since_reset: Float.round(time_since_reset / 60, 1)
      )

      %{state | circuit_open: true}
    else
      if time_since_reset &gt;= 86_400 do
        AppLogger.websocket_info(&quot;Resetting circuit breaker&quot;,
          previous_reconnect_count: state.reconnects
        )

        %{state | reconnects: 0, last_circuit_reset: current_time}
      else
        state
      end
    end
  end

  defp calculate_reconnect_delay(reconnect_count) do
    base_delay = 500
    delay = :math.pow(1.5, min(reconnect_count, 10)) * base_delay
    jitter = :rand.uniform() * 0.5 - 0.25
    delay_with_jitter = delay * (1 + jitter)
    trunc(min(delay_with_jitter, 120_000))
  end

  @impl true
  def terminate(reason, state) do
    AppLogger.websocket_info(&quot;WebSocket terminating&quot;,
      reason: inspect(reason),
      connected: state.connected,
      reconnects: state.reconnects,
      circuit_open: state.circuit_open
    )

    :ok
  end
end</file><file path="lib/wanderer_notifier/application.ex">defmodule WandererNotifier.NoopConsumer do
  @moduledoc &quot;&quot;&quot;
  A minimal Discord consumer that ignores all events.
  Used during application startup and testing to satisfy Nostrum requirements.
  &quot;&quot;&quot;
  use Nostrum.Consumer

  @impl true
  def handle_event(_event), do: :ok
end

defmodule WandererNotifier.Application do
  @moduledoc &quot;&quot;&quot;
  Application module for WandererNotifier.
  Handles application startup and environment configuration.
  &quot;&quot;&quot;

  use Application

  alias WandererNotifier.Logger.Logger, as: AppLogger
  alias WandererNotifier.Killmail.Metrics

  @doc &quot;&quot;&quot;
  Starts the WandererNotifier application.
  &quot;&quot;&quot;
  def start(_type, _args) do
    AppLogger.startup_info(&quot;Starting WandererNotifier&quot;)

    # Initialize metric registry (not as a supervised child)
    initialize_metric_registry()

    children = [
      {WandererNotifier.NoopConsumer, []},
      {Cachex, name: :wanderer_cache},
      {Metrics, []},
      {WandererNotifier.Core.Stats, []},
      {WandererNotifier.License.Service, []},
      {WandererNotifier.Core.Application.Service, []},
      WandererNotifier.Schedulers.Supervisor
      # Add other children here
    ]

    opts = [strategy: :one_for_one, name: WandererNotifier.Supervisor]
    Supervisor.start_link(children, opts)
  end

  defp initialize_metric_registry do
    case WandererNotifier.Killmail.MetricRegistry.initialize() do
      {:ok, atoms} -&gt;
        AppLogger.log_startup_state_change(
          :metric_registry,
          &quot;Metric registry initialized successfully&quot;,
          %{metric_count: length(atoms)}
        )

        :ok

      error -&gt;
        AppLogger.startup_error(&quot;Failed to initialize metric registry&quot;, error: inspect(error))
        error
    end
  end

  @doc &quot;&quot;&quot;
  Gets the current environment.
  &quot;&quot;&quot;
  def get_env do
    Application.get_env(:wanderer_notifier, :environment, :dev)
  end

  @doc &quot;&quot;&quot;
  Gets a configuration value for the given key.
  &quot;&quot;&quot;
  def get_env(key, default \\ nil) do
    Application.get_env(:wanderer_notifier, key, default)
  end

  @doc &quot;&quot;&quot;
  Gets a configuration value for the given key and module.
  &quot;&quot;&quot;
  def get_env(module, key, default) do
    Application.get_env(module, key, default)
  end

  @doc &quot;&quot;&quot;
  Reloads modules.
  &quot;&quot;&quot;
  def reload(modules) do
    AppLogger.config_info(&quot;Reloading modules&quot;, modules: inspect(modules))
    Code.compiler_options(ignore_module_conflict: true)

    Enum.each(modules, fn module -&gt;
      :code.purge(module)
      :code.delete(module)
      :code.load_file(module)
    end)

    AppLogger.config_info(&quot;Module reload complete&quot;)
    {:ok, modules}
  rescue
    error -&gt;
      AppLogger.config_error(&quot;Error reloading modules&quot;, error: inspect(error))
      {:error, error}
  end
end</file><file path="rel/overlays/env.bat">@echo off

rem Environment variables for Wanderer Notifier
rem This script supports both the legacy and new naming conventions

rem Core Discord configuration
if not defined WANDERER_DISCORD_BOT_TOKEN (
  if defined DISCORD_BOT_TOKEN (
    set WANDERER_DISCORD_BOT_TOKEN=%DISCORD_BOT_TOKEN%
  ) else (
    set WANDERER_DISCORD_BOT_TOKEN=
  )
) else (
  set DISCORD_BOT_TOKEN=%WANDERER_DISCORD_BOT_TOKEN%
)

if not defined WANDERER_DISCORD_CHANNEL_ID (
  if defined DISCORD_CHANNEL_ID (
    set WANDERER_DISCORD_CHANNEL_ID=%DISCORD_CHANNEL_ID%
  ) else (
    set WANDERER_DISCORD_CHANNEL_ID=
  )
) else (
  set DISCORD_CHANNEL_ID=%WANDERER_DISCORD_CHANNEL_ID%
)

rem License configuration
if not defined WANDERER_LICENSE_KEY (
  if defined LICENSE_KEY (
    set WANDERER_LICENSE_KEY=%LICENSE_KEY%
  ) else (
    set WANDERER_LICENSE_KEY=
  )
) else (
  set LICENSE_KEY=%WANDERER_LICENSE_KEY%
)

rem Map configuration
if not defined WANDERER_MAP_URL (
  if defined MAP_URL (
    set WANDERER_MAP_URL=%MAP_URL%
  ) else if defined MAP_URL_WITH_NAME (
    set WANDERER_MAP_URL=%MAP_URL_WITH_NAME%
  ) else (
    set WANDERER_MAP_URL=
  )
) else (
  set MAP_URL=%WANDERER_MAP_URL%
  set MAP_URL_WITH_NAME=%WANDERER_MAP_URL%
)

if not defined WANDERER_MAP_TOKEN (
  if defined MAP_TOKEN (
    set WANDERER_MAP_TOKEN=%MAP_TOKEN%
  ) else (
    set WANDERER_MAP_TOKEN=
  )
) else (
  set MAP_TOKEN=%WANDERER_MAP_TOKEN%
)

rem Web server configuration
if not defined WANDERER_PORT (
  if defined PORT (
    set WANDERER_PORT=%PORT%
  ) else (
    set WANDERER_PORT=4000
  )
) else (
  set PORT=%WANDERER_PORT%
)

if not defined WANDERER_HOST (
  if defined HOST (
    set WANDERER_HOST=%HOST%
  ) else (
    set WANDERER_HOST=0.0.0.0
  )
) else (
  set HOST=%WANDERER_HOST%
)

if not defined WANDERER_SCHEME (
  if defined SCHEME (
    set WANDERER_SCHEME=%SCHEME%
  ) else (
    set WANDERER_SCHEME=http
  )
) else (
  set SCHEME=%WANDERER_SCHEME%
)

rem Database configuration
if not defined WANDERER_DB_USER (
  if defined POSTGRES_USER (
    set WANDERER_DB_USER=%POSTGRES_USER%
  ) else (
    set WANDERER_DB_USER=postgres
  )
) else (
  set POSTGRES_USER=%WANDERER_DB_USER%
)

if not defined WANDERER_DB_PASSWORD (
  if defined POSTGRES_PASSWORD (
    set WANDERER_DB_PASSWORD=%POSTGRES_PASSWORD%
  ) else (
    set WANDERER_DB_PASSWORD=postgres
  )
) else (
  set POSTGRES_PASSWORD=%WANDERER_DB_PASSWORD%
)

if not defined WANDERER_DB_HOST (
  if defined POSTGRES_HOST (
    set WANDERER_DB_HOST=%POSTGRES_HOST%
  ) else (
    set WANDERER_DB_HOST=postgres
  )
) else (
  set POSTGRES_HOST=%WANDERER_DB_HOST%
)

if not defined WANDERER_DB_NAME (
  if defined POSTGRES_DB (
    set WANDERER_DB_NAME=%POSTGRES_DB%
  ) else (
    set WANDERER_DB_NAME=wanderer_notifier
  )
) else (
  set POSTGRES_DB=%WANDERER_DB_NAME%
)

if not defined WANDERER_DB_PORT (
  if defined POSTGRES_PORT (
    set WANDERER_DB_PORT=%POSTGRES_PORT%
  ) else (
    set WANDERER_DB_PORT=5432
  )
) else (
  set POSTGRES_PORT=%WANDERER_DB_PORT%
)

rem Config path for release configuration
set CONFIG_PATH=/app/etc

rem Set environment
set MIX_ENV=prod

rem Optional: Set the timezone
if not defined TZ set TZ=UTC</file><file path="rel/overlays/env.sh">#!/bin/sh

# Environment variables for Wanderer Notifier
# This script supports both the legacy and new naming conventions

# Core Discord configuration
export DISCORD_BOT_TOKEN=&quot;${WANDERER_DISCORD_BOT_TOKEN:-${DISCORD_BOT_TOKEN:-}}&quot;
export WANDERER_DISCORD_BOT_TOKEN=&quot;${WANDERER_DISCORD_BOT_TOKEN:-${DISCORD_BOT_TOKEN:-}}&quot;
export DISCORD_CHANNEL_ID=&quot;${WANDERER_DISCORD_CHANNEL_ID:-${DISCORD_CHANNEL_ID:-}}&quot;
export WANDERER_DISCORD_CHANNEL_ID=&quot;${WANDERER_DISCORD_CHANNEL_ID:-${DISCORD_CHANNEL_ID:-}}&quot;

# License configuration
export LICENSE_KEY=&quot;${WANDERER_LICENSE_KEY:-${LICENSE_KEY:-}}&quot;
export WANDERER_LICENSE_KEY=&quot;${WANDERER_LICENSE_KEY:-${LICENSE_KEY:-}}&quot;

# Map configuration
export MAP_URL=&quot;${WANDERER_MAP_URL:-${MAP_URL:-}}&quot;
export WANDERER_MAP_URL=&quot;${WANDERER_MAP_URL:-${MAP_URL:-}}&quot;
export MAP_TOKEN=&quot;${WANDERER_MAP_TOKEN:-${MAP_TOKEN:-}}&quot;
export WANDERER_MAP_TOKEN=&quot;${WANDERER_MAP_TOKEN:-${MAP_TOKEN:-}}&quot;
export MAP_URL_WITH_NAME=&quot;${WANDERER_MAP_URL:-${MAP_URL_WITH_NAME:-}}&quot;
export WANDERER_MAP_URL=&quot;${WANDERER_MAP_URL:-${MAP_URL_WITH_NAME:-}}&quot;

# Web server configuration
export PORT=&quot;${WANDERER_PORT:-${PORT:-4000}}&quot;
export WANDERER_PORT=&quot;${WANDERER_PORT:-${PORT:-4000}}&quot;
export HOST=&quot;${WANDERER_HOST:-${HOST:-0.0.0.0}}&quot;
export WANDERER_HOST=&quot;${WANDERER_HOST:-${HOST:-0.0.0.0}}&quot;
export SCHEME=&quot;${WANDERER_SCHEME:-${SCHEME:-http}}&quot;
export WANDERER_SCHEME=&quot;${WANDERER_SCHEME:-${SCHEME:-http}}&quot;

# Database configuration
export POSTGRES_USER=&quot;${WANDERER_DB_USER:-${POSTGRES_USER:-postgres}}&quot;
export WANDERER_DB_USER=&quot;${WANDERER_DB_USER:-${POSTGRES_USER:-postgres}}&quot;
export POSTGRES_PASSWORD=&quot;${WANDERER_DB_PASSWORD:-${POSTGRES_PASSWORD:-postgres}}&quot;
export WANDERER_DB_PASSWORD=&quot;${WANDERER_DB_PASSWORD:-${POSTGRES_PASSWORD:-postgres}}&quot;
export POSTGRES_HOST=&quot;${WANDERER_DB_HOST:-${POSTGRES_HOST:-postgres}}&quot;
export WANDERER_DB_HOST=&quot;${WANDERER_DB_HOST:-${POSTGRES_HOST:-postgres}}&quot;
export POSTGRES_DB=&quot;${WANDERER_DB_NAME:-${POSTGRES_DB:-wanderer_notifier}}&quot;
export WANDERER_DB_NAME=&quot;${WANDERER_DB_NAME:-${POSTGRES_DB:-wanderer_notifier}}&quot;
export POSTGRES_PORT=&quot;${WANDERER_DB_PORT:-${POSTGRES_PORT:-5432}}&quot;
export WANDERER_DB_PORT=&quot;${WANDERER_DB_PORT:-${POSTGRES_PORT:-5432}}&quot;

# Feature flags
export ENABLE_KILL_CHARTS=&quot;${WANDERER_FEATURE_KILL_CHARTS:-${ENABLE_KILL_CHARTS:-false}}&quot;
export WANDERER_FEATURE_KILL_CHARTS=&quot;${WANDERER_FEATURE_KILL_CHARTS:-${ENABLE_KILL_CHARTS:-false}}&quot;
export ENABLE_MAP_CHARTS=&quot;${WANDERER_FEATURE_MAP_CHARTS:-${ENABLE_MAP_CHARTS:-false}}&quot;
export WANDERER_FEATURE_MAP_CHARTS=&quot;${WANDERER_FEATURE_MAP_CHARTS:-${ENABLE_MAP_CHARTS:-false}}&quot;
export ENABLE_TRACK_KSPACE_SYSTEMS=&quot;${WANDERER_FEATURE_TRACK_KSPACE:-${ENABLE_TRACK_KSPACE_SYSTEMS:-true}}&quot;
export WANDERER_FEATURE_TRACK_KSPACE=&quot;${WANDERER_FEATURE_TRACK_KSPACE:-${ENABLE_TRACK_KSPACE_SYSTEMS:-true}}&quot;

# Cache configuration
export CACHE_DIR=&quot;${WANDERER_CACHE_DIR:-${CACHE_DIR:-/app/data/cache}}&quot;
export WANDERER_CACHE_DIR=&quot;${WANDERER_CACHE_DIR:-${CACHE_DIR:-/app/data/cache}}&quot;

# Application configuration
export MIX_ENV=prod
export LANG=&quot;${LANG:-en_US.UTF-8}&quot;
export TZ=&quot;${TZ:-UTC}&quot;
export CONFIG_PATH=&quot;/app/etc&quot;

# API token handling
if [ &quot;${MIX_ENV}&quot; = &quot;prod&quot; ]; then
  # In production mode
  if [ -n &quot;${WANDERER_NOTIFIER_API_TOKEN}&quot; ] || [ -n &quot;${NOTIFIER_API_TOKEN}&quot; ]; then
    # If environment variables are set, use them (security override)
    export NOTIFIER_API_TOKEN=&quot;${WANDERER_NOTIFIER_API_TOKEN:-${NOTIFIER_API_TOKEN}}&quot;
    export WANDERER_NOTIFIER_API_TOKEN=&quot;${WANDERER_NOTIFIER_API_TOKEN:-${NOTIFIER_API_TOKEN}}&quot;
    echo &quot;Using API token from environment variable&quot;
  else
    # Otherwise, clear token environment variables to use baked-in value
    echo &quot;Using baked-in API token from release configuration&quot;
    unset NOTIFIER_API_TOKEN
    unset WANDERER_NOTIFIER_API_TOKEN
  fi
else
  # In development mode, ensure both variables are set for compatibility
  export NOTIFIER_API_TOKEN=&quot;${WANDERER_NOTIFIER_API_TOKEN:-${NOTIFIER_API_TOKEN:-}}&quot;
  export WANDERER_NOTIFIER_API_TOKEN=&quot;${WANDERER_NOTIFIER_API_TOKEN:-${NOTIFIER_API_TOKEN:-}}&quot;
fi</file><file path="rel/overlays/sys.config">[
  {wanderer_notifier, [
    % This file provides minimal configuration for the release 
    % The full configuration will be loaded from the CONFIG_PATH location
    % by the config provider specified in mix.exs
  ]},
  {kernel, [
    {logger_level, info}
  ]}
].</file><file path="rel/overlays/wanderer_notifier.service">[Unit]
Description=WandererNotifier Discord Bot
After=network.target

[Service]
Type=simple
User=wanderer
Group=wanderer
WorkingDirectory=/opt/wanderer_notifier
Environment=LANG=en_US.UTF-8
Environment=MIX_ENV=prod
EnvironmentFile=/opt/wanderer_notifier/etc/environment
ExecStart=/opt/wanderer_notifier/bin/wanderer_notifier start
ExecStop=/opt/wanderer_notifier/bin/wanderer_notifier stop
Restart=on-failure
RestartSec=5
RemainAfterExit=no
SyslogIdentifier=wanderer_notifier

# Increase security
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=true

[Install]
WantedBy=multi-user.target</file><file path="renderer/src/components/ActivityChartCard.jsx">import React, { useState, useEffect } from &apos;react&apos;;
import { FaCircleNotch, FaDiscord, FaExclamationTriangle, FaBug, FaSync, FaPlus } from &apos;react-icons/fa&apos;;

function ActivityChartCard({ title, description, chartType }) {
  const [chartUrl, setChartUrl] = useState(null);
  const [loading, setLoading] = useState(false);
  const [sending, setSending] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  const [debugInfo, setDebugInfo] = useState(null);
  const [retryCount, setRetryCount] = useState(0);

  // Cleanup function for blob URLs
  const cleanupBlobUrl = (url) =&gt; {
    if (url &amp;&amp; url.startsWith(&apos;blob:&apos;)) {
      URL.revokeObjectURL(url);
    }
  };

  const generateChart = async (forceRefresh = false) =&gt; {
    setLoading(true);
    setError(null);
    setDebugInfo(null);
    
    // Cleanup previous blob URL if it exists
    cleanupBlobUrl(chartUrl);
    
    // Only add timestamp when explicitly forcing a refresh
    const timestamp = forceRefresh ? `?t=${Date.now()}` : &apos;&apos;;
    console.log(`Fetching chart for ${chartType}${forceRefresh ? &apos; (force refresh)&apos; : &apos;&apos;}...`);
    
    try {
      const response = await fetch(`/api/charts/activity/generate/${chartType}${timestamp}`);
      console.log(`Response status: ${response.status}`);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const blob = await response.blob();
      const imageUrl = URL.createObjectURL(blob);
      setChartUrl(imageUrl);
      console.log(&apos;Chart image blob URL created&apos;);
      setRetryCount(0);
    } catch (error) {
      console.error(`Error generating ${chartType} chart:`, error);
      setError(error.message);
      if (retryCount &lt; 2) {
        console.log(`Auto-retrying (attempt ${retryCount + 1})...`);
        const timeout = Math.pow(2, retryCount) * 1000;
        setTimeout(() =&gt; {
          setRetryCount(prev =&gt; prev + 1);
          generateChart(true);
        }, timeout);
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() =&gt; {
    // Only generate chart on initial load
    generateChart(false);
    // Cleanup blob URL when component unmounts
    return () =&gt; cleanupBlobUrl(chartUrl);
  }, [chartType]);

  const sendToDiscord = () =&gt; {
    setSending(true);
    setSuccess(null);
    setError(null);
    
    console.log(&apos;Sending chart to Discord...&apos;);
    
    fetch(`/api/charts/activity/send-to-discord/${chartType}`)
      .then(response =&gt; {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data =&gt; {
        if (data.status === &apos;ok&apos;) {
          setSuccess(&apos;Chart sent to Discord!&apos;);
          setTimeout(() =&gt; setSuccess(null), 5000);
        } else {
          throw new Error(data.message || &apos;Failed to send chart to Discord&apos;);
        }
      })
      .catch(error =&gt; {
        console.error(&apos;Error sending chart to Discord:&apos;, error);
        setError(`Failed to send chart: ${error.message}`);
      })
      .finally(() =&gt; {
        setSending(false);
      });
  };

  const retryWithDirectUrl = () =&gt; {
    setRetryCount(0);
    generateChart(true);
  };

  return (
    &lt;div className=&quot;bg-white rounded-lg shadow-md overflow-hidden&quot;&gt;
      &lt;div className=&quot;p-4 border-b&quot;&gt;
        &lt;h2 className=&quot;text-xl font-semibold text-gray-800&quot;&gt;{title}&lt;/h2&gt;
        &lt;p className=&quot;text-gray-600 text-sm mt-1&quot;&gt;{description}&lt;/p&gt;
      &lt;/div&gt;

      &lt;div className=&quot;relative bg-black rounded-lg overflow-hidden&quot;&gt;
        {loading ? (
          &lt;div className=&quot;flex items-center justify-center h-64&quot;&gt;
            &lt;FaCircleNotch className=&quot;h-8 w-8 text-gray-400 animate-spin&quot; /&gt;
          &lt;/div&gt;
        ) : chartUrl ? (
          &lt;img
            src={chartUrl}
            alt={title}
            className=&quot;w-full h-auto&quot;
            onError={(e) =&gt; {
              console.error(&apos;Error loading chart image&apos;);
              setError(&apos;Failed to load chart image&apos;);
              e.target.style.display = &apos;none&apos;;
            }}
          /&gt;
        ) : (
          &lt;div className=&quot;flex items-center justify-center h-64 text-gray-500&quot;&gt;
            No chart available
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      {/* Debug Information */}
      {debugInfo &amp;&amp; (
        &lt;div className=&quot;mt-4&quot;&gt;
          &lt;button
            className=&quot;flex items-center text-sm text-gray-600 hover:text-gray-800&quot;
            onClick={() =&gt; setDebugInfo(null)}
          &gt;
            &lt;FaBug className=&quot;mr-1&quot; /&gt;
            &lt;span&gt;Debug Info&lt;/span&gt;
          &lt;/button&gt;
          &lt;pre className=&quot;mt-2 p-2 bg-gray-50 rounded text-xs overflow-x-auto&quot;&gt;
            {debugInfo}
          &lt;/pre&gt;
        &lt;/div&gt;
      )}

      {/* Error Message */}
      {error &amp;&amp; (
        &lt;div className=&quot;p-4 bg-red-50 text-red-700 flex items-center&quot;&gt;
          &lt;FaExclamationTriangle className=&quot;mr-2&quot; /&gt;
          &lt;span&gt;{error}&lt;/span&gt;
        &lt;/div&gt;
      )}

      {/* Success Message */}
      {success &amp;&amp; (
        &lt;div className=&quot;p-4 bg-green-50 text-green-700&quot;&gt;
          {success}
        &lt;/div&gt;
      )}

      {/* Action Buttons */}
      &lt;div className=&quot;p-4 border-t bg-gray-50 flex justify-between&quot;&gt;
        &lt;button
          onClick={retryWithDirectUrl}
          className=&quot;flex items-center px-3 py-2 bg-blue-50 text-blue-600 rounded hover:bg-blue-100 transition duration-200&quot;
          disabled={loading}
        &gt;
          &lt;FaSync className={`mr-2 ${loading ? &apos;animate-spin&apos; : &apos;&apos;}`} /&gt;
          &lt;span&gt;Refresh&lt;/span&gt;
        &lt;/button&gt;
        
        &lt;button
          onClick={sendToDiscord}
          className=&quot;flex items-center px-3 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition duration-200&quot;
          disabled={sending || loading || !chartUrl}
        &gt;
          &lt;FaDiscord className=&quot;mr-2&quot; /&gt;
          &lt;span&gt;{sending ? &apos;Sending...&apos; : &apos;Send to Discord&apos;}&lt;/span&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default ActivityChartCard;</file><file path="renderer/src/components/CharacterKillsCard.jsx">import React, { useState, useEffect } from &apos;react&apos;;
import { 
  FaCircleNotch, 
  FaUsers,
  FaCheckCircle,
  FaExclamationTriangle,
  FaInfoCircle,
  FaChartBar,
  FaCalendarAlt,
  FaRegCalendar,
  FaBug,
  FaHammer,
  FaSync,
  FaCaretDown,
  FaCaretUp
} from &apos;react-icons/fa&apos;;

function CharacterKillsCard({ title = &quot;Debug Functions&quot;, description = &quot;use with caution&quot; }) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  const [stats, setStats] = useState(null);
  const [trackedInfo, setTrackedInfo] = useState(null);
  const [loadingInfo, setLoadingInfo] = useState(false);
  const [aggregating, setAggregating] = useState(false);
  const [aggregationInfo, setAggregationInfo] = useState(null);
  const [aggregationStats, setAggregationStats] = useState(null);
  const [debugData, setDebugData] = useState(null);
  const [debugInfo, setDebugInfo] = useState(null);
  const [forceSyncing, setForceSyncing] = useState(false);
  const [showCharacters, setShowCharacters] = useState(false);

  useEffect(() =&gt; {
    fetchTrackedInfo();
    fetchAggregationStats();
  }, []);

  const fetchTrackedInfo = async () =&gt; {
    try {
      setLoadingInfo(true);
      const response = await fetch(`/api/character-kills/stats`);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      setTrackedInfo(data);
      console.log(&quot;Tracked info loaded:&quot;, data);
    } catch (error) {
      console.error(&apos;Error fetching tracked info:&apos;, error);
    } finally {
      setLoadingInfo(false);
    }
  };

  const fetchAggregationStats = async () =&gt; {
    try {
      const response = await fetch(`/api/charts/killmail/debug`);
      if (!response.ok) {
        console.log(`Aggregation stats not available: ${response.status}`);
        return;
      }
      const data = await response.json();
      if (data.status === &apos;ok&apos;) {
        setAggregationStats({
          aggregated_characters: data.data.counts.tracked_characters_db || 0,
          total_stats: data.data.counts.statistics || 0,
          periods: data.data.counts.by_period || {}
        });
        console.log(&quot;Aggregation stats loaded:&quot;, data);
      }
    } catch (error) {
      console.error(&apos;Error fetching aggregation stats:&apos;, error);
    }
  };

  const fetchAllCharacterKills = async () =&gt; {
    try {
      setLoading(true);
      setError(null);
      setSuccess(null);
      setStats(null);

      const url = `/api/character-kills?all=true`;
      console.log(`Triggering kill data loading: ${url}`);
      
      const response = await fetch(url, {
        headers: {
          &apos;Accept&apos;: &apos;application/json&apos;,
          &apos;Content-Type&apos;: &apos;application/json&apos;
        }
      });
      console.log(`Response status: ${response.status}`);
      
      if (!response.ok) {
        let errorMessage;
        try {
          const errorData = await response.json();
          console.error(&quot;Error response:&quot;, errorData);
          errorMessage = errorData.message || errorData.details || `HTTP error! Status: ${response.status}`;
        } catch (parseError) {
          errorMessage = `HTTP error! Status: ${response.status}`;
        }
        throw new Error(errorMessage);
      }
      
      const data = await response.json();
      console.log(&quot;Response received:&quot;, data);
      
      if (data.status === &apos;ok&apos;) {
        setStats(data.data);
        setSuccess(data.data.message);
        setTimeout(() =&gt; {
          fetchTrackedInfo();
        }, 1000);
        setTimeout(() =&gt; {
          setSuccess(null);
        }, 5000);
      } else {
        throw new Error(data.message || &apos;Failed to load kill data&apos;);
      }
    } catch (error) {
      console.error(&apos;Error:&apos;, error);
      setError(error.message || &apos;An unknown error occurred&apos;);
    } finally {
      setLoading(false);
    }
  };

  const triggerAggregation = async (periodType = &apos;weekly&apos;) =&gt; {
    try {
      setAggregating(true);
      setError(null);
      setSuccess(null);
      setAggregationInfo(null);

      console.log(`Triggering ${periodType} aggregation...`);
      
      const response = await fetch(`/api/charts/killmail/aggregate?type=${periodType}`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const data = await response.json();
      console.log(&quot;Aggregation response:&quot;, data);
      
      if (data.status === &apos;ok&apos;) {
        setAggregationInfo(data);
        setSuccess(`Aggregation completed for ${data.target_date}`);
        setTimeout(() =&gt; {
          fetchAggregationStats();
        }, 1000);
        setTimeout(() =&gt; {
          setSuccess(null);
        }, 5000);
      } else {
        throw new Error(data.message || &apos;Failed to run aggregation&apos;);
      }
    } catch (error) {
      console.error(&apos;Aggregation error:&apos;, error);
      setError(`Aggregation error: ${error.message}`);
    } finally {
      setAggregating(false);
    }
  };

  const fetchDebugData = async () =&gt; {
    setDebugData(null);
    setDebugInfo(&quot;Loading debug information...&quot;);
    
    try {
      const response = await fetch(`/api/charts/killmail/debug`);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      console.log(&apos;Debug data:&apos;, data);
      setDebugData(data);
      setDebugInfo(JSON.stringify(data, null, 2));
    } catch (error) {
      console.error(&apos;Error fetching debug data:&apos;, error);
      setDebugInfo(`Error fetching debug data: ${error.message}`);
    }
  };

  const forceSync = async () =&gt; {
    if (!window.confirm(&apos;This will DELETE all characters from the database and resync from cache. Continue?&apos;)) {
      return;
    }
    
    setForceSyncing(true);
    setSuccess(null);
    setError(null);
    setDebugInfo(null);
    
    console.log(&apos;Force syncing characters from cache to database...&apos;);
    
    try {
      const response = await fetch(`/api/charts/killmail/force-sync-characters`);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const data = await response.json();
      console.log(&apos;Force sync result:&apos;, data);
      if (data.status === &apos;ok&apos;) {
        setSuccess(`Force sync completed successfully! Database now contains ${data.details.db_count || 0} characters.`);
        setTimeout(() =&gt; {
          setSuccess(null);
        }, 5000);
      } else {
        throw new Error(data.message || &apos;Failed to force sync characters&apos;);
      }
    } catch (error) {
      console.error(&apos;Error during force sync:&apos;, error);
      setError(`Force sync error: ${error.message}`);
    } finally {
      setForceSyncing(false);
    }
  };

  return (
    &lt;div className=&quot;bg-white rounded-lg shadow-md overflow-hidden border border-gray-200&quot;&gt;
      &lt;div className=&quot;p-4 border-b&quot;&gt;
        &lt;h3 className=&quot;text-lg font-semibold text-gray-800&quot;&gt;{title}&lt;/h3&gt;
        &lt;p className=&quot;text-sm text-gray-600 mt-1&quot;&gt;{description}&lt;/p&gt;
      &lt;/div&gt;
      
      {trackedInfo &amp;&amp; (
        &lt;div className=&quot;px-4 py-3 bg-gray-50 border-b&quot;&gt;
          &lt;div className=&quot;flex items-center justify-between&quot;&gt;
            &lt;div className=&quot;flex items-center text-sm text-gray-700&quot;&gt;
              &lt;FaInfoCircle className=&quot;mr-2 text-indigo-500&quot; /&gt;
              &lt;div&gt;
                &lt;span className=&quot;font-medium&quot;&gt;{trackedInfo.tracked_characters}&lt;/span&gt; tracked characters, 
                &lt;span className=&quot;font-medium ml-1&quot;&gt;{trackedInfo.total_kills}&lt;/span&gt; total kills
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;button 
              onClick={() =&gt; setShowCharacters(!showCharacters)} 
              className=&quot;text-sm text-indigo-600 flex items-center hover:text-indigo-800&quot;
            &gt;
              {showCharacters ? &lt;FaCaretUp className=&quot;mr-1&quot; /&gt; : &lt;FaCaretDown className=&quot;mr-1&quot; /&gt;}
              {showCharacters ? &apos;Hide Details&apos; : &apos;Show Details&apos;}
              &lt;span className=&quot;ml-1 px-1.5 py-0.5 bg-indigo-100 text-indigo-800 rounded-full text-xs&quot;&gt;
                {trackedInfo.character_stats?.length || 0}
              &lt;/span&gt;
            &lt;/button&gt;
          &lt;/div&gt;
          
          {showCharacters &amp;&amp; trackedInfo.character_stats &amp;&amp; (
            &lt;div className=&quot;mt-3 p-2 max-h-60 overflow-y-auto bg-white rounded border border-gray-200&quot;&gt;
              {trackedInfo.character_stats.every(char =&gt; char.kill_count === 0) &amp;&amp; (
                &lt;div className=&quot;bg-yellow-50 p-2 mb-2 rounded border border-yellow-200 text-xs text-yellow-800&quot;&gt;
                  &lt;FaExclamationTriangle className=&quot;inline-block mr-1&quot; /&gt; 
                  All characters have 0 kill counts. Try running the &quot;Load Kill Data&quot; operation to fetch and process kill data.
                &lt;/div&gt;
              )}
              &lt;table className=&quot;w-full text-sm text-left text-gray-600&quot;&gt;
                &lt;thead className=&quot;text-xs text-gray-700 uppercase bg-gray-50&quot;&gt;
                  &lt;tr&gt;
                    &lt;th className=&quot;px-2 py-1&quot;&gt;Character&lt;/th&gt;
                    &lt;th className=&quot;px-2 py-1 text-right&quot;&gt;Kills&lt;/th&gt;
                  &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                  {trackedInfo.character_stats
                    .sort((a, b) =&gt; b.kill_count - a.kill_count)
                    .map((character) =&gt; (
                      &lt;tr key={character.character_id} className=&quot;border-b hover:bg-gray-50&quot;&gt;
                        &lt;td className=&quot;px-2 py-1&quot;&gt;{character.character_name}&lt;/td&gt;
                        &lt;td className=&quot;px-2 py-1 text-right&quot;&gt;{character.kill_count}&lt;/td&gt;
                      &lt;/tr&gt;
                    ))
                  }
                &lt;/tbody&gt;
              &lt;/table&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
      )}
      
      {aggregationStats &amp;&amp; (
        &lt;div className=&quot;px-4 py-3 bg-gray-100 border-b&quot;&gt;
          &lt;div className=&quot;flex items-center text-sm text-gray-700&quot;&gt;
            &lt;FaChartBar className=&quot;mr-2 text-purple-500&quot; /&gt;
            &lt;div&gt;
              &lt;span className=&quot;font-medium&quot;&gt;{aggregationStats.aggregated_characters || 0}&lt;/span&gt; characters, 
              &lt;span className=&quot;font-medium ml-1&quot;&gt;{aggregationStats.total_stats || 0}&lt;/span&gt; stats
            &lt;/div&gt;
          &lt;/div&gt;
          {aggregationStats.last_aggregation &amp;&amp; (
            &lt;div className=&quot;mt-1 flex items-center text-sm text-gray-700&quot;&gt;
              &lt;FaCalendarAlt className=&quot;mr-2 text-purple-500&quot; /&gt;
              &lt;div&gt;
                Last: &lt;span className=&quot;font-medium&quot;&gt;{aggregationStats.last_aggregation}&lt;/span&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
      )}

      {error &amp;&amp; (
        &lt;div className=&quot;p-4 bg-red-50 border-b&quot;&gt;
          &lt;div className=&quot;flex items-center text-sm text-red-700&quot;&gt;
            &lt;FaExclamationTriangle className=&quot;mr-2&quot; /&gt;
            {error}
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {success &amp;&amp; (
        &lt;div className=&quot;p-4 bg-green-50 border-b&quot;&gt;
          &lt;div className=&quot;flex items-center text-sm text-green-700&quot;&gt;
            &lt;FaCheckCircle className=&quot;mr-2&quot; /&gt;
            {success}
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {debugInfo &amp;&amp; (
        &lt;div className=&quot;p-4 bg-gray-50 border-b&quot;&gt;
          &lt;pre className=&quot;text-xs text-gray-700 whitespace-pre-wrap&quot;&gt;{debugInfo}&lt;/pre&gt;
        &lt;/div&gt;
      )}
      
      &lt;div className=&quot;p-4&quot;&gt;
        &lt;div className=&quot;grid grid-cols-2 gap-3 mb-4&quot;&gt;
          &lt;button
            onClick={fetchAllCharacterKills}
            disabled={loading}
            title=&quot;Load Kill Data&quot;
            className=&quot;p-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition flex items-center justify-center disabled:opacity-50&quot;
          &gt;
            {loading ? &lt;FaCircleNotch className=&quot;animate-spin&quot; /&gt; : &lt;FaUsers className=&quot;mr-2&quot; /&gt;}
            &lt;span&gt;Load Kill Data&lt;/span&gt;
          &lt;/button&gt;

          &lt;button
            onClick={() =&gt; triggerAggregation(&apos;weekly&apos;)}
            disabled={aggregating}
            title=&quot;Run Aggregation&quot;
            className=&quot;p-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition flex items-center justify-center disabled:opacity-50&quot;
          &gt;
            {aggregating ? &lt;FaCircleNotch className=&quot;animate-spin&quot; /&gt; : &lt;FaSync className=&quot;mr-2&quot; /&gt;}
            &lt;span&gt;Run Aggregation&lt;/span&gt;
          &lt;/button&gt;

          &lt;button
            onClick={fetchDebugData}
            disabled={loading}
            title=&quot;View Database Status&quot;
            className=&quot;p-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition flex items-center justify-center disabled:opacity-50&quot;
          &gt;
            &lt;FaBug className=&quot;mr-2&quot; /&gt;
            &lt;span&gt;Database Status&lt;/span&gt;
          &lt;/button&gt;

          &lt;button
            onClick={forceSync}
            disabled={forceSyncing}
            title=&quot;Force Sync Characters&quot;
            className=&quot;p-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition flex items-center justify-center disabled:opacity-50&quot;
          &gt;
            {forceSyncing ? &lt;FaCircleNotch className=&quot;animate-spin&quot; /&gt; : &lt;FaHammer className=&quot;mr-2&quot; /&gt;}
            &lt;span&gt;Force Sync Characters&lt;/span&gt;
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default CharacterKillsCard;</file><file path="renderer/src/components/ChartsDashboard.jsx">import React, { useState, useEffect } from &apos;react&apos;;
import { FaCircleNotch, FaDiscord, FaExclamationTriangle, FaCheckCircle, FaChartBar, FaInfoCircle, FaMapMarkedAlt } from &apos;react-icons/fa&apos;;
import ActivityChartCard from &apos;./ActivityChartCard&apos;;
import KillmailChartCard from &apos;./KillmailChartCard&apos;;
import CharacterKillsCard from &apos;./CharacterKillsCard&apos;;

export default function ChartsDashboard() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [features, setFeatures] = useState({
    mapChartsEnabled: false,
    killChartsEnabled: false
  });

  useEffect(() =&gt; {
    try {
      fetch(&apos;/api/debug/status&apos;)
        .then(response =&gt; response.json())
        .then(response =&gt; {
          const features = response.data.features;
          setFeatures({
            mapChartsEnabled: features.map_charts || false,
            killChartsEnabled: features.kill_charts || false
          });
          setLoading(false);
        })
        .catch(error =&gt; {
          console.error(&apos;Error fetching chart configuration:&apos;, error);
          setError(`Failed to load chart configuration: ${error.message}`);
          setFeatures({
            mapChartsEnabled: false,
            killChartsEnabled: false
          });
          setLoading(false);
        });
    } catch (err) {
      console.error(&apos;Unhandled error in chart config fetch:&apos;, err);
      setError(`Unhandled error: ${err.message}`);
      setLoading(false);
    }
  }, []);

  const loadChartImage = async (url) =&gt; {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const blob = await response.blob();
      return URL.createObjectURL(blob);
    } catch (error) {
      console.error(&apos;Error loading chart image:&apos;, error);
      throw error;
    }
  };

  if (loading) {
    return (
      &lt;div className=&quot;flex flex-col items-center justify-center min-h-screen bg-gray-50&quot;&gt;
        &lt;FaCircleNotch className=&quot;h-12 w-12 text-indigo-600 animate-spin mb-4&quot; /&gt;
        &lt;h2 className=&quot;text-xl font-semibold text-gray-700&quot;&gt;Loading Charts Dashboard...&lt;/h2&gt;
      &lt;/div&gt;
    );
  }

  if (error) {
    return (
      &lt;div className=&quot;container mx-auto px-4 py-16&quot;&gt;
        &lt;div className=&quot;bg-red-100 border border-red-200 rounded-lg p-6 shadow-md&quot;&gt;
          &lt;div className=&quot;flex items-center mb-4&quot;&gt;
            &lt;FaExclamationTriangle className=&quot;text-red-500 h-8 w-8 mr-3&quot; /&gt;
            &lt;h2 className=&quot;text-xl font-bold text-red-700&quot;&gt;Configuration Error&lt;/h2&gt;
          &lt;/div&gt;
          &lt;p className=&quot;text-red-700 mb-4&quot;&gt;{error}&lt;/p&gt;
          &lt;p className=&quot;text-gray-600&quot;&gt;
            Please check your configuration settings and ensure the backend services are running.
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;container mx-auto px-4 py-8&quot;&gt;
      {/* Header with EVE-inspired styling */}
      &lt;div className=&quot;mb-8 text-center&quot;&gt;
        &lt;div className=&quot;inline-block bg-gradient-to-r from-blue-600 to-indigo-800 p-2 rounded-lg shadow-lg mb-4&quot;&gt;
          &lt;FaChartBar className=&quot;h-8 w-8 text-white&quot; /&gt;
        &lt;/div&gt;
        &lt;h1 className=&quot;text-3xl font-bold text-gray-800 mb-2&quot;&gt;EVE Online Charts Dashboard&lt;/h1&gt;
        &lt;p className=&quot;text-gray-600&quot;&gt;
          Killmail visualization and statistics for tracked characters
        &lt;/p&gt;
      &lt;/div&gt;

      {/* Feature Status Cards */}
      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-4 mb-6&quot;&gt;
        &lt;div className={`p-4 rounded-lg shadow-sm transition-all duration-300 ${features.mapChartsEnabled ? &apos;bg-green-50 border border-green-200 hover:shadow-md&apos; : &apos;bg-gray-100 border border-gray-200&apos;}`}&gt;
          &lt;div className=&quot;flex items-center&quot;&gt;
            &lt;div className={`flex-shrink-0 rounded-full p-2 mr-3 ${features.mapChartsEnabled ? &apos;bg-green-100 text-green-500&apos; : &apos;bg-gray-200 text-gray-400&apos;}`}&gt;
              &lt;FaMapMarkedAlt className=&quot;h-5 w-5&quot; /&gt;
            &lt;/div&gt;
            &lt;div&gt;
              &lt;span className=&quot;block font-medium&quot;&gt;Map Charts&lt;/span&gt;
              &lt;span className={`text-sm ${features.mapChartsEnabled ? &apos;text-green-600&apos; : &apos;text-gray-500&apos;}`}&gt;
                {features.mapChartsEnabled ? &apos;Enabled&apos; : &apos;Disabled&apos;}
              &lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div className={`p-4 rounded-lg shadow-sm transition-all duration-300 ${features.killChartsEnabled ? &apos;bg-green-50 border border-green-200 hover:shadow-md&apos; : &apos;bg-gray-100 border border-gray-200&apos;}`}&gt;
          &lt;div className=&quot;flex items-center&quot;&gt;
            &lt;div className={`flex-shrink-0 rounded-full p-2 mr-3 ${features.killChartsEnabled ? &apos;bg-green-100 text-green-500&apos; : &apos;bg-gray-200 text-gray-400&apos;}`}&gt;
              &lt;FaChartBar className=&quot;h-5 w-5&quot; /&gt;
            &lt;/div&gt;
            &lt;div&gt;
              &lt;span className=&quot;block font-medium&quot;&gt;Kill Charts&lt;/span&gt;
              &lt;span className={`text-sm ${features.killChartsEnabled ? &apos;text-green-600&apos; : &apos;text-gray-500&apos;}`}&gt;
                {features.killChartsEnabled ? &apos;Enabled&apos; : &apos;Disabled&apos;}
              &lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Chart Cards with better layout */}
      {features.mapChartsEnabled &amp;&amp; (
        &lt;div className=&quot;mb-10&quot;&gt;
          &lt;div className=&quot;flex items-center mb-4&quot;&gt;
            &lt;FaMapMarkedAlt className=&quot;text-indigo-500 mr-2&quot; /&gt;
            &lt;h2 className=&quot;text-xl font-semibold text-gray-800&quot;&gt;Activity Charts&lt;/h2&gt;
          &lt;/div&gt;
          &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;
            &lt;ActivityChartCard 
              title=&quot;Activity Summary&quot;
              description=&quot;Character activity summary for the last 24 hours&quot;
              chartType=&quot;activity_summary&quot;
              loadChartImage={loadChartImage}
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {features.killChartsEnabled &amp;&amp; (
        &lt;div&gt;
          &lt;div className=&quot;flex items-center mb-4&quot;&gt;
            &lt;FaChartBar className=&quot;text-indigo-500 mr-2&quot; /&gt;
            &lt;h2 className=&quot;text-xl font-semibold text-gray-800&quot;&gt;Killmail Charts&lt;/h2&gt;
          &lt;/div&gt;
          &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8&quot;&gt;
            &lt;KillmailChartCard 
              title=&quot;Weekly Character Kills&quot;
              description=&quot;Top characters by kills in the past week&quot;
              chartType=&quot;weekly_kills&quot;
              loadChartImage={loadChartImage}
            /&gt;
            &lt;KillmailChartCard 
              title=&quot;Weekly ISK Destroyed&quot;
              description=&quot;Top characters by ISK destroyed in the past week&quot;
              chartType=&quot;weekly_isk&quot;
              loadChartImage={loadChartImage}
            /&gt;
            &lt;KillmailChartCard 
              title=&quot;Kill Validation&quot;
              description=&quot;Comparison of kills in ZKillboard API vs Database&quot;
              chartType=&quot;validation&quot;
              loadChartImage={loadChartImage}
            /&gt;
          &lt;/div&gt;
          &lt;div className=&quot;mt-6&quot;&gt;
            &lt;CharacterKillsCard 
              title=&quot;Character Kill Data&quot; 
              description=&quot;Load and aggregate kill data for tracked characters&quot;
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {(!features.mapChartsEnabled &amp;&amp; !features.killChartsEnabled) &amp;&amp; (
        &lt;div className=&quot;bg-yellow-50 border border-yellow-200 rounded-lg p-6 text-center shadow-md&quot;&gt;
          &lt;FaInfoCircle className=&quot;h-10 w-10 text-yellow-500 mx-auto mb-4&quot; /&gt;
          &lt;h3 className=&quot;text-xl font-medium text-yellow-800 mb-2&quot;&gt;No Chart Features Enabled&lt;/h3&gt;
          &lt;p className=&quot;text-yellow-700 mb-4&quot;&gt;
            Both map and kill chart features are currently disabled in your configuration.
          &lt;/p&gt;
          &lt;p className=&quot;text-gray-600 text-sm&quot;&gt;
            Enable these features in your application configuration to view available charts.
          &lt;/p&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</file><file path="renderer/src/components/Dashboard.jsx">// src/components/Dashboard.jsx
import React, { useEffect, useState } from &quot;react&quot;;
import {
  FaSync,
  FaCheckCircle,
  FaPowerOff,
  FaCloud,
  FaHeart,
  FaTimes,
  FaCircleNotch,
  FaExclamationTriangle,
  FaBell,
  FaSkullCrossbones,
  FaChartBar
} from &quot;react-icons/fa&quot;;
import { Link } from &quot;react-router-dom&quot;;

export default function Dashboard() {
  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [testMessage, setTestMessage] = useState(null);
  const [dbStats, setDbStats] = useState(null);

  // On mount, fetch dashboard status
  useEffect(() =&gt; {
    fetchStatus();
  }, []);

  // Fetch the status data
  async function fetchStatus() {
    try {
      setLoading(true);
      console.log(&quot;Fetching status data from API...&quot;);
      const response = await fetch(&quot;/api/debug/status&quot;);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      console.log(&quot;Status data received:&quot;, data);
      setStatus(data.data);
      setError(null);

      // Always fetch database stats
      await fetchDbStats();
    } catch (err) {
      console.error(&quot;Error fetching status:&quot;, err);
      setError(&quot;Failed to load dashboard data. Please try again.&quot;);
    } finally {
      setLoading(false);
    }
  }

  // Fetch database statistics
  async function fetchDbStats() {
    try {
      console.log(&quot;Fetching database statistics...&quot;);
      const response = await fetch(&quot;/api/debug/db-stats&quot;);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      console.log(&quot;Database stats received:&quot;, data);
      if (data.status === &quot;ok&quot;) {
        setDbStats(data.data);
      } else {
        console.warn(&quot;Failed to get database stats:&quot;, data.message);
      }
    } catch (err) {
      console.error(&quot;Error fetching database stats:&quot;, err);
      // We don&apos;t set the main error state here to avoid blocking the entire dashboard
    }
  }

  // Toolbar actions
  async function handleRefreshPage() {
    await fetchStatus();
    setTestMessage(&quot;Dashboard refreshed!&quot;);
  }

  async function handleRevalidateLicense() {
    try {
      const response = await fetch(&quot;/api/revalidate-license&quot;);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      
      // Check if the validation was actually successful by examining the success field
      if (data.success) {
        setTestMessage(data.message || &quot;License successfully validated!&quot;);
      } else {
        // Handle unsuccessful validation with the error message
        console.error(&quot;License validation failed:&quot;, data.details);
        setTestMessage(data.message || &quot;License validation failed&quot;);
      }
      
      // Refresh the status display
      fetchStatus();
    } catch (err) {
      console.error(&quot;Error revalidating license:&quot;, err);
      setTestMessage(&quot;Error revalidating license&quot;);
    }
  }

  // Test notification actions
  async function testKillNotification() {
    try {
      console.log(&quot;Sending test kill notification request...&quot;);
      const response = await fetch(&quot;/api/notifications/test&quot;, {
        method: &apos;POST&apos;,
        headers: {
          &apos;Content-Type&apos;: &apos;application/json&apos;,
        },
        body: JSON.stringify({ type: &apos;kill&apos; })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      console.log(&quot;Kill notification response:&quot;, data);
      setTestMessage(data.message || &quot;Kill notification sent!&quot;);
    } catch (err) {
      console.error(&quot;Error sending kill notification:&quot;, err);
      setTestMessage(&quot;Error sending kill notification&quot;);
    }
  }

  async function testSystemNotification() {
    try {
      console.log(&quot;Sending test system notification request...&quot;);
      const response = await fetch(&quot;/api/notifications/test&quot;, {
        method: &apos;POST&apos;,
        headers: {
          &apos;Content-Type&apos;: &apos;application/json&apos;,
        },
        body: JSON.stringify({ type: &apos;system&apos; })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      console.log(&quot;System notification response:&quot;, data);
      setTestMessage(data.message || &quot;System notification sent!&quot;);
    } catch (err) {
      console.error(&quot;Error sending system notification:&quot;, err);
      setTestMessage(&quot;Error sending system notification&quot;);
    }
  }

  async function testCharacterNotification() {
    try {
      console.log(&quot;Sending test character notification request...&quot;);
      const response = await fetch(&quot;/api/notifications/test&quot;, {
        method: &apos;POST&apos;,
        headers: {
          &apos;Content-Type&apos;: &apos;application/json&apos;,
        },
        body: JSON.stringify({ type: &apos;character&apos; })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      console.log(&quot;Character notification response:&quot;, data);
      setTestMessage(data.message || &quot;Character notification sent!&quot;);
    } catch (err) {
      console.error(&quot;Error sending character notification:&quot;, err);
      setTestMessage(&quot;Error sending character notification&quot;);
    }
  }

  /* -------------------------
   * Loading &amp; Error States
   * ------------------------*/
  if (loading &amp;&amp; !status) {
    return (
      &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;
        {/* Animated spinner */}
        &lt;FaCircleNotch className=&quot;h-10 w-10 text-indigo-600 animate-spin&quot; /&gt;
      &lt;/div&gt;
    );
  }

  if (error) {
    return (
      &lt;div className=&quot;flex items-center justify-center min-h-screen px-4&quot;&gt;
        &lt;div className=&quot;flex items-center space-x-3 bg-red-50 border border-red-200 text-red-600 p-4 rounded-md&quot;&gt;
          &lt;FaExclamationTriangle className=&quot;text-red-600&quot; /&gt;
          &lt;span&gt;{error}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  /* -------------------------
   * Main Dashboard UI
   * ------------------------*/
  return (
    &lt;div className=&quot;min-h-screen bg-gradient-to-b from-indigo-50 to-white&quot;&gt;
      {/* Outer container with spacing */}
      &lt;div className=&quot;max-w-7xl mx-auto px-4 py-8 sm:px-6 lg:px-8 space-y-8&quot;&gt;
        {/* Title &amp; Toolbar */}
        &lt;div className=&quot;flex flex-col sm:flex-row items-start sm:items-center justify-between&quot;&gt;
          &lt;h1 className=&quot;flex items-center text-2xl font-bold text-indigo-800 space-x-2 mb-4 sm:mb-0&quot;&gt;
            &lt;FaBell /&gt;
            &lt;span&gt;Wanderer Notifier Dashboard&lt;/span&gt;
          &lt;/h1&gt;
          &lt;div className=&quot;flex space-x-2&quot;&gt;
            {/* Button: Refresh */}
            &lt;div className=&quot;relative group&quot;&gt;
              &lt;button
                className=&quot;p-2 bg-white text-gray-700 border border-gray-200 rounded-md hover:bg-gray-100 transition-colors&quot;
                onClick={handleRefreshPage}
              &gt;
                &lt;FaSync /&gt;
              &lt;/button&gt;
              {/* Tooltip */}
              &lt;div className=&quot;absolute hidden group-hover:block bg-black text-white text-xs rounded py-1 px-2 -top-8 left-1/2 transform -translate-x-1/2 whitespace-nowrap&quot;&gt;
                Refresh
              &lt;/div&gt;
            &lt;/div&gt;

            {/* Button: Revalidate License */}
            &lt;div className=&quot;relative group&quot;&gt;
              &lt;button
                className=&quot;p-2 bg-white text-gray-700 border border-gray-200 rounded-md hover:bg-gray-100 transition-colors&quot;
                onClick={handleRevalidateLicense}
              &gt;
                &lt;FaCheckCircle /&gt;
              &lt;/button&gt;
              {/* Tooltip */}
              &lt;div className=&quot;absolute hidden group-hover:block bg-black text-white text-xs rounded py-1 px-2 -top-8 left-1/2 transform -translate-x-1/2 whitespace-nowrap&quot;&gt;
                Revalidate License
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Test Message Banner */}
        {testMessage &amp;&amp; (
          &lt;div className={`${testMessage.toLowerCase().includes(&apos;failed&apos;) || testMessage.toLowerCase().includes(&apos;error&apos;) 
                           ? &apos;bg-red-50 border border-red-200&apos; 
                           : &apos;bg-green-50 border border-green-200&apos;} 
                          p-3 rounded-md flex items-center justify-between`}&gt;
            &lt;div className={`${testMessage.toLowerCase().includes(&apos;failed&apos;) || testMessage.toLowerCase().includes(&apos;error&apos;)
                           ? &apos;text-red-700&apos; 
                           : &apos;text-green-700&apos;} flex items-center space-x-2`}&gt;
              {testMessage.toLowerCase().includes(&apos;failed&apos;) || testMessage.toLowerCase().includes(&apos;error&apos;) 
               ? &lt;FaExclamationTriangle /&gt; 
               : &lt;FaCheckCircle /&gt;}
              &lt;span className=&quot;font-medium&quot;&gt;{testMessage}&lt;/span&gt;
            &lt;/div&gt;
            &lt;button
              onClick={() =&gt; setTestMessage(null)}
              className=&quot;ml-4 text-gray-500 hover:text-gray-700&quot;
            &gt;
              &lt;FaTimes /&gt;
            &lt;/button&gt;
          &lt;/div&gt;
        )}

        {/* Notification Statistics */}
        &lt;section&gt;
          &lt;h2 className=&quot;text-lg font-semibold text-gray-800 mb-4 flex items-center space-x-2&quot;&gt;
            &lt;FaSkullCrossbones className=&quot;text-sky-600&quot; /&gt;
            &lt;span&gt;Notification Statistics&lt;/span&gt;
          &lt;/h2&gt;
          &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4&quot;&gt;
            {/* Total Notifications */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
              &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;
                Total Notifications
              &lt;/h4&gt;
              &lt;p className=&quot;text-2xl font-bold text-gray-700&quot;&gt;
                {status?.stats?.notifications?.total || 0}
              &lt;/p&gt;
            &lt;/div&gt;

            {/* Kill Notifications */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
              &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;
                Kill Notifications
              &lt;/h4&gt;
              &lt;p className=&quot;text-2xl font-bold text-gray-700&quot;&gt;
                {status?.stats?.notifications?.kills || 0}
              &lt;/p&gt;
            &lt;/div&gt;

            {/* Character Notifications */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
              &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;
                Character Notifications
              &lt;/h4&gt;
              &lt;p className=&quot;text-2xl font-bold text-gray-700&quot;&gt;
                {status?.stats?.notifications?.characters || 0}
              &lt;/p&gt;
            &lt;/div&gt;

            {/* System Notifications */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
              &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;
                System Notifications
              &lt;/h4&gt;
              &lt;p className=&quot;text-2xl font-bold text-gray-700&quot;&gt;
                {status?.stats?.notifications?.systems || 0}
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/section&gt;

        {/* Database Statistics */}
        {dbStats &amp;&amp; dbStats.db_health.status !== &quot;disabled&quot; &amp;&amp; (
          &lt;section&gt;
            &lt;h2 className=&quot;text-lg font-semibold text-gray-800 mb-4 flex items-center space-x-2&quot;&gt;
              &lt;FaChartBar className=&quot;text-purple-600&quot; /&gt;
              &lt;span&gt;Database Statistics&lt;/span&gt;
            &lt;/h2&gt;
            &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4&quot;&gt;
              {/* Total Tracked Characters */}
              &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
                &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;
                  Tracked Characters in Database
                &lt;/h4&gt;
                &lt;p className=&quot;text-2xl font-bold text-gray-700&quot;&gt;
                  {dbStats?.killmail?.tracked_characters || 0}
                &lt;/p&gt;
              &lt;/div&gt;

              {/* Total Killmails */}
              &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
                &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;
                  Total Killmails Stored
                &lt;/h4&gt;
                &lt;p className=&quot;text-2xl font-bold text-gray-700&quot;&gt;
                  {dbStats?.killmail?.total_kills || 0}
                &lt;/p&gt;
              &lt;/div&gt;

              {/* Database Health */}
              &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
                &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;
                  Database Connection
                &lt;/h4&gt;
                {dbStats?.db_health ? (
                  &lt;div&gt;
                    &lt;p className=&quot;flex items-center mt-1&quot;&gt;
                      {dbStats.db_health.status === &quot;connected&quot; ? (
                        &lt;&gt;
                          &lt;FaCheckCircle className=&quot;text-green-500 mr-2&quot; /&gt;
                          &lt;span className=&quot;bg-green-100 text-green-800 text-sm px-2 py-1 rounded&quot;&gt;
                            Connected
                          &lt;/span&gt;
                        &lt;/&gt;
                      ) : (
                        &lt;&gt;
                          &lt;FaTimes className=&quot;text-red-500 mr-2&quot; /&gt;
                          &lt;span className=&quot;bg-red-100 text-red-800 text-sm px-2 py-1 rounded&quot;&gt;
                            Error
                          &lt;/span&gt;
                        &lt;/&gt;
                      )}
                    &lt;/p&gt;
                    {dbStats.db_health.ping_ms &amp;&amp; (
                      &lt;p className=&quot;text-sm text-gray-500 mt-1&quot;&gt;
                        Ping: {dbStats.db_health.ping_ms}ms
                      &lt;/p&gt;
                    )}
                  &lt;/div&gt;
                ) : (
                  &lt;p className=&quot;flex items-center mt-1&quot;&gt;
                    &lt;FaCircleNotch className=&quot;text-gray-400 mr-2 animate-spin&quot; /&gt;
                    &lt;span className=&quot;text-gray-500&quot;&gt;Checking...&lt;/span&gt;
                  &lt;/p&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/section&gt;
        )}

        {/* License Status */}
        &lt;section&gt;
          &lt;h2 className=&quot;text-lg font-semibold text-gray-800 mb-4 flex items-center space-x-2&quot;&gt;
            &lt;FaCheckCircle className=&quot;text-green-600&quot; /&gt;
            &lt;span&gt;License Status&lt;/span&gt;
          &lt;/h2&gt;
          &lt;div className=&quot;bg-white p-5 rounded-md shadow-sm border border-gray-100&quot;&gt;
            &lt;div className=&quot;bg-gray-50 p-4 rounded-md border border-gray-200 space-y-2&quot;&gt;
              &lt;div&gt;
                &lt;strong&gt;Valid: &lt;/strong&gt;
                {status?.license?.valid ? &quot;Yes&quot; : &quot;No&quot;}
              &lt;/div&gt;
              {status?.license?.bot_assigned &amp;&amp; (
                &lt;div&gt;
                  &lt;strong&gt;Bot Assigned: &lt;/strong&gt;Yes
                &lt;/div&gt;
              )}
              {status?.license?.details &amp;&amp; (
                &lt;div&gt;
                  &lt;strong&gt;License Name: &lt;/strong&gt;
                  {status.license.details.license_name}
                &lt;/div&gt;
              )}
              {status?.license?.error_message &amp;&amp; (
                &lt;div className=&quot;text-red-600&quot;&gt;
                  &lt;strong&gt;Error: &lt;/strong&gt;
                  {status.license.error_message}
                &lt;/div&gt;
              )}
              &lt;div className=&quot;mt-3 text-sm text-gray-500&quot;&gt;
                &lt;p&gt;
                  {status?.license?.valid 
                    ? &quot;Your license is active and valid.&quot;
                    : &quot;Your license is not valid. Please check your license key in the configuration.&quot;}
                &lt;/p&gt;
                {!status?.license?.valid &amp;&amp; (
                  &lt;p className=&quot;mt-1&quot;&gt;
                    Try clicking the &quot;Revalidate License&quot; button in the top-right corner to retry validation.
                  &lt;/p&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/section&gt;

        {/* Feature Status */}
        &lt;section&gt;
          &lt;h2 className=&quot;text-lg font-semibold text-gray-800 mb-4 flex items-center space-x-2&quot;&gt;
            &lt;FaBell className=&quot;text-pink-500&quot; /&gt;
            &lt;span&gt;Feature Status&lt;/span&gt;
          &lt;/h2&gt;
          &lt;div className=&quot;grid grid-cols-1 md:grid-cols-3 gap-4&quot;&gt;
            {/* Kill Notifications */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100 flex items-center justify-between&quot;&gt;
              &lt;span className=&quot;font-medium text-gray-700&quot;&gt;Kill Notifications&lt;/span&gt;
              &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                &lt;span
                  className={
                    status?.features?.kill_notifications_enabled
                      ? &quot;bg-green-100 text-green-800 text-sm px-2 py-1 rounded&quot;
                      : &quot;bg-red-100 text-red-800 text-sm px-2 py-1 rounded&quot;
                  }
                &gt;
                  {status?.features?.kill_notifications_enabled
                    ? &quot;Enabled&quot;
                    : &quot;Disabled&quot;}
                &lt;/span&gt;
                {/* Icon button */}
                &lt;button
                  className=&quot;relative group p-2 text-gray-600 hover:bg-gray-200 rounded-md transition-colors&quot;
                  onClick={testKillNotification}
                &gt;
                  &lt;FaSkullCrossbones /&gt;
                  {/* Tooltip */}
                  &lt;div className=&quot;absolute hidden group-hover:block bg-black text-white text-xs rounded py-1 px-2 bottom-full mb-1 left-1/2 transform -translate-x-1/2 whitespace-nowrap&quot;&gt;
                    Test Kill Notification
                  &lt;/div&gt;
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            {/* System Notifications */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100 flex items-center justify-between&quot;&gt;
              &lt;span className=&quot;font-medium text-gray-700&quot;&gt;System Notifications&lt;/span&gt;
              &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                &lt;span
                  className={
                    status?.features?.system_notifications_enabled
                      ? &quot;bg-green-100 text-green-800 text-sm px-2 py-1 rounded&quot;
                      : &quot;bg-red-100 text-red-800 text-sm px-2 py-1 rounded&quot;
                  }
                &gt;
                  {status?.features?.system_notifications_enabled
                    ? &quot;Enabled&quot;
                    : &quot;Disabled&quot;}
                &lt;/span&gt;
                &lt;button
                  className=&quot;relative group p-2 text-gray-600 hover:bg-gray-200 rounded-md transition-colors&quot;
                  onClick={testSystemNotification}
                &gt;
                  &lt;FaCloud /&gt;
                  &lt;div className=&quot;absolute hidden group-hover:block bg-black text-white text-xs rounded py-1 px-2 bottom-full mb-1 left-1/2 transform -translate-x-1/2 whitespace-nowrap&quot;&gt;
                    Test System Notification
                  &lt;/div&gt;
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;

            {/* Character Notifications */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100 flex items-center justify-between&quot;&gt;
              &lt;span className=&quot;font-medium text-gray-700&quot;&gt;Character Notifications&lt;/span&gt;
              &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                &lt;span
                  className={
                    status?.features?.character_notifications_enabled
                      ? &quot;bg-green-100 text-green-800 text-sm px-2 py-1 rounded&quot;
                      : &quot;bg-red-100 text-red-800 text-sm px-2 py-1 rounded&quot;
                  }
                &gt;
                  {status?.features?.character_notifications_enabled
                    ? &quot;Enabled&quot;
                    : &quot;Disabled&quot;}
                &lt;/span&gt;
                &lt;button
                  className=&quot;relative group p-2 text-gray-600 hover:bg-gray-200 rounded-md transition-colors&quot;
                  onClick={testCharacterNotification}
                &gt;
                  &lt;FaHeart /&gt;
                  &lt;div className=&quot;absolute hidden group-hover:block bg-black text-white text-xs rounded py-1 px-2 bottom-full mb-1 left-1/2 transform -translate-x-1/2 whitespace-nowrap&quot;&gt;
                    Test Character Notification
                  &lt;/div&gt;
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            
            {/* Map Charts */}
            {status?.features?.map_charts &amp;&amp; (
              &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100 flex items-center justify-between&quot;&gt;
                &lt;span className=&quot;font-medium text-gray-700&quot;&gt;Map Charts&lt;/span&gt;
                &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                  &lt;span className=&quot;bg-green-100 text-green-800 text-sm px-2 py-1 rounded&quot;&gt;
                    Enabled
                  &lt;/span&gt;
                  &lt;Link
                    to=&quot;/charts&quot;
                    className=&quot;relative group p-2 text-gray-600 hover:bg-gray-200 rounded-md transition-colors&quot;
                  &gt;
                    &lt;FaChartBar /&gt;
                    &lt;div className=&quot;absolute hidden group-hover:block bg-black text-white text-xs rounded py-1 px-2 bottom-full mb-1 left-1/2 transform -translate-x-1/2 whitespace-nowrap&quot;&gt;
                      View Map Charts
                    &lt;/div&gt;
                  &lt;/Link&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            )}
            
            {/* Kill Charts */}
            {status?.features?.kill_charts &amp;&amp; (
              &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100 flex items-center justify-between&quot;&gt;
                &lt;span className=&quot;font-medium text-gray-700&quot;&gt;Kill Charts&lt;/span&gt;
                &lt;div className=&quot;flex items-center space-x-2&quot;&gt;
                  &lt;span className=&quot;bg-green-100 text-green-800 text-sm px-2 py-1 rounded&quot;&gt;
                    Enabled
                  &lt;/span&gt;
                  &lt;Link
                    to=&quot;/charts&quot;
                    className=&quot;relative group p-2 text-gray-600 hover:bg-gray-200 rounded-md transition-colors&quot;
                  &gt;
                    &lt;FaChartBar /&gt;
                    &lt;div className=&quot;absolute hidden group-hover:block bg-black text-white text-xs rounded py-1 px-2 bottom-full mb-1 left-1/2 transform -translate-x-1/2 whitespace-nowrap&quot;&gt;
                      View Kill Charts
                    &lt;/div&gt;
                  &lt;/Link&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            )}
            
            {/* Add any other features here */}
          &lt;/div&gt;
        &lt;/section&gt;

        {/* Usage Statistics */}
        {status?.features?.usage &amp;&amp; (
          &lt;section&gt;
            &lt;h2 className=&quot;text-lg font-semibold text-gray-800 mb-4 flex items-center space-x-2&quot;&gt;
              &lt;FaSync className=&quot;text-yellow-500&quot; /&gt;
              &lt;span&gt;Usage Statistics&lt;/span&gt;
            &lt;/h2&gt;
            &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-4&quot;&gt;
              {/* Tracked Systems */}
              &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
                &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-2&quot;&gt;
                  Tracked Systems
                &lt;/h4&gt;
                &lt;p className=&quot;mb-2 text-gray-800&quot;&gt;
                  {status.features.usage.tracked_systems.current}
                &lt;/p&gt;
              &lt;/div&gt;

              {/* Tracked Characters */}
              &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
                &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-2&quot;&gt;
                  Tracked Characters
                &lt;/h4&gt;
                &lt;p className=&quot;mb-2 text-gray-800&quot;&gt;
                  {status.features.usage.tracked_characters.current}
                &lt;/p&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/section&gt;
        )}

        {/* System Status */}
        &lt;section&gt;
          &lt;h2 className=&quot;text-lg font-semibold text-gray-800 mb-4 flex items-center space-x-2&quot;&gt;
            &lt;FaPowerOff className=&quot;text-purple-500&quot; /&gt;
            &lt;span&gt;System Status&lt;/span&gt;
          &lt;/h2&gt;
          &lt;div className=&quot;grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4&quot;&gt;
            {/* Uptime */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
              &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;Uptime&lt;/h4&gt;
              &lt;p className=&quot;text-gray-800&quot;&gt;{status?.stats?.uptime || &quot;Unknown&quot;}&lt;/p&gt;
            &lt;/div&gt;
            {/* WebSocket */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
              &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;WebSocket&lt;/h4&gt;
              &lt;p&gt;
                {status?.stats?.websocket?.connected ? (
                  &lt;span className=&quot;bg-green-100 text-green-800 text-sm px-2 py-1 rounded&quot;&gt;
                    Connected
                  &lt;/span&gt;
                ) : (
                  &lt;span className=&quot;bg-red-100 text-red-800 text-sm px-2 py-1 rounded&quot;&gt;
                    Disconnected
                  &lt;/span&gt;
                )}
              &lt;/p&gt;
            &lt;/div&gt;
            {/* Last Message */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
              &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;Last Message&lt;/h4&gt;
              &lt;p className=&quot;text-gray-800&quot;&gt;
                {status?.stats?.websocket?.last_message
                  ? new Date(status.stats.websocket.last_message).toLocaleTimeString()
                  : &quot;Never&quot;}
              &lt;/p&gt;
            &lt;/div&gt;
            {/* Reconnects */}
            &lt;div className=&quot;bg-white p-4 rounded-md shadow-sm border border-gray-100&quot;&gt;
              &lt;h4 className=&quot;text-sm font-semibold text-gray-600 mb-1&quot;&gt;Reconnects&lt;/h4&gt;
              &lt;p className=&quot;text-gray-800&quot;&gt;
                {status?.stats?.websocket?.reconnects || 0}
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/section&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</file><file path="renderer/src/components/KillComparison.tsx">import React, { useState, useEffect } from &apos;react&apos;;
import { Box, Button, Card, CardContent, Grid, Typography, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper, Chip, IconButton, Collapse, Alert, CircularProgress, Select, MenuItem, InputLabel, FormControl } from &apos;@mui/material&apos;;
import { format } from &apos;date-fns&apos;;
import { useQuery, useMutation } from &apos;@tanstack/react-query&apos;;
import { fetchApi } from &apos;../utils/api&apos;;
import KeyboardArrowDownIcon from &apos;@mui/icons-material/KeyboardArrowDown&apos;;
import KeyboardArrowUpIcon from &apos;@mui/icons-material/KeyboardArrowUp&apos;;
import SyncIcon from &apos;@mui/icons-material/Sync&apos;;
import RefreshIcon from &apos;@mui/icons-material/Refresh&apos;;
import KillComparisonTrends from &apos;./KillComparisonTrends&apos;;

// Cache constants
const CACHE_KEY = &apos;killComparisonCache&apos;;
const CACHE_EXPIRY_HOURS = 6; // Cache expires after 6 hours

interface CharacterComparison {
  character_id: number;
  character_name: string;
  our_kills: number;
  zkill_kills: number;
  missing_kills: number[];
  missing_percentage: number;
}

interface AnalysisResult {
  reason: string;
  count: number;
  examples: number[];
}

interface CacheItem {
  timestamp: number;
  startDate: string;
  endDate: string;
  data: CharacterComparison[];
}

// Row component for character comparison
const CharacterRow = ({ character, timeRangeType, onAnalyze }: { 
  character: CharacterComparison, 
  timeRangeType: string,
  onAnalyze: (characterId: number, killIds: number[]) =&gt; void 
}) =&gt; {
  const [open, setOpen] = useState(false);
  const [syncing, setSyncing] = useState(false);
  const [syncResult, setSyncResult] = useState&lt;string | null&gt;(null);
  const [showTrends, setShowTrends] = useState(false);

  const syncCharacterKills = async () =&gt; {
    setSyncing(true);
    setSyncResult(null);
    try {
      await fetchApi(`/api/character-kills?character_id=${character.character_id}`);
      setSyncResult(&apos;Sync completed successfully!&apos;);
      setTimeout(() =&gt; setSyncResult(null), 3000);
    } catch (error) {
      console.error(&apos;Failed to sync character kills:&apos;, error);
      setSyncResult(&apos;Sync failed. Please try again.&apos;);
    } finally {
      setSyncing(false);
    }
  };

  return (
    &lt;&gt;
      &lt;TableRow sx={{ &apos;&amp; &gt; *&apos;: { borderBottom: &apos;unset&apos; } }}&gt;
        &lt;TableCell&gt;
          &lt;IconButton
            aria-label=&quot;expand row&quot;
            size=&quot;small&quot;
            onClick={() =&gt; setOpen(!open)}
          &gt;
            {open ? &lt;KeyboardArrowUpIcon /&gt; : &lt;KeyboardArrowDownIcon /&gt;}
          &lt;/IconButton&gt;
        &lt;/TableCell&gt;
        &lt;TableCell component=&quot;th&quot; scope=&quot;row&quot;&gt;
          {character.character_name}
        &lt;/TableCell&gt;
        &lt;TableCell align=&quot;right&quot;&gt;{character.our_kills}&lt;/TableCell&gt;
        &lt;TableCell align=&quot;right&quot;&gt;{character.zkill_kills}&lt;/TableCell&gt;
        &lt;TableCell align=&quot;right&quot;&gt;{character.missing_kills.length}&lt;/TableCell&gt;
        &lt;TableCell align=&quot;right&quot;&gt;
          &lt;Chip 
            label={`${character.missing_percentage.toFixed(1)}%`} 
            color={character.missing_percentage &gt; 10 ? &quot;error&quot; : 
                 character.missing_percentage &gt; 5 ? &quot;warning&quot; : &quot;success&quot;} 
            variant=&quot;outlined&quot;
          /&gt;
        &lt;/TableCell&gt;
        &lt;TableCell&gt;
          &lt;Box sx={{ display: &apos;flex&apos;, gap: 1 }}&gt;
            &lt;IconButton 
              color=&quot;primary&quot; 
              onClick={syncCharacterKills} 
              disabled={syncing}
              title=&quot;Sync character kills&quot;
            &gt;
              {syncing ? &lt;CircularProgress size={24} /&gt; : &lt;SyncIcon /&gt;}
            &lt;/IconButton&gt;
            {character.missing_kills.length &gt; 0 &amp;&amp; (
              &lt;Button
                variant=&quot;outlined&quot;
                size=&quot;small&quot;
                onClick={() =&gt; onAnalyze(character.character_id, character.missing_kills)}
              &gt;
                Analyze
              &lt;/Button&gt;
            )}
            &lt;Button
              variant=&quot;outlined&quot;
              size=&quot;small&quot;
              onClick={() =&gt; setShowTrends(!showTrends)}
            &gt;
              {showTrends ? &apos;Hide Trends&apos; : &apos;Show Trends&apos;}
            &lt;/Button&gt;
          &lt;/Box&gt;
          {syncResult &amp;&amp; (
            &lt;Typography variant=&quot;caption&quot; color={syncResult.includes(&apos;failed&apos;) ? &apos;error&apos; : &apos;success&apos;}&gt;
              {syncResult}
            &lt;/Typography&gt;
          )}
        &lt;/TableCell&gt;
      &lt;/TableRow&gt;
      &lt;TableRow&gt;
        &lt;TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={7}&gt;
          &lt;Collapse in={open || showTrends} timeout=&quot;auto&quot; unmountOnExit&gt;
            &lt;Box sx={{ margin: 1 }}&gt;
              {open &amp;&amp; (
                &lt;&gt;
                  &lt;Typography variant=&quot;h6&quot; gutterBottom component=&quot;div&quot;&gt;
                    Missing Kill IDs
                  &lt;/Typography&gt;
                  &lt;Box sx={{ display: &apos;flex&apos;, flexWrap: &apos;wrap&apos;, gap: 1 }}&gt;
                    {character.missing_kills.length &gt; 0 ? (
                      character.missing_kills.map((killId) =&gt; (
                        &lt;Chip 
                          key={killId} 
                          label={killId} 
                          onClick={() =&gt; window.open(`https://zkillboard.com/kill/${killId}/`, &apos;_blank&apos;)}
                          clickable
                        /&gt;
                      ))
                    ) : (
                      &lt;Typography variant=&quot;body2&quot; color=&quot;text.secondary&quot;&gt;
                        No missing kills found
                      &lt;/Typography&gt;
                    )}
                  &lt;/Box&gt;
                &lt;/&gt;
              )}
              
              {showTrends &amp;&amp; (
                &lt;Box mt={2}&gt;
                  &lt;KillComparisonTrends 
                    characterId={character.character_id}
                    timeRangeType={timeRangeType}
                  /&gt;
                &lt;/Box&gt;
              )}
            &lt;/Box&gt;
          &lt;/Collapse&gt;
        &lt;/TableCell&gt;
      &lt;/TableRow&gt;
    &lt;/&gt;
  );
};

const KillComparison: React.FC = () =&gt; {
  const timeRangeOptions = [
    { value: &quot;1h&quot;, label: &quot;Last Hour&quot; },
    { value: &quot;4h&quot;, label: &quot;Last 4 Hours&quot; },
    { value: &quot;12h&quot;, label: &quot;Last 12 Hours&quot; },
    { value: &quot;24h&quot;, label: &quot;Last 24 Hours&quot; },
    { value: &quot;7d&quot;, label: &quot;Last 7 Days&quot; }
  ];
  
  const [timeRangeType, setTimeRangeType] = useState&lt;string&gt;(&quot;4h&quot;);
  const [characterData, setCharacterData] = useState&lt;CharacterComparison[]&gt;([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  const [syncMessage, setSyncMessage] = useState&lt;{type: &apos;success&apos; | &apos;error&apos;, text: string} | null&gt;(null);
  const [analyzingCharacter, setAnalyzingCharacter] = useState&lt;number | null&gt;(null);
  const [analysisResults, setAnalysisResults] = useState&lt;AnalysisResult[] | null&gt;(null);
  const [cacheInfo, setCacheInfo] = useState&lt;{cached_at?: string, cache_expires_at?: string} | null&gt;(null);

  const loadComparisonData = async () =&gt; {
    setLoading(true);
    setError(null);
    setAnalysisResults(null);
    setCacheInfo(null);

    try {
      const response = await fetchApi(`/api/kills/compare-cache?type=${timeRangeType}`);
      
      if (!response || !response.data) {
        throw new Error(&apos;No response data received&apos;);
      }
      
      if (!response.data.character_breakdown || !Array.isArray(response.data.character_breakdown)) {
        throw new Error(&apos;No character breakdown data received&apos;);
      }

      setCacheInfo({
        cached_at: response.data.cached_at,
        cache_expires_at: response.data.cache_expires_at
      });

      const sortedData = [...response.data.character_breakdown].sort(
        (a, b) =&gt; b.missing_percentage - a.missing_percentage
      );
      
      setCharacterData(sortedData);
      
    } catch (error) {
      console.error(&apos;Failed to load comparison data:&apos;, error);
      setError(`Failed to load data: ${error instanceof Error ? error.message : String(error)}`);
      setCharacterData([]);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() =&gt; {
    loadComparisonData();
  }, [timeRangeType]);

  const handleSyncAllMissing = async () =&gt; {
    if (!confirm(&quot;This will fetch and sync kills for all characters with missing data. Continue?&quot;)) {
      return;
    }
    
    const charactersWithMissing = characterData.filter(char =&gt; char.missing_percentage &gt; 0);
    
    if (charactersWithMissing.length === 0) {
      setSyncMessage({ type: &apos;success&apos;, text: &apos;No characters with missing kills found!&apos; });
      setTimeout(() =&gt; setSyncMessage(null), 3000);
      return;
    }
    
    try {
      setSyncMessage({ type: &apos;success&apos;, text: &apos;Starting sync of all characters...&apos; });
      
      for (const character of charactersWithMissing) {
        setSyncMessage({ 
          type: &apos;success&apos;, 
          text: `Syncing ${character.character_name} (${charactersWithMissing.indexOf(character) + 1}/${charactersWithMissing.length})...` 
        });
        
        await fetchApi(`/api/character-kills?character_id=${character.character_id}`);
      }
      
      setSyncMessage({ type: &apos;success&apos;, text: &apos;All characters synced successfully!&apos; });
      loadComparisonData();
      setTimeout(() =&gt; setSyncMessage(null), 5000);
    } catch (error) {
      setSyncMessage({ type: &apos;error&apos;, text: `Error syncing characters: ${error}` });
    }
  };

  const handleAnalyzeMissing = async (characterId: number, killIds: number[]) =&gt; {
    if (killIds.length === 0) return;
    
    setAnalyzingCharacter(characterId);
    setAnalysisResults(null);
    
    try {
      const response = await fetchApi(&apos;/api/kills/analyze-missing&apos;, {
        method: &apos;POST&apos;,
        body: JSON.stringify({
          character_id: characterId,
          kill_ids: killIds
        })
      });
      
      if (response.data) {
        setAnalysisResults(response.data);
      }
    } catch (error) {
      console.error(&apos;Failed to analyze missing kills:&apos;, error);
      setError(`Analysis failed: ${error instanceof Error ? error.message : String(error)}`);
    } finally {
      setAnalyzingCharacter(null);
    }
  };

  const formatDate = (dateString?: string) =&gt; {
    if (!dateString) return &quot;&quot;;
    try {
      const date = new Date(dateString);
      return date.toLocaleString();
    } catch (e) {
      return dateString;
    }
  };

  const getCharacterName = (characterId: number | null) =&gt; {
    if (!characterId) return &apos;&apos;;
    const character = characterData.find(c =&gt; c.character_id === characterId);
    return character ? character.character_name : `Character #${characterId}`;
  };

  return (
    &lt;Box sx={{ p: 3 }}&gt;
      &lt;Typography variant=&quot;h4&quot; gutterBottom&gt;
        Kill Comparison Tool
      &lt;/Typography&gt;

      &lt;Card sx={{ mb: 3 }}&gt;
        &lt;CardContent&gt;
          &lt;Grid container spacing={3} alignItems=&quot;center&quot;&gt;
            &lt;Grid item xs={12} md={6}&gt;
              &lt;FormControl fullWidth&gt;
                &lt;InputLabel id=&quot;timerange-select-label&quot;&gt;Time Range&lt;/InputLabel&gt;
                &lt;Select
                  labelId=&quot;timerange-select-label&quot;
                  value={timeRangeType}
                  label=&quot;Time Range&quot;
                  onChange={(e) =&gt; setTimeRangeType(e.target.value)}
                &gt;
                  {timeRangeOptions.map(option =&gt; (
                    &lt;MenuItem key={option.value} value={option.value}&gt;
                      {option.label}
                    &lt;/MenuItem&gt;
                  ))}
                &lt;/Select&gt;
              &lt;/FormControl&gt;
            &lt;/Grid&gt;
            
            &lt;Grid item xs={12} md={6}&gt;
              &lt;Button
                variant=&quot;contained&quot;
                onClick={loadComparisonData}
                disabled={loading}
                startIcon={loading ? &lt;CircularProgress size={20} /&gt; : &lt;RefreshIcon /&gt;}
                fullWidth
                sx={{ height: &apos;56px&apos; }}
              &gt;
                {loading ? &apos;Loading...&apos; : &apos;Refresh Data&apos;}
              &lt;/Button&gt;
            &lt;/Grid&gt;
          &lt;/Grid&gt;
          
          &lt;Box sx={{ mt: 2, display: &apos;flex&apos;, justifyContent: &apos;space-between&apos;, alignItems: &apos;center&apos; }}&gt;
            &lt;Typography variant=&quot;caption&quot; color=&quot;text.secondary&quot;&gt;
              Using pre-cached data for better performance.
            &lt;/Typography&gt;
            
            {cacheInfo &amp;&amp; (
              &lt;Typography variant=&quot;caption&quot; color=&quot;text.secondary&quot;&gt;
                Cached at: {formatDate(cacheInfo.cached_at)} 
                {cacheInfo.cache_expires_at &amp;&amp; ` (expires: ${formatDate(cacheInfo.cache_expires_at)})`}
              &lt;/Typography&gt;
            )}
          &lt;/Box&gt;
        &lt;/CardContent&gt;
      &lt;/Card&gt;

      {error &amp;&amp; (
        &lt;Alert severity=&quot;error&quot; sx={{ mb: 3 }} onClose={() =&gt; setError(null)}&gt;
          {error}
        &lt;/Alert&gt;
      )}
      
      {syncMessage &amp;&amp; (
        &lt;Alert 
          severity={syncMessage.type} 
          sx={{ mb: 3 }}
          onClose={() =&gt; setSyncMessage(null)}
        &gt;
          {syncMessage.text}
        &lt;/Alert&gt;
      )}

      {loading ? (
        &lt;Box display=&quot;flex&quot; justifyContent=&quot;center&quot; alignItems=&quot;center&quot; py={4}&gt;
          &lt;CircularProgress /&gt;
        &lt;/Box&gt;
      ) : characterData.length &gt; 0 ? (
        &lt;Card sx={{ mb: 3 }}&gt;
          &lt;CardContent&gt;
            &lt;Box display=&quot;flex&quot; justifyContent=&quot;space-between&quot; alignItems=&quot;center&quot; mb={2}&gt;
              &lt;Typography variant=&quot;h6&quot;&gt;
                Character Kill Comparison
                {refreshing &amp;&amp; (
                  &lt;CircularProgress size={16} sx={{ ml: 1, verticalAlign: &apos;middle&apos; }} /&gt;
                )}
              &lt;/Typography&gt;
              {characterData.some(char =&gt; char.missing_percentage &gt; 0) &amp;&amp; (
                &lt;Button 
                  variant=&quot;contained&quot; 
                  color=&quot;primary&quot; 
                  onClick={handleSyncAllMissing}
                  startIcon={&lt;SyncIcon /&gt;}
                &gt;
                  Sync All Missing
                &lt;/Button&gt;
              )}
            &lt;/Box&gt;

            &lt;TableContainer component={Paper}&gt;
              &lt;Table aria-label=&quot;character breakdown table&quot;&gt;
                &lt;TableHead&gt;
                  &lt;TableRow&gt;
                    &lt;TableCell /&gt;
                    &lt;TableCell&gt;Character&lt;/TableCell&gt;
                    &lt;TableCell align=&quot;right&quot;&gt;Our DB Kills&lt;/TableCell&gt;
                    &lt;TableCell align=&quot;right&quot;&gt;zKill Kills&lt;/TableCell&gt;
                    &lt;TableCell align=&quot;right&quot;&gt;Missing&lt;/TableCell&gt;
                    &lt;TableCell align=&quot;right&quot;&gt;Missing %&lt;/TableCell&gt;
                    &lt;TableCell&gt;Actions&lt;/TableCell&gt;
                  &lt;/TableRow&gt;
                &lt;/TableHead&gt;
                &lt;TableBody&gt;
                  {characterData.map((character) =&gt; (
                    &lt;CharacterRow 
                      key={character.character_id} 
                      character={character}
                      timeRangeType={timeRangeType}
                      onAnalyze={handleAnalyzeMissing}
                    /&gt;
                  ))}
                &lt;/TableBody&gt;
              &lt;/Table&gt;
            &lt;/TableContainer&gt;
            
            {!characterData.some(char =&gt; char.missing_percentage &gt; 0) &amp;&amp; (
              &lt;Alert severity=&quot;success&quot; sx={{ mt: 2 }}&gt;
                All tracked characters have complete kill data! No missing kills found.
              &lt;/Alert&gt;
            )}
          &lt;/CardContent&gt;
        &lt;/Card&gt;
      ) : (
        &lt;Alert severity=&quot;info&quot; sx={{ mb: 3 }}&gt;
          No character data available for the selected time period.
        &lt;/Alert&gt;
      )}

      {analysisResults &amp;&amp; (
        &lt;Card&gt;
          &lt;CardContent&gt;
            &lt;Typography variant=&quot;h6&quot; gutterBottom&gt;
              Missing Kills Analysis for {getCharacterName(analyzingCharacter)}
            &lt;/Typography&gt;
            &lt;Grid container spacing={2}&gt;
              {analysisResults.map((result) =&gt; (
                &lt;Grid item xs={12} key={result.reason}&gt;
                  &lt;Typography variant=&quot;subtitle1&quot;&gt;
                    {result.reason} ({result.count} kills)
                  &lt;/Typography&gt;
                  {result.examples.length &gt; 0 &amp;&amp; (
                    &lt;Typography variant=&quot;body2&quot; color=&quot;textSecondary&quot;&gt;
                      Example Kill IDs: {result.examples.join(&apos;, &apos;)}
                    &lt;/Typography&gt;
                  )}
                &lt;/Grid&gt;
              ))}
            &lt;/Grid&gt;
          &lt;/CardContent&gt;
        &lt;/Card&gt;
      )}
    &lt;/Box&gt;
  );
};

export default KillComparison;</file><file path="renderer/src/components/KillComparisonTrends.tsx">import React from &apos;react&apos;;
import { Box, Card, CardContent, Typography, CircularProgress } from &apos;@mui/material&apos;;
import { LineChart, Line, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer } from &apos;recharts&apos;;
import { format } from &apos;date-fns&apos;;
import { useQuery } from &apos;@tanstack/react-query&apos;;
import { fetchApi } from &apos;../utils/api&apos;;

interface TrendData {
  timestamp: string;
  our_kills: number;
  zkill_kills: number;
  missing_count: number;
  percentage_match: number;
}

interface KillComparisonTrendsProps {
  characterId: number;
  timeRangeType: string;
}

const KillComparisonTrends: React.FC&lt;KillComparisonTrendsProps&gt; = ({ characterId, timeRangeType }) =&gt; {
  const { data: trendData, isLoading, error } = useQuery&lt;TrendData[]&gt;(
    [&apos;killTrends&apos;, characterId, timeRangeType],
    async () =&gt; {
      const response = await fetchApi(`/api/kills/trends?character_id=${characterId}&amp;time_range=${timeRangeType}`);
      return response.data;
    },
    {
      refetchInterval: 300000, // Refresh every 5 minutes
      enabled: !!characterId &amp;&amp; !!timeRangeType
    }
  );

  if (isLoading) {
    return (
      &lt;Box display=&quot;flex&quot; justifyContent=&quot;center&quot; p={2}&gt;
        &lt;CircularProgress /&gt;
      &lt;/Box&gt;
    );
  }

  if (error) {
    return (
      &lt;Box p={2}&gt;
        &lt;Typography color=&quot;error&quot;&gt;Error loading trend data&lt;/Typography&gt;
      &lt;/Box&gt;
    );
  }

  const formatDate = (timestamp: string) =&gt; {
    return format(new Date(timestamp), &apos;HH:mm:ss&apos;);
  };

  return (
    &lt;Card&gt;
      &lt;CardContent&gt;
        &lt;Typography variant=&quot;h6&quot; gutterBottom&gt;
          Kill Tracking Trends
        &lt;/Typography&gt;

        &lt;Box height={300}&gt;
          &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;100%&quot;&gt;
            &lt;LineChart
              data={trendData}
              margin={{
                top: 5,
                right: 30,
                left: 20,
                bottom: 5,
              }}
            &gt;
              &lt;XAxis 
                dataKey=&quot;timestamp&quot; 
                tickFormatter={formatDate}
              /&gt;
              &lt;YAxis yAxisId=&quot;left&quot; /&gt;
              &lt;YAxis yAxisId=&quot;right&quot; orientation=&quot;right&quot; /&gt;
              &lt;Tooltip
                labelFormatter={(label) =&gt; format(new Date(label), &apos;yyyy-MM-dd HH:mm:ss&apos;)}
              /&gt;
              &lt;Legend /&gt;
              &lt;Line
                yAxisId=&quot;left&quot;
                type=&quot;monotone&quot;
                dataKey=&quot;our_kills&quot;
                name=&quot;Our Kills&quot;
                stroke=&quot;#8884d8&quot;
                dot={false}
              /&gt;
              &lt;Line
                yAxisId=&quot;left&quot;
                type=&quot;monotone&quot;
                dataKey=&quot;zkill_kills&quot;
                name=&quot;zKill Kills&quot;
                stroke=&quot;#82ca9d&quot;
                dot={false}
              /&gt;
              &lt;Line
                yAxisId=&quot;right&quot;
                type=&quot;monotone&quot;
                dataKey=&quot;percentage_match&quot;
                name=&quot;Match %&quot;
                stroke=&quot;#ffc658&quot;
                dot={false}
              /&gt;
            &lt;/LineChart&gt;
          &lt;/ResponsiveContainer&gt;
        &lt;/Box&gt;

        {trendData &amp;&amp; trendData.length &gt; 0 &amp;&amp; (
          &lt;Box mt={2}&gt;
            &lt;Typography variant=&quot;body2&quot; color=&quot;textSecondary&quot;&gt;
              Last updated: {format(new Date(trendData[0].timestamp), &apos;yyyy-MM-dd HH:mm:ss&apos;)}
            &lt;/Typography&gt;
          &lt;/Box&gt;
        )}
      &lt;/CardContent&gt;
    &lt;/Card&gt;
  );
};

export default KillComparisonTrends;</file><file path="renderer/src/components/KillmailChartCard.jsx">import React, { useState, useEffect } from &apos;react&apos;;
import { FaSync, FaDiscord, FaExclamationTriangle, FaCircleNotch, FaCheckCircle } from &apos;react-icons/fa&apos;;

function KillmailChartCard({ title, description, chartType, loadChartImage }) {
  const [chartUrl, setChartUrl] = useState(null);
  const [loading, setLoading] = useState(false);
  const [sending, setSending] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);

  const generateChart = async (forceRefresh = false) =&gt; {
    setLoading(true);
    setError(null);
    
    // Add a timestamp for force refresh
    const timestamp = forceRefresh ? `?t=${Date.now()}` : &apos;&apos;;
    console.log(`Fetching chart for ${chartType}${forceRefresh ? &apos; (force refresh)&apos; : &apos;&apos;}...`);
    
    try {
      // Use the original endpoint (UI-specific one was removed)
      const response = await fetch(`/api/charts/killmail/generate/${chartType}${timestamp}`);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      // Handle binary image data
      const blob = await response.blob();
      const imageUrl = URL.createObjectURL(blob);
      setChartUrl(imageUrl);
    } catch (error) {
      console.error(`Error generating ${chartType} chart:`, error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() =&gt; {
    generateChart();
    return () =&gt; {
      // Cleanup object URLs when component unmounts
      if (chartUrl) {
        URL.revokeObjectURL(chartUrl);
      }
    };
  }, [chartType]);

  const sendToDiscord = async () =&gt; {
    setSending(true);
    setSuccess(null);
    setError(null);
    
    console.log(&apos;Sending chart to Discord...&apos;);
    
    try {
      // Note: We&apos;re still using the original endpoint for Discord sending
      // This ensures we use the default Discord-friendly background
      const response = await fetch(`/api/charts/killmail/send-to-discord/${chartType}`);
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      if (data.status === &apos;ok&apos;) {
        setSuccess(&apos;Chart sent to Discord!&apos;);
        setTimeout(() =&gt; setSuccess(null), 5000);
      } else {
        throw new Error(data.message || &apos;Failed to send chart to Discord&apos;);
      }
    } catch (error) {
      console.error(&apos;Error sending chart to Discord:&apos;, error);
      setError(`Failed to send chart: ${error.message}`);
    } finally {
      setSending(false);
    }
  };

  return (
    &lt;div className=&quot;bg-white rounded-lg shadow-md overflow-hidden&quot;&gt;
      &lt;div className=&quot;p-4 border-b&quot;&gt;
        &lt;h2 className=&quot;text-xl font-semibold text-gray-800&quot;&gt;{title}&lt;/h2&gt;
        {chartType !== &apos;weekly_kills&apos; &amp;&amp; (
          &lt;p className=&quot;text-gray-600 text-sm mt-1&quot;&gt;{description}&lt;/p&gt;
        )}
      &lt;/div&gt;
      
      &lt;div className=&quot;relative bg-black rounded-lg overflow-hidden&quot;&gt;
        {loading ? (
          &lt;div className=&quot;flex items-center justify-center h-64&quot;&gt;
            &lt;FaCircleNotch className=&quot;h-8 w-8 text-gray-400 animate-spin&quot; /&gt;
          &lt;/div&gt;
        ) : chartUrl ? (
          &lt;img
            src={chartUrl}
            alt={title}
            className=&quot;w-full h-auto&quot;
            onError={(e) =&gt; {
              console.error(&apos;Error loading chart image&apos;);
              setError(&apos;Failed to load chart image&apos;);
              e.target.style.display = &apos;none&apos;;
            }}
          /&gt;
        ) : (
          &lt;div className=&quot;flex items-center justify-center h-64 text-gray-500&quot;&gt;
            No chart available
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      {error &amp;&amp; (
        &lt;div className=&quot;p-4 bg-red-50&quot;&gt;
          &lt;div className=&quot;flex items-center text-sm text-red-700&quot;&gt;
            &lt;FaExclamationTriangle className=&quot;mr-2&quot; /&gt;
            {error}
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {success &amp;&amp; (
        &lt;div className=&quot;p-4 bg-green-50&quot;&gt;
          &lt;div className=&quot;flex items-center text-sm text-green-700&quot;&gt;
            &lt;FaCheckCircle className=&quot;mr-2&quot; /&gt;
            {success}
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      &lt;div className=&quot;p-4 flex justify-end space-x-2&quot;&gt;
        &lt;button
          type=&quot;button&quot;
          onClick={() =&gt; generateChart(true)}
          disabled={loading}
          title=&quot;Refresh Chart&quot;
          className=&quot;p-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition flex items-center justify-center disabled:opacity-50&quot;
        &gt;
          {loading ? &lt;FaCircleNotch className=&quot;animate-spin&quot; /&gt; : &lt;FaSync className=&quot;mr-2&quot; /&gt;}
          &lt;span&gt;Refresh&lt;/span&gt;
        &lt;/button&gt;

        &lt;button
          type=&quot;button&quot;
          onClick={sendToDiscord}
          disabled={sending || loading}
          title=&quot;Send to Discord&quot;
          className=&quot;p-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition flex items-center justify-center disabled:opacity-50&quot;
        &gt;
          {sending ? &lt;FaCircleNotch className=&quot;animate-spin&quot; /&gt; : &lt;FaDiscord className=&quot;mr-2&quot; /&gt;}
          &lt;span&gt;Send to Discord&lt;/span&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default KillmailChartCard;</file><file path="renderer/src/components/Navigation.tsx">import React from &apos;react&apos;;
import { Link } from &apos;react-router-dom&apos;;
import { Drawer, List, ListItem, ListItemIcon, ListItemText } from &apos;@mui/material&apos;;
import CompareIcon from &apos;@mui/icons-material/Compare&apos;;
import BarChartIcon from &apos;@mui/icons-material/BarChart&apos;;
import TimelineIcon from &apos;@mui/icons-material/Timeline&apos;;

const Navigation: React.FC = () =&gt; {
  const menuItems = [
    {
      text: &apos;Kill Comparison&apos;,
      icon: &lt;CompareIcon /&gt;,
      path: &apos;/kill-comparison&apos;
    },
    {
      text: &apos;Activity Charts&apos;,
      icon: &lt;TimelineIcon /&gt;,
      path: &apos;/charts&apos;
    },
    {
      text: &apos;Kill Charts&apos;,
      icon: &lt;BarChartIcon /&gt;,
      path: &apos;/kill-charts&apos;
    }
  ];

  return (
    &lt;Drawer variant=&quot;permanent&quot; anchor=&quot;left&quot;&gt;
      &lt;List&gt;
        {menuItems.map((item) =&gt; (
          &lt;ListItem 
            key={item.text} 
            component={Link} 
            to={item.path}
            sx={{ &apos;&amp;:hover&apos;: { backgroundColor: &apos;rgba(0, 0, 0, 0.04)&apos; } }}
          &gt;
            &lt;ListItemIcon&gt;{item.icon}&lt;/ListItemIcon&gt;
            &lt;ListItemText primary={item.text} /&gt;
          &lt;/ListItem&gt;
        ))}
      &lt;/List&gt;
    &lt;/Drawer&gt;
  );
};

export default Navigation;</file><file path="renderer/src/components/SchedulerCard.jsx">import React, { useState } from &apos;react&apos;;
import { 
  FaCalendarCheck, 
  FaHourglassHalf, 
  FaCalendarAlt, 
  FaCheckCircle, 
  FaExclamationTriangle, 
  FaClock, 
  FaPlayCircle,
  FaCircleNotch
} from &apos;react-icons/fa&apos;;

// Component for displaying individual scheduler information in a card
const SchedulerCard = ({ scheduler, onRefresh }) =&gt; {
  const [executing, setExecuting] = useState(false);

  // Handle case when scheduler isn&apos;t fully loaded
  if (!scheduler) return null;

  const {
    name,
    type,
    enabled,
    last_run,
    next_run,
    interval,
    hour,
    minute,
    stats
  } = scheduler;

  // Format interval in a human-readable format (convert from ms to seconds/minutes)
  const formatInterval = (intervalMs) =&gt; {
    if (!intervalMs) return &apos;N/A&apos;;
    
    if (intervalMs &lt; 1000) return `${intervalMs}ms`;
    if (intervalMs &lt; 60000) return `${Math.round(intervalMs / 1000)}s`;
    if (intervalMs &lt; 3600000) return `${Math.round(intervalMs / 60000)}m`;
    return `${Math.round(intervalMs / 3600000)}h`;
  };

  // Calculate success rate percentage
  const calculateSuccessRate = () =&gt; {
    const total = (stats?.success_count || 0) + (stats?.error_count || 0);
    if (total === 0) return 0;
    return Math.round((stats?.success_count || 0) * 100 / total);
  };

  // Determine color based on success rate
  const getSuccessRateColor = (rate) =&gt; {
    if (rate &gt;= 90) return &apos;text-green-600&apos;;
    if (rate &gt;= 70) return &apos;text-yellow-600&apos;;
    return &apos;text-red-600&apos;;
  };

  // Special formatting for schedule display
  const getScheduleDisplay = () =&gt; {
    if (type === &apos;interval&apos; &amp;&amp; interval) {
      return `Every ${formatInterval(interval)}`;
    } else if (type === &apos;time&apos;) {
      // Safely handle potentially null hour and minute values
      const hourStr = hour !== null &amp;&amp; hour !== undefined ? hour.toString().padStart(2, &apos;0&apos;) : &apos;00&apos;;
      const minuteStr = minute !== null &amp;&amp; minute !== undefined ? minute.toString().padStart(2, &apos;0&apos;) : &apos;00&apos;;
      return `Daily at ${hourStr}:${minuteStr} UTC`;
    }
    return &apos;Unknown schedule&apos;;
  };

  // Get icon based on scheduler type
  const getTypeIcon = () =&gt; {
    if (type === &apos;interval&apos;) return &lt;FaHourglassHalf className=&quot;mr-1 text-indigo-500&quot; /&gt;;
    if (type === &apos;time&apos;) return &lt;FaCalendarAlt className=&quot;mr-1 text-purple-500&quot; /&gt;;
    return &lt;FaClock className=&quot;mr-1 text-gray-500&quot; /&gt;;
  };

  // Execute the scheduler
  const handleExecute = async () =&gt; {
    if (!enabled || executing) return;
    
    try {
      setExecuting(true);
      const response = await fetch(`/api/debug/schedulers/${name}/execute`, {
        method: &apos;POST&apos;,
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      // Wait a bit before refreshing to allow the scheduler to complete
      setTimeout(() =&gt; {
        if (onRefresh) onRefresh();
        setExecuting(false);
      }, 1000);
    } catch (err) {
      console.error(&apos;Error executing scheduler:&apos;, err);
      setExecuting(false);
    }
  };

  return (
    &lt;div className={`bg-white rounded-lg shadow-sm border ${enabled ? &apos;border-green-100&apos; : &apos;border-gray-200&apos;} p-4 hover:shadow-md transition-shadow`}&gt;
      {/* Header */}
      &lt;div className=&quot;flex justify-between items-center mb-3&quot;&gt;
        &lt;h3 className=&quot;font-semibold text-gray-800 text-lg flex items-center&quot;&gt;
          {getTypeIcon()}
          &lt;span&gt;{name}&lt;/span&gt;
        &lt;/h3&gt;
        &lt;span className={`px-2 py-1 text-xs rounded-full ${enabled ? &apos;bg-green-100 text-green-800&apos; : &apos;bg-gray-100 text-gray-800&apos;}`}&gt;
          {enabled ? &apos;Enabled&apos; : &apos;Disabled&apos;}
        &lt;/span&gt;
      &lt;/div&gt;

      {/* Schedule information */}
      &lt;div className=&quot;text-sm text-gray-600 mb-3 flex items-center&quot;&gt;
        &lt;FaCalendarCheck className=&quot;mr-1 text-gray-500&quot; /&gt;
        &lt;span&gt;{getScheduleDisplay()}&lt;/span&gt;
      &lt;/div&gt;

      {/* Last run and next run information */}
      &lt;div className=&quot;grid grid-cols-2 gap-3 mb-3&quot;&gt;
        &lt;div&gt;
          &lt;div className=&quot;text-xs text-gray-500 mb-1&quot;&gt;Last Run&lt;/div&gt;
          &lt;div className=&quot;text-sm&quot;&gt;
            {last_run ? (
              &lt;div className=&quot;flex items-center&quot;&gt;
                {last_run.relative}
              &lt;/div&gt;
            ) : (
              &lt;span className=&quot;text-gray-400&quot;&gt;Never&lt;/span&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;div className=&quot;text-xs text-gray-500 mb-1&quot;&gt;Next Run&lt;/div&gt;
          &lt;div className=&quot;text-sm&quot;&gt;
            {next_run ? (
              &lt;div className=&quot;flex items-center&quot;&gt;
                {next_run.relative}
              &lt;/div&gt;
            ) : (
              &lt;span className=&quot;text-gray-400&quot;&gt;Unknown&lt;/span&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Statistics */}
      &lt;div className=&quot;mt-4 pt-3 border-t border-gray-100&quot;&gt;
        &lt;div className=&quot;grid grid-cols-3 gap-2 text-center&quot;&gt;
          &lt;div&gt;
            &lt;div className=&quot;text-xs text-gray-500 mb-1&quot;&gt;Success Rate&lt;/div&gt;
            &lt;div className={`font-semibold ${getSuccessRateColor(calculateSuccessRate())}`}&gt;
              {calculateSuccessRate()}%
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;div className=&quot;text-xs text-gray-500 mb-1&quot;&gt;Successes&lt;/div&gt;
            &lt;div className=&quot;text-green-600 font-semibold flex items-center justify-center&quot;&gt;
              &lt;FaCheckCircle className=&quot;mr-1&quot; /&gt;
              {stats?.success_count || 0}
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;div className=&quot;text-xs text-gray-500 mb-1&quot;&gt;Errors&lt;/div&gt;
            &lt;div className=&quot;text-red-600 font-semibold flex items-center justify-center&quot;&gt;
              &lt;FaExclamationTriangle className=&quot;mr-1&quot; /&gt;
              {stats?.error_count || 0}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Last run duration if available */}
        {stats?.last_duration_ms &amp;&amp; (
          &lt;div className=&quot;mt-3 text-xs text-gray-600&quot;&gt;
            Last duration: {stats.last_duration_ms}ms
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      {/* Run now button - disabled if scheduler is disabled or currently executing */}
      &lt;div className=&quot;mt-3 flex justify-end&quot;&gt;
        &lt;button
          disabled={!enabled || executing}
          className={`text-xs px-2 py-1 rounded flex items-center ${
            enabled &amp;&amp; !executing
              ? &apos;bg-indigo-50 text-indigo-700 hover:bg-indigo-100&apos;
              : &apos;bg-gray-50 text-gray-400 cursor-not-allowed&apos;
          }`}
          onClick={handleExecute}
        &gt;
          {executing ? (
            &lt;FaCircleNotch className=&quot;mr-1 animate-spin&quot; /&gt;
          ) : (
            &lt;FaPlayCircle className=&quot;mr-1&quot; /&gt;
          )}
          {executing ? &apos;Running...&apos; : &apos;Run Now&apos;}
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default SchedulerCard;</file><file path="renderer/src/components/SchedulerDashboard.jsx">import React, { useState, useEffect } from &apos;react&apos;;
import SchedulerCard from &apos;./SchedulerCard&apos;;
import { 
  FaCalendarAlt, 
  FaCircleNotch, 
  FaExclamationTriangle, 
  FaSync, 
  FaPlayCircle,
  FaFilter,
  FaCheck,
  FaTimes
} from &apos;react-icons/fa&apos;;

// Dashboard component for displaying all scheduler information
const SchedulerDashboard = () =&gt; {
  const [schedulers, setSchedulers] = useState([]);
  const [summary, setSummary] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [refreshing, setRefreshing] = useState(false);
  const [filter, setFilter] = useState(&apos;all&apos;); // all, enabled, disabled, interval, time

  // Fetch scheduler data on component mount and when manual refresh is triggered
  useEffect(() =&gt; {
    fetchSchedulers();
  }, []);

  // Function to fetch scheduler data from the API
  const fetchSchedulers = async () =&gt; {
    try {
      setRefreshing(true);
      console.log(&apos;Fetching scheduler data...&apos;);
      const response = await fetch(&apos;/api/debug/scheduler-stats&apos;);
      
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      const responseData = await response.json();
      console.log(&apos;Scheduler data received:&apos;, responseData);
      
      // Extract data from the nested structure
      const data = responseData.data || {};
      
      if (!data.schedulers || !Array.isArray(data.schedulers)) {
        console.warn(&apos;No schedulers array in response:&apos;, responseData);
        setSchedulers([]);
        setSummary(data.summary || {
          total: 0,
          enabled: 0,
          disabled: 0,
          by_type: { interval: 0, time: 0 }
        });
        setError(&quot;No scheduler data available&quot;);
      } else {
        setSchedulers(data.schedulers);
        setSummary(data.summary);
        setError(null);
      }
    } catch (err) {
      console.error(&apos;Error fetching scheduler data:&apos;, err);
      setError(`Failed to load scheduler data: ${err.message}`);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Handle manual refresh button click
  const handleRefresh = () =&gt; {
    fetchSchedulers();
  };

  // Handle run all schedulers button click
  const handleRunAll = async () =&gt; {
    try {
      setRefreshing(true);
      const response = await fetch(&apos;/api/debug/schedulers/execute&apos;, {
        method: &apos;POST&apos;,
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      
      // After trigger execution, refresh data after a small delay to allow processing
      setTimeout(() =&gt; {
        fetchSchedulers();
      }, 1000);
    } catch (err) {
      console.error(&apos;Error executing schedulers:&apos;, err);
      setError(`Failed to execute schedulers: ${err.message}`);
      setRefreshing(false);
    }
  };

  // Filter schedulers based on selected filter
  const filteredSchedulers = () =&gt; {
    if (!schedulers || schedulers.length === 0) return [];
    
    switch (filter) {
      case &apos;enabled&apos;:
        return schedulers.filter(s =&gt; s.enabled);
      case &apos;disabled&apos;:
        return schedulers.filter(s =&gt; !s.enabled);
      case &apos;interval&apos;:
        return schedulers.filter(s =&gt; s.type === &apos;interval&apos;);
      case &apos;time&apos;:
        return schedulers.filter(s =&gt; s.type === &apos;time&apos;);
      default:
        return schedulers;
    }
  };

  // Loading state
  if (loading &amp;&amp; !schedulers.length) {
    return (
      &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;
        &lt;FaCircleNotch className=&quot;h-10 w-10 text-indigo-600 animate-spin&quot; /&gt;
      &lt;/div&gt;
    );
  }

  // Error state
  if (error &amp;&amp; !schedulers.length) {
    return (
      &lt;div className=&quot;flex items-center justify-center min-h-screen px-4&quot;&gt;
        &lt;div className=&quot;flex items-center space-x-3 bg-red-50 border border-red-200 text-red-600 p-4 rounded-md&quot;&gt;
          &lt;FaExclamationTriangle className=&quot;text-red-600&quot; /&gt;
          &lt;span&gt;{error}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className=&quot;min-h-screen bg-gradient-to-b from-indigo-50 to-white&quot;&gt;
      &lt;div className=&quot;max-w-7xl mx-auto px-4 py-8 sm:px-6 lg:px-8 space-y-6&quot;&gt;
        {/* Header */}
        &lt;div className=&quot;flex flex-col sm:flex-row items-start sm:items-center justify-between mb-6&quot;&gt;
          &lt;h1 className=&quot;flex items-center text-2xl font-bold text-indigo-800 space-x-2 mb-4 sm:mb-0&quot;&gt;
            &lt;FaCalendarAlt /&gt;
            &lt;span&gt;Scheduler Dashboard&lt;/span&gt;
          &lt;/h1&gt;
          &lt;div className=&quot;flex space-x-2&quot;&gt;
            {/* Refresh button */}
            &lt;button
              className=&quot;flex items-center px-3 py-2 bg-white text-gray-700 border border-gray-200 rounded-md hover:bg-gray-100 transition-colors&quot;
              onClick={handleRefresh}
              disabled={refreshing}
            &gt;
              {refreshing ? (
                &lt;FaCircleNotch className=&quot;mr-2 animate-spin&quot; /&gt;
              ) : (
                &lt;FaSync className=&quot;mr-2&quot; /&gt;
              )}
              &lt;span&gt;Refresh&lt;/span&gt;
            &lt;/button&gt;
            
            {/* Run all button */}
            &lt;button
              className=&quot;flex items-center px-3 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors&quot;
              onClick={handleRunAll}
              disabled={refreshing}
            &gt;
              &lt;FaPlayCircle className=&quot;mr-2&quot; /&gt;
              &lt;span&gt;Run All&lt;/span&gt;
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Error message if present */}
        {error &amp;&amp; (
          &lt;div className=&quot;bg-red-50 border border-red-200 text-red-600 p-4 rounded-md flex items-center mb-6&quot;&gt;
            &lt;FaExclamationTriangle className=&quot;mr-2&quot; /&gt;
            &lt;span&gt;{error}&lt;/span&gt;
          &lt;/div&gt;
        )}

        {/* Summary statistics */}
        {summary &amp;&amp; (
          &lt;div className=&quot;bg-white p-4 rounded-lg shadow-sm border border-gray-100 mb-6&quot;&gt;
            &lt;h2 className=&quot;text-lg font-semibold text-gray-800 mb-4&quot;&gt;Scheduler Summary&lt;/h2&gt;
            &lt;div className=&quot;grid grid-cols-2 md:grid-cols-4 gap-4&quot;&gt;
              &lt;div className=&quot;bg-indigo-50 p-3 rounded-md&quot;&gt;
                &lt;div className=&quot;text-sm text-indigo-800 mb-1&quot;&gt;Total Schedulers&lt;/div&gt;
                &lt;div className=&quot;text-2xl font-bold text-indigo-700&quot;&gt;{summary.total}&lt;/div&gt;
              &lt;/div&gt;
              &lt;div className=&quot;bg-green-50 p-3 rounded-md&quot;&gt;
                &lt;div className=&quot;text-sm text-green-800 mb-1&quot;&gt;Enabled&lt;/div&gt;
                &lt;div className=&quot;text-2xl font-bold text-green-700&quot;&gt;{summary.enabled}&lt;/div&gt;
              &lt;/div&gt;
              &lt;div className=&quot;bg-gray-50 p-3 rounded-md&quot;&gt;
                &lt;div className=&quot;text-sm text-gray-800 mb-1&quot;&gt;Disabled&lt;/div&gt;
                &lt;div className=&quot;text-2xl font-bold text-gray-700&quot;&gt;{summary.disabled}&lt;/div&gt;
              &lt;/div&gt;
              &lt;div className=&quot;bg-purple-50 p-3 rounded-md&quot;&gt;
                &lt;div className=&quot;text-sm text-purple-800 mb-1&quot;&gt;Next execution&lt;/div&gt;
                &lt;div className=&quot;text-lg font-bold text-purple-700&quot;&gt;
                  {schedulers.length &gt; 0 &amp;&amp; schedulers.some(s =&gt; s.next_run) ? 
                    schedulers
                      .filter(s =&gt; s.enabled &amp;&amp; s.next_run)
                      .sort((a, b) =&gt; new Date(a.next_run.timestamp) - new Date(b.next_run.timestamp))[0]?.next_run.relative || &apos;N/A&apos;
                    : &apos;N/A&apos;
                  }
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}

        {/* Filter controls */}
        &lt;div className=&quot;flex flex-wrap items-center space-x-2 mb-4&quot;&gt;
          &lt;div className=&quot;flex items-center text-gray-700 mr-2&quot;&gt;
            &lt;FaFilter className=&quot;mr-1&quot; /&gt;
            &lt;span&gt;Filter:&lt;/span&gt;
          &lt;/div&gt;
          
          &lt;button
            className={`px-3 py-1 text-sm rounded-full ${
              filter === &apos;all&apos; 
                ? &apos;bg-indigo-100 text-indigo-800 border border-indigo-200&apos; 
                : &apos;bg-gray-100 text-gray-700 border border-gray-200 hover:bg-gray-200&apos;
            }`}
            onClick={() =&gt; setFilter(&apos;all&apos;)}
          &gt;
            All
          &lt;/button&gt;
          
          &lt;button
            className={`px-3 py-1 text-sm rounded-full flex items-center ${
              filter === &apos;enabled&apos; 
                ? &apos;bg-green-100 text-green-800 border border-green-200&apos; 
                : &apos;bg-gray-100 text-gray-700 border border-gray-200 hover:bg-gray-200&apos;
            }`}
            onClick={() =&gt; setFilter(&apos;enabled&apos;)}
          &gt;
            &lt;FaCheck className=&quot;mr-1 text-xs&quot; /&gt;
            Enabled
          &lt;/button&gt;
          
          &lt;button
            className={`px-3 py-1 text-sm rounded-full flex items-center ${
              filter === &apos;disabled&apos; 
                ? &apos;bg-red-100 text-red-800 border border-red-200&apos; 
                : &apos;bg-gray-100 text-gray-700 border border-gray-200 hover:bg-gray-200&apos;
            }`}
            onClick={() =&gt; setFilter(&apos;disabled&apos;)}
          &gt;
            &lt;FaTimes className=&quot;mr-1 text-xs&quot; /&gt;
            Disabled
          &lt;/button&gt;
          
          &lt;button
            className={`px-3 py-1 text-sm rounded-full ${
              filter === &apos;interval&apos; 
                ? &apos;bg-indigo-100 text-indigo-800 border border-indigo-200&apos; 
                : &apos;bg-gray-100 text-gray-700 border border-gray-200 hover:bg-gray-200&apos;
            }`}
            onClick={() =&gt; setFilter(&apos;interval&apos;)}
          &gt;
            Interval
          &lt;/button&gt;
          
          &lt;button
            className={`px-3 py-1 text-sm rounded-full ${
              filter === &apos;time&apos; 
                ? &apos;bg-purple-100 text-purple-800 border border-purple-200&apos; 
                : &apos;bg-gray-100 text-gray-700 border border-gray-200 hover:bg-gray-200&apos;
            }`}
            onClick={() =&gt; setFilter(&apos;time&apos;)}
          &gt;
            Time-based
          &lt;/button&gt;
        &lt;/div&gt;
        
        {/* Scheduler cards */}
        &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4&quot;&gt;
          {filteredSchedulers().map((scheduler) =&gt; (
            &lt;SchedulerCard 
              key={scheduler.name} 
              scheduler={scheduler}
              onRefresh={fetchSchedulers}
            /&gt;
          ))}
        &lt;/div&gt;
        
        {/* Empty state */}
        {(!filteredSchedulers().length) &amp;&amp; (
          &lt;div className=&quot;text-center py-12 bg-gray-50 rounded-lg&quot;&gt;
            &lt;FaCalendarAlt className=&quot;mx-auto h-12 w-12 text-gray-400&quot; /&gt;
            &lt;h3 className=&quot;mt-2 text-sm font-medium text-gray-900&quot;&gt;No schedulers&lt;/h3&gt;
            &lt;p className=&quot;mt-1 text-sm text-gray-500&quot;&gt;
              {filter !== &apos;all&apos; 
                ? &apos;No schedulers match the current filter.&apos; 
                : &apos;No schedulers found in the system.&apos;}
            &lt;/p&gt;
            &lt;div className=&quot;mt-4&quot;&gt;
              &lt;button
                className=&quot;bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition-colors&quot;
                onClick={() =&gt; {
                  // Try fetching the raw schedulers endpoint
                  fetch(&apos;/api/debug/schedulers&apos;)
                    .then(response =&gt; response.json())
                    .then(data =&gt; {
                      console.log(&apos;Raw scheduler data:&apos;, data);
                      alert(&apos;Raw scheduler data fetched. See console for details.&apos;);
                    })
                    .catch(err =&gt; {
                      console.error(&apos;Error fetching raw scheduler data:&apos;, err);
                      alert(&apos;Error fetching raw scheduler data. See console for details.&apos;);
                    });
                }}
              &gt;
                Check Raw Scheduler Data
              &lt;/button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default SchedulerDashboard;</file><file path="renderer/src/utils/api.ts">interface ApiResponse&lt;T = any&gt; {
  data: T;
  success: boolean;
  error?: string;
}

export async function fetchApi&lt;T = any&gt;(
  url: string,
  options: RequestInit = {}
): Promise&lt;ApiResponse&lt;T&gt;&gt; {
  try {
    const defaultHeaders = {
      &apos;Content-Type&apos;: &apos;application/json&apos;,
      &apos;Accept&apos;: &apos;application/json&apos;,
    };

    const response = await fetch(url, {
      ...options,
      headers: {
        ...defaultHeaders,
        ...options.headers,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || `HTTP error! status: ${response.status}`);
    }

    return {
      data,
      success: true,
    };
  } catch (error) {
    console.error(&apos;API call failed:&apos;, error);
    return {
      data: null as T,
      success: false,
      error: error instanceof Error ? error.message : &apos;Unknown error occurred&apos;,
    };
  }
}</file><file path="renderer/src/App.css">/* src/App.css */
/*
  The styles below are optional.
  If you&apos;d like a fully Tailwind-based approach,
  you can remove this file entirely or keep
  any keyframes or brand-specific overrides here.
*/

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}</file><file path="renderer/src/App.jsx">// src/App.jsx
import React, { useState, useEffect } from &quot;react&quot;;
import { BrowserRouter as Router, Routes, Route, Link, Navigate } from &quot;react-router-dom&quot;;
import { QueryClient, QueryClientProvider } from &apos;@tanstack/react-query&apos;;
import { LocalizationProvider } from &apos;@mui/x-date-pickers&apos;;
import { AdapterDateFns } from &apos;@mui/x-date-pickers/AdapterDateFns&apos;;
import { enUS } from &apos;date-fns/locale&apos;;
import Dashboard from &quot;./components/Dashboard&quot;;
import ChartsDashboard from &quot;./components/ChartsDashboard&quot;;
import KillComparison from &quot;./components/KillComparison&quot;;
import SchedulerDashboard from &quot;./components/SchedulerDashboard&quot;;
import { FaChartBar, FaHome, FaSkullCrossbones, FaCalendarAlt } from &quot;react-icons/fa&quot;;

// Create a client
const queryClient = new QueryClient();

function App() {
  const [mapChartsEnabled, setMapChartsEnabled] = useState(false);
  const [killChartsEnabled, setKillChartsEnabled] = useState(false);
  const [debugEnabled, setDebugEnabled] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    // Fetch status when component mounts
    fetch(&apos;/api/debug/status&apos;)
      .then(response =&gt; response.json())
      .then(response =&gt; {
        const features = response.data.features;
        setMapChartsEnabled(features.map_charts);
        setKillChartsEnabled(features.kill_charts);
        setDebugEnabled(features.debug);
        setLoading(false);
      })
      .catch(error =&gt; {
        console.error(&apos;Error fetching status:&apos;, error);
        setMapChartsEnabled(false);
        setKillChartsEnabled(false);
        setDebugEnabled(false);
        setLoading(false);
      });
  }, []);

  if (loading) {
    return &lt;div className=&quot;min-h-screen bg-gradient-to-b from-blue-50 to-blue-100 flex items-center justify-center&quot;&gt;
      &lt;p className=&quot;text-lg&quot;&gt;Loading application...&lt;/p&gt;
    &lt;/div&gt;;
  }

  // Determine whether to show charts link (if either map charts or kill charts is enabled)
  const showChartsLink = mapChartsEnabled || killChartsEnabled;

  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;LocalizationProvider 
        dateAdapter={AdapterDateFns}
        adapterLocale={enUS}
        localeText={{ start: &apos;Start&apos;, end: &apos;End&apos; }}
      &gt;
        &lt;Router&gt;
          &lt;div className=&quot;min-h-screen bg-gradient-to-b from-blue-50 to-blue-100&quot;&gt;
            &lt;nav className=&quot;bg-gray-800 text-white p-4&quot;&gt;
              &lt;div className=&quot;max-w-7xl mx-auto flex justify-between items-center&quot;&gt;
                &lt;div className=&quot;text-xl font-bold&quot;&gt;Wanderer Notifier&lt;/div&gt;
                &lt;div className=&quot;flex space-x-4&quot;&gt;
                  &lt;Link to=&quot;/&quot; className=&quot;flex items-center space-x-1 hover:text-indigo-300 transition-colors&quot;&gt;
                    &lt;FaHome /&gt;
                    &lt;span&gt;Home&lt;/span&gt;
                  &lt;/Link&gt;
                  {showChartsLink &amp;&amp; (
                    &lt;Link to=&quot;/charts&quot; className=&quot;flex items-center space-x-1 hover:text-indigo-300 transition-colors&quot;&gt;
                      &lt;FaChartBar /&gt;
                      &lt;span&gt;Charts&lt;/span&gt;
                    &lt;/Link&gt;
                  )}
                  {debugEnabled &amp;&amp; (
                  &lt;Link to=&quot;/schedulers&quot; className=&quot;flex items-center space-x-1 hover:text-indigo-300 transition-colors&quot;&gt;
                    &lt;FaCalendarAlt /&gt;
                    &lt;span&gt;Schedulers&lt;/span&gt;
                  &lt;/Link&gt;
                  )}
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/nav&gt;
            
            &lt;Routes&gt;
              &lt;Route path=&quot;/&quot; element={&lt;Dashboard /&gt;} /&gt;
              &lt;Route 
                path=&quot;/charts&quot; 
                element={showChartsLink ? &lt;ChartsDashboard /&gt; : &lt;Navigate to=&quot;/&quot; replace /&gt;} 
              /&gt;
              &lt;Route 
                path=&quot;/schedulers&quot; 
                element={debugEnabled ? &lt;SchedulerDashboard /&gt; : &lt;Navigate to=&quot;/&quot; replace /&gt;} 
              /&gt;
            &lt;/Routes&gt;
          &lt;/div&gt;
        &lt;/Router&gt;
      &lt;/LocalizationProvider&gt;
    &lt;/QueryClientProvider&gt;
  );
}

export default App;</file><file path="renderer/src/index.css">/* src/index.css */
@import &quot;tailwindcss&quot;;

/* Tailwind Directives */
@tailwind base;
@tailwind components;
@tailwind utilities;</file><file path="renderer/src/main.jsx">import { StrictMode } from &apos;react&apos;
import { createRoot } from &apos;react-dom/client&apos;
import &apos;./index.css&apos;
import App from &apos;./App.jsx&apos;

createRoot(document.getElementById(&apos;root&apos;)).render(
  &lt;StrictMode&gt;
    &lt;App /&gt;
  &lt;/StrictMode&gt;,
)</file><file path="renderer/.gitignore"># Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?</file><file path="renderer/eslint.config.js">import js from &apos;@eslint/js&apos;
import globals from &apos;globals&apos;
import reactHooks from &apos;eslint-plugin-react-hooks&apos;
import reactRefresh from &apos;eslint-plugin-react-refresh&apos;

export default [
  { ignores: [&apos;dist&apos;] },
  {
    files: [&apos;**/*.{js,jsx}&apos;],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: &apos;latest&apos;,
        ecmaFeatures: { jsx: true },
        sourceType: &apos;module&apos;,
      },
    },
    plugins: {
      &apos;react-hooks&apos;: reactHooks,
      &apos;react-refresh&apos;: reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      &apos;no-unused-vars&apos;: [&apos;error&apos;, { varsIgnorePattern: &apos;^[A-Z_]&apos; }],
      &apos;react-refresh/only-export-components&apos;: [
        &apos;warn&apos;,
        { allowConstantExport: true },
      ],
    },
  },
]</file><file path="renderer/index.html">&lt;!-- // index.html --&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; sizes=&quot;32x32&quot; href=&quot;/bot.ico&quot; /&gt;
    &lt;title&gt;Wanderer Notifier Dashboard&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;!-- Scripts are injected by Vite --&gt;
    &lt;script type=&quot;module&quot; src=&quot;/src/main.jsx&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</file><file path="renderer/package.json">{
  &quot;name&quot;: &quot;react_app&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;watch&quot;: &quot;vite build --watch --minify false --emptyOutDir false --mode development&quot;,
    &quot;dev:watch&quot;: &quot;npm run watch &amp; npx onchange &apos;dist/**/*&apos; -- cp -r dist/* ../priv/static/app/&quot;,
    &quot;dev:sync&quot;: &quot;node watch-and-copy.js&quot;,
    &quot;sync&quot;: &quot;node watch-sync.js&quot;,
    &quot;lint&quot;: &quot;eslint .&quot;,
    &quot;postbuild&quot;: &quot;rm -rf ../priv/static/app &amp;&amp; mkdir -p ../priv/static/app &amp;&amp; cp -r dist/* ../priv/static/app/&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;chart-service&quot;: &quot;node chart-service/chart-generator.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@emotion/react&quot;: &quot;^11.14.0&quot;,
    &quot;@emotion/styled&quot;: &quot;^11.14.0&quot;,
    &quot;@mui/icons-material&quot;: &quot;^6.4.8&quot;,
    &quot;@mui/lab&quot;: &quot;^6.0.0-beta.31&quot;,
    &quot;@mui/material&quot;: &quot;^6.4.8&quot;,
    &quot;@mui/x-date-pickers&quot;: &quot;^7.28.0&quot;,
    &quot;@tailwindcss/vite&quot;: &quot;^4.0.14&quot;,
    &quot;@tanstack/react-query&quot;: &quot;^5.69.0&quot;,
    &quot;body-parser&quot;: &quot;^1.20.2&quot;,
    &quot;date-fns&quot;: &quot;^2.30.0&quot;,
    &quot;express&quot;: &quot;^4.18.2&quot;,
    &quot;react&quot;: &quot;^19.0.0&quot;,
    &quot;react-dom&quot;: &quot;^19.0.0&quot;,
    &quot;react-icons&quot;: &quot;^5.5.0&quot;,
    &quot;react-router-dom&quot;: &quot;^6.30.0&quot;,
    &quot;recharts&quot;: &quot;^2.15.1&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@eslint/js&quot;: &quot;^9.21.0&quot;,
    &quot;@tailwindcss/postcss&quot;: &quot;^4.0.14&quot;,
    &quot;@types/react&quot;: &quot;^19.0.10&quot;,
    &quot;@types/react-dom&quot;: &quot;^19.0.4&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^4.3.4&quot;,
    &quot;autoprefixer&quot;: &quot;^10.4.21&quot;,
    &quot;eslint&quot;: &quot;^9.21.0&quot;,
    &quot;eslint-plugin-react-hooks&quot;: &quot;^5.1.0&quot;,
    &quot;eslint-plugin-react-refresh&quot;: &quot;^0.4.19&quot;,
    &quot;globals&quot;: &quot;^15.15.0&quot;,
    &quot;nodemon&quot;: &quot;^3.0.3&quot;,
    &quot;onchange&quot;: &quot;^7.1.0&quot;,
    &quot;postcss&quot;: &quot;^8.5.3&quot;,
    &quot;tailwindcss&quot;: &quot;^4.0.14&quot;,
    &quot;vite&quot;: &quot;^6.2.5&quot;
  }
}</file><file path="renderer/postcss.config.cjs">// postcss.config.cjs
module.exports = {
  plugins: [
    require(&apos;@tailwindcss/postcss&apos;)({ config: &quot;./tailwind.config.cjs&quot; }),
    require(&apos;autoprefixer&apos;),
  ],
};</file><file path="renderer/README.md"># React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript and enable type-aware lint rules. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.</file><file path="renderer/tailwind.config.cjs">// tailwind.config.cjs
const path = require(&quot;path&quot;);

module.exports = {
  content: [
    path.join(__dirname, &quot;index.html&quot;),
    path.join(__dirname, &quot;src/**/*.{js,jsx,ts,tsx}&quot;),
  ],
  safelist: [
    &apos;min-h-screen&apos;,
    &apos;bg-gray-50&apos;,
    &apos;bg-gradient-to-b&apos;,
    &apos;from-sky-100&apos;,
    &apos;to-violet-50&apos;,
    // Add any other classes that are used dynamically or not detected automatically
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};</file><file path="renderer/vite.config.js">// vite.config.js
import { defineConfig } from &apos;vite&apos;;
import react from &apos;@vitejs/plugin-react&apos;;
import tailwindcss from &apos;@tailwindcss/vite&apos;;

export default defineConfig({
  plugins: [
    react(),
    tailwindcss()
  ],
  base: &apos;/&apos;,
  build: {
    assetsDir: &apos;assets&apos;
  },
  server: {
    proxy: {
      &apos;/api&apos;: {
        target: &apos;http://localhost:4000&apos;,
        changeOrigin: true
      },
      &apos;/charts&apos;: {
        target: &apos;http://localhost:4000&apos;,
        changeOrigin: true
      }
    }
  }
});</file><file path="renderer/watch-and-copy.js">#!/usr/bin/env node

/**
 * This script watches the dist directory for changes and copies files to priv/static/app.
 * It ensures that the Vite build output is immediately available to the Elixir application.
 */

import fs from &apos;fs&apos;;
import path from &apos;path&apos;;
import { exec, spawn } from &apos;child_process&apos;;
import { fileURLToPath } from &apos;url&apos;;

// Get directory paths in ES module format
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const distDir = path.resolve(__dirname, &apos;dist&apos;);
const targetDir = path.resolve(__dirname, &apos;../priv/static/app&apos;);

// Ensure the target directory exists
if (!fs.existsSync(targetDir)) {
  console.log(`Creating target directory: ${targetDir}`);
  fs.mkdirSync(targetDir, { recursive: true });
}

// Initial copy of all files
console.log(&apos;Performing initial copy of all files...&apos;);
exec(`cp -r ${distDir}/* ${targetDir}/`, (error) =&gt; {
  if (error) {
    console.error(`Error during initial copy: ${error.message}`);
    return;
  }
  console.log(&apos;Initial copy completed successfully&apos;);
});

// Start the Vite build in watch mode
console.log(&apos;Starting Vite build in watch mode...&apos;);
const viteProcess = spawn(&apos;npm&apos;, [&apos;run&apos;, &apos;watch&apos;], { 
  stdio: &apos;inherit&apos;,
  shell: true
});

viteProcess.on(&apos;error&apos;, (error) =&gt; {
  console.error(`Error starting Vite: ${error.message}`);
});

// Watch for changes in the dist directory
console.log(`Watching for changes in ${distDir}`);
fs.watch(distDir, { recursive: true }, (eventType, filename) =&gt; {
  if (!filename) return;
  
  const sourcePath = path.join(distDir, filename);
  const targetPath = path.join(targetDir, filename);
  
  // Make sure the event is real and the file exists
  try {
    fs.statSync(sourcePath);
  } catch (e) {
    // File doesn&apos;t exist anymore, might be a deletion event
    return;
  }
  
  console.log(`File changed: ${filename}`);
  
  // Create directory if it doesn&apos;t exist
  const targetDirPath = path.dirname(targetPath);
  if (!fs.existsSync(targetDirPath)) {
    fs.mkdirSync(targetDirPath, { recursive: true });
  }
  
  // Copy file
  exec(`cp -r &quot;${sourcePath}&quot; &quot;${targetPath}&quot;`, (error) =&gt; {
    if (error) {
      console.error(`Error copying ${filename}: ${error.message}`);
      return;
    }
    console.log(`Copied ${filename} to ${targetPath}`);
  });
});

console.log(&apos;Watch and copy process started. Press Ctrl+C to stop.&apos;);

// Handle process termination
process.on(&apos;SIGINT&apos;, () =&gt; {
  console.log(&apos;Stopping watch and copy process...&apos;);
  viteProcess.kill();
  process.exit(0);
});</file><file path="renderer/watch-sync.js">#!/usr/bin/env node

/**
 * This script builds the Vite project and watches for rebuilt files,
 * copying them to the Elixir static directory automatically.
 */

import { spawn } from &apos;child_process&apos;;
import fs from &apos;fs&apos;;
import path from &apos;path&apos;;
import { fileURLToPath } from &apos;url&apos;;

// Get directory paths in ES module format
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const staticDir = path.resolve(__dirname, &apos;../priv/static/app&apos;);

// Make sure the target directory exists
console.log(`Ensuring target directory exists: ${staticDir}`);
if (!fs.existsSync(staticDir)) {
  fs.mkdirSync(staticDir, { recursive: true });
}

// Build and watch command - using shell directly for simpler implementation
console.log(&apos;Starting Vite build with watch...&apos;);

// Run Vite in watch mode
const cmd = process.platform === &apos;win32&apos; ? &apos;npm.cmd&apos; : &apos;npm&apos;;
const vite = spawn(cmd, [&apos;run&apos;, &apos;watch&apos;], { 
  stdio: &apos;inherit&apos;, 
  shell: true
});

// Add a file watcher on dist directory
console.log(&apos;Setting up watcher for changes...&apos;);

// Set up a timer to periodically sync the directories
const syncInterval = 1000; // 1 second
let lastRun = Date.now();

function syncDirectories() {
  const now = Date.now();
  
  // Don&apos;t run more often than the interval
  if (now - lastRun &lt; syncInterval) return;
  lastRun = now;
  
  // Use rsync for more efficient directory syncing
  const syncProcess = spawn(&apos;cp&apos;, [&apos;-r&apos;, &apos;dist/&apos;, &apos;../priv/static/app/&apos;], {
    stdio: &apos;inherit&apos;,
    shell: true
  });
  
  syncProcess.on(&apos;error&apos;, (err) =&gt; {
    console.error(&apos;Error syncing directories:&apos;, err);
  });
}

// Ensure initial build happens before watching
setTimeout(() =&gt; {
  // Initial sync
  syncDirectories();
  
  // Set up interval for checking for changes
  setInterval(syncDirectories, syncInterval);
  
  console.log(&apos;Watch and sync process active. Press Ctrl+C to stop.&apos;);
}, 5000);

// Handle process termination
process.on(&apos;SIGINT&apos;, () =&gt; {
  console.log(&apos;Stopping watch process...&apos;);
  vite.kill();
  process.exit(0);
});

process.on(&apos;exit&apos;, () =&gt; {
  vite.kill();
});</file><file path="scripts/dev.sh">#!/bin/bash

# Purpose: Start both the Elixir server and the JavaScript watcher for development
# This script helps ensure that JavaScript changes are immediately reflected in the Elixir app

# Define terminal colors
GREEN=&apos;\033[0;32m&apos;
YELLOW=&apos;\033[1;33m&apos;
BLUE=&apos;\033[0;34m&apos;
RED=&apos;\033[0;31m&apos;
NC=&apos;\033[0m&apos; # No Color

echo -e &quot;${BLUE}=== Starting Wanderer Notifier Development Environment ===${NC}&quot;

# Create necessary directories
echo -e &quot;${YELLOW}Ensuring required directories exist...${NC}&quot;
mkdir -p priv/static/app

# First, build the React app initially
echo -e &quot;${YELLOW}Building React app...${NC}&quot;
cd renderer &amp;&amp; npm run build &amp;&amp; cd ..

# Start the JS watcher in the background
echo -e &quot;${YELLOW}Starting JavaScript file watcher...${NC}&quot;
(cd renderer &amp;&amp; npm run dev:sync) &amp;
JS_WATCHER_PID=$!

# Trap Ctrl+C to kill all processes
trap &apos;kill $JS_WATCHER_PID 2&gt;/dev/null&apos; EXIT

# Start the Elixir server
echo -e &quot;${GREEN}Starting Elixir server...${NC}&quot;
echo -e &quot;${YELLOW}(Press Ctrl+C to stop both servers)${NC}&quot;
mix phx.server

# This will be executed when the script is interrupted
echo -e &quot;${RED}Shutting down all processes...${NC}&quot;</file><file path="scripts/setup_test_env.sh">#!/bin/bash

# Setup Test Environment Script for WandererNotifier
set -e  # Exit on error

echo &quot;Setting up test environment for WandererNotifier...&quot;

# Create main test directories
echo &quot;Creating test directory structure...&quot;
mkdir -p test/support/{mocks,fixtures,helpers}
mkdir -p test/wanderer_notifier/{api,cache,core,data,discord,notifiers,schedulers,services}
mkdir -p test/integration/{flows,system}

# Create test helper
echo &quot;Creating test_helper.exs...&quot;
cat &gt; test/test_helper.exs &lt;&lt; &apos;EOL&apos;
ExUnit.start()

# Define mocks for external dependencies
Mox.defmock(WandererNotifier.MockHTTP, for: WandererNotifier.HttpClient.Behaviour)
Mox.defmock(WandererNotifier.MockCache, for: WandererNotifier.Data.Cache.Behaviour)
Mox.defmock(WandererNotifier.MockDiscord, for: WandererNotifier.Discord.Behaviour)
Mox.defmock(WandererNotifier.MockWebSocket, for: WandererNotifier.WebSocket.Behaviour)

# Set Mox global mode for integration tests where needed
Application.put_env(:mox, :verify_on_exit, true)
EOL

# Create HTTP behavior module
echo &quot;Creating HTTP behaviour module...&quot;
mkdir -p lib/wanderer_notifier/http
cat &gt; lib/wanderer_notifier/http/behaviour.ex &lt;&lt; &apos;EOL&apos;
defmodule WandererNotifier.HTTP.Behaviour do
  @moduledoc &quot;&quot;&quot;
  Defines the behaviour for HTTP clients to enable mocking in tests.
  &quot;&quot;&quot;

  @type headers :: [{String.t(), String.t()}]
  @type options :: Keyword.t()
  @type response :: %{status: integer(), body: String.t() | map(), headers: headers()}

  @callback get(url :: String.t(), headers :: headers(), options :: options()) ::
              {:ok, response()} | {:error, term()}

  @callback post(url :: String.t(), body :: term(), headers :: headers(), options :: options()) ::
              {:ok, response()} | {:error, term()}
end
EOL

# Create test environment configuration
echo &quot;Creating test environment configuration...&quot;
mkdir -p config
cat &gt; config/test.exs &lt;&lt; &apos;EOL&apos;
import Config

config :wanderer_notifier,
  # Use test-specific configuration
  http_client: WandererNotifier.MockHTTP,
  discord_client: WandererNotifier.MockDiscord,
  websocket_client: WandererNotifier.MockWebSocket,
  cache_name: :test_cache,
  
  # Faster timeouts for tests
  api_timeout: 100,
  
  # Test-specific feature flags
  features: %{
    &quot;send_discord_notifications&quot; =&gt; true,
    &quot;track_character_changes&quot; =&gt; true,
    &quot;generate_tps_charts&quot; =&gt; false  # Disable for tests
  }

# Configure logger for test environment
config :logger, level: :warn
EOL

# Create test fixtures
echo &quot;Creating test fixtures...&quot;
mkdir -p test/support/fixtures
cat &gt; test/support/fixtures/api_responses.ex &lt;&lt; &apos;EOL&apos;
defmodule WandererNotifier.Test.Fixtures.ApiResponses do
  @moduledoc &quot;&quot;&quot;
  Provides fixture data for API responses used in tests.
  &quot;&quot;&quot;

  def map_systems_response do
    %{
      &quot;systems&quot; =&gt; [
        %{
          &quot;id&quot; =&gt; &quot;J123456&quot;,
          &quot;name&quot; =&gt; &quot;Test System&quot;,
          &quot;security_status&quot; =&gt; -1.0,
          &quot;region_id&quot; =&gt; 10000001,
          &quot;tracked&quot; =&gt; true,
          &quot;activity&quot; =&gt; 25
        },
        %{
          &quot;id&quot; =&gt; &quot;J654321&quot;,
          &quot;name&quot; =&gt; &quot;Another System&quot;,
          &quot;security_status&quot; =&gt; -0.9,
          &quot;region_id&quot; =&gt; 10000002,
          &quot;tracked&quot; =&gt; false,
          &quot;activity&quot; =&gt; 5
        }
      ]
    }
  end

  def esi_character_response do
    %{
      &quot;character_id&quot; =&gt; 12345,
      &quot;corporation_id&quot; =&gt; 67890,
      &quot;alliance_id&quot; =&gt; 54321,
      &quot;name&quot; =&gt; &quot;Test Character&quot;,
      &quot;security_status&quot; =&gt; 5.0
    }
  end

  def zkill_message do
    %{
      &quot;killID&quot; =&gt; 12345678,
      &quot;killmail_time&quot; =&gt; &quot;2023-06-15T12:34:56Z&quot;,
      &quot;solar_system_id&quot; =&gt; 30000142,
      &quot;victim&quot; =&gt; %{
        &quot;character_id&quot; =&gt; 12345,
        &quot;corporation_id&quot; =&gt; 67890,
        &quot;ship_type_id&quot; =&gt; 582
      },
      &quot;attackers&quot; =&gt; [
        %{
          &quot;character_id&quot; =&gt; 98765,
          &quot;corporation_id&quot; =&gt; 54321,
          &quot;ship_type_id&quot; =&gt; 11567
        }
      ],
      &quot;zkb&quot; =&gt; %{
        &quot;totalValue&quot; =&gt; 100000000.0,
        &quot;points&quot; =&gt; 10
      }
    }
  end
end
EOL

# Create sample test
echo &quot;Creating sample test...&quot;
mkdir -p test/wanderer_notifier/helpers
cat &gt; test/wanderer_notifier/helpers/sample_test.exs &lt;&lt; &apos;EOL&apos;
defmodule WandererNotifier.Helpers.SampleTest do
  use ExUnit.Case
  
  test &quot;basic assertion works&quot; do
    assert 1 + 1 == 2
  end
end
EOL

# Update mix.exs to include test coverage
echo &quot;Checking if ExCoveralls is in dependencies...&quot;
if ! grep -q &quot;excoveralls&quot; mix.exs; then
  echo &quot;Please add ExCoveralls to your mix.exs dependencies:&quot;
  echo &quot;
  defp deps do
    [
      # ... existing deps
      {:excoveralls, \&quot;~&gt; 0.14\&quot;, only: :test},
    ]
  end

  def project do
    [
      # ... existing project config
      test_coverage: [tool: ExCoveralls],
      preferred_cli_env: [
        coveralls: :test,
        \&quot;coveralls.detail\&quot;: :test,
        \&quot;coveralls.post\&quot;: :test,
        \&quot;coveralls.html\&quot;: :test
      ]
    ]
  end
  &quot;
fi

# Create GitHub Actions workflow for CI
echo &quot;Creating GitHub Actions workflow...&quot;
mkdir -p .github/workflows
cat &gt; .github/workflows/test.yml &lt;&lt; &apos;EOL&apos;
name: Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Elixir
        uses: erlef/setup-beam@v1
        with:
          elixir-version: &apos;1.14.x&apos;
          otp-version: &apos;25.x&apos;
      - name: Install dependencies
        run: mix deps.get
      - name: Run tests
        run: mix test
      - name: Run code quality checks
        run: mix credo
EOL

# Make this script executable
chmod +x scripts/setup_test_env.sh

echo &quot;Test environment setup complete!&quot;
echo &quot;You can now run: mix test&quot;
echo &quot;For more information, see the testing documentation in docs/testing/&quot;</file><file path="scripts/test_docker_image.sh">#!/bin/bash

# test_docker_image.sh - Validates a built Docker image for the Wanderer Notifier application
# This script performs basic validation to ensure the critical components are working

set -e

# Default values
IMAGE_NAME=&quot;guarzo/wanderer-notifier&quot;
TAG=&quot;latest&quot;
TIMEOUT=30
BASIC_ONLY=false
DISCORD_TOKEN=&quot;test_token_for_validation&quot;

# Default environment variables
DEFAULT_ENV_VARS=(
  &quot;MAP_URL_WITH_NAME=http://example.com/map?name=testmap&quot;
  &quot;MAP_TOKEN=test-map-token&quot;
  &quot;DISCORD_CHANNEL_ID=123456789&quot;
  &quot;LICENSE_KEY=test-license-key&quot;
  &quot;WANDERER_ENV=test&quot;
  &quot;WANDERER_FEATURE_DISABLE_WEBSOCKET=true&quot;
)

# Initialize EXTRA_ENV_VARS with defaults
EXTRA_ENV_VARS=&quot;&quot;
for var in &quot;${DEFAULT_ENV_VARS[@]}&quot;; do
  EXTRA_ENV_VARS=&quot;$EXTRA_ENV_VARS -e $var&quot;
done

# Display help information
show_help() {
  echo &quot;Usage: $0 [OPTIONS]&quot;
  echo &quot;Test and validate a Wanderer Notifier Docker image&quot;
  echo
  echo &quot;Options:&quot;
  echo &quot;  -i, --image IMAGE_NAME   Docker image name (default: $IMAGE_NAME)&quot;
  echo &quot;  -t, --tag TAG            Docker image tag (default: $TAG)&quot;
  echo &quot;  -b, --basic              Run only basic validation tests without starting the app&quot;
  echo &quot;  -d, --discord-token TOK  Set a test Discord token for validation (default: test_token_for_validation)&quot;
  echo &quot;  -e, --env VAR=VALUE      Add/override environment variable (can be used multiple times)&quot;
  echo &quot;  -h, --help               Display this help message&quot;
  echo
  echo &quot;Default environment variables:&quot;
  for var in &quot;${DEFAULT_ENV_VARS[@]}&quot;; do
    echo &quot;  $var&quot;
  done
  echo
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -i|--image)
      IMAGE_NAME=&quot;$2&quot;
      shift 2
      ;;
    -t|--tag)
      TAG=&quot;$2&quot;
      shift 2
      ;;
    -b|--basic)
      BASIC_ONLY=true
      shift
      ;;
    -d|--discord-token)
      DISCORD_TOKEN=&quot;$2&quot;
      shift 2
      ;;
    -e|--env)
      # Override or append environment variable
      key=&quot;${2%%=*}&quot;  # Get the part before =
      EXTRA_ENV_VARS=$(echo &quot;$EXTRA_ENV_VARS&quot; | sed -E &quot;s#-e ${key}=[^ ]*#-e $2#&quot;)
      if ! echo &quot;$EXTRA_ENV_VARS&quot; | grep -q &quot; -e $key=&quot;; then
        EXTRA_ENV_VARS=&quot;$EXTRA_ENV_VARS -e $2&quot;
      fi
      shift 2
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      echo &quot;Unknown option: $1&quot;
      show_help
      exit 1
      ;;
  esac
done

FULL_IMAGE=&quot;${IMAGE_NAME}:${TAG}&quot;
echo &quot;Testing image: $FULL_IMAGE&quot;

# Function to run a command inside the container
run_in_container() {
  local cmd=&quot;$1&quot;
  local env_vars=&quot;$2&quot;
  
  if [ -z &quot;$env_vars&quot; ]; then
    docker run --rm -t &quot;$FULL_IMAGE&quot; /bin/sh -c &quot;$cmd&quot;
  else
    # shellcheck disable=SC2086
    # We intentionally want word splitting for env vars, but each var is properly quoted
    docker run --rm -t $env_vars &quot;$FULL_IMAGE&quot; /bin/sh -c &quot;$cmd&quot;
  fi
}

# Check if the image exists
if ! docker image inspect &quot;$FULL_IMAGE&quot; &amp;&gt; /dev/null; then
  echo &quot;Error: Image $FULL_IMAGE does not exist locally&quot;
  exit 1
fi

echo &quot;======= Basic System Tests =======&quot;

echo &quot;Checking OS and runtime versions...&quot;
run_in_container &quot;cat /etc/os-release &amp;&amp; echo &apos;Elixir version:&apos; &amp;&amp; elixir --version&quot;

echo &quot;Checking GLIBC version...&quot;
run_in_container &quot;ldd --version | head -n1&quot;

echo &quot;Verifying file permissions...&quot;
run_in_container &quot;ls -la /app/bin/ &amp;&amp; ls -la /app/data/&quot;

echo &quot;Checking data directories...&quot;
run_in_container &quot;find /app/data -type d | sort&quot;

echo &quot;======= Environment Debugging =======&quot;
echo &quot;Checking environment variables...&quot;
run_in_container &quot;printenv | grep -E &apos;CONFIG|NOTIFIER&apos; || echo &apos;No matching environment variables found&apos;&quot;

echo &quot;Checking startup debug logs...&quot;
run_in_container &quot;test -f /tmp/startup_debug.txt &amp;&amp; cat /tmp/startup_debug.txt || echo &apos;Startup debug file not found&apos;&quot;

echo &quot;Checking /tmp/config_debug.txt if it exists...&quot;
run_in_container &quot;test -f /tmp/config_debug.txt &amp;&amp; cat /tmp/config_debug.txt || echo &apos;Config debug file not found&apos;&quot;

echo &quot;======= Application Tests =======&quot;

echo &quot;Checking Config.Reader implementation...&quot;
run_in_container &quot;elixir -e &apos;IO.puts(\&quot;Exploring Config.Reader module...\&quot;); \
Code.ensure_loaded(Config.Reader); \
if function_exported?(Code, :fetch_docs, 1) do \
  case Code.fetch_docs(Config.Reader) do \
    {:docs_v1, _, _, _, module_doc, _, _} when is_binary(module_doc) -&gt; \
      IO.puts(\&quot;Module docs: #{String.slice(module_doc, 0, 200)}...\&quot;); \
    _ -&gt; \
      IO.puts(\&quot;No documentation available for Config.Reader\&quot;) \
  end \
end; \
if function_exported?(Config.Reader, :read!, 2) do \
  IO.puts(\&quot;Function Config.Reader.read!/2 is exported\&quot;); \
else \
  IO.puts(\&quot;Function Config.Reader.read!/2 is NOT exported!\&quot;) \
end; \
if function_exported?(Config.Reader, :load, 2) do \
  IO.puts(\&quot;Function Config.Reader.load/2 is exported\&quot;); \
else \
  IO.puts(\&quot;Function Config.Reader.load/2 is NOT exported!\&quot;) \
end&apos;&quot; &quot;-e WANDERER_ENV=test&quot;


if [ &quot;$BASIC_ONLY&quot; = true ]; then
  echo &quot;Running basic application tests only (without starting the app)...&quot;
  
  echo &quot;Testing Elixir runtime with basic eval...&quot;
  run_in_container &quot;elixir -e &apos;IO.puts(\&quot;Basic Elixir runtime test passed with result: #{1+1}\&quot;)&apos;&quot;
  
  echo &quot;Checking application version file...&quot;
  run_in_container &quot;if [ -f /app/VERSION ]; then cat /app/VERSION; else echo &apos;Version file not found&apos;; fi&quot;
  
  echo &quot;Testing config file exists (without setting CONFIG_PATH)...&quot;
  run_in_container &quot;elixir -e &apos;IO.puts(\&quot;Config test: #{File.exists?(\&quot;/app/etc/wanderer_notifier.exs\&quot;)}\&quot;)&apos;&quot;
else
  echo &quot;Testing full application startup (may require environment variables)...&quot;
  
  echo &quot;Testing Elixir runtime with application eval (basic)...&quot;
  run_in_container &quot;elixir -e &apos;IO.puts(\&quot;Basic Elixir runtime test: OK\&quot;)&apos;&quot; || echo &quot;Basic Elixir test failed, but continuing...&quot;

  echo &quot;Checking Elixir application version...&quot;
  # Try to get version with eval first
  run_in_container &quot;/app/bin/wanderer_notifier eval &apos;IO.puts \&quot;Version test\&quot;&apos;&quot; &quot;-e DISCORD_BOT_TOKEN=$DISCORD_TOKEN -e WANDERER_ENV=test&quot; || echo &quot;Application eval failed, but continuing...&quot;

  echo &quot;Testing simplified application boot...&quot;
  # Try to run a very simple command
  run_in_container &quot;/app/bin/wanderer_notifier eval &apos;System.version |&gt; IO.puts&apos;&quot; &quot;-e DISCORD_BOT_TOKEN=$DISCORD_TOKEN -e WANDERER_ENV=test&quot; || echo &quot;Simple boot test failed, but continuing...&quot;
  
  echo &quot;Testing minimal application boot (with clean shutdown)...&quot;
  # Temporarily disable exit on error for this test
  set +e
  
  # Use a shorter timeout and force kill if needed
  run_in_container &quot;timeout --kill-after=5s 10s /app/bin/wanderer_notifier eval &apos;IO.puts(\&quot;Application started\&quot;); Process.sleep(1000); :init.stop()&apos;&quot; &quot;-e DISCORD_BOT_TOKEN=$DISCORD_TOKEN -e WANDERER_ENV=test -e WANDERER_FEATURE_DISABLE_WEBSOCKET=true&quot;
  EXIT_CODE=$?
  
  # 137 is SIGKILL (128 + 9), 143 is SIGTERM (128 + 15), 124 is timeout&apos;s normal exit
  if [ $EXIT_CODE -eq 137 ]; then
    echo &quot; Minimal boot test completed (terminated as expected with SIGKILL)&quot;
    EXIT_CODE=0  # Reset exit code since this is expected
  elif [ $EXIT_CODE -eq 143 ]; then
    echo &quot; Minimal boot test completed (clean shutdown with SIGTERM)&quot;
    EXIT_CODE=0  # Reset exit code since this is expected
  elif [ $EXIT_CODE -eq 124 ]; then
    echo &quot; Minimal boot test completed (normal timeout)&quot;
    EXIT_CODE=0  # Reset exit code since this is expected
  elif [ $EXIT_CODE -eq 0 ]; then
    echo &quot; Minimal boot test completed (clean exit)&quot;
  else
    echo &quot; Minimal boot test failed with unexpected exit code: $EXIT_CODE&quot;
    # Don&apos;t exit here, let&apos;s continue with other tests
    echo &quot;Continuing with remaining tests...&quot;
  fi
  
  # Re-enable exit on error
  set -e
  
  # Only run the functional web test if not in basic mode
  if [ &quot;$BASIC_ONLY&quot; = false ]; then
    echo &quot;======= Functional Web Test =======&quot;
    echo &quot;Starting application container in background...&quot;
    
    # Create a unique container name for this test
    CONTAINER_NAME=&quot;wanderer-test-$(date +%s)&quot;
    
    # Debug: Show what environment variables we&apos;re going to use
    echo &quot;Environment variables being passed to container:&quot;
    echo &quot;DISCORD_BOT_TOKEN=$DISCORD_TOKEN&quot;
    echo &quot;Extra env vars: $EXTRA_ENV_VARS&quot;
    
    # Start the container in the background with all required environment variables
    docker run --name &quot;$CONTAINER_NAME&quot; -d -p 4000:4000 \
      -e DISCORD_BOT_TOKEN=&quot;$DISCORD_TOKEN&quot; \
      $EXTRA_ENV_VARS \
      &quot;$FULL_IMAGE&quot;
    
    # Debug: Verify environment variables in the container
    echo &quot;Verifying environment variables in container:&quot;
    docker exec &quot;$CONTAINER_NAME&quot; env || echo &quot;Could not check environment variables&quot;
    
    echo &quot;Waiting for application to start (up to 20 seconds)...&quot;
    MAX_ATTEMPTS=20
    ATTEMPT=0
    SUCCESS=false
    
    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
      ATTEMPT=$((ATTEMPT+1))
      echo &quot;Attempt $ATTEMPT of $MAX_ATTEMPTS...&quot;
      
      # Try different possible health endpoints
      if curl -s http://localhost:4000/health 2&gt;/dev/null | grep -q &quot;ok&quot;; then
        echo &quot; Health check successful! Application is running correctly (using /health endpoint).&quot;
        SUCCESS=true
        break
      elif curl -s http://localhost:4000/status 2&gt;/dev/null | grep -q &quot;ok\|status\|running&quot;; then
        echo &quot; Health check successful! Application is running correctly (using /status endpoint).&quot;
        SUCCESS=true
        break
      elif curl -s http://localhost:4000/ 2&gt;/dev/null | grep -q &quot;html\|body\|wanderer&quot;; then
        echo &quot; Health check successful! Application is running correctly (using root endpoint).&quot;
        SUCCESS=true
        break
      fi
      
      # Check if container is still running
      if ! docker ps | grep -q &quot;$CONTAINER_NAME&quot;; then
        echo &quot; ERROR: Container stopped running! Checking logs:&quot;
        docker logs &quot;$CONTAINER_NAME&quot;
        SUCCESS=false
        break
      fi
      
      # Add more debug info on every attempt
      if [ $((ATTEMPT % 5)) -eq 0 ]; then
        echo &quot;Debug: Container status and logs at attempt $ATTEMPT:&quot;
        docker ps | grep &quot;$CONTAINER_NAME&quot; || echo &quot;Container not found in docker ps&quot;
        echo &quot;Last 50 lines of container logs:&quot;
        docker logs --tail 50 &quot;$CONTAINER_NAME&quot;

        # Try to get application status
        echo &quot;Debug: Checking application status...&quot;
        docker exec &quot;$CONTAINER_NAME&quot; /app/bin/wanderer_notifier eval &quot;
          IO.puts(\&quot;Application status:\&quot;)
          IO.puts(\&quot;- System running: \#{:init.get_status()}\&quot;)
          IO.puts(\&quot;- Applications: \#{inspect Application.started_applications()}\&quot;)
          IO.puts(\&quot;- Processes: \#{length Process.list()}\&quot;)
          &quot; 2&gt;/dev/null || echo &quot;Could not get application status&quot;
      fi

      # If we&apos;re on the 10th attempt, output some debug info
      if [ $ATTEMPT -eq 10 ]; then
        echo &quot;Debug: Checking available routes...&quot;
        docker exec &quot;$CONTAINER_NAME&quot; /app/bin/wanderer_notifier eval &quot;
          IO.puts(\&quot;Feature Configuration:\&quot;)
          IO.puts(\&quot;  Kill Charts: \#{Application.get_env(:wanderer_notifier, :wanderer_feature_kill_charts, false)}\&quot;)
          IO.puts(\&quot;  Map Charts: \#{Application.get_env(:wanderer_notifier, :wanderer_feature_map_charts, false)}\&quot;)
          &quot; 2&gt;/dev/null
        
        # Check if the application is at least running properly even if web endpoints aren&apos;t available
        echo &quot;Debug: Checking application status via eval...&quot;
        if docker exec &quot;$CONTAINER_NAME&quot; /app/bin/wanderer_notifier eval &quot;IO.puts(\&quot;Elixir application running: \#{Application.started_applications() |&gt; Enum.map(&amp; elem(&amp;1, 0)) |&gt; Enum.member?(:wanderer_notifier)}\&quot;)&quot; 2&gt;/dev/null | grep -q &quot;true&quot;; then
          echo &quot; Application is running correctly (verified via eval command).&quot;
          echo &quot;Note: Web endpoints are not responding, but the application is running.&quot;
          SUCCESS=true
          break
        fi
      fi
      
      sleep 5
    done
    
    # Cleanup the container
    echo &quot;Stopping test container...&quot;
    docker stop &quot;$CONTAINER_NAME&quot; &gt;/dev/null
    docker rm &quot;$CONTAINER_NAME&quot; &gt;/dev/null
    
    if [ &quot;$SUCCESS&quot; != &quot;true&quot; ]; then
      echo &quot; ERROR: Application failed to start properly or health check failed.&quot;
      echo &quot;This is a blocking error - the application must start successfully for validation to pass.&quot;
      exit 1
    fi
  else
    echo &quot;Skipping functional web test in basic mode...&quot;
  fi
fi

echo &quot;======= Connection Tests =======&quot;

echo &quot;Testing PostgreSQL client installation...&quot;
run_in_container &quot;psql --version&quot;

echo &quot;======= Script Tests =======&quot;

echo &quot;Checking database operations script...&quot;
run_in_container &quot;test -f /app/bin/db_operations.sh &amp;&amp; echo &apos;Database operations script exists&apos;&quot;

echo &quot;Checking startup script...&quot;
run_in_container &quot;test -f /app/bin/start_with_db.sh &amp;&amp; echo &apos;Startup script exists&apos;&quot;

echo &quot;======= Summary =======&quot;
echo &quot; All validation tests completed for $FULL_IMAGE&quot;
echo &quot;Note: These are basic validation tests. For complete testing, additional integration tests should be run.&quot;</file><file path="scripts/validate_and_start.sh">#!/bin/bash
set -e
exec &quot;$@&quot;</file><file path="scripts/version.sh">#!/bin/bash

# version.sh - Generates consistent version strings for the Wanderer Notifier application
# This script implements a Semantic Versioning (SemVer) strategy

set -e

# Default values
VERSION_FILE=&quot;VERSION&quot;
DEFAULT_VERSION=&quot;1.0.0&quot;
GIT_SHORT_SHA=$(git rev-parse --short HEAD 2&gt;/dev/null || echo &quot;unknown&quot;)
BUILD_DATE=$(date +&apos;%Y%m%d&apos;)

# Function to validate semver format
validate_semver() {
  local version=$1
  if ! [[ $version =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
    echo &quot;Error: Version must follow SemVer format (X.Y.Z[-prerelease][+build])&quot; &gt;&amp;2
    return 1
  fi
  return 0
}

# Function to get current version
get_current_version() {
  if [ -f &quot;$VERSION_FILE&quot; ]; then
    cat &quot;$VERSION_FILE&quot;
  else
    echo &quot;$DEFAULT_VERSION&quot;
  fi
}

# Function to create a new version
generate_version() {
  local version_type=$1
  local current=$(get_current_version)
  
  # Extract components
  local major=$(echo $current | cut -d. -f1)
  local minor=$(echo $current | cut -d. -f2)
  local patch=$(echo $current | cut -d. -f3 | cut -d- -f1 | cut -d+ -f1)
  
  case &quot;$version_type&quot; in
    major)
      major=$((major + 1))
      minor=0
      patch=0
      ;;
    minor)
      minor=$((minor + 1))
      patch=0
      ;;
    patch)
      patch=$((patch + 1))
      ;;
    *)
      echo &quot;No version change specified, using current version&quot;
      ;;
  esac
  
  echo &quot;$major.$minor.$patch&quot;
}

# Function to generate a full version string with metadata
generate_full_version() {
  local version=$1
  local env=${2:-prod}
  
  if [ &quot;$env&quot; = &quot;dev&quot; ]; then
    echo &quot;${version}-dev+${BUILD_DATE}.${GIT_SHORT_SHA}&quot;
  else
    echo &quot;${version}+${BUILD_DATE}.${GIT_SHORT_SHA}&quot;
  fi
}

# Function to generate Docker tags
generate_docker_tags() {
  local version=$1
  
  # Extract components
  local major=$(echo $version | cut -d. -f1)
  local minor=$(echo $version | cut -d. -f2)
  
  echo &quot;v${version}&quot;
  echo &quot;v${major}.${minor}&quot;
  echo &quot;v${major}&quot;
  echo &quot;latest&quot;
}

# Function to update version in project files
update_version_files() {
  local version=$1
  local full_version=$2
  
  # Update VERSION file
  echo &quot;$version&quot; &gt; &quot;$VERSION_FILE&quot;
  
  # Update mix.exs if it exists
  if [ -f &quot;mix.exs&quot; ]; then
    sed -i &quot;s/version: \&quot;[^\&quot;]*\&quot;/version: \&quot;$version\&quot;/&quot; mix.exs
    echo &quot;Updated mix.exs with version $version&quot;
  fi
  
  echo &quot;Version files updated to $version (full: $full_version)&quot;
}

# Main script execution
main() {
  local command=${1:-&quot;get&quot;}
  local version_type=${2:-&quot;&quot;}
  local env=${3:-&quot;prod&quot;}
  
  case &quot;$command&quot; in
    get)
      get_current_version
      ;;
    bump)
      if [ -z &quot;$version_type&quot; ]; then
        echo &quot;Error: Please specify a version type (major, minor, patch)&quot; &gt;&amp;2
        exit 1
      fi
      local new_version=$(generate_version &quot;$version_type&quot;)
      echo &quot;$new_version&quot;
      ;;
    full)
      local version=$(get_current_version)
      generate_full_version &quot;$version&quot; &quot;$env&quot;
      ;;
    tags)
      local version=$(get_current_version)
      generate_docker_tags &quot;$version&quot;
      ;;
    update)
      if [ -n &quot;$version_type&quot; ]; then
        local new_version=$(generate_version &quot;$version_type&quot;)
        local full_version=$(generate_full_version &quot;$new_version&quot; &quot;$env&quot;)
        update_version_files &quot;$new_version&quot; &quot;$full_version&quot;
      else
        local current_version=$(get_current_version)
        local full_version=$(generate_full_version &quot;$current_version&quot; &quot;$env&quot;)
        echo &quot;No version change requested. Current version: $current_version (full: $full_version)&quot;
      fi
      ;;
    *)
      echo &quot;Unknown command: $command&quot; &gt;&amp;2
      echo &quot;Usage: $0 [get|bump|full|tags|update] [major|minor|patch] [prod|dev]&quot; &gt;&amp;2
      exit 1
      ;;
  esac
}

# Execute main function with all arguments
main &quot;$@&quot;</file><file path="test/support/fixtures/api_responses.ex">defmodule WandererNotifier.Test.Fixtures.ApiResponses do
  @moduledoc &quot;&quot;&quot;
  Provides fixture data for API responses used in tests.
  &quot;&quot;&quot;

  def map_systems_response do
    %{
      &quot;systems&quot; =&gt; [
        %{
          &quot;id&quot; =&gt; &quot;J123456&quot;,
          &quot;name&quot; =&gt; &quot;Test System&quot;,
          &quot;security_status&quot; =&gt; -1.0,
          &quot;region_id&quot; =&gt; 10_000_001,
          &quot;tracked&quot; =&gt; true,
          &quot;activity&quot; =&gt; 25
        },
        %{
          &quot;id&quot; =&gt; &quot;J654321&quot;,
          &quot;name&quot; =&gt; &quot;Another System&quot;,
          &quot;security_status&quot; =&gt; -0.9,
          &quot;region_id&quot; =&gt; 10_000_002,
          &quot;tracked&quot; =&gt; false,
          &quot;activity&quot; =&gt; 5
        }
      ]
    }
  end

  def esi_character_response do
    %{
      &quot;character_id&quot; =&gt; 12_345,
      &quot;corporation_id&quot; =&gt; 67_890,
      &quot;alliance_id&quot; =&gt; 54_321,
      &quot;name&quot; =&gt; &quot;Test Character&quot;,
      &quot;security_status&quot; =&gt; 5.0
    }
  end

  def zkill_message do
    %{
      &quot;killID&quot; =&gt; 12_345_678,
      &quot;killmail_time&quot; =&gt; &quot;2023-06-15T12:34:56Z&quot;,
      &quot;solar_system_id&quot; =&gt; 30_000_142,
      &quot;victim&quot; =&gt; %{
        &quot;character_id&quot; =&gt; 12_345,
        &quot;corporation_id&quot; =&gt; 67_890,
        &quot;ship_type_id&quot; =&gt; 582
      },
      &quot;attackers&quot; =&gt; [
        %{
          &quot;character_id&quot; =&gt; 98_765,
          &quot;corporation_id&quot; =&gt; 54_321,
          &quot;ship_type_id&quot; =&gt; 11_567
        }
      ],
      &quot;zkb&quot; =&gt; %{
        &quot;totalValue&quot; =&gt; 100_000_000.0,
        &quot;points&quot; =&gt; 10
      }
    }
  end
end</file><file path="test/support/mocks/cache_mock.ex">defmodule WandererNotifier.Test.Support.Mocks.CacheMock do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of the cache behavior for testing.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Cache.Behaviour

  @impl true
  def get(key), do: {:ok, Process.get({:cache, key})}

  @impl true
  def set(key, value, _ttl) do
    Process.put({:cache, key}, value)
    {:ok, value}
  end

  @impl true
  def put(key, value) do
    Process.put({:cache, key}, value)
    {:ok, value}
  end

  @impl true
  def delete(key) do
    Process.delete({:cache, key})
    :ok
  end

  @impl true
  def clear do
    # This is a simplified clear that only clears cache-related process dictionary entries
    Process.get_keys()
    |&gt; Enum.filter(fn
      {:cache, _} -&gt; true
      _ -&gt; false
    end)
    |&gt; Enum.each(&amp;Process.delete/1)

    :ok
  end

  @impl true
  def get_and_update(key, update_fun) do
    current = Process.get({:cache, key})
    {current_value, new_value} = update_fun.(current)
    Process.put({:cache, key}, new_value)
    {:ok, {current_value, new_value}}
  end

  @impl true
  def get_recent_kills do
    case get(WandererNotifier.Cache.Keys.zkill_recent_kills()) do
      {:ok, kills} when is_list(kills) -&gt; kills
      _ -&gt; []
    end
  end
end</file><file path="test/support/mocks/mock_date.ex">defmodule WandererNotifier.MockDate do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of Date functions for testing.
  &quot;&quot;&quot;
  @behaviour WandererNotifier.DateBehaviour

  @impl true
  def utc_today do
    Date.utc_today()
  end

  @impl true
  def day_of_week(date) do
    Date.day_of_week(date)
  end
end</file><file path="test/support/mocks/mock_notifier_factory.ex">defmodule WandererNotifier.MockNotifierFactory do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of NotifierFactory for testing.
  &quot;&quot;&quot;
  @behaviour WandererNotifier.Notifiers.FactoryBehaviour

  @impl true
  def notify(:send_discord_embed, [embed]) do
    case embed do
      nil -&gt;
        # Simplified error handling
        {:error, &quot;Invalid embed&quot;}

      %{title: nil} -&gt;
        {:error, &quot;Missing title&quot;}

      _ -&gt;
        {:ok, %{embed: embed}}
    end
  end

  def notify(type, _args) do
    {:error, &quot;Unsupported notification type: #{inspect(type)}&quot;}
  end
end</file><file path="test/support/stubs/discord_notifier.ex">defmodule WandererNotifier.Test.Stubs.DiscordNotifier do
  @moduledoc &quot;&quot;&quot;
  Stub implementation of the Discord notifier for testing.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Notifiers.DiscordNotifierBehaviour

  @impl true
  def send_notification(_type, _data) do
    {:ok, :sent}
  end

  @impl true
  def send_to_channel(_channel_id, _data) do
    {:ok, :sent}
  end

  @impl true
  def send_discord_embed(_embed) do
    {:ok, :sent}
  end
end</file><file path="test/support/mocks.ex">defmodule WandererNotifier.MockZKillClient do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of the ZKillboard client for testing.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Killmail.ZKillClient

  @impl true
  def get_single_killmail(_kill_id), do: {:ok, []}

  @impl true
  def get_recent_kills(_limit \\ 10), do: {:ok, []}

  @impl true
  def get_system_kills(_system_id, _limit \\ 5), do: {:ok, []}

  @impl true
  def get_character_kills(_character_id, _limit \\ 25, _page \\ 1), do: {:ok, []}
end

defmodule WandererNotifier.MockESI do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of the ESI service for testing.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Api.ESI.ServiceBehaviour

  @impl true
  def get_killmail(_kill_id, _hash), do: {:ok, %{}}

  @impl true
  def get_character_info(_character_id), do: {:ok, %{}}

  @impl true
  def get_corporation_info(_corporation_id), do: {:ok, %{}}

  @impl true
  def get_alliance_info(_alliance_id), do: {:ok, %{}}

  @impl true
  def get_system_info(_system_id), do: {:ok, %{}}

  @impl true
  def get_type_info(_type_id), do: {:ok, %{}}

  @impl true
  def get_system(_system_id), do: {:ok, %{}}

  @impl true
  def get_character(_character_id), do: {:ok, %{}}

  @impl true
  def get_type(_type_id), do: {:ok, %{}}

  @impl true
  def get_ship_type_name(_ship_type_id), do: {:ok, %{&quot;name&quot; =&gt; &quot;Test Ship&quot;}}

  @impl true
  def get_system_kills(_system_id, _limit) do
    {:ok, []}
  end
end

defmodule WandererNotifier.Test.Support.Mocks do
  @moduledoc &quot;&quot;&quot;
  Mock implementations for testing.
  &quot;&quot;&quot;

  alias WandererNotifier.Cache.Keys
  alias WandererNotifier.Logger.Logger, as: AppLogger

  @behaviour WandererNotifier.Cache.Behaviour

  # -- Cache Implementation --

  @impl true
  def get(key), do: {:ok, Process.get({:cache, key})}

  @impl true
  def set(key, value, _ttl) do
    AppLogger.cache_debug(&quot;Setting cache value with TTL&quot;,
      key: key,
      value: value
    )

    Process.put({:cache, key}, value)
    {:ok, value}
  end

  @impl true
  def put(key, value) do
    Process.put({:cache, key}, value)
    {:ok, value}
  end

  @impl true
  def delete(key) do
    Process.delete({:cache, key})
    :ok
  end

  @impl true
  def clear do
    # This is a simplified clear that only clears cache-related process dictionary entries
    Process.get_keys()
    |&gt; Enum.filter(fn
      {:cache, _} -&gt; true
      _ -&gt; false
    end)
    |&gt; Enum.each(&amp;Process.delete/1)

    :ok
  end

  @impl true
  def get_and_update(key, update_fun) do
    current = Process.get({:cache, key})
    {current_value, new_value} = update_fun.(current)
    Process.put({:cache, key}, new_value)
    {:ok, {current_value, new_value}}
  end

  @impl true
  def get_recent_kills do
    case get(Keys.zkill_recent_kills()) do
      {:ok, kills} when is_list(kills) -&gt; kills
      _ -&gt; []
    end
  end

  # -- Other Mock Implementations --
  # Add other mock implementations here as needed
end

defmodule WandererNotifier.MockRepository do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of the repository for testing.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Data.Cache.RepositoryBehaviour

  @impl true
  def delete(_key), do: :ok

  @impl true
  def exists?(_key), do: false

  @impl true
  def get(_key), do: nil

  @impl true
  def get_and_update(_key, _fun), do: {nil, nil}

  @impl true
  def get_tracked_characters, do: []

  @impl true
  def put(_key, _value), do: :ok

  @impl true
  def set(_key, _value, _ttl), do: :ok

  @impl true
  def clear, do: :ok
end

defmodule WandererNotifier.MockLogger do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of the logger for testing.
  &quot;&quot;&quot;

  def debug(_message, _metadata \\ []), do: :ok
  def info(_message, _metadata \\ []), do: :ok
  def warn(_message, _metadata \\ []), do: :ok
  def error(_message, _metadata \\ []), do: :ok
  def api_debug(_message, _metadata \\ []), do: :ok
  def api_info(_message, _metadata \\ []), do: :ok
  def api_warn(_message, _metadata \\ []), do: :ok
  def api_error(_message, _metadata \\ []), do: :ok
  def websocket_info(_message, _metadata \\ []), do: :ok
  def websocket_error(_message, _metadata \\ []), do: :ok
end

defmodule WandererNotifier.MockConfig do
  @moduledoc &quot;&quot;&quot;
  Mock for the config module.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Config.Behaviour

  @impl true
  def character_tracking_enabled?, do: true

  @impl true
  def character_notifications_enabled?, do: true

  @impl true
  def system_notifications_enabled?, do: true

  @impl true
  def get_feature_status do
    %{
      notifications_enabled: true,
      character_notifications_enabled: true,
      system_notifications_enabled: true,
      kill_notifications_enabled: true,
      character_tracking_enabled: true,
      system_tracking_enabled: true,
      tracked_systems_notifications_enabled: true,
      tracked_characters_notifications_enabled: true,
      status_messages_disabled: true,
      track_kspace_systems: true
    }
  end

  @impl true
  def discord_channel_id_for(channel) do
    case channel do
      :main -&gt; &quot;123456789&quot;
      :system_kill -&gt; &quot;123456789&quot;
      :character_kill -&gt; &quot;123456789&quot;
      :system -&gt; &quot;123456789&quot;
      :character -&gt; &quot;123456789&quot;
      _ -&gt; &quot;123456789&quot;
    end
  end

  @impl true
  def get_map_config do
    %{
      url: &quot;https://wanderer.ltd&quot;,
      name: &quot;TestMap&quot;,
      token: &quot;test-token&quot;,
      csrf_token: &quot;test-csrf-token&quot;
    }
  end

  @impl true
  def get_env(key, default) do
    case key do
      :webhook_url -&gt; &quot;https://discord.com/api/webhooks/123/abc&quot;
      :map_url -&gt; &quot;https://wanderer.ltd&quot;
      :map_name -&gt; &quot;TestMap&quot;
      :map_token -&gt; &quot;test-token&quot;
      :test_mode -&gt; true
      _ -&gt; default
    end
  end

  @impl true
  def static_info_cache_ttl, do: 3600

  @impl true
  def map_url, do: &quot;https://wanderer.ltd&quot;

  @impl true
  def map_name, do: &quot;TestMap&quot;

  @impl true
  def map_token, do: &quot;test-token&quot;

  @impl true
  def map_csrf_token, do: &quot;test-csrf-token&quot;

  @impl true
  def license_key, do: &quot;test-license-key&quot;

  @impl true
  def license_manager_api_url, do: &quot;https://license.example.com&quot;

  @impl true
  def license_manager_api_key, do: &quot;test-api-key&quot;

  @impl true
  def notifier_api_token, do: &quot;test-api-token&quot;

  @impl true
  def track_kspace_systems?, do: true
end

defmodule WandererNotifier.MockCacheHelpers do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of cache helpers for testing.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Data.Cache.HelpersBehaviour

  @impl true
  def get_cached_kills(_id) do
    {:ok, []}
  end

  @impl true
  def get_tracked_systems do
    []
  end

  @impl true
  def get_tracked_characters do
    []
  end

  @impl true
  def get_ship_name(_ship_type_id) do
    {:ok, &quot;Test Ship&quot;}
  end

  @impl true
  def get_character_name(_character_id) do
    {:ok, &quot;Test Character&quot;}
  end
end

defmodule WandererNotifier.TestHelpers.Mocks do
  @moduledoc &quot;&quot;&quot;
  Defines mock behaviors for external services used in tests.
  &quot;&quot;&quot;

  # Define mock behaviors for ZKill service
  defmodule ZKillBehavior do
    @moduledoc &quot;&quot;&quot;
    Behaviour module for ZKill service mocks in tests.
    Defines the contract that ZKill service mocks must implement.
    &quot;&quot;&quot;

    @callback get_killmail(String.t(), String.t()) :: {:ok, map()} | {:error, any()}
    @callback get_system_kills(String.t(), integer()) :: {:ok, list()} | {:error, any()}
  end

  # Define mock behaviors for ESI service
  defmodule ESIBehavior do
    @moduledoc &quot;&quot;&quot;
    Behaviour module for ESI service mocks in tests.
    Defines the contract that ESI service mocks must implement.
    &quot;&quot;&quot;

    @callback get_character_info(String.t()) :: {:ok, map()} | {:error, any()}
    @callback get_type_info(String.t()) :: {:ok, map()} | {:error, any()}
    @callback get_ship_type_name(String.t()) :: {:ok, map()} | {:error, any()}
    @callback get_system_kills(String.t(), integer()) :: {:ok, list()} | {:error, any()}
    @callback get_killmail(String.t(), String.t()) :: {:ok, map()} | {:error, any()}
  end
end

# Define the mocks
Mox.defmock(WandererNotifier.Api.ZKill.ServiceMock,
  for: WandererNotifier.TestHelpers.Mocks.ZKillBehavior
)

Mox.defmock(WandererNotifier.Api.ESI.ServiceMock,
  for: WandererNotifier.TestHelpers.Mocks.ESIBehavior
)

Mox.defmock(WandererNotifier.MockZKillClient, for: WandererNotifier.Killmail.ZKillClient)</file><file path="test/support/test_cache_stubs.ex">defmodule WandererNotifier.Test.Support.TestCacheStubs do
  @moduledoc &quot;&quot;&quot;
  Test stubs for cache behavior.
  &quot;&quot;&quot;

  @behaviour WandererNotifier.Cache.Behaviour

  @impl true
  def get(_key), do: {:ok, nil}

  @impl true
  def set(_key, value, _ttl), do: {:ok, value}

  @impl true
  def put(_key, value), do: {:ok, value}

  @impl true
  def delete(_key), do: :ok

  @impl true
  def clear, do: :ok

  @impl true
  def get_and_update(_key, update_fun) do
    {current, updated} = update_fun.(nil)
    {:ok, {current, updated}}
  end

  @impl true
  def get_recent_kills, do: []
end</file><file path="test/wanderer_notifier/api/api_test.exs">defmodule WandererNotifier.ApiTest do
  use ExUnit.Case
  import Mox
  alias WandererNotifier.Test.Fixtures.ApiResponses

  setup :verify_on_exit!

  test &quot;uses fixtures for API testing&quot; do
    # Set up mock with specific expectations for each URL
    WandererNotifier.MockHTTP
    |&gt; expect(:get, fn url, _headers, _options -&gt;
      assert String.contains?(url, &quot;/systems&quot;)
      {:ok, %{status: 200, body: ApiResponses.map_systems_response(), headers: []}}
    end)
    |&gt; expect(:get, fn url, _headers, _options -&gt;
      assert String.contains?(url, &quot;/characters&quot;)
      {:ok, %{status: 200, body: ApiResponses.esi_character_response(), headers: []}}
    end)

    # Test systems endpoint
    systems_result = WandererNotifier.MockHTTP.get(&quot;https://api.example.com/systems&quot;, [], [])
    assert {:ok, %{status: 200, body: systems_body}} = systems_result
    assert length(systems_body[&quot;systems&quot;]) == 2
    assert Enum.at(systems_body[&quot;systems&quot;], 0)[&quot;name&quot;] == &quot;Test System&quot;

    # Test characters endpoint
    char_result = WandererNotifier.MockHTTP.get(&quot;https://api.example.com/characters&quot;, [], [])
    assert {:ok, %{status: 200, body: char_body}} = char_result
    assert char_body[&quot;character_id&quot;] == 12_345
    assert char_body[&quot;name&quot;] == &quot;Test Character&quot;
  end
end</file><file path="test/wanderer_notifier/config/debug_test.exs">defmodule WandererNotifier.Config.DebugTest do
  use ExUnit.Case, async: false
  alias WandererNotifier.Config.Debug

  # Save original environment before tests
  setup do
    # Save original environment variables
    original_env = System.get_env(&quot;WANDERER_DEBUG_LOGGING&quot;)
    original_map_url = Application.get_env(:wanderer_notifier, :map_url)
    original_map_token = Application.get_env(:wanderer_notifier, :map_token)
    original_map_name = Application.get_env(:wanderer_notifier, :map_name)
    original_map_url_with_name = Application.get_env(:wanderer_notifier, :map_url_with_name)
    original_config = Application.get_env(:wanderer_notifier, :debug_logging_enabled)

    # Clean up after tests
    on_exit(fn -&gt;
      # Restore original environment
      if is_nil(original_env) do
        System.delete_env(&quot;WANDERER_DEBUG_LOGGING&quot;)
      else
        System.put_env(&quot;WANDERER_DEBUG_LOGGING&quot;, original_env)
      end

      # Restore original config
      if is_nil(original_config) do
        Application.delete_env(:wanderer_notifier, :debug_logging_enabled)
      else
        Application.put_env(:wanderer_notifier, :debug_logging_enabled, original_config)
      end

      # Restore map settings
      restore_or_delete_config(:map_url, original_map_url)
      restore_or_delete_config(:map_token, original_map_token)
      restore_or_delete_config(:map_name, original_map_name)
      restore_or_delete_config(:map_url_with_name, original_map_url_with_name)
    end)

    :ok
  end

  # Helper to restore or delete config
  defp restore_or_delete_config(key, value) do
    if is_nil(value) do
      Application.delete_env(:wanderer_notifier, key)
    else
      Application.put_env(:wanderer_notifier, key, value)
    end
  end

  describe &quot;debug_logging_enabled?/0&quot; do
    test &quot;returns false by default&quot; do
      # Clear the environment and configuration
      System.delete_env(&quot;WANDERER_DEBUG_LOGGING&quot;)
      Application.delete_env(:wanderer_notifier, :debug_logging_enabled)

      refute Debug.debug_logging_enabled?()
    end

    test &quot;returns true when enabled via environment variable&quot; do
      System.put_env(&quot;WANDERER_DEBUG_LOGGING&quot;, &quot;true&quot;)
      Application.delete_env(:wanderer_notifier, :debug_logging_enabled)

      assert Debug.debug_logging_enabled?()
    end

    test &quot;returns true when enabled via config&quot; do
      System.delete_env(&quot;WANDERER_DEBUG_LOGGING&quot;)
      Application.put_env(:wanderer_notifier, :debug_logging_enabled, true)

      assert Debug.debug_logging_enabled?()
    end

    test &quot;config takes precedence over environment variable&quot; do
      System.put_env(&quot;WANDERER_DEBUG_LOGGING&quot;, &quot;false&quot;)
      Application.put_env(:wanderer_notifier, :debug_logging_enabled, true)

      assert Debug.debug_logging_enabled?()
    end
  end

  describe &quot;toggle_debug_logging/0&quot; do
    test &quot;toggles debug logging from false to true&quot; do
      # Ensure debug logging is disabled
      System.delete_env(&quot;WANDERER_DEBUG_LOGGING&quot;)
      Application.delete_env(:wanderer_notifier, :debug_logging_enabled)

      # Toggle debug logging
      assert Debug.toggle_debug_logging() == true

      # Verify the setting was updated
      assert Debug.debug_logging_enabled?()
    end

    test &quot;toggles debug logging from true to false&quot; do
      # Ensure debug logging is enabled
      Application.put_env(:wanderer_notifier, :debug_logging_enabled, true)

      # Toggle debug logging
      assert Debug.toggle_debug_logging() == false

      # Verify the setting was updated
      refute Debug.debug_logging_enabled?()
    end
  end

  describe &quot;set_debug_logging/1&quot; do
    test &quot;sets debug logging to true&quot; do
      Application.delete_env(:wanderer_notifier, :debug_logging_enabled)

      assert Debug.set_debug_logging(true) == true
      assert Debug.debug_logging_enabled?()
    end

    test &quot;sets debug logging to false&quot; do
      Application.put_env(:wanderer_notifier, :debug_logging_enabled, true)

      assert Debug.set_debug_logging(false) == false
      refute Debug.debug_logging_enabled?()
    end
  end

  describe &quot;map_debug_settings/0&quot; do
    setup do
      # Clear application configuration before each test
      Application.delete_env(:wanderer_notifier, :map_url)
      Application.delete_env(:wanderer_notifier, :map_token)
      Application.delete_env(:wanderer_notifier, :map_name)
      Application.delete_env(:wanderer_notifier, :map_url_with_name)

      :ok
    end

    test &quot;returns default values when not configured&quot; do
      # Clear all environment variables that could affect the test
      [
        &quot;MAP_URL&quot;,
        &quot;MAP_TOKEN&quot;,
        &quot;MAP_NAME&quot;,
        &quot;MAP_URL_WITH_NAME&quot;,
        &quot;WANDERER_MAP_URL&quot;,
        &quot;WANDERER_MAP_TOKEN&quot;,
        &quot;WANDERER_MAP_NAME&quot;,
        &quot;WANDERER_MAP_URL_WITH_NAME&quot;
      ]
      |&gt; Enum.each(&amp;System.delete_env/1)

      settings = Debug.map_debug_settings()

      assert is_map(settings)
      assert is_nil(settings.map_url)
      assert is_nil(settings.map_token)
      assert is_nil(settings.map_name)
      assert is_nil(settings.map_url_with_name)
    end

    test &quot;returns values from environment variables&quot; do
      # Clear any existing env vars first
      [&quot;MAP_URL&quot;, &quot;MAP_TOKEN&quot;, &quot;WANDERER_MAP_URL&quot;, &quot;WANDERER_MAP_TOKEN&quot;]
      |&gt; Enum.each(&amp;System.delete_env/1)

      System.put_env(&quot;WANDERER_MAP_URL&quot;, &quot;https://example.com/map&quot;)
      System.put_env(&quot;WANDERER_MAP_TOKEN&quot;, &quot;test-token&quot;)

      settings = Debug.map_debug_settings()

      assert settings.map_url == &quot;https://example.com/map&quot;
      assert settings.map_token == &quot;test-token&quot;
    end

    test &quot;supports legacy environment variables for backward compatibility&quot; do
      # Clear any existing env vars first
      [&quot;MAP_URL&quot;, &quot;MAP_TOKEN&quot;, &quot;WANDERER_MAP_URL&quot;, &quot;WANDERER_MAP_TOKEN&quot;]
      |&gt; Enum.each(&amp;System.delete_env/1)

      System.put_env(&quot;MAP_URL&quot;, &quot;https://example.com/map&quot;)
      System.put_env(&quot;MAP_TOKEN&quot;, &quot;test-token&quot;)

      settings = Debug.map_debug_settings()

      assert settings.map_url == &quot;https://example.com/map&quot;
      assert settings.map_token == &quot;test-token&quot;
    end

    test &quot;prefixed variables take precedence over legacy variables&quot; do
      # Setup both new and legacy variables with different values
      System.put_env(&quot;WANDERER_MAP_URL&quot;, &quot;https://wanderer.example.com&quot;)
      System.put_env(&quot;MAP_URL&quot;, &quot;https://legacy.example.com&quot;)

      settings = Debug.map_debug_settings()

      assert settings.map_url == &quot;https://wanderer.example.com&quot;
    end
  end
end</file><file path="test/wanderer_notifier/config/notifications_test.exs">defmodule WandererNotifier.Config.NotificationsTest do
  use ExUnit.Case, async: true

  alias WandererNotifier.Config.Notifications

  describe &quot;channels&quot; do
    test &quot;should return system_kill channel ID&quot; do
      # Mock the environment variable
      Application.put_env(:wanderer_notifier, :discord_system_kill_channel_id, &quot;12345&quot;)

      # Test the function
      assert Notifications.channel_id(:system_kill) == &quot;12345&quot;

      # Clean up
      Application.delete_env(:wanderer_notifier, :discord_system_kill_channel_id)
    end

    test &quot;should return character_kill channel ID&quot; do
      # Mock the environment variable
      Application.put_env(:wanderer_notifier, :discord_character_kill_channel_id, &quot;67890&quot;)

      # Test the function
      assert Notifications.channel_id(:character_kill) == &quot;67890&quot;

      # Clean up
      Application.delete_env(:wanderer_notifier, :discord_character_kill_channel_id)
    end

    test &quot;should use fallback for missing channel IDs&quot; do
      # Setup main channel as fallback
      Application.put_env(:wanderer_notifier, :discord_channel_id, &quot;main-channel&quot;)

      # Test fallback for system kill channel
      assert Notifications.channel_id(:system_kill) == &quot;main-channel&quot;

      # Test fallback for character kill channel
      assert Notifications.channel_id(:character_kill) == &quot;main-channel&quot;

      # Clean up
      Application.delete_env(:wanderer_notifier, :discord_channel_id)
    end
  end

  describe &quot;get_discord_channel_id_for&quot; do
    test &quot;should map kill feature to system_kill channel&quot; do
      # Mock the environment variable
      Application.put_env(:wanderer_notifier, :discord_system_kill_channel_id, &quot;12345&quot;)

      # Test the mapping
      assert Notifications.get_discord_channel_id_for(:kill) == &quot;12345&quot;

      # Clean up
      Application.delete_env(:wanderer_notifier, :discord_system_kill_channel_id)
    end

    test &quot;should return appropriate channel for system_kill&quot; do
      # Mock the environment variable
      Application.put_env(:wanderer_notifier, :discord_system_kill_channel_id, &quot;12345&quot;)

      # Test the function
      assert Notifications.get_discord_channel_id_for(:system_kill) == &quot;12345&quot;

      # Clean up
      Application.delete_env(:wanderer_notifier, :discord_system_kill_channel_id)
    end

    test &quot;should return appropriate channel for character_kill&quot; do
      # Mock the environment variable
      Application.put_env(:wanderer_notifier, :discord_character_kill_channel_id, &quot;67890&quot;)

      # Test the function
      assert Notifications.get_discord_channel_id_for(:character_kill) == &quot;67890&quot;

      # Clean up
      Application.delete_env(:wanderer_notifier, :discord_character_kill_channel_id)
    end
  end
end</file><file path="test/wanderer_notifier/config/timings_test.exs">defmodule WandererNotifier.Config.TimingsTest do
  use ExUnit.Case, async: false
  alias WandererNotifier.Config.Timings

  # Save the original environment before running tests
  setup do
    # Store original timing configuration
    original_config = Application.get_env(:wanderer_notifier, :systems_cache_ttl)

    # Ensure we clean up after tests run
    on_exit(fn -&gt;
      if original_config do
        Application.put_env(:wanderer_notifier, :systems_cache_ttl, original_config)
      else
        Application.delete_env(:wanderer_notifier, :systems_cache_ttl)
      end
    end)

    :ok
  end

  describe &quot;config/0&quot; do
    test &quot;returns a complete configuration map&quot; do
      config = Timings.config()

      assert is_map(config)
      assert is_map(config.cache)
      assert is_map(config.intervals)
      assert is_map(config.schedulers)

      # Check a sample value from each section
      assert config.cache.systems.ttl == Timings.systems_cache_ttl()
      assert config.intervals.system_update == Timings.system_update_scheduler_interval()
      assert config.schedulers.activity_chart.interval == Timings.activity_chart_interval()
    end
  end

  describe &quot;cache TTL functions&quot; do
    test &quot;systems_cache_ttl/0 returns the configured value or default&quot; do
      # Test with configured value
      Application.put_env(:wanderer_notifier, :systems_cache_ttl, 9000)
      assert Timings.systems_cache_ttl() == 9000

      # Test with default value
      Application.delete_env(:wanderer_notifier, :systems_cache_ttl)
      assert Timings.systems_cache_ttl() == 86_400
    end

    test &quot;cache_ttls/0 returns a map with all TTL configurations&quot; do
      ttls = Timings.cache_ttls()

      assert is_map(ttls)
      assert ttls.systems.ttl == Timings.systems_cache_ttl()
      assert ttls.characters.ttl == Timings.characters_cache_ttl()
      assert ttls.static_info.ttl == Timings.static_info_cache_ttl()
      assert is_binary(ttls.systems.description)
    end
  end

  describe &quot;interval functions&quot; do
    test &quot;system_update_scheduler_interval/0 returns the configured value or default&quot; do
      # Test with configured value
      Application.put_env(:wanderer_notifier, :system_update_scheduler_interval, 60_000)
      assert Timings.system_update_scheduler_interval() == 60_000

      # Test with default value
      Application.delete_env(:wanderer_notifier, :system_update_scheduler_interval)
      assert Timings.system_update_scheduler_interval() == 30_000
    end

    test &quot;reconnect_delay/0 returns the configured value or default&quot; do
      # Test with configured value
      Application.put_env(:wanderer_notifier, :reconnect_delay, 10_000)
      assert Timings.reconnect_delay() == 10_000

      # Test with default value
      Application.delete_env(:wanderer_notifier, :reconnect_delay)
      assert Timings.reconnect_delay() == 5_000
    end
  end

  describe &quot;scheduler functions&quot; do
    test &quot;chart_hour/0 returns the configured value or default&quot; do
      # Test with configured value
      Application.put_env(:wanderer_notifier, :chart_service_hour, 15)
      assert Timings.chart_hour() == 15

      # Test with default value
      Application.delete_env(:wanderer_notifier, :chart_service_hour)
      assert Timings.chart_hour() == 12
    end

    test &quot;scheduler_configs/0 returns a map with all scheduler configurations&quot; do
      configs = Timings.scheduler_configs()

      assert is_map(configs)
      assert configs.activity_chart.type == :interval
      assert configs.kill_chart.type == :time
      assert configs.kill_chart.hour == Timings.chart_hour()
      assert configs.character_update.interval == Timings.character_update_scheduler_interval()
    end
  end

  describe &quot;validation&quot; do
    test &quot;validate/0 returns :ok for valid configuration&quot; do
      # Set valid test values
      Application.put_env(:wanderer_notifier, :system_update_scheduler_interval, 60_000)
      Application.put_env(:wanderer_notifier, :systems_cache_ttl, 86_400)
      Application.put_env(:wanderer_notifier, :chart_service_hour, 12)

      assert Timings.validate() == :ok
    end

    test &quot;validate/0 returns error for invalid interval&quot; do
      # Set invalid value
      Application.put_env(:wanderer_notifier, :system_update_scheduler_interval, -1)

      assert {:error, errors} = Timings.validate()
      assert Enum.any?(errors, &amp;String.contains?(&amp;1, &quot;system_update_scheduler_interval&quot;))
    end

    test &quot;validate/0 returns error for invalid TTL&quot; do
      # Set invalid value
      Application.put_env(:wanderer_notifier, :systems_cache_ttl, 0)

      assert {:error, errors} = Timings.validate()
      assert Enum.any?(errors, &amp;String.contains?(&amp;1, &quot;systems_cache_ttl&quot;))
    end

    test &quot;validate/0 returns error for invalid hour&quot; do
      # Set invalid value
      Application.put_env(:wanderer_notifier, :chart_service_hour, 25)

      assert {:error, errors} = Timings.validate()
      assert Enum.any?(errors, &amp;String.contains?(&amp;1, &quot;hour must be between&quot;))
    end
  end
end</file><file path="test/wanderer_notifier/config/version_test.exs">defmodule WandererNotifier.Config.VersionTest do
  use ExUnit.Case
  alias WandererNotifier.Config.Version

  describe &quot;version/0&quot; do
    test &quot;returns a valid semantic version string&quot; do
      version = Version.version()
      assert is_binary(version)
      # Validate it matches semantic versioning pattern (x.y.z)
      assert Regex.match?(~r/^\d+\.\d+\.\d+$/, version)
    end
  end

  describe &quot;version_tuple/0&quot; do
    test &quot;returns a tuple of integers&quot; do
      version_tuple = Version.version_tuple()
      assert is_tuple(version_tuple)
      assert tuple_size(version_tuple) == 3
      assert is_integer(elem(version_tuple, 0))
      assert is_integer(elem(version_tuple, 1))
      assert is_integer(elem(version_tuple, 2))
    end
  end

  describe &quot;version_info/0&quot; do
    test &quot;returns a map with version components&quot; do
      info = Version.version_info()
      assert is_map(info)
      assert Map.has_key?(info, :version)
      assert Map.has_key?(info, :major)
      assert Map.has_key?(info, :minor)
      assert Map.has_key?(info, :patch)
      assert is_integer(info.major)
      assert is_integer(info.minor)
      assert is_integer(info.patch)
    end
  end

  describe &quot;at_least?/1&quot; do
    test &quot;correctly compares versions&quot; do
      version = Version.version()
      [major, minor, patch] = String.split(version, &quot;.&quot;) |&gt; Enum.map(&amp;String.to_integer/1)

      # Same version returns true
      assert Version.at_least?(version)

      # Lower version returns true
      assert Version.at_least?(&quot;#{major - 1}.#{minor}.#{patch}&quot;)
      assert Version.at_least?(&quot;#{major}.#{minor - 1}.#{patch}&quot;)
      assert Version.at_least?(&quot;#{major}.#{minor}.#{patch - 1}&quot;)

      # Higher version returns false
      refute Version.at_least?(&quot;#{major + 1}.#{minor}.#{patch}&quot;)
      refute Version.at_least?(&quot;#{major}.#{minor + 1}.#{patch}&quot;)
      refute Version.at_least?(&quot;#{major}.#{minor}.#{patch + 1}&quot;)
    end
  end
end</file><file path="test/wanderer_notifier/core/application/service_test.exs">defmodule WandererNotifier.Core.Application.ServiceTest do
  use ExUnit.Case, async: false
  import Mox

  alias WandererNotifier.Core.Application.Service
  alias WandererNotifier.MockDiscordNotifier, as: DiscordNotifier
  alias WandererNotifier.MockNotifierFactory, as: NotifierFactory
  alias WandererNotifier.MockStructuredFormatter, as: StructuredFormatter

  setup :verify_on_exit!

  setup do
    # Mock StructuredFormatter
    stub(StructuredFormatter, :format_system_status_message, fn _title,
                                                                _desc,
                                                                _stats,
                                                                _uptime,
                                                                _features,
                                                                _license,
                                                                _systems,
                                                                _chars -&gt;
      %{content: &quot;Test message&quot;}
    end)

    stub(StructuredFormatter, :to_discord_format, fn _message -&gt;
      %{content: &quot;Test message&quot;}
    end)

    # Mock Discord notifier
    stub(DiscordNotifier, :send_discord_embed, fn _embed -&gt;
      {:ok, %{status_code: 200}}
    end)

    stub(DiscordNotifier, :send_notification, fn _type, _data -&gt;
      {:ok, %{status_code: 200}}
    end)

    # Mock NotifierFactory to handle the notification properly
    stub(NotifierFactory, :notify, fn
      :send_discord_embed_to_channel, [_channel_id, _embed] -&gt; :ok
      :send_message, [_message] -&gt; :ok
      _type, _args -&gt; :ok
    end)

    :ok
  end

  describe &quot;startup notification&quot; do
    test &quot;sends startup notification successfully&quot; do
      # Get the existing service PID or start a new one
      pid =
        case Process.whereis(Service) do
          nil -&gt;
            {:ok, pid} = Service.start_link([])
            pid

          pid -&gt;
            pid
        end

      # Send startup notification
      send(pid, :send_startup_notification)

      # Give it a moment to process
      Process.sleep(100)

      # The service should still be alive
      assert Process.alive?(pid)
    end
  end
end</file><file path="test/wanderer_notifier/data/cache/cache_test.exs">defmodule WandererNotifier.Data.CacheTest do
  # Disable async since we&apos;re using shared ETS tables
  use ExUnit.Case, async: false
  # Suppress log output during tests
  @moduletag :capture_log

  alias WandererNotifier.Data.Cache

  setup_all do
    # Ensure tables exist before any test
    table_opts = [
      :named_table,
      :public,
      :set,
      {:write_concurrency, false},
      {:read_concurrency, true}
    ]

    # Create tables if they don&apos;t exist
    if :ets.whereis(:cache_table) == :undefined do
      :ets.new(:cache_table, table_opts)
    end

    if :ets.whereis(:locks_table) == :undefined do
      :ets.new(:locks_table, table_opts)
    end

    on_exit(fn -&gt;
      # Clean up tables after all tests
      :ets.delete_all_objects(:cache_table)
      :ets.delete_all_objects(:locks_table)
    end)

    :ok
  end

  setup do
    # Clean tables before each test
    :ets.delete_all_objects(:cache_table)
    :ets.delete_all_objects(:locks_table)
    :ok
  end

  describe &quot;get/1&quot; do
    test &quot;returns value when key exists&quot; do
      key = &quot;test_key&quot;
      value = &quot;test_value&quot;
      :ets.insert(:cache_table, {key, value})

      assert {:ok, ^value} = Cache.get(key)
    end

    test &quot;returns error when key does not exist&quot; do
      assert {:error, :not_found} = Cache.get(&quot;nonexistent_key&quot;)
    end
  end

  describe &quot;set/3&quot; do
    test &quot;sets value successfully&quot; do
      key = &quot;test_key&quot;
      value = &quot;test_value&quot;

      assert {:ok, ^value} = Cache.set(key, value)
      assert [{^key, ^value}] = :ets.lookup(:cache_table, key)
    end
  end

  describe &quot;put/3&quot; do
    test &quot;puts value successfully&quot; do
      key = &quot;test_key&quot;
      value = &quot;test_value&quot;

      assert {:ok, ^value} = Cache.put(key, value)
      assert [{^key, ^value}] = :ets.lookup(:cache_table, key)
    end
  end

  describe &quot;delete/1&quot; do
    test &quot;deletes value successfully&quot; do
      key = &quot;test_key&quot;
      value = &quot;test_value&quot;
      :ets.insert(:cache_table, {key, value})

      assert :ok = Cache.delete(key)
      assert [] = :ets.lookup(:cache_table, key)
    end
  end

  describe &quot;clear/0&quot; do
    test &quot;clears all values&quot; do
      :ets.insert(:cache_table, {&quot;key1&quot;, &quot;value1&quot;})
      :ets.insert(:cache_table, {&quot;key2&quot;, &quot;value2&quot;})

      assert :ok = Cache.clear()
      assert [] = :ets.tab2list(:cache_table)
    end
  end

  describe &quot;get_and_update/2&quot; do
    test &quot;updates existing value&quot; do
      key = &quot;test_key&quot;
      initial_value = &quot;initial&quot;
      updated_value = &quot;updated&quot;
      :ets.insert(:cache_table, {key, initial_value})

      assert {:ok, ^initial_value} =
               Cache.get_and_update(key, fn val -&gt;
                 assert val == initial_value
                 {val, updated_value}
               end)

      assert [{^key, ^updated_value}] = :ets.lookup(:cache_table, key)
    end

    test &quot;handles non-existing value&quot; do
      key = &quot;test_key&quot;
      new_value = &quot;new_value&quot;

      assert {:ok, nil} =
               Cache.get_and_update(key, fn nil -&gt;
                 {nil, new_value}
               end)

      assert [{^key, ^new_value}] = :ets.lookup(:cache_table, key)
    end
  end
end</file><file path="test/wanderer_notifier/data/cache/helpers_test.exs">defmodule WandererNotifier.Data.Cache.HelpersTest do
  use ExUnit.Case, async: false
  require Logger

  import Mox

  # Setup mocks before tests
  setup :verify_on_exit!

  alias WandererNotifier.Data.Cache.Helpers, as: CacheHelpers
  alias WandererNotifier.Data.Cache.RepositoryMock
  alias WandererNotifier.Data.MapSystem

  setup do
    # Set the mock as the implementation for Repository
    Application.put_env(
      :wanderer_notifier,
      :cache_repository,
      WandererNotifier.Data.Cache.RepositoryMock
    )

    # Ensure ETS tables exist
    table_opts = [
      :named_table,
      :public,
      :set,
      {:write_concurrency, true},
      {:read_concurrency, true}
    ]

    # Create tables if they don&apos;t exist
    if :ets.whereis(:cache_table) == :undefined do
      :ets.new(:cache_table, table_opts)
    end

    if :ets.whereis(:locks_table) == :undefined do
      :ets.new(:locks_table, table_opts)
    end

    # Clean up any existing data
    :ets.delete_all_objects(:cache_table)
    :ets.delete_all_objects(:locks_table)

    # Default behaviors - empty cache
    RepositoryMock
    |&gt; stub(:get, fn key -&gt;
      case key do
        &quot;map:systems&quot; -&gt; []
        &quot;tracked:systems&quot; -&gt; []
        &quot;map:characters&quot; -&gt; []
        &quot;tracked:characters&quot; -&gt; []
        &quot;map:system:&quot; &lt;&gt; _id -&gt; nil
        &quot;map:character:&quot; &lt;&gt; _id -&gt; nil
        _ -&gt; nil
      end
    end)
    |&gt; stub(:put, fn _key, _value -&gt; :ok end)
    |&gt; stub(:set, fn _key, _value, _ttl -&gt; :ok end)
    |&gt; stub(:delete, fn _key -&gt; :ok end)
    |&gt; stub(:clear, fn -&gt; :ok end)
    |&gt; stub(:get_and_update, fn _key, fun -&gt;
      {old, new} = fun.(nil)
      {old, new}
    end)

    :ok
  end

  # Basic sanity testing for public API
  describe &quot;get_tracked_systems/0&quot; do
    test &quot;returns empty list when no systems are tracked&quot; do
      result = CacheHelpers.get_tracked_systems()
      assert is_list(result)
      assert result == []
    end
  end

  describe &quot;add_system_to_tracked/2&quot; do
    test &quot;adds system with integer ID&quot; do
      system_data = %{name: &quot;Test System&quot;}
      system_id = 12_345

      RepositoryMock
      |&gt; expect(:get, fn &quot;map:system:12345&quot; -&gt; nil end)
      |&gt; expect(:put, fn &quot;map:system:12345&quot;, ^system_data -&gt; :ok end)
      |&gt; expect(:put, fn &quot;tracked:system:12345&quot;, true -&gt; :ok end)
      |&gt; expect(:get, fn &quot;tracked:systems&quot; -&gt; [] end)
      |&gt; expect(:put, fn &quot;tracked:systems&quot;, [%{&quot;system_id&quot; =&gt; &quot;12345&quot;}] -&gt; :ok end)

      result = CacheHelpers.add_system_to_tracked(system_id, system_data)
      assert result == :ok
    end

    test &quot;adds system with string ID&quot; do
      system_data = %{name: &quot;Test System&quot;}
      system_id = &quot;12345&quot;

      RepositoryMock
      |&gt; expect(:get, fn &quot;map:system:12345&quot; -&gt; nil end)
      |&gt; expect(:put, fn &quot;map:system:12345&quot;, ^system_data -&gt; :ok end)
      |&gt; expect(:put, fn &quot;tracked:system:12345&quot;, true -&gt; :ok end)
      |&gt; expect(:get, fn &quot;tracked:systems&quot; -&gt; [] end)
      |&gt; expect(:put, fn &quot;tracked:systems&quot;, [%{&quot;system_id&quot; =&gt; &quot;12345&quot;}] -&gt; :ok end)

      result = CacheHelpers.add_system_to_tracked(system_id, system_data)
      assert result == :ok
    end

    test &quot;handles adding duplicate system IDs&quot; do
      system_data = %{name: &quot;Test System Updated&quot;}
      system_id = 12_345
      existing_systems = [%{&quot;system_id&quot; =&gt; &quot;12345&quot;}]

      RepositoryMock
      |&gt; expect(:get, fn &quot;map:system:12345&quot; -&gt; %{&quot;system_id&quot; =&gt; &quot;12345&quot;} end)
      |&gt; expect(:put, fn &quot;tracked:system:12345&quot;, true -&gt; :ok end)
      |&gt; expect(:get, fn &quot;tracked:systems&quot; -&gt; existing_systems end)
      |&gt; expect(:put, fn &quot;tracked:systems&quot;, ^existing_systems -&gt; :ok end)

      result = CacheHelpers.add_system_to_tracked(system_id, system_data)
      assert result == :ok
    end

    test &quot;handles MapSystem struct&quot; do
      system = %MapSystem{
        id: &quot;168dae37-2e19-4982-8936-d945a8485420&quot;,
        solar_system_id: 30_000_142,
        name: &quot;Jita&quot;,
        original_name: &quot;Jita&quot;,
        temporary_name: nil,
        locked: true,
        class_title: nil,
        effect_name: nil,
        region_name: &quot;The Forge&quot;,
        statics: [],
        static_details: [],
        system_type: :kspace,
        type_description: &quot;High-sec&quot;,
        is_shattered: false,
        sun_type_id: 123
      }

      RepositoryMock
      |&gt; expect(:get, fn &quot;map:system:30000142&quot; -&gt; nil end)
      |&gt; expect(:put, fn &quot;map:system:30000142&quot;, ^system -&gt; :ok end)
      |&gt; expect(:put, fn &quot;tracked:system:30000142&quot;, true -&gt; :ok end)
      |&gt; expect(:get, fn &quot;tracked:systems&quot; -&gt; [] end)
      |&gt; expect(:put, fn &quot;tracked:systems&quot;, [%{&quot;system_id&quot; =&gt; &quot;30000142&quot;}] -&gt; :ok end)

      result = CacheHelpers.add_system_to_tracked(system.solar_system_id, system)
      assert result == :ok
    end
  end

  describe &quot;remove_system_from_tracked/1&quot; do
    test &quot;removes system when it exists in tracked list&quot; do
      RepositoryMock
      |&gt; expect(:get, fn &quot;tracked:systems&quot; -&gt; [%{&quot;system_id&quot; =&gt; &quot;12345&quot;}] end)
      |&gt; expect(:put, fn &quot;tracked:systems&quot;, [] -&gt; :ok end)
      |&gt; expect(:delete, fn &quot;tracked:system:12345&quot; -&gt; :ok end)

      result = CacheHelpers.remove_system_from_tracked(12_345)
      assert result == :ok
    end

    test &quot;handles removing non-existent system gracefully&quot; do
      RepositoryMock
      |&gt; expect(:get, fn &quot;tracked:systems&quot; -&gt; [] end)
      |&gt; expect(:put, fn &quot;tracked:systems&quot;, [] -&gt; :ok end)
      |&gt; expect(:delete, fn &quot;tracked:system:999999&quot; -&gt; :ok end)

      result = CacheHelpers.remove_system_from_tracked(999_999)
      assert result == :ok
    end

    test &quot;handles string ID for removal&quot; do
      RepositoryMock
      |&gt; expect(:get, fn &quot;tracked:systems&quot; -&gt; [%{&quot;system_id&quot; =&gt; &quot;12345&quot;}] end)
      |&gt; expect(:put, fn &quot;tracked:systems&quot;, [] -&gt; :ok end)
      |&gt; expect(:delete, fn &quot;tracked:system:12345&quot; -&gt; :ok end)

      result = CacheHelpers.remove_system_from_tracked(&quot;12345&quot;)
      assert result == :ok
    end
  end

  describe &quot;get_tracked_characters/0&quot; do
    test &quot;returns empty list when no characters are tracked&quot; do
      result = CacheHelpers.get_tracked_characters()
      assert is_list(result)
      assert result == []
    end
  end

  describe &quot;add_character_to_tracked/2&quot; do
    test &quot;adds character with integer ID&quot; do
      character_data = %{
        name: &quot;Test Character&quot;,
        eve_id: &quot;12345&quot;,
        character_id: &quot;12345&quot;
      }

      RepositoryMock
      |&gt; expect(:get, fn &quot;map:character:12345&quot; -&gt; nil end)
      |&gt; expect(:put, fn &quot;map:character:12345&quot;, ^character_data -&gt; :ok end)
      |&gt; expect(:put, fn &quot;tracked:character:12345&quot;, true -&gt; :ok end)

      result = CacheHelpers.add_character_to_tracked(12_345, character_data)
      assert result == :ok
    end

    test &quot;adds character with string ID&quot; do
      character_data = %{
        name: &quot;Test Character&quot;,
        eve_id: &quot;12345&quot;,
        character_id: &quot;12345&quot;
      }

      RepositoryMock
      |&gt; expect(:get, fn &quot;map:character:12345&quot; -&gt; nil end)
      |&gt; expect(:put, fn &quot;map:character:12345&quot;, ^character_data -&gt; :ok end)
      |&gt; expect(:put, fn &quot;tracked:character:12345&quot;, true -&gt; :ok end)

      result = CacheHelpers.add_character_to_tracked(&quot;12345&quot;, character_data)
      assert result == :ok
    end

    test &quot;handles adding duplicate character IDs&quot; do
      character_data = %{
        name: &quot;Test Character Updated&quot;,
        eve_id: &quot;12345&quot;,
        character_id: &quot;12345&quot;
      }

      RepositoryMock
      |&gt; expect(:get, fn &quot;map:character:12345&quot; -&gt; %{&quot;character_id&quot; =&gt; &quot;12345&quot;} end)
      |&gt; expect(:put, fn &quot;tracked:character:12345&quot;, true -&gt; :ok end)

      result = CacheHelpers.add_character_to_tracked(12_345, character_data)
      assert result == :ok
    end
  end
end</file><file path="test/wanderer_notifier/data/cache/keys_test.exs">defmodule WandererNotifier.Data.Cache.KeysTest do
  use ExUnit.Case, async: true

  alias WandererNotifier.Data.Cache.Keys

  describe &quot;key generation&quot; do
    test &quot;system/1 generates correct system key&quot; do
      assert Keys.system(30_004_759) == &quot;map:system:30004759&quot;
      assert Keys.system(&quot;30004759&quot;) == &quot;map:system:30004759&quot;
    end

    test &quot;character/1 generates correct character key&quot; do
      assert Keys.character(12_345) == &quot;map:character:12345&quot;
      assert Keys.character(&quot;12345&quot;) == &quot;map:character:12345&quot;
    end

    test &quot;tracked_system/1 generates correct tracked system key&quot; do
      assert Keys.tracked_system(30_004_759) == &quot;tracked:system:30004759&quot;
      assert Keys.tracked_system(&quot;30004759&quot;) == &quot;tracked:system:30004759&quot;
    end

    test &quot;tracked_character/1 generates correct tracked character key&quot; do
      assert Keys.tracked_character(12_345) == &quot;tracked:character:12345&quot;
      assert Keys.tracked_character(&quot;12345&quot;) == &quot;tracked:character:12345&quot;
    end

    test &quot;esi_killmail/1 generates correct ESI killmail key&quot; do
      assert Keys.esi_killmail(98_765) == &quot;esi:killmail:98765&quot;
      assert Keys.esi_killmail(&quot;98765&quot;) == &quot;esi:killmail:98765&quot;
    end

    test &quot;recent_kills/0 generates correct recent kills key&quot; do
      assert Keys.recent_kills() == &quot;recent:kills&quot;
    end

    test &quot;killmail_exists/3 generates correct existence check key&quot; do
      assert Keys.killmail_exists(123, 456, &quot;attacker&quot;) == &quot;exists:killmail:123:456:attacker&quot;
      assert Keys.killmail_exists(&quot;123&quot;, &quot;456&quot;, &quot;victim&quot;) == &quot;exists:killmail:123:456:victim&quot;
    end

    test &quot;character_recent_kills/1 generates correct character recent kills key&quot; do
      assert Keys.character_recent_kills(12_345) == &quot;character:12345:recent_kills&quot;
      assert Keys.character_recent_kills(&quot;12345&quot;) == &quot;character:12345:recent_kills&quot;
    end

    test &quot;zkill_recent_kills/0 generates correct zkill recent kills key&quot; do
      assert Keys.zkill_recent_kills() == &quot;zkill:recent_kills&quot;
    end
  end

  describe &quot;key validation&quot; do
    test &quot;valid?/1 returns true for valid keys&quot; do
      assert Keys.valid?(&quot;map:system:12345&quot;)
      assert Keys.valid?(&quot;recent:kills&quot;)
      assert Keys.valid?(&quot;exists:killmail:123:456:attacker&quot;)
    end

    test &quot;valid?/1 returns false for invalid keys&quot; do
      refute Keys.valid?(&quot;invalid-key&quot;)
      refute Keys.valid?(&quot;map&quot;)
      refute Keys.valid?(&quot;&quot;)
    end
  end

  describe &quot;pattern extraction&quot; do
    test &quot;extract_pattern/1 extracts correct pattern from keys&quot; do
      assert Keys.extract_pattern(&quot;map:system:12345&quot;) == &quot;map:system&quot;
      assert Keys.extract_pattern(&quot;recent:kills&quot;) == &quot;recent:kills&quot;
      assert Keys.extract_pattern(&quot;map:character:98765&quot;) == &quot;map:character&quot;
    end
  end

  describe &quot;key type detection&quot; do
    test &quot;is_array_key?/1 identifies array keys correctly&quot; do
      assert Keys.is_array_key?(&quot;array:data&quot;)
      assert Keys.is_array_key?(&quot;list:items&quot;)
      assert Keys.is_array_key?(&quot;recent:kills&quot;)
      refute Keys.is_array_key?(&quot;map:system:12345&quot;)
    end

    test &quot;is_map_key?/1 identifies map keys correctly&quot; do
      assert Keys.is_map_key?(&quot;map:system:12345&quot;)
      assert Keys.is_map_key?(&quot;data:items&quot;)
      assert Keys.is_map_key?(&quot;config:settings&quot;)
      refute Keys.is_map_key?(&quot;array:data&quot;)
    end

    test &quot;is_critical_key?/1 identifies critical keys correctly&quot; do
      assert Keys.is_critical_key?(&quot;critical:app_state&quot;)
      assert Keys.is_critical_key?(&quot;license_status&quot;)
      assert Keys.is_critical_key?(&quot;core_config&quot;)
      refute Keys.is_critical_key?(&quot;map:system:12345&quot;)
    end

    test &quot;is_state_key?/1 identifies state keys correctly&quot; do
      assert Keys.is_state_key?(&quot;state:app_data&quot;)
      assert Keys.is_state_key?(&quot;app:settings&quot;)
      assert Keys.is_state_key?(&quot;config:app&quot;)
      refute Keys.is_state_key?(&quot;map:system:12345&quot;)
    end

    test &quot;is_static_info_key?/1 identifies static info keys correctly&quot; do
      assert Keys.is_static_info_key?(&quot;map:system:static_info&quot;)
      assert Keys.is_static_info_key?(&quot;data:static_info&quot;)
      refute Keys.is_static_info_key?(&quot;map:system:12345&quot;)
    end
  end
end</file><file path="test/wanderer_notifier/data/character_test.exs">defmodule WandererNotifier.Data.CharacterTest do
  use ExUnit.Case, async: true
  alias WandererNotifier.Character.Character

  describe &quot;new/1&quot; do
    test &quot;creates a character from map with standard fields&quot; do
      map = %{
        &quot;character&quot; =&gt; %{
          &quot;character_id&quot; =&gt; &quot;12345&quot;,
          &quot;eve_id&quot; =&gt; &quot;12345&quot;,
          &quot;name&quot; =&gt; &quot;Test Character&quot;,
          &quot;corporation_id&quot; =&gt; &quot;67_890&quot;,
          &quot;corporation_ticker&quot; =&gt; &quot;CORP&quot;,
          &quot;alliance_id&quot; =&gt; &quot;54_321&quot;,
          &quot;alliance_ticker&quot; =&gt; &quot;ALLY&quot;
        }
      }

      character = Character.new(map)

      assert %Character{} = character
      assert character.character_id == &quot;12345&quot;
      assert character.name == &quot;Test Character&quot;
      assert character.corporation_id == 67_890
      assert character.corporation_ticker == &quot;CORP&quot;
      assert character.alliance_id == 54_321
      assert character.alliance_ticker == &quot;ALLY&quot;
      assert character.tracked == true
    end

    test &quot;creates a character from nested character data&quot; do
      map = %{
        &quot;character&quot; =&gt; %{
          &quot;character_id&quot; =&gt; &quot;12345&quot;,
          &quot;eve_id&quot; =&gt; &quot;12345&quot;,
          &quot;name&quot; =&gt; &quot;Nested Character&quot;,
          &quot;corporation_id&quot; =&gt; &quot;67_890&quot;,
          &quot;corporation_ticker&quot; =&gt; &quot;CORP&quot;
        }
      }

      character = Character.new(map)

      assert %Character{} = character
      assert character.character_id == &quot;12345&quot;
      assert character.name == &quot;Nested Character&quot;
      assert character.corporation_id == 67_890
      assert character.corporation_ticker == &quot;CORP&quot;
      assert character.tracked == true
    end

    test &quot;handles alternative field names&quot; do
      map = %{
        &quot;character&quot; =&gt; %{
          &quot;id&quot; =&gt; &quot;12345&quot;,
          &quot;eve_id&quot; =&gt; &quot;12345&quot;,
          &quot;name&quot; =&gt; &quot;Alt Field Character&quot;,
          &quot;corporation_id&quot; =&gt; &quot;67_890&quot;,
          &quot;corporation_ticker&quot; =&gt; &quot;CORP&quot;,
          &quot;alliance_id&quot; =&gt; &quot;54_321&quot;,
          &quot;alliance_ticker&quot; =&gt; &quot;ALLY&quot;
        }
      }

      character = Character.new(map)

      assert %Character{} = character
      assert character.character_id == &quot;12345&quot;
      assert character.name == &quot;Alt Field Character&quot;
      assert character.corporation_id == 67_890
      assert character.corporation_ticker == &quot;CORP&quot;
      assert character.alliance_id == 54_321
      assert character.alliance_ticker == &quot;ALLY&quot;
    end

    test &quot;handles tracked field&quot; do
      map = %{
        &quot;character&quot; =&gt; %{
          &quot;character_id&quot; =&gt; &quot;12345&quot;,
          &quot;eve_id&quot; =&gt; &quot;12345&quot;,
          &quot;name&quot; =&gt; &quot;Untracked Character&quot;
        },
        &quot;tracked&quot; =&gt; false
      }

      character = Character.new(map)

      assert %Character{} = character
      assert character.tracked == false
    end

    test &quot;raises error for missing required fields&quot; do
      assert_raise ArgumentError, ~r/Missing required eve_id field/, fn -&gt;
        Character.new(%{&quot;character&quot; =&gt; %{&quot;name&quot; =&gt; &quot;Missing ID&quot;}})
      end

      assert_raise ArgumentError, ~r/Missing required eve_id field/, fn -&gt;
        Character.new(%{&quot;character&quot; =&gt; %{&quot;character_id&quot; =&gt; &quot;12345&quot;, &quot;name&quot; =&gt; &quot;Missing EVE ID&quot;}})
      end

      assert_raise ArgumentError, ~r/Missing required fields for Character/, fn -&gt;
        Character.new(%{&quot;character&quot; =&gt; %{&quot;character_id&quot; =&gt; &quot;12345&quot;, &quot;eve_id&quot; =&gt; &quot;12345&quot;}})
      end
    end

    test &quot;raises error for invalid input type&quot; do
      assert_raise ArgumentError, fn -&gt;
        Character.new(&quot;not a map&quot;)
      end
    end
  end

  describe &quot;from_map/1&quot; do
    test &quot;creates a character from map with exact field names&quot; do
      map = %{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: 67_890,
        corporation_ticker: &quot;CORP&quot;,
        alliance_id: 54_321,
        alliance_ticker: &quot;ALLY&quot;,
        tracked: false
      }

      character = Character.from_map(map)

      assert %Character{} = character
      assert character.character_id == &quot;12345&quot;
      assert character.name == &quot;Test Character&quot;
      assert character.corporation_id == 67_890
      assert character.corporation_ticker == &quot;CORP&quot;
      assert character.alliance_id == 54_321
      assert character.alliance_ticker == &quot;ALLY&quot;
      assert character.tracked == false
    end

    test &quot;raises error for missing required fields&quot; do
      assert_raise ArgumentError, fn -&gt;
        Character.from_map(%{name: &quot;Missing ID&quot;})
      end

      assert_raise ArgumentError, fn -&gt;
        Character.from_map(%{character_id: &quot;12345&quot;})
      end
    end
  end

  describe &quot;Access behaviour&quot; do
    setup do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: 67_890,
        corporation_ticker: &quot;CORP&quot;,
        alliance_id: 54_321,
        alliance_ticker: &quot;ALLY&quot;,
        tracked: true
      }

      {:ok, character: character}
    end

    test &quot;fetch/2 retrieves struct fields with atom keys&quot;, %{character: character} do
      assert {:ok, &quot;12345&quot;} = Character.fetch(character, :character_id)
      assert {:ok, &quot;Test Character&quot;} = Character.fetch(character, :name)
      assert {:ok, 67_890} = Character.fetch(character, :corporation_id)
    end

    test &quot;fetch/2 retrieves special field mappings with string keys&quot;, %{character: character} do
      assert {:ok, &quot;12345&quot;} = Character.fetch(character, &quot;character_id&quot;)
      assert {:ok, &quot;12345&quot;} = Character.fetch(character, &quot;id&quot;)
      assert {:ok, 67_890} = Character.fetch(character, &quot;corporationID&quot;)
      assert {:ok, &quot;CORP&quot;} = Character.fetch(character, &quot;corporationName&quot;)
      assert {:ok, 54_321} = Character.fetch(character, &quot;allianceID&quot;)
      assert {:ok, &quot;ALLY&quot;} = Character.fetch(character, &quot;allianceName&quot;)
    end

    test &quot;fetch/2 returns error for non-existent keys&quot;, %{character: character} do
      assert :error = Character.fetch(character, :non_existent)
      assert :error = Character.fetch(character, &quot;non_existent&quot;)
    end

    test &quot;get/2 retrieves values with default&quot;, %{character: character} do
      assert Character.get(character, :character_id) == &quot;12345&quot;
      assert Character.get(character, &quot;character_id&quot;) == &quot;12345&quot;
      assert Character.get(character, :non_existent) == nil
      assert Character.get(character, :non_existent, &quot;default&quot;) == &quot;default&quot;
    end

    test &quot;get_and_update/3 raises error as not implemented&quot;, %{character: character} do
      assert_raise RuntimeError, ~r/get_and_update not implemented/, fn -&gt;
        Character.get_and_update(character, :name, fn val -&gt; {val, &quot;New Name&quot;} end)
      end
    end

    test &quot;pop/2 raises error as not implemented&quot;, %{character: character} do
      assert_raise RuntimeError, ~r/pop not implemented/, fn -&gt;
        Character.pop(character, :name)
      end
    end
  end

  describe &quot;has_alliance?/1&quot; do
    test &quot;returns true when alliance data is present&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        alliance_id: 54_321,
        alliance_ticker: &quot;ALLY&quot;
      }

      assert Character.has_alliance?(character) == true
    end

    test &quot;returns false when alliance data is missing&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        alliance_id: nil,
        alliance_ticker: nil
      }

      assert Character.has_alliance?(character) == false
    end

    test &quot;returns false when alliance ticker is empty&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        alliance_id: 54_321,
        alliance_ticker: &quot;&quot;
      }

      assert Character.has_alliance?(character) == false
    end
  end

  describe &quot;has_corporation?/1&quot; do
    test &quot;returns true when corporation data is present&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: 67_890,
        corporation_ticker: &quot;CORP&quot;
      }

      assert Character.has_corporation?(character) == true
    end

    test &quot;returns false when corporation data is missing&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: nil,
        corporation_ticker: nil
      }

      assert Character.has_corporation?(character) == false
    end

    test &quot;returns false when corporation ticker is empty&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: 67_890,
        corporation_ticker: &quot;&quot;
      }

      assert Character.has_corporation?(character) == false
    end
  end

  describe &quot;format_name/1&quot; do
    test &quot;formats name with corporation and alliance&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: 67_890,
        corporation_ticker: &quot;CORP&quot;,
        alliance_id: 54_321,
        alliance_ticker: &quot;ALLY&quot;
      }

      assert Character.format_name(character) == &quot;Test Character [CORP] &lt;ALLY&gt;&quot;
    end

    test &quot;formats name with corporation only&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: 67_890,
        corporation_ticker: &quot;CORP&quot;
      }

      assert Character.format_name(character) == &quot;Test Character [CORP]&quot;
    end

    test &quot;formats name with no corporation or alliance&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;
      }

      assert Character.format_name(character) == &quot;Test Character&quot;
    end

    test &quot;handles nil name&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: nil
      }

      assert Character.format_name(character) == &quot;Unknown Character&quot;
    end
  end

  describe &quot;validate/1&quot; do
    test &quot;returns ok for valid character&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;
      }

      assert {:ok, ^character} = Character.validate(character)
    end

    test &quot;returns error for missing character_id&quot; do
      character = %Character{
        character_id: nil,
        name: &quot;Test Character&quot;
      }

      assert {:error, message} = Character.validate(character)
      assert message =~ &quot;missing required character_id&quot;
    end

    test &quot;returns error for missing name&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: nil
      }

      assert {:error, message} = Character.validate(character)
      assert message =~ &quot;missing required name&quot;
    end
  end

  describe &quot;accessing fields&quot; do
    test &quot;no longer provides eve_id compatibility&quot; do
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;
      }

      # Access protocol with eve_id key should return error
      assert :error = Character.fetch(character, &quot;eve_id&quot;)
      assert nil == Character.get(character, &quot;eve_id&quot;)

      # But character_id always works
      assert character.character_id == &quot;12345&quot;
      assert {:ok, &quot;12345&quot;} = Character.fetch(character, &quot;character_id&quot;)
      assert &quot;12345&quot; == Character.get(character, &quot;character_id&quot;)
    end
  end
end</file><file path="test/wanderer_notifier/data/datetime_util_test.exs">defmodule WandererNotifier.Data.DateTimeUtilTest do
  use ExUnit.Case

  alias WandererNotifier.Data.DateTimeUtil

  describe &quot;parse_datetime/1&quot; do
    test &quot;handles nil value&quot; do
      assert DateTimeUtil.parse_datetime(nil) == nil
    end

    test &quot;handles DateTime struct&quot; do
      dt = DateTime.from_naive!(~N[2023-01-01 12:00:00], &quot;Etc/UTC&quot;)
      assert DateTimeUtil.parse_datetime(dt) == dt
    end

    test &quot;parses valid ISO 8601 string&quot; do
      iso_string = &quot;2023-02-15T08:30:45Z&quot;
      expected = DateTime.from_naive!(~N[2023-02-15 08:30:45], &quot;Etc/UTC&quot;)

      result = DateTimeUtil.parse_datetime(iso_string)

      assert result.year == expected.year
      assert result.month == expected.month
      assert result.day == expected.day
      assert result.hour == expected.hour
      assert result.minute == expected.minute
      assert result.second == expected.second
    end

    test &quot;handles invalid date string&quot; do
      assert DateTimeUtil.parse_datetime(&quot;not a date&quot;) == nil
    end

    test &quot;handles malformed ISO 8601 string&quot; do
      assert DateTimeUtil.parse_datetime(&quot;2023-02-30T25:70:99Z&quot;) == nil
    end

    test &quot;handles non-string, non-DateTime values&quot; do
      assert DateTimeUtil.parse_datetime(123) == nil
      assert DateTimeUtil.parse_datetime(%{}) == nil
      assert DateTimeUtil.parse_datetime([]) == nil
    end
  end
end</file><file path="test/wanderer_notifier/data/killmail_test.exs">defmodule WandererNotifier.Killmail.KillmailTest do
  use ExUnit.Case, async: true
  alias WandererNotifier.Killmail.Killmail

  describe &quot;new/2&quot; do
    test &quot;creates a valid killmail struct with two arguments&quot; do
      killmail = Killmail.new(&quot;12345&quot;, %{&quot;totalValue&quot; =&gt; 1_000_000})
      assert %Killmail{} = killmail
      assert killmail.killmail_id == &quot;12345&quot;
      assert killmail.zkb == %{&quot;totalValue&quot; =&gt; 1_000_000}
      assert killmail.esi_data == nil
    end

    test &quot;creates a valid killmail struct with three arguments&quot; do
      esi_data = %{&quot;solar_system_id&quot; =&gt; 30_000_142}
      killmail = Killmail.new(&quot;12345&quot;, %{&quot;totalValue&quot; =&gt; 1_000_000}, esi_data)
      assert %Killmail{} = killmail
      assert killmail.killmail_id == &quot;12345&quot;
      assert killmail.zkb == %{&quot;totalValue&quot; =&gt; 1_000_000}
      assert killmail.esi_data == esi_data
    end
  end

  describe &quot;from_map/1&quot; do
    test &quot;creates a killmail struct from a map&quot; do
      map = %{
        &quot;killmail_id&quot; =&gt; 123_456_789,
        &quot;zkb&quot; =&gt; %{&quot;hash&quot; =&gt; &quot;abcd1234&quot;, &quot;totalValue&quot; =&gt; 1_000_000.0},
        &quot;esi_data&quot; =&gt; %{
          &quot;victim&quot; =&gt; %{&quot;character_id&quot; =&gt; 98_765, &quot;ship_type_id&quot; =&gt; 12_345},
          &quot;attackers&quot; =&gt; [%{&quot;character_id&quot; =&gt; 54_321, &quot;ship_type_id&quot; =&gt; 67_890}],
          &quot;solar_system_id&quot; =&gt; 30_000_142
        }
      }

      result = Killmail.from_map(map)

      assert %Killmail{} = result
      assert result.killmail_id == 123_456_789
      assert result.zkb == map[&quot;zkb&quot;]
      assert result.esi_data == map[&quot;esi_data&quot;]
    end
  end

  describe &quot;Access behavior&quot; do
    setup do
      esi_data = %{
        &quot;victim&quot; =&gt; %{&quot;character_id&quot; =&gt; 93_847_759, &quot;ship_type_id&quot; =&gt; 33_470},
        &quot;solar_system_id&quot; =&gt; 30_000_142,
        &quot;attackers&quot; =&gt; [
          %{&quot;character_id&quot; =&gt; 95_465_499, &quot;ship_type_id&quot; =&gt; 11_987}
        ]
      }

      zkb_data = %{
        &quot;totalValue&quot; =&gt; 1_000_000_000,
        &quot;points&quot; =&gt; 100
      }

      killmail = Killmail.new(&quot;12345&quot;, zkb_data, esi_data)

      %{killmail: killmail}
    end

    test &quot;allows direct field access via string keys&quot;, %{killmail: killmail} do
      assert killmail[&quot;killmail_id&quot;] == &quot;12345&quot;
      assert killmail[&quot;zkb&quot;] == %{&quot;totalValue&quot; =&gt; 1_000_000_000, &quot;points&quot; =&gt; 100}

      assert killmail[&quot;esi_data&quot;] == %{
               &quot;victim&quot; =&gt; %{&quot;character_id&quot; =&gt; 93_847_759, &quot;ship_type_id&quot; =&gt; 33_470},
               &quot;solar_system_id&quot; =&gt; 30_000_142,
               &quot;attackers&quot; =&gt; [
                 %{&quot;character_id&quot; =&gt; 95_465_499, &quot;ship_type_id&quot; =&gt; 11_987}
               ]
             }
    end

    test &quot;allows access to nested ESI data via string keys&quot;, %{killmail: killmail} do
      assert killmail[&quot;victim&quot;] == %{&quot;character_id&quot; =&gt; 93_847_759, &quot;ship_type_id&quot; =&gt; 33_470}
      assert killmail[&quot;solar_system_id&quot;] == 30_000_142
      assert killmail[&quot;attackers&quot;] == [%{&quot;character_id&quot; =&gt; 95_465_499, &quot;ship_type_id&quot; =&gt; 11_987}]
    end

    test &quot;returns nil for undefined keys&quot;, %{killmail: killmail} do
      assert killmail[&quot;undefined_key&quot;] == nil
    end

    test &quot;get_and_update allows modification of fields&quot;, %{killmail: killmail} do
      {old_value, updated_killmail} =
        Access.get_and_update(killmail, &quot;killmail_id&quot;, fn current -&gt;
          {current, &quot;54321&quot;}
        end)

      assert old_value == &quot;12345&quot;
      assert updated_killmail.killmail_id == &quot;54321&quot;
    end

    test &quot;pop removes a field value&quot;, %{killmail: killmail} do
      {victim, updated_killmail} = Access.pop(killmail, &quot;victim&quot;)

      assert victim == %{&quot;character_id&quot; =&gt; 93_847_759, &quot;ship_type_id&quot; =&gt; 33_470}
      assert updated_killmail[&quot;victim&quot;] == nil
    end
  end

  describe &quot;helper functions&quot; do
    setup do
      esi_data = %{
        &quot;victim&quot; =&gt; %{&quot;character_id&quot; =&gt; 93_847_759, &quot;ship_type_id&quot; =&gt; 33_470},
        &quot;solar_system_id&quot; =&gt; 30_000_142,
        &quot;attackers&quot; =&gt; [
          %{&quot;character_id&quot; =&gt; 95_465_499, &quot;ship_type_id&quot; =&gt; 11_987}
        ]
      }

      zkb_data = %{
        &quot;totalValue&quot; =&gt; 1_000_000_000,
        &quot;points&quot; =&gt; 100
      }

      killmail = Killmail.new(&quot;12345&quot;, zkb_data, esi_data)

      %{killmail: killmail}
    end

    test &quot;get_victim returns victim data&quot;, %{killmail: killmail} do
      assert Killmail.get_victim(killmail) == %{
               &quot;character_id&quot; =&gt; 93_847_759,
               &quot;ship_type_id&quot; =&gt; 33_470
             }
    end

    test &quot;get_attacker returns first attacker&quot;, %{killmail: killmail} do
      assert Killmail.get_attacker(killmail) == [
               %{
                 &quot;character_id&quot; =&gt; 95_465_499,
                 &quot;ship_type_id&quot; =&gt; 11_987
               }
             ]
    end

    test &quot;get_system_id returns solar system ID&quot;, %{killmail: killmail} do
      assert Killmail.get_system_id(killmail) == 30_000_142
    end

    test &quot;from_map creates killmail from map&quot;, %{killmail: killmail} do
      # Convert to map and back
      map = %{
        &quot;killmail_id&quot; =&gt; killmail.killmail_id,
        &quot;zkb&quot; =&gt; killmail.zkb,
        &quot;esi_data&quot; =&gt; killmail.esi_data
      }

      recreated = Killmail.from_map(map)

      assert %Killmail{} = recreated
      assert recreated.killmail_id == killmail.killmail_id
      assert recreated.zkb == killmail.zkb
      assert recreated.esi_data == killmail.esi_data
    end
  end
end</file><file path="test/wanderer_notifier/data/map_util_test.exs">defmodule WandererNotifier.Data.MapUtilTest do
  use ExUnit.Case

  alias WandererNotifier.Data.MapUtil

  describe &quot;get_value/2&quot; do
    test &quot;gets value with string key&quot; do
      map = %{&quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30}
      assert MapUtil.get_value(map, [&quot;name&quot;]) == &quot;John&quot;
      assert MapUtil.get_value(map, [&quot;age&quot;]) == 30
    end

    test &quot;gets value with atom key&quot; do
      map = %{name: &quot;John&quot;, age: 30}
      assert MapUtil.get_value(map, [:name]) == &quot;John&quot;
      assert MapUtil.get_value(map, [:age]) == 30
    end

    test &quot;tries multiple keys until it finds a match&quot; do
      map = %{&quot;user_id&quot; =&gt; 123}
      assert MapUtil.get_value(map, [&quot;id&quot;, &quot;user_id&quot;, :id, :user_id]) == 123

      map = %{user_id: 456}
      assert MapUtil.get_value(map, [&quot;id&quot;, &quot;user_id&quot;, :id, :user_id]) == 456
    end

    test &quot;returns nil when no keys match&quot; do
      map = %{&quot;foo&quot; =&gt; &quot;bar&quot;}
      assert MapUtil.get_value(map, [&quot;name&quot;, :name]) == nil
    end

    test &quot;handles empty map&quot; do
      assert MapUtil.get_value(%{}, [&quot;name&quot;, :name]) == nil
    end
  end

  describe &quot;extract_to_struct/3&quot; do
    defmodule TestStruct do
      defstruct [:name, :age, :location]
    end

    test &quot;extracts values into a struct using specified mappings&quot; do
      map = %{&quot;name&quot; =&gt; &quot;john&quot;, &quot;user_age&quot; =&gt; 30, &quot;city&quot; =&gt; &quot;New York&quot;}
      mappings = [name: [&quot;name&quot;], age: [&quot;user_age&quot;], location: [&quot;city&quot;]]

      result = MapUtil.extract_to_struct(map, TestStruct, mappings)

      assert %TestStruct{name: &quot;john&quot;, age: 30, location: &quot;New York&quot;} = result
    end

    test &quot;returns default values when keys are not found&quot; do
      map = %{&quot;user_age&quot; =&gt; 30}
      mappings = [name: [&quot;name&quot;], age: [&quot;user_age&quot;], location: [&quot;city&quot;]]

      result = MapUtil.extract_to_struct(map, TestStruct, mappings)

      assert %TestStruct{name: nil, age: 30, location: nil} = result
    end
  end

  describe &quot;extract_map/2&quot; do
    test &quot;extracts values into a map using mappings&quot; do
      map = %{
        &quot;name&quot; =&gt; &quot;John&quot;,
        &quot;years&quot; =&gt; 30,
        &quot;email_address&quot; =&gt; &quot;john@example.com&quot;
      }

      mappings = [
        {:name, [&quot;name&quot;, :name]},
        {:age, [&quot;age&quot;, &quot;years&quot;, :age, :years]},
        {:email, [&quot;email&quot;, &quot;email_address&quot;, :email, :email_address]}
      ]

      result = MapUtil.extract_map(map, mappings)

      assert is_map(result)
      assert result.name == &quot;John&quot;
      assert result.age == 30
      assert result.email == &quot;john@example.com&quot;
    end

    test &quot;uses default values when keys are not found&quot; do
      map = %{&quot;name&quot; =&gt; &quot;John&quot;}

      mappings = [
        {:name, [&quot;name&quot;]},
        {:age, [&quot;age&quot;], 0},
        {:email, [&quot;email&quot;], &quot;no-email@example.com&quot;}
      ]

      result = MapUtil.extract_map(map, mappings)

      assert is_map(result)
      assert result.name == &quot;John&quot;
      assert result.age == 0
      assert result.email == &quot;no-email@example.com&quot;
    end
  end

  describe &quot;atomize_keys/2&quot; do
    test &quot;converts string keys to atom keys&quot; do
      map = %{&quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30}
      result = MapUtil.atomize_keys(map)

      assert result == %{name: &quot;John&quot;, age: 30}
    end

    test &quot;keeps existing atom keys&quot; do
      map = %{&quot;name&quot; =&gt; &quot;John&quot;, age: 30}
      result = MapUtil.atomize_keys(map)

      assert result == %{name: &quot;John&quot;, age: 30}
    end

    test &quot;recursively converts nested maps when option is set&quot; do
      map = %{
        &quot;user&quot; =&gt; %{
          &quot;name&quot; =&gt; &quot;John&quot;,
          &quot;address&quot; =&gt; %{&quot;city&quot; =&gt; &quot;New York&quot;}
        }
      }

      result = MapUtil.atomize_keys(map, recursive: true)

      assert result == %{
               user: %{
                 name: &quot;John&quot;,
                 address: %{city: &quot;New York&quot;}
               }
             }
    end

    test &quot;does not recursively convert by default&quot; do
      map = %{
        &quot;user&quot; =&gt; %{
          &quot;name&quot; =&gt; &quot;John&quot;
        }
      }

      result = MapUtil.atomize_keys(map)

      assert result == %{
               user: %{
                 &quot;name&quot; =&gt; &quot;John&quot;
               }
             }
    end
  end
end</file><file path="test/wanderer_notifier/data/system_test.exs">defmodule WandererNotifier.Data.SystemTest do
  use ExUnit.Case, async: true
  alias WandererNotifier.Data.System

  describe &quot;new/1&quot; do
    test &quot;creates a new system from a map&quot; do
      attrs = %{
        system_id: 31_000_001,
        system_name: &quot;J123456&quot;,
        security_status: -0.99,
        region_id: 10_000_001,
        region_name: &quot;Deklein&quot;,
        constellation_id: 20_000_001,
        constellation_name: &quot;Test Constellation&quot;,
        effect: &quot;Wolf-Rayet&quot;,
        type: &quot;C6&quot;,
        tracked: true,
        tracked_since: DateTime.utc_now()
      }

      result = System.new(attrs)

      assert %System{} = result
      assert result.system_id == 31_000_001
      assert result.system_name == &quot;J123456&quot;
      assert result.security_status == -0.99
      assert result.region_id == 10_000_001
      assert result.region_name == &quot;Deklein&quot;
      assert result.constellation_id == 20_000_001
      assert result.constellation_name == &quot;Test Constellation&quot;
      assert result.effect == &quot;Wolf-Rayet&quot;
      assert result.type == &quot;C6&quot;
      assert result.tracked == true
      assert %DateTime{} = result.tracked_since
    end

    test &quot;creates a new system from keyword list&quot; do
      now = DateTime.utc_now()

      attrs = [
        system_id: 31_000_002,
        system_name: &quot;J987654&quot;,
        security_status: -0.75,
        tracked: true,
        tracked_since: now
      ]

      result = System.new(attrs)

      assert %System{} = result
      assert result.system_id == 31_000_002
      assert result.system_name == &quot;J987654&quot;
      assert result.security_status == -0.75
      assert result.tracked == true
      assert result.tracked_since == now
      # Default values
      assert result.region_id == nil
      assert result.effect == nil
    end
  end

  describe &quot;from_map/1&quot; do
    test &quot;converts a map with string keys to System struct&quot; do
      map = %{
        &quot;system_id&quot; =&gt; 31_000_003,
        &quot;system_name&quot; =&gt; &quot;J555555&quot;,
        &quot;security_status&quot; =&gt; -1.0,
        &quot;region_id&quot; =&gt; 10_000_002,
        &quot;region_name&quot; =&gt; &quot;Catch&quot;,
        &quot;constellation_id&quot; =&gt; 20_000_002,
        &quot;constellation_name&quot; =&gt; &quot;Some Constellation&quot;,
        &quot;effect&quot; =&gt; &quot;Cataclysmic Variable&quot;,
        &quot;type&quot; =&gt; &quot;C5&quot;,
        &quot;tracked&quot; =&gt; true,
        &quot;tracked_since&quot; =&gt; &quot;2023-07-15T12:30:45Z&quot;
      }

      result = System.from_map(map)

      assert %System{} = result
      assert result.system_id == 31_000_003
      assert result.system_name == &quot;J555555&quot;
      assert result.security_status == -1.0
      assert result.region_id == 10_000_002
      assert result.region_name == &quot;Catch&quot;
      assert result.constellation_id == 20_000_002
      assert result.constellation_name == &quot;Some Constellation&quot;
      assert result.effect == &quot;Cataclysmic Variable&quot;
      assert result.type == &quot;C5&quot;
      assert result.tracked == true
      assert %DateTime{} = result.tracked_since
      assert result.tracked_since.year == 2023
      assert result.tracked_since.month == 7
      assert result.tracked_since.day == 15
    end

    test &quot;converts a map with atom keys to System struct&quot; do
      map = %{
        system_id: 31_000_004,
        system_name: &quot;J111111&quot;,
        security_status: -0.8,
        tracked: false
      }

      result = System.from_map(map)

      assert %System{} = result
      assert result.system_id == 31_000_004
      assert result.system_name == &quot;J111111&quot;
      assert result.security_status == -0.8
      assert result.tracked == false
      assert result.tracked_since == nil
    end

    test &quot;handles missing values with defaults&quot; do
      map = %{
        &quot;system_id&quot; =&gt; 31_000_005,
        &quot;system_name&quot; =&gt; &quot;J222222&quot;
      }

      result = System.from_map(map)

      assert %System{} = result
      assert result.system_id == 31_000_005
      assert result.system_name == &quot;J222222&quot;
      assert result.security_status == nil
      assert result.tracked == false
      assert result.tracked_since == nil
    end

    test &quot;handles DateTime objects in tracked_since&quot; do
      now = DateTime.utc_now()

      map = %{
        &quot;system_id&quot; =&gt; 31_000_006,
        &quot;system_name&quot; =&gt; &quot;J333333&quot;,
        &quot;tracked&quot; =&gt; true,
        &quot;tracked_since&quot; =&gt; now
      }

      result = System.from_map(map)

      assert %System{} = result
      assert result.tracked_since == now
    end
  end

  describe &quot;parse_datetime/1&quot; do
    test &quot;delegates to DateTimeUtil.parse_datetime/1&quot; do
      # This is a simple test to verify delegation works
      assert System.parse_datetime(nil) == nil
      assert System.parse_datetime(&quot;invalid&quot;) == nil

      valid_dt = &quot;2023-08-20T15:30:45Z&quot;
      parsed = System.parse_datetime(valid_dt)
      assert %DateTime{} = parsed
      assert parsed.year == 2023
      assert parsed.month == 8
      assert parsed.day == 20
    end
  end
end</file><file path="test/wanderer_notifier/esi/entities_test.exs">defmodule WandererNotifier.ESI.EntitiesTest do
  use ExUnit.Case, async: true
  alias WandererNotifier.ESI.Entities.{Character, Corporation, Alliance, SolarSystem}

  describe &quot;Character entity&quot; do
    test &quot;creates Character struct from ESI data&quot; do
      # Sample ESI character data
      character_data = %{
        &quot;character_id&quot; =&gt; 123_456,
        &quot;name&quot; =&gt; &quot;Test Character&quot;,
        &quot;corporation_id&quot; =&gt; 789_012,
        &quot;alliance_id&quot; =&gt; 345_678,
        &quot;security_status&quot; =&gt; 0.5,
        &quot;birthday&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;
      }

      # Create Character struct
      character = Character.from_esi_data(character_data)

      # Verify fields
      assert character.character_id == 123_456
      assert character.name == &quot;Test Character&quot;
      assert character.corporation_id == 789_012
      assert character.alliance_id == 345_678
      assert character.security_status == 0.5
      assert character.birthday == ~U[2020-01-01 00:00:00Z]
    end

    test &quot;converts Character struct to map&quot; do
      # Create Character struct
      character = %Character{
        character_id: 123_456,
        name: &quot;Test Character&quot;,
        corporation_id: 789_012,
        alliance_id: 345_678,
        security_status: 0.5,
        birthday: ~U[2020-01-01 00:00:00Z]
      }

      # Convert to map
      map = Character.to_map(character)

      # Verify fields
      assert map[&quot;character_id&quot;] == 123_456
      assert map[&quot;name&quot;] == &quot;Test Character&quot;
      assert map[&quot;corporation_id&quot;] == 789_012
      assert map[&quot;alliance_id&quot;] == 345_678
      assert map[&quot;security_status&quot;] == 0.5
      assert map[&quot;birthday&quot;] == &quot;2020-01-01T00:00:00Z&quot;
    end

    test &quot;handles nil values gracefully&quot; do
      # Sample ESI character data with nil values
      character_data = %{
        &quot;character_id&quot; =&gt; 123_456,
        &quot;name&quot; =&gt; &quot;Test Character&quot;,
        &quot;corporation_id&quot; =&gt; 789_012
      }

      # Create Character struct
      character = Character.from_esi_data(character_data)

      # Verify fields
      assert character.character_id == 123_456
      assert character.name == &quot;Test Character&quot;
      assert character.corporation_id == 789_012
      assert character.alliance_id == nil
      assert character.security_status == nil
      assert character.birthday == nil
    end
  end

  describe &quot;Corporation entity&quot; do
    test &quot;creates Corporation struct from ESI data&quot; do
      # Sample ESI corporation data
      corporation_data = %{
        &quot;corporation_id&quot; =&gt; 789_012,
        &quot;name&quot; =&gt; &quot;Test Corporation&quot;,
        &quot;ticker&quot; =&gt; &quot;TSTC&quot;,
        &quot;member_count&quot; =&gt; 100,
        &quot;alliance_id&quot; =&gt; 345_678,
        &quot;description&quot; =&gt; &quot;A test corporation&quot;,
        &quot;date_founded&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;
      }

      # Create Corporation struct
      corporation = Corporation.from_esi_data(corporation_data)

      # Verify fields
      assert corporation.corporation_id == 789_012
      assert corporation.name == &quot;Test Corporation&quot;
      assert corporation.ticker == &quot;TSTC&quot;
      assert corporation.member_count == 100
      assert corporation.alliance_id == 345_678
      assert corporation.description == &quot;A test corporation&quot;
      assert corporation.founding_date == ~U[2020-01-01 00:00:00Z]
    end

    test &quot;converts Corporation struct to map&quot; do
      # Create Corporation struct
      corporation = %Corporation{
        corporation_id: 789_012,
        name: &quot;Test Corporation&quot;,
        ticker: &quot;TSTC&quot;,
        member_count: 100,
        alliance_id: 345_678,
        description: &quot;A test corporation&quot;,
        founding_date: ~U[2020-01-01 00:00:00Z]
      }

      # Convert to map
      map = Corporation.to_map(corporation)

      # Verify fields
      assert map[&quot;corporation_id&quot;] == 789_012
      assert map[&quot;name&quot;] == &quot;Test Corporation&quot;
      assert map[&quot;ticker&quot;] == &quot;TSTC&quot;
      assert map[&quot;member_count&quot;] == 100
      assert map[&quot;alliance_id&quot;] == 345_678
      assert map[&quot;description&quot;] == &quot;A test corporation&quot;
      assert map[&quot;date_founded&quot;] == &quot;2020-01-01T00:00:00Z&quot;
    end
  end

  describe &quot;Alliance entity&quot; do
    test &quot;creates Alliance struct from ESI data&quot; do
      # Sample ESI alliance data
      alliance_data = %{
        &quot;alliance_id&quot; =&gt; 345_678,
        &quot;name&quot; =&gt; &quot;Test Alliance&quot;,
        &quot;ticker&quot; =&gt; &quot;TSTA&quot;,
        &quot;executor_corporation_id&quot; =&gt; 789_012,
        &quot;creator_id&quot; =&gt; 123_456,
        &quot;date_founded&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;,
        &quot;faction_id&quot; =&gt; 555_555
      }

      # Create Alliance struct
      alliance = Alliance.from_esi_data(alliance_data)

      # Verify fields
      assert alliance.alliance_id == 345_678
      assert alliance.name == &quot;Test Alliance&quot;
      assert alliance.ticker == &quot;TSTA&quot;
      assert alliance.executor_corporation_id == 789_012
      assert alliance.creator_id == 123_456
      assert alliance.creation_date == ~U[2020-01-01 00:00:00Z]
      assert alliance.faction_id == 555_555
    end

    test &quot;converts Alliance struct to map&quot; do
      # Create Alliance struct
      alliance = %Alliance{
        alliance_id: 345_678,
        name: &quot;Test Alliance&quot;,
        ticker: &quot;TSTA&quot;,
        executor_corporation_id: 789_012,
        creator_id: 123_456,
        creation_date: ~U[2020-01-01 00:00:00Z],
        faction_id: 555_555
      }

      # Convert to map
      map = Alliance.to_map(alliance)

      # Verify fields
      assert map[&quot;alliance_id&quot;] == 345_678
      assert map[&quot;name&quot;] == &quot;Test Alliance&quot;
      assert map[&quot;ticker&quot;] == &quot;TSTA&quot;
      assert map[&quot;executor_corporation_id&quot;] == 789_012
      assert map[&quot;creator_id&quot;] == 123_456
      assert map[&quot;date_founded&quot;] == &quot;2020-01-01T00:00:00Z&quot;
      assert map[&quot;faction_id&quot;] == 555_555
    end
  end

  describe &quot;SolarSystem entity&quot; do
    test &quot;creates SolarSystem struct from ESI data&quot; do
      # Sample ESI solar system data
      system_data = %{
        &quot;system_id&quot; =&gt; 30_000_142,
        &quot;name&quot; =&gt; &quot;Jita&quot;,
        &quot;constellation_id&quot; =&gt; 20_000_020,
        &quot;security_status&quot; =&gt; 0.9,
        &quot;security_class&quot; =&gt; &quot;B&quot;,
        &quot;position&quot; =&gt; %{&quot;x&quot; =&gt; 1.0, &quot;y&quot; =&gt; 2.0, &quot;z&quot; =&gt; 3.0},
        &quot;star_id&quot; =&gt; 40_000_001,
        &quot;planets&quot; =&gt; [%{&quot;planet_id&quot; =&gt; 50_000_001}],
        &quot;region_id&quot; =&gt; 10_000_002
      }

      # Create SolarSystem struct
      system = SolarSystem.from_esi_data(system_data)

      # Verify fields
      assert system.system_id == 30_000_142
      assert system.name == &quot;Jita&quot;
      assert system.constellation_id == 20_000_020
      assert system.security_status == 0.9
      assert system.security_class == &quot;B&quot;
      assert system.position == %{x: 1.0, y: 2.0, z: 3.0}
      assert system.star_id == 40_000_001
      assert system.planets == [%{&quot;planet_id&quot; =&gt; 50_000_001}]
      assert system.region_id == 10_000_002
    end

    test &quot;converts SolarSystem struct to map&quot; do
      # Create SolarSystem struct
      system = %SolarSystem{
        system_id: 30_000_142,
        name: &quot;Jita&quot;,
        constellation_id: 20_000_020,
        security_status: 0.9,
        security_class: &quot;B&quot;,
        position: %{x: 1.0, y: 2.0, z: 3.0},
        star_id: 40_000_001,
        planets: [%{&quot;planet_id&quot; =&gt; 50_000_001}],
        region_id: 10_000_002
      }

      # Convert to map
      map = SolarSystem.to_map(system)

      # Verify fields
      assert map[&quot;system_id&quot;] == 30_000_142
      assert map[&quot;name&quot;] == &quot;Jita&quot;
      assert map[&quot;constellation_id&quot;] == 20_000_020
      assert map[&quot;security_status&quot;] == 0.9
      assert map[&quot;security_class&quot;] == &quot;B&quot;
      assert map[&quot;position&quot;] == %{&quot;x&quot; =&gt; 1.0, &quot;y&quot; =&gt; 2.0, &quot;z&quot; =&gt; 3.0}
      assert map[&quot;star_id&quot;] == 40_000_001
      assert map[&quot;planets&quot;] == [%{&quot;planet_id&quot; =&gt; 50_000_001}]
      assert map[&quot;region_id&quot;] == 10_000_002
    end

    test &quot;calculates security band correctly&quot; do
      high_sec = %SolarSystem{security_status: 0.5}
      low_sec = %SolarSystem{security_status: 0.4}
      null_sec = %SolarSystem{security_status: 0.0}
      unknown = %SolarSystem{security_status: nil}

      assert SolarSystem.security_band(high_sec) == &quot;High&quot;
      assert SolarSystem.security_band(low_sec) == &quot;Low&quot;
      assert SolarSystem.security_band(null_sec) == &quot;Null&quot;
      assert SolarSystem.security_band(unknown) == &quot;Unknown&quot;

      # Direct value tests
      assert SolarSystem.security_band(1.0) == &quot;High&quot;
      assert SolarSystem.security_band(0.5) == &quot;High&quot;
      assert SolarSystem.security_band(0.4) == &quot;Low&quot;
      assert SolarSystem.security_band(0.1) == &quot;Low&quot;
      assert SolarSystem.security_band(0.0) == &quot;Null&quot;
      assert SolarSystem.security_band(-0.1) == &quot;Null&quot;
    end
  end
end</file><file path="test/wanderer_notifier/esi/service_test.exs">defmodule WandererNotifier.ESI.ServiceTest do
  use ExUnit.Case, async: true
  import Mox

  alias WandererNotifier.ESI.Service
  alias WandererNotifier.ESI.Entities.{Character, Corporation, Alliance, SolarSystem}
  alias WandererNotifier.Cache.Repository, as: CacheRepo

  # Make sure mocks are verified after each test
  setup :verify_on_exit!

  # Stub the Client module
  setup do
    # Mock the ESI client
    Application.put_env(:wanderer_notifier, :http_client, WandererNotifier.HttpClient.Httpoison)

    # Setup for character tests
    character_data = %{
      &quot;character_id&quot; =&gt; 123_456,
      &quot;name&quot; =&gt; &quot;Test Character&quot;,
      &quot;corporation_id&quot; =&gt; 789_012,
      &quot;alliance_id&quot; =&gt; 345_678,
      &quot;security_status&quot; =&gt; 0.5,
      &quot;birthday&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;
    }

    corporation_data = %{
      &quot;corporation_id&quot; =&gt; 789_012,
      &quot;name&quot; =&gt; &quot;Test Corporation&quot;,
      &quot;ticker&quot; =&gt; &quot;TSTC&quot;,
      &quot;member_count&quot; =&gt; 100,
      &quot;alliance_id&quot; =&gt; 345_678,
      &quot;description&quot; =&gt; &quot;A test corporation&quot;,
      &quot;date_founded&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;
    }

    alliance_data = %{
      &quot;alliance_id&quot; =&gt; 345_678,
      &quot;name&quot; =&gt; &quot;Test Alliance&quot;,
      &quot;ticker&quot; =&gt; &quot;TSTA&quot;,
      &quot;executor_corporation_id&quot; =&gt; 789_012,
      &quot;creator_id&quot; =&gt; 123_456,
      &quot;date_founded&quot; =&gt; &quot;2020-01-01T00:00:00Z&quot;,
      &quot;faction_id&quot; =&gt; 555_555
    }

    system_data = %{
      &quot;system_id&quot; =&gt; 30_000_142,
      &quot;name&quot; =&gt; &quot;Jita&quot;,
      &quot;constellation_id&quot; =&gt; 20_000_020,
      &quot;security_status&quot; =&gt; 0.9,
      &quot;security_class&quot; =&gt; &quot;B&quot;,
      &quot;position&quot; =&gt; %{&quot;x&quot; =&gt; 1.0, &quot;y&quot; =&gt; 2.0, &quot;z&quot; =&gt; 3.0},
      &quot;star_id&quot; =&gt; 40_000_001,
      &quot;planets&quot; =&gt; [%{&quot;planet_id&quot; =&gt; 50_000_001}],
      &quot;region_id&quot; =&gt; 10_000_002
    }

    # Define mocks for ESI client calls
    stub(WandererNotifier.ESI.Client, :get_character_info, fn 123_456, _opts -&gt;
      {:ok, character_data}
    end)

    stub(WandererNotifier.ESI.Client, :get_corporation_info, fn 789_012, _opts -&gt;
      {:ok, corporation_data}
    end)

    stub(WandererNotifier.ESI.Client, :get_alliance_info, fn 345_678, _opts -&gt;
      {:ok, alliance_data}
    end)

    stub(WandererNotifier.ESI.Client, :get_solar_system, fn 30_000_142, _opts -&gt;
      {:ok, system_data}
    end)

    # Return test data for use in tests
    %{
      character_data: character_data,
      corporation_data: corporation_data,
      alliance_data: alliance_data,
      system_data: system_data
    }
  end

  describe &quot;get_character_struct/2&quot; do
    test &quot;returns a Character struct when successful&quot;, %{character_data: character_data} do
      # Ensure cache is empty for this test
      CacheRepo.delete(&quot;character:123456&quot;)

      # Get character struct from ESI service
      {:ok, character} = Service.get_character_struct(123_456)

      # Verify that it&apos;s a Character struct with the correct data
      assert %Character{} = character
      assert character.character_id == 123_456
      assert character.name == &quot;Test Character&quot;
      assert character.corporation_id == 789_012
      assert character.alliance_id == 345_678
      assert character.security_status == 0.5
      assert character.birthday == ~U[2020-01-01 00:00:00Z]
    end

    test &quot;uses cached data when available&quot;, %{character_data: character_data} do
      # Ensure the character is in the cache
      CacheRepo.put(&quot;character:123456&quot;, character_data)

      # Stub the client to return an error, to verify we&apos;re using the cache
      stub(WandererNotifier.ESI.Client, :get_character_info, fn _, _ -&gt;
        {:error, &quot;Should not be called&quot;}
      end)

      # Get character struct from ESI service
      {:ok, character} = Service.get_character_struct(123_456)

      # Verify that it&apos;s a Character struct with the correct data
      assert %Character{} = character
      assert character.character_id == 123_456
      assert character.name == &quot;Test Character&quot;
    end
  end

  describe &quot;get_corporation_struct/2&quot; do
    test &quot;returns a Corporation struct when successful&quot;, %{corporation_data: corporation_data} do
      # Ensure cache is empty for this test
      CacheRepo.delete(&quot;corporation:789012&quot;)

      # Get corporation struct from ESI service
      {:ok, corporation} = Service.get_corporation_struct(789_012)

      # Verify that it&apos;s a Corporation struct with the correct data
      assert %Corporation{} = corporation
      assert corporation.corporation_id == 789_012
      assert corporation.name == &quot;Test Corporation&quot;
      assert corporation.ticker == &quot;TSTC&quot;
      assert corporation.member_count == 100
      assert corporation.alliance_id == 345_678
      assert corporation.description == &quot;A test corporation&quot;
      assert corporation.founding_date == ~U[2020-01-01 00:00:00Z]
    end
  end

  describe &quot;get_alliance_struct/2&quot; do
    test &quot;returns an Alliance struct when successful&quot;, %{alliance_data: alliance_data} do
      # Ensure cache is empty for this test
      CacheRepo.delete(&quot;alliance:345678&quot;)

      # Get alliance struct from ESI service
      {:ok, alliance} = Service.get_alliance_struct(345_678)

      # Verify that it&apos;s an Alliance struct with the correct data
      assert %Alliance{} = alliance
      assert alliance.alliance_id == 345_678
      assert alliance.name == &quot;Test Alliance&quot;
      assert alliance.ticker == &quot;TSTA&quot;
      assert alliance.executor_corporation_id == 789_012
      assert alliance.creator_id == 123_456
      assert alliance.creation_date == ~U[2020-01-01 00:00:00Z]
      assert alliance.faction_id == 555_555
    end
  end

  describe &quot;get_system_struct/2&quot; do
    test &quot;returns a SolarSystem struct when successful&quot;, %{system_data: system_data} do
      # Ensure cache is empty for this test
      CacheRepo.delete(&quot;system:30000142&quot;)

      # Get solar system struct from ESI service
      {:ok, system} = Service.get_system_struct(30_000_142)

      # Verify that it&apos;s a SolarSystem struct with the correct data
      assert %SolarSystem{} = system
      assert system.system_id == 30_000_142
      assert system.name == &quot;Jita&quot;
      assert system.constellation_id == 20_000_020
      assert system.security_status == 0.9
      assert system.security_class == &quot;B&quot;
      assert system.position == %{x: 1.0, y: 2.0, z: 3.0}
      assert system.star_id == 40_000_001
      assert system.planets == [%{&quot;planet_id&quot; =&gt; 50_000_001}]
      assert system.region_id == 10_000_002
    end
  end
end</file><file path="test/wanderer_notifier/helpers/deduplication_helper_test.exs">defmodule WandererNotifier.Helpers.DeduplicationHelperTest do
  use ExUnit.Case, async: false
  require Logger

  alias WandererNotifier.Notifiers.Helpers.Deduplication, as: DeduplicationHelper

  setup do
    # First clear any existing data to ensure tests start with a clean state
    try do
      DeduplicationHelper.clear_all()
    rescue
      _ -&gt; :ok
    end

    # Only start the process if it&apos;s not already running
    if !Process.whereis(DeduplicationHelper) do
      start_supervised!(DeduplicationHelper)
    end

    :ok
  end

  test &quot;check_and_mark/1 marks entries as seen&quot; do
    test_key = &quot;test:key&quot;

    # First check should return {:ok, :new} (not seen)
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)

    # Second check should return {:ok, :duplicate} (already seen)
    assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(test_key)
  end

  test &quot;check_and_mark/1 entries expire after TTL&quot; do
    test_key = &quot;test:ttl_expire&quot;

    # First check should return {:ok, :new} (not seen)
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)

    # Clear the key directly (simulating TTL expiry)
    :ok = DeduplicationHelper.handle_clear_key(test_key)

    # After clearing, should return {:ok, :new} again
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)
  end

  test &quot;check_and_mark/1 handles different keys independently&quot; do
    key1 = &quot;test:key1&quot;
    key2 = &quot;test:key2&quot;

    # First key should not be seen
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(key1)

    # Second key should also not be seen
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(key2)

    # First key should now be seen
    assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(key1)

    # Second key should also be seen
    assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(key2)
  end

  describe &quot;check_and_mark_system/1&quot; do
    test &quot;handles integer system IDs&quot; do
      system_id = 31_000_001
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(system_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_system(system_id)
    end

    test &quot;handles string system IDs&quot; do
      system_id = &quot;31_000_002&quot;
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(system_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_system(system_id)
    end

    test &quot;different system IDs are tracked separately&quot; do
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(31_000_003)
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(31_000_004)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_system(31_000_003)
    end
  end

  describe &quot;check_and_mark_character/1&quot; do
    test &quot;handles integer character IDs&quot; do
      character_id = 12_345
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_character(character_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_character(character_id)
    end

    test &quot;handles string character IDs&quot; do
      character_id = &quot;67890&quot;
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_character(character_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_character(character_id)
    end
  end

  describe &quot;check_and_mark_kill/1&quot; do
    test &quot;handles integer kill IDs&quot; do
      kill_id = 123_456_789
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_kill(kill_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_kill(kill_id)
    end

    test &quot;handles string kill IDs&quot; do
      kill_id = &quot;987_654_321&quot;
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_kill(kill_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_kill(kill_id)
    end
  end

  describe &quot;clear_all/0&quot; do
    test &quot;clears all deduplication entries&quot; do
      # Mark some entries
      DeduplicationHelper.check_and_mark(&quot;test:clear1&quot;)
      DeduplicationHelper.check_and_mark_system(30_000_142)
      DeduplicationHelper.check_and_mark_character(12_345)
      DeduplicationHelper.check_and_mark_kill(123_456_789)

      # They should all be duplicates
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(&quot;test:clear1&quot;)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_system(30_000_142)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_character(12_345)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_kill(123_456_789)

      # Clear all entries
      :ok = DeduplicationHelper.clear_all()

      # Now they should all be new again
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(&quot;test:clear1&quot;)
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(30_000_142)
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_character(12_345)
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_kill(123_456_789)
    end
  end

  describe &quot;handle_clear_key/1&quot; do
    test &quot;clears a specific key&quot; do
      # Mark a key
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(&quot;test:expire&quot;)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(&quot;test:expire&quot;)

      # Manually clear the key
      :ok = DeduplicationHelper.handle_clear_key(&quot;test:expire&quot;)

      # It should be new again
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(&quot;test:expire&quot;)
    end
  end

  describe &quot;TTL and expiration&quot; do
    test &quot;entries can be manually expired&quot; do
      test_key = &quot;test:manual_expire&quot;

      # Mark the key
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(test_key)

      # Manually clear the key
      :ok = DeduplicationHelper.handle_clear_key(test_key)

      # Should be new again
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)
    end

    test &quot;clearing all entries removes all deduplication data&quot; do
      keys = [&quot;test:clear1&quot;, &quot;test:clear2&quot;, &quot;test:clear3&quot;]

      # Mark all keys
      Enum.each(keys, fn key -&gt;
        assert {:ok, :new} = DeduplicationHelper.check_and_mark(key)
      end)

      # Verify they&apos;re all marked
      Enum.each(keys, fn key -&gt;
        assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(key)
      end)

      # Clear all entries
      :ok = DeduplicationHelper.clear_all()

      # Verify they&apos;re all new again
      Enum.each(keys, fn key -&gt;
        assert {:ok, :new} = DeduplicationHelper.check_and_mark(key)
      end)
    end
  end
end</file><file path="test/wanderer_notifier/helpers/sample_test.exs">defmodule WandererNotifier.Helpers.SampleTest do
  use ExUnit.Case

  test &quot;basic assertion works&quot; do
    assert 1 + 1 == 2
  end
end</file><file path="test/wanderer_notifier/http/http_test.exs">defmodule WandererNotifier.HttpTest do
  use ExUnit.Case
  import Mox

  setup :verify_on_exit!

  test &quot;mocks HTTP client successfully&quot; do
    # Set up mock expectation
    WandererNotifier.MockHTTP
    |&gt; expect(:get, fn _url, _headers, _options -&gt;
      {:ok, %{status: 200, body: %{&quot;message&quot; =&gt; &quot;Test successful&quot;}, headers: []}}
    end)

    # Verify that the mock works when called
    result = WandererNotifier.MockHTTP.get(&quot;https://example.com&quot;, [], [])

    # Assert the result matches our expectation
    assert {:ok, %{status: 200, body: %{&quot;message&quot; =&gt; &quot;Test successful&quot;}}} = result
  end
end</file><file path="test/wanderer_notifier/notifiers/discord/notifier_test.exs">defmodule WandererNotifier.Notifiers.Discord.NotifierTest do
  use ExUnit.Case, async: false
  import ExUnit.CaptureLog
  require Logger

  alias WandererNotifier.Config.Application
  alias WandererNotifier.Killmail.Killmail
  alias WandererNotifier.Notifiers.Discord.Notifier

  setup do
    previous_env = Application.get_env(:wanderer_notifier, :env)
    previous_log_level = Logger.level()

    Application.put_env(:wanderer_notifier, :env, :test)
    Logger.configure(level: :info)

    on_exit(fn -&gt;
      Application.put_env(:wanderer_notifier, :env, previous_env)
      Logger.configure(level: previous_log_level)
    end)

    {:ok, %{previous_env: previous_env, previous_log_level: previous_log_level}}
  end

  describe &quot;send_message/2&quot; do
    test &quot;handles basic message in test mode&quot; do
      # Use a more direct approach to ensure we capture the log
      assert capture_log(fn -&gt;
               assert :ok = Notifier.send_message(&quot;Test message&quot;)
             end) =~ &quot;DISCORD MOCK: Test message&quot;
    end
  end

  describe &quot;send_embed/4&quot; do
    test &quot;handles basic embed in test mode&quot; do
      # Use a more direct approach to ensure we capture the log
      assert capture_log(fn -&gt;
               assert :ok =
                        Notifier.send_embed(
                          &quot;Test Title&quot;,
                          &quot;Test Description&quot;,
                          &quot;https://example.com&quot;
                        )
             end) =~ &quot;DISCORD MOCK: Test Title - Test Description&quot;
    end
  end

  describe &quot;Killmail.new usage&quot; do
    test &quot;properly creates a killmail struct from map data&quot; do
      # Test data matching what would be in the notifier
      killmail_id = &quot;12345&quot;
      zkb_data = %{&quot;totalValue&quot; =&gt; 1_000_000_000, &quot;points&quot; =&gt; 100}

      # Create a killmail using the signature we expect
      killmail = Killmail.new(killmail_id, zkb_data)

      # Validate the struct is properly created
      assert %Killmail{} = killmail
      assert killmail.killmail_id == killmail_id
      assert killmail.zkb == zkb_data
      assert killmail.esi_data == nil
    end

    test &quot;properly handles with three parameters&quot; do
      # Test data matching what would be in the notifier
      killmail_id = &quot;12345&quot;
      zkb_data = %{&quot;totalValue&quot; =&gt; 1_000_000_000, &quot;points&quot; =&gt; 100}
      esi_data = %{&quot;solar_system_id&quot; =&gt; 30_000_142, &quot;victim&quot; =&gt; %{&quot;ship_type_id&quot; =&gt; 123}}

      # Create a killmail using all three parameters
      killmail = Killmail.new(killmail_id, zkb_data, esi_data)

      # Validate the struct is properly created
      assert %Killmail{} = killmail
      assert killmail.killmail_id == killmail_id
      assert killmail.zkb == zkb_data
      assert killmail.esi_data == esi_data
    end
  end
end</file><file path="test/wanderer_notifier/notifiers/helpers/deduplication_test.exs">defmodule WandererNotifier.Notifiers.Helpers.DeduplicationTest do
  use ExUnit.Case, async: false
  require Logger

  alias WandererNotifier.Notifiers.Helpers.Deduplication, as: DeduplicationHelper

  setup do
    # Clear all deduplication entries before each test
    DeduplicationHelper.clear_all()
    :ok
  end

  test &quot;check_and_mark/1 marks entries as seen&quot; do
    test_key = &quot;test:key&quot;

    # First check should return {:ok, :new} (not seen)
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)

    # Second check should return {:ok, :duplicate} (already seen)
    assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(test_key)
  end

  test &quot;check_and_mark/1 entries expire after TTL&quot; do
    test_key = &quot;test:ttl_expire&quot;

    # First check should return {:ok, :new} (not seen)
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)

    # Clear the key directly (simulating TTL expiry)
    :ok = DeduplicationHelper.handle_clear_key(test_key)

    # After clearing, should return {:ok, :new} again
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)
  end

  test &quot;check_and_mark/1 handles different keys independently&quot; do
    key1 = &quot;test:key1&quot;
    key2 = &quot;test:key2&quot;

    # First key should not be seen
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(key1)

    # Second key should also not be seen
    assert {:ok, :new} = DeduplicationHelper.check_and_mark(key2)

    # First key should now be seen
    assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(key1)

    # Second key should also be seen
    assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(key2)
  end

  describe &quot;check_and_mark_system/1&quot; do
    test &quot;handles integer system IDs&quot; do
      system_id = 31_000_001
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(system_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_system(system_id)
    end

    test &quot;handles string system IDs&quot; do
      system_id = &quot;31_000_002&quot;
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(system_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_system(system_id)
    end

    test &quot;different system IDs are tracked separately&quot; do
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(31_000_003)
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(31_000_004)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_system(31_000_003)
    end
  end

  describe &quot;check_and_mark_character/1&quot; do
    test &quot;handles integer character IDs&quot; do
      character_id = 12_345
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_character(character_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_character(character_id)
    end

    test &quot;handles string character IDs&quot; do
      character_id = &quot;67890&quot;
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_character(character_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_character(character_id)
    end
  end

  describe &quot;check_and_mark_kill/1&quot; do
    test &quot;handles integer kill IDs&quot; do
      kill_id = 123_456_789
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_kill(kill_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_kill(kill_id)
    end

    test &quot;handles string kill IDs&quot; do
      kill_id = &quot;987_654_321&quot;
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_kill(kill_id)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_kill(kill_id)
    end
  end

  describe &quot;clear_all/0&quot; do
    test &quot;clears all deduplication entries&quot; do
      # Mark some entries
      DeduplicationHelper.check_and_mark(&quot;test:clear1&quot;)
      DeduplicationHelper.check_and_mark_system(30_000_142)
      DeduplicationHelper.check_and_mark_character(12_345)
      DeduplicationHelper.check_and_mark_kill(123_456_789)

      # They should all be duplicates
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(&quot;test:clear1&quot;)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_system(30_000_142)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_character(12_345)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark_kill(123_456_789)

      # Clear all entries
      :ok = DeduplicationHelper.clear_all()

      # Now they should all be new again
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(&quot;test:clear1&quot;)
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_system(30_000_142)
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_character(12_345)
      assert {:ok, :new} = DeduplicationHelper.check_and_mark_kill(123_456_789)
    end
  end

  describe &quot;handle_clear_key/1&quot; do
    test &quot;clears a specific key&quot; do
      # Mark a key
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(&quot;test:expire&quot;)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(&quot;test:expire&quot;)

      # Manually clear the key
      :ok = DeduplicationHelper.handle_clear_key(&quot;test:expire&quot;)

      # It should be new again
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(&quot;test:expire&quot;)
    end
  end

  describe &quot;TTL and expiration&quot; do
    test &quot;entries can be manually expired&quot; do
      test_key = &quot;test:manual_expire&quot;

      # Mark the key
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)
      assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(test_key)

      # Manually clear the key
      :ok = DeduplicationHelper.handle_clear_key(test_key)

      # Should be new again
      assert {:ok, :new} = DeduplicationHelper.check_and_mark(test_key)
    end

    test &quot;clearing all entries removes all deduplication data&quot; do
      keys = [&quot;test:clear1&quot;, &quot;test:clear2&quot;, &quot;test:clear3&quot;]

      # Mark all keys
      Enum.each(keys, fn key -&gt;
        assert {:ok, :new} = DeduplicationHelper.check_and_mark(key)
      end)

      # Verify they&apos;re all marked
      Enum.each(keys, fn key -&gt;
        assert {:ok, :duplicate} = DeduplicationHelper.check_and_mark(key)
      end)

      # Clear all entries
      :ok = DeduplicationHelper.clear_all()

      # Verify they&apos;re all new again
      Enum.each(keys, fn key -&gt;
        assert {:ok, :new} = DeduplicationHelper.check_and_mark(key)
      end)
    end
  end
end</file><file path="test/wanderer_notifier/notifiers/structured_formatter_test.exs">defmodule WandererNotifier.Notifiers.StructuredFormatterTest do
  use ExUnit.Case
  import Mox

  alias WandererNotifier.Api.ESI.ServiceMock, as: ESIServiceMock
  alias WandererNotifier.Api.ZKill.ServiceMock, as: ZKillServiceMock
  alias WandererNotifier.Character.Character
  alias WandererNotifier.Killmail.Killmail
  alias WandererNotifier.Data.MapSystem
  alias WandererNotifier.MockZKillClient
  alias WandererNotifier.Notifiers.StructuredFormatter

  # Set up mocks for the test
  setup :verify_on_exit!

  setup do
    # Configure application to use mocks
    Application.put_env(:wanderer_notifier, :zkill_service, ZKillServiceMock)
    Application.put_env(:wanderer_notifier, :esi_service, ESIServiceMock)
    Application.put_env(:wanderer_notifier, :zkill_client, MockZKillClient)

    # Set up expectations for the ZKill client mock
    stub(MockZKillClient, :get_system_kills, fn _system_id, _limit -&gt;
      {:ok,
       [
         %{
           &quot;killmail_id&quot; =&gt; 12_345,
           &quot;zkb&quot; =&gt; %{
             &quot;totalValue&quot; =&gt; 1_000_000.0,
             &quot;points&quot; =&gt; 1,
             &quot;hash&quot; =&gt; &quot;abc123&quot;
           }
         }
       ]}
    end)

    # Set up expectations for the ESI service mock
    stub(ESIServiceMock, :get_killmail, fn _kill_id, _hash -&gt;
      {:ok,
       %{
         &quot;killmail_id&quot; =&gt; 12_345,
         &quot;solar_system_id&quot; =&gt; 30_000_142,
         &quot;victim&quot; =&gt; %{
           &quot;character_id&quot; =&gt; 93_265_357,
           &quot;ship_type_id&quot; =&gt; 587
         },
         &quot;attackers&quot; =&gt; [
           %{
             &quot;character_id&quot; =&gt; 93_898_784,
             &quot;ship_type_id&quot; =&gt; 11_567
           }
         ]
       }}
    end)

    # Set up expectations for the ZKill service mock
    stub(ZKillServiceMock, :get_single_killmail, fn _kill_id -&gt;
      {:ok,
       %{
         &quot;killmail_id&quot; =&gt; 12_345,
         &quot;solar_system_id&quot; =&gt; 30_000_142,
         &quot;victim&quot; =&gt; %{
           &quot;character_id&quot; =&gt; 93_265_357,
           &quot;ship_type_id&quot; =&gt; 587
         },
         &quot;attackers&quot; =&gt; [
           %{
             &quot;character_id&quot; =&gt; 93_898_784,
             &quot;ship_type_id&quot; =&gt; 11_567
           }
         ]
       }}
    end)

    # Add stub for ZKill service get_system_kills
    stub(ZKillServiceMock, :get_system_kills, fn _system_id, _limit -&gt;
      {:ok,
       [
         %{
           &quot;killmail_id&quot; =&gt; 12_345,
           &quot;zkb&quot; =&gt; %{
             &quot;totalValue&quot; =&gt; 1_000_000.0,
             &quot;points&quot; =&gt; 1,
             &quot;hash&quot; =&gt; &quot;abc123&quot;
           }
         }
       ]}
    end)

    # Set up expectations for the ESI service mock
    stub(ESIServiceMock, :get_character_info, fn _character_id -&gt;
      {:ok, %{&quot;name&quot; =&gt; &quot;Test Character&quot;}}
    end)

    stub(ESIServiceMock, :get_type_info, fn _type_id -&gt;
      {:ok, %{&quot;name&quot; =&gt; &quot;Test Ship&quot;}}
    end)

    stub(ESIServiceMock, :get_ship_type_name, fn _ship_type_id -&gt;
      {:ok, %{&quot;name&quot; =&gt; &quot;Test Ship&quot;}}
    end)

    # Return an empty context
    :ok
  end

  describe &quot;colors/0&quot; do
    test &quot;returns a map of color constants&quot; do
      colors = StructuredFormatter.colors()
      assert is_map(colors)
      assert Map.has_key?(colors, :default)
      assert Map.has_key?(colors, :success)
      assert Map.has_key?(colors, :warning)
      assert Map.has_key?(colors, :error)
      assert Map.has_key?(colors, :info)
      assert Map.has_key?(colors, :wormhole)
      assert Map.has_key?(colors, :highsec)
      assert Map.has_key?(colors, :lowsec)
      assert Map.has_key?(colors, :nullsec)
    end
  end

  describe &quot;convert_color/1&quot; do
    test &quot;converts atom color names to integer values&quot; do
      assert StructuredFormatter.convert_color(:default) == StructuredFormatter.colors().default
      assert StructuredFormatter.convert_color(:success) == StructuredFormatter.colors().success
      assert StructuredFormatter.convert_color(:warning) == StructuredFormatter.colors().warning
      assert StructuredFormatter.convert_color(:error) == StructuredFormatter.colors().error
      assert StructuredFormatter.convert_color(:info) == StructuredFormatter.colors().info
    end

    test &quot;returns integer color values unchanged&quot; do
      assert StructuredFormatter.convert_color(0x3498DB) == 0x3498DB
      assert StructuredFormatter.convert_color(16_711_680) == 16_711_680
    end

    test &quot;converts hex strings to integer values&quot; do
      assert StructuredFormatter.convert_color(&quot;#FF0000&quot;) == 0xFF0000
      assert StructuredFormatter.convert_color(&quot;#00FF00&quot;) == 0x00FF00
      assert StructuredFormatter.convert_color(&quot;#0000FF&quot;) == 0x0000FF
    end

    test &quot;returns default color for invalid inputs&quot; do
      default_color = StructuredFormatter.colors().default
      assert StructuredFormatter.convert_color(nil) == default_color
      assert StructuredFormatter.convert_color(&quot;invalid&quot;) == default_color
      assert StructuredFormatter.convert_color([]) == default_color
    end
  end

  describe &quot;format_kill_notification/1&quot; do
    test &quot;formats a killmail notification correctly&quot; do
      # Create a test killmail using the proper struct
      killmail = %Killmail{
        killmail_id: &quot;12345&quot;,
        zkb: %{
          &quot;totalValue&quot; =&gt; 1_000_000.0,
          &quot;points&quot; =&gt; 1
        },
        esi_data: %{
          &quot;killmail_id&quot; =&gt; 12_345,
          &quot;solar_system_id&quot; =&gt; 30_000_142,
          &quot;victim&quot; =&gt; %{
            &quot;character_id&quot; =&gt; 93_265_357,
            &quot;ship_type_id&quot; =&gt; 587
          },
          &quot;attackers&quot; =&gt; [
            %{
              &quot;character_id&quot; =&gt; 93_898_784,
              &quot;ship_type_id&quot; =&gt; 11_567
            }
          ]
        }
      }

      # Format the notification
      result = StructuredFormatter.format_kill_notification(killmail)

      # Assert the result structure
      assert is_map(result)
      assert result.type == :kill_notification
      assert result.title == &quot;Kill Notification&quot;
      assert result.description =~ &quot;lost&quot;
      assert result.color
      assert result.url =~ &quot;zkillboard.com/kill/12345&quot;
      assert result.thumbnail.url =~ &quot;images.evetech.net&quot;
      assert is_list(result.fields)
      assert length(result.fields) &gt; 0
    end

    test &quot;handles killmail with missing or partial data&quot; do
      # Create a test killmail with minimal data using the proper struct
      killmail = %Killmail{
        killmail_id: &quot;12345&quot;,
        zkb: %{
          &quot;totalValue&quot; =&gt; 1_000_000.0,
          &quot;points&quot; =&gt; 1
        },
        esi_data: %{
          &quot;killmail_id&quot; =&gt; 12_345,
          &quot;solar_system_id&quot; =&gt; 30_000_142,
          &quot;victim&quot; =&gt; %{},
          &quot;attackers&quot; =&gt; []
        }
      }

      # Format the notification
      result = StructuredFormatter.format_kill_notification(killmail)

      # Assert the result structure
      assert is_map(result)
      assert result.type == :kill_notification
      assert result.title == &quot;Kill Notification&quot;
      assert result.description =~ &quot;Unknown Pilot&quot;
      assert result.color
      assert result.url =~ &quot;zkillboard.com/kill/12345&quot;
      assert result.thumbnail
      assert is_list(result.fields)
      assert length(result.fields) &gt; 0
    end
  end

  describe &quot;format_character_notification/1&quot; do
    test &quot;formats a character notification correctly&quot; do
      # Create a test character with all required fields
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        corporation_id: 67_890,
        corporation_ticker: &quot;TSTC&quot;,
        alliance_id: 54_321,
        alliance_ticker: &quot;TSTA&quot;,
        tracked: true
      }

      result = StructuredFormatter.format_character_notification(character)

      # Check that the result has the expected structure
      assert is_map(result)
      assert result.type == :character_notification
      assert result.title == &quot;New Character Tracked&quot;
      assert result.description =~ &quot;new character&quot;
      assert result.color
      assert result.thumbnail.url =~ &quot;12345&quot;
      assert result.fields

      # Check character field
      character_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Character&quot; end)
      assert character_field
      assert character_field.value =~ &quot;Test Character&quot;
      assert character_field.value =~ &quot;zkillboard.com/character/12345&quot;

      # Check corporation field
      corporation_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Corporation&quot; end)
      assert corporation_field
      assert corporation_field.value =~ &quot;TSTC&quot;
      assert corporation_field.value =~ &quot;zkillboard.com/corporation/67890&quot;
    end

    test &quot;handles character without corporation data&quot; do
      # Create a test character with minimal required fields
      character = %Character{
        character_id: &quot;12345&quot;,
        name: &quot;Test Character&quot;,
        tracked: true
      }

      result = StructuredFormatter.format_character_notification(character)

      # Check that the result omits the corporation field
      assert is_map(result)
      assert result.type == :character_notification
      refute Enum.any?(result.fields, fn field -&gt; field.name == &quot;Corporation&quot; end)
    end
  end

  describe &quot;format_system_notification/1&quot; do
    test &quot;formats a wormhole system notification correctly&quot; do
      # Create a test wormhole system
      system = %MapSystem{
        id: &quot;map-123456&quot;,
        solar_system_id: 31_000_001,
        name: &quot;J123456&quot;,
        original_name: &quot;J123456&quot;,
        system_type: :wormhole,
        type_description: &quot;Wormhole&quot;,
        class_title: &quot;Class 5&quot;,
        effect_name: &quot;Wolf-Rayet&quot;,
        is_shattered: false,
        locked: false,
        region_name: &quot;Unknown&quot;,
        static_details: [
          %{
            &quot;name&quot; =&gt; &quot;C140&quot;,
            &quot;destination&quot; =&gt; %{
              &quot;short_name&quot; =&gt; &quot;C5&quot;
            }
          },
          %{
            &quot;name&quot; =&gt; &quot;N944&quot;,
            &quot;destination&quot; =&gt; %{
              &quot;short_name&quot; =&gt; &quot;H&quot;
            }
          }
        ],
        sun_type_id: 45_041
      }

      result = StructuredFormatter.format_system_notification(system)

      # Check that the result has the expected structure
      assert is_map(result)
      assert result.type == :system_notification
      assert result.title == &quot;New System Mapped: J123456&quot;

      assert result.description ==
               &quot;Class 5 wormhole added to the map.&quot;

      assert result.color
      assert result.thumbnail.url
      assert result.fields

      # Check system field
      system_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;System&quot; end)
      assert system_field
      assert system_field.value =~ &quot;J123456&quot;

      # Check statics field
      statics_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Statics&quot; end)
      assert statics_field
      assert statics_field.value =~ &quot;C140&quot;
      assert statics_field.value =~ &quot;N944&quot;

      # Check effect field
      effect_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Effect&quot; end)
      assert effect_field
      assert effect_field.value =~ &quot;Wolf-Rayet&quot;

      # Check region field
      region_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Region&quot; end)
      assert region_field
      assert region_field.value =~ &quot;Unknown&quot;
    end

    test &quot;formats a k-space system notification correctly&quot; do
      # Create a test k-space system
      system = %MapSystem{
        solar_system_id: &quot;30000142&quot;,
        name: &quot;Jita&quot;,
        type_description: &quot;High-sec&quot;,
        region_name: &quot;The Forge&quot;,
        system_type: &quot;k-space&quot;
      }

      result = StructuredFormatter.format_system_notification(system)

      # Check that the result has the expected structure
      assert is_map(result)
      assert result.type == :system_notification
      assert result.title =~ &quot;New System Mapped: Jita&quot;
      assert result.description =~ &quot;High-sec system added to the map.&quot;
      assert result.color
      assert result.thumbnail.url
      assert result.fields

      # Check system field
      system_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;System&quot; end)
      assert system_field
      assert system_field.value =~ &quot;Jita&quot;
      assert system_field.value =~ &quot;zkillboard.com/system/30000142&quot;

      # Check region field
      region_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Region&quot; end)
      assert region_field
      assert region_field.value =~ &quot;The Forge&quot;
    end

    test &quot;raises for system without required fields&quot; do
      # Create structs missing required fields
      system_with_only_name = struct(MapSystem, %{name: &quot;Test System&quot;})
      system_with_only_id = struct(MapSystem, %{solar_system_id: 12_345})
      empty_system = MapSystem.new(%{})

      # Test with missing system ID
      assert_raise RuntimeError, ~r/solar_system_id is missing/, fn -&gt;
        StructuredFormatter.format_system_notification(system_with_only_name)
      end

      # Test with missing name
      assert_raise RuntimeError, ~r/name is missing/, fn -&gt;
        StructuredFormatter.format_system_notification(system_with_only_id)
      end

      # Test with both fields missing (from new)
      assert_raise RuntimeError, ~r/solar_system_id is missing|name is missing/, fn -&gt;
        StructuredFormatter.format_system_notification(empty_system)
      end
    end
  end

  describe &quot;to_discord_format/1&quot; do
    test &quot;converts a generic notification to Discord format&quot; do
      # Create a generic notification with minimal fields
      notification = %{
        type: :test_notification,
        title: &quot;Test Title&quot;,
        description: &quot;Test Description&quot;,
        color: 0x3498DB,
        url: &quot;https://example.com&quot;,
        timestamp: &quot;2023-04-15T12:30:45Z&quot;,
        fields: [
          %{name: &quot;Field 1&quot;, value: &quot;Value 1&quot;, inline: true},
          %{name: &quot;Field 2&quot;, value: &quot;Value 2&quot;, inline: false}
        ]
      }

      result = StructuredFormatter.to_discord_format(notification)

      # Check that the result is in Discord format
      assert is_map(result)
      assert result[&quot;title&quot;] == &quot;Test Title&quot;
      assert result[&quot;description&quot;] == &quot;Test Description&quot;
      assert result[&quot;color&quot;] == 0x3498DB
      assert result[&quot;url&quot;] == &quot;https://example.com&quot;
      assert result[&quot;timestamp&quot;] == &quot;2023-04-15T12:30:45Z&quot;
      assert length(result[&quot;fields&quot;]) == 2
      assert Enum.at(result[&quot;fields&quot;], 0)[&quot;name&quot;] == &quot;Field 1&quot;
      assert Enum.at(result[&quot;fields&quot;], 0)[&quot;value&quot;] == &quot;Value 1&quot;
      assert Enum.at(result[&quot;fields&quot;], 0)[&quot;inline&quot;] == true
      assert Enum.at(result[&quot;fields&quot;], 1)[&quot;name&quot;] == &quot;Field 2&quot;
      assert Enum.at(result[&quot;fields&quot;], 1)[&quot;value&quot;] == &quot;Value 2&quot;
      assert Enum.at(result[&quot;fields&quot;], 1)[&quot;inline&quot;] == false
    end
  end

  describe &quot;format_system_status_message/8&quot; do
    test &quot;formats a system status message correctly&quot; do
      # Create test data
      stats = %{
        notifications: %{
          total: 100,
          kills: 50,
          systems: 30,
          characters: 20
        },
        websocket: %{
          connected: true,
          last_message: DateTime.utc_now()
        }
      }

      features_status = %{
        kill_notifications_enabled: true,
        system_tracking_enabled: true,
        character_tracking_enabled: true,
        activity_charts: false
      }

      license_status = %{
        valid: true,
        premium: false
      }

      # 1 day, 1 hour, 1 minute, 30 seconds
      uptime = 86_400 + 3_600 + 60 + 30

      result =
        StructuredFormatter.format_system_status_message(
          &quot;System Status&quot;,
          &quot;Current system status report&quot;,
          stats,
          uptime,
          features_status,
          license_status,
          # systems_count
          10,
          # characters_count
          5
        )

      # Check that the result has the expected structure
      assert is_map(result)
      assert result.type == :status_notification
      assert result.title == &quot;System Status&quot;
      assert result.description =~ &quot;Current system status&quot;
      assert result.color
      assert result.thumbnail.url
      assert result.footer.text =~ &quot;Wanderer Notifier&quot;

      # Check uptime field
      uptime_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Uptime&quot; end)
      assert uptime_field
      assert uptime_field.value =~ &quot;1d 1h 1m 30s&quot;

      # Check license field
      license_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;License&quot; end)
      assert license_field
      assert license_field.value =~ &quot;&quot;

      # Check systems field
      systems_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Systems&quot; end)
      assert systems_field
      assert systems_field.value =~ &quot;10&quot;

      # Check characters field
      characters_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Characters&quot; end)
      assert characters_field
      assert characters_field.value =~ &quot;5&quot;

      # Check notifications field
      notifications_field =
        Enum.find(result.fields, fn field -&gt; field.name == &quot; Notifications&quot; end)

      assert notifications_field
      assert notifications_field.value =~ &quot;Total: **100**&quot;
      assert notifications_field.value =~ &quot;Kills: **50**&quot;
      assert notifications_field.value =~ &quot;Systems: **30**&quot;
      assert notifications_field.value =~ &quot;Characters: **20**&quot;

      # Check features field
      features_field =
        Enum.find(result.fields, fn field -&gt; field.name == &quot; Primary Features&quot; end)

      assert features_field
      assert features_field.value =~ &quot; Kill Notifications&quot;
      assert features_field.value =~ &quot; System Notifications&quot;
      assert features_field.value =~ &quot; Character Notifications&quot;
      assert features_field.value =~ &quot; Activity Charts&quot;
    end

    test &quot;handles startup message without uptime&quot; do
      # Create minimal test data
      stats = %{
        notifications: %{
          total: 0,
          kills: 0,
          systems: 0,
          characters: 0
        }
      }

      features_status = %{
        kill_notifications_enabled: true
      }

      license_status = %{
        valid: true,
        premium: false
      }

      result =
        StructuredFormatter.format_system_status_message(
          &quot;WandererNotifier Started&quot;,
          &quot;The service has started&quot;,
          stats,
          # nil uptime for startup
          nil,
          features_status,
          license_status,
          0,
          0
        )

      # Check startup-specific information
      uptime_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;Uptime&quot; end)
      assert uptime_field
      assert uptime_field.value =~ &quot;Just started&quot;

      license_field = Enum.find(result.fields, fn field -&gt; field.name == &quot;License&quot; end)
      assert license_field
      # Non-premium
      assert license_field.value =~ &quot;&quot;
    end
  end
end</file><file path="test/README.md"># WandererNotifier Tests

This directory contains tests for the WandererNotifier application.

## Directory Structure

```
test/
 support/                 # Support modules for testing
    fixtures/            # Sample data files
    mocks/               # Mock implementations
    helpers/             # Test helper functions
 wanderer_notifier/       # Unit and component tests
    api/                 # API client tests
    cache/               # Cache repository tests
    http/                # HTTP client tests
    data/                # Data structure tests
    discord/             # Discord integration tests
    helpers/             # Helper function tests
    notifiers/           # Notifier implementation tests
    schedulers/          # Scheduler tests
    services/            # Service tests
 integration/             # Cross-component tests
    flows/               # End-to-end flow tests
    system/              # System behavior tests
 test_helper.exs          # Test configuration and setup
```

## Current Test Coverage

| Component        | Type        | Status      |
| ---------------- | ----------- | ----------- |
| HTTP Client      | Mock        | Implemented |
| Cache Repository | Mock        | Implemented |
| API Client       | Integration | Implemented |
| Basic Helper     | Unit        | Implemented |

## Running Tests

```bash
# Run all tests
mix test

# Run a specific test file
mix test test/wanderer_notifier/http/http_test.exs

# Run with code coverage report
mix test --cover
```

## Mocking

The tests use the Mox library to mock external dependencies. The following mocks are available:

- `WandererNotifier.MockHTTP` - For mocking HTTP requests
- `WandererNotifier.MockCache` - For mocking cache operations
- `WandererNotifier.MockDiscord` - For mocking Discord operations
- `WandererNotifier.MockWebSocket` - For mocking WebSocket operations

## Fixtures

Sample data for tests is available in `test/support/fixtures/api_responses.ex`. Current fixtures include:

- Map API system data
- ESI character responses
- zKillboard killmail messages

## Adding New Tests

When adding new tests:

1. Follow the existing pattern and directory structure
2. Use the appropriate mocks for external dependencies
3. Use fixtures for sample data
4. Follow the AAA pattern (Arrange, Act, Assert)
5. Ensure tests are independent and don&apos;t rely on side effects

## Test Environment

The test environment configuration is in `config/test.exs`. It includes:

- Mocked dependencies instead of real ones
- Faster timeouts for tests
- Test-specific feature flags

## Further Documentation

For more details on the testing strategy and example implementations, see:

- `docs/testing/testing-strategy.md`
- `docs/testing/example-tests.md`
- `docs/testing/getting-started.md`</file><file path="test/test_helper.exs"># Configure test environment before anything else
Application.put_env(:wanderer_notifier, :environment, :test)

# Disable all external services and background processes in test
Application.put_env(:wanderer_notifier, :discord_enabled, false)
Application.put_env(:wanderer_notifier, :scheduler_enabled, false)
Application.put_env(:wanderer_notifier, :character_tracking_enabled, false)
Application.put_env(:wanderer_notifier, :system_notifications_enabled, false)

# Configure Mox
Application.ensure_all_started(:mox)

# Define single mock for repository
Mox.defmock(WandererNotifier.Cache.RepositoryMock,
  for: WandererNotifier.Cache.RepositoryBehaviour
)

# Configure cache implementation
Application.put_env(:wanderer_notifier, :cache_impl, WandererNotifier.ETSCache)

Application.put_env(
  :wanderer_notifier,
  :cache_repository,
  WandererNotifier.Cache.RepositoryMock
)

# Start ExUnit with global mode disabled
ExUnit.start(capture_log: true)

# Initialize ETS tables under supervision
defmodule WandererNotifier.TestSupervisor do
  use Supervisor

  def start_link(init_arg) do
    Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)
  end

  @impl true
  def init(_init_arg) do
    # Initialize ETS tables under supervision
    table_opts = [
      :named_table,
      :public,
      :set,
      {:write_concurrency, true},
      {:read_concurrency, true}
    ]

    # Create tables if they don&apos;t exist
    if :ets.whereis(:cache_table) == :undefined do
      :ets.new(:cache_table, table_opts)
    end

    if :ets.whereis(:locks_table) == :undefined do
      :ets.new(:locks_table, table_opts)
    end

    # Return empty children list since tables are created
    Supervisor.init([], strategy: :one_for_one)
  end
end

# Start the test supervisor
{:ok, _pid} = WandererNotifier.TestSupervisor.start_link([])

# Define mocks for external services
Mox.defmock(WandererNotifier.Api.ESI.ServiceMock, for: WandererNotifier.Api.ESI.ServiceBehaviour)

# Configure application to use mocks
Application.put_env(:wanderer_notifier, :esi_service, WandererNotifier.Api.ESI.ServiceMock)

# Cache-related mocks
Mox.defmock(WandererNotifier.MockCache, for: WandererNotifier.Cache.CacheBehaviour)

# Define mocks for external dependencies
Mox.defmock(WandererNotifier.MockESI, for: WandererNotifier.Api.ESI.ServiceBehaviour)
Mox.defmock(WandererNotifier.MockLogger, for: WandererNotifier.Logger.Behaviour)
Mox.defmock(WandererNotifier.MockHTTP, for: WandererNotifier.HttpClient.Behaviour)

# Define mocks for notifiers
Mox.defmock(WandererNotifier.MockStructuredFormatter,
  for: WandererNotifier.Notifiers.StructuredFormatterBehaviour
)

Mox.defmock(WandererNotifier.MockDiscordNotifier,
  for: WandererNotifier.Notifiers.DiscordNotifierBehaviour
)

# Configure application to use mocks
Application.put_env(:wanderer_notifier, :discord_notifier, WandererNotifier.MockDiscordNotifier)

# Set up default stubs for Discord notifier
Mox.stub_with(WandererNotifier.MockDiscordNotifier, WandererNotifier.Test.Stubs.DiscordNotifier)

# Define mocks for cache helpers
Mox.defmock(WandererNotifier.MockCacheHelpers, for: WandererNotifier.Cache.HelpersBehaviour)

Mox.defmock(WandererNotifier.MockRepository, for: WandererNotifier.Cache.RepositoryBehaviour)

# Set Mox to verify on exit
Application.put_env(:mox, :verify_on_exit, true)

# Define mocks for config and date
Mox.defmock(WandererNotifier.MockConfig, for: WandererNotifier.Config.Behaviour)
Mox.defmock(WandererNotifier.MockDate, for: WandererNotifier.DateBehaviour)

# Define mocks for notifier factory
Mox.defmock(WandererNotifier.MockNotifierFactory,
  for: WandererNotifier.Notifiers.FactoryBehaviour
)

# Set up application environment for testing
Application.put_env(:wanderer_notifier, :config_module, WandererNotifier.MockConfig)
Application.put_env(:wanderer_notifier, :cache_helpers_module, WandererNotifier.MockCacheHelpers)
Application.put_env(:wanderer_notifier, :notifier_factory, WandererNotifier.MockNotifierFactory)
Application.put_env(:wanderer_notifier, :date_module, WandererNotifier.MockDate)

# Set up test configuration
Application.put_env(:wanderer_notifier, :http_client, WandererNotifier.MockHTTP)
Application.put_env(:wanderer_notifier, :cache_client, WandererNotifier.MockCache)
Application.put_env(:wanderer_notifier, :notifier_client, WandererNotifier.MockNotifier)

# Set up test environment variables
System.put_env(&quot;MAP_URL&quot;, &quot;http://test.map.url&quot;)
System.put_env(&quot;MAP_TOKEN&quot;, &quot;test_map_token&quot;)
System.put_env(&quot;MAP_NAME&quot;, &quot;test_map&quot;)
System.put_env(&quot;NOTIFIER_API_TOKEN&quot;, &quot;test_notifier_token&quot;)
System.put_env(&quot;LICENSE_KEY&quot;, &quot;test_license_key&quot;)
System.put_env(&quot;LICENSE_MANAGER_API_URL&quot;, &quot;http://test.license.url&quot;)
System.put_env(&quot;DISCORD_WEBHOOK_URL&quot;, &quot;http://test.discord.url&quot;)

# Configure logger level for tests
Logger.configure(level: :warn)

# Helper functions for tests
defmodule WandererNotifier.TestHelpers do
  @moduledoc &quot;&quot;&quot;
  Helper functions for tests.
  &quot;&quot;&quot;

  def mock_http_response(status_code, body) do
    {:ok, %{status_code: status_code, body: body}}
  end

  def mock_http_error(reason) do
    {:error, reason}
  end

  def mock_cache_response(value) do
    {:ok, value}
  end

  def mock_cache_error(reason) do
    {:error, reason}
  end

  def mock_notifier_response do
    :ok
  end

  def mock_notifier_error(reason) do
    {:error, reason}
  end
end</file><file path="_config.yml">title: Wanderer Notifier
description: Get real-time EVE Online notifications directly to your Discord channel
remote_theme: pages-themes/cayman@v0.2.0
plugins:
- jekyll-remote-theme
- jekyll-seo-tag

# GitHub information
github:
  repository_url: https://github.com/guarzo/wanderer-notifier
  is_project_page: true
  owner_name: guarzo
  owner_url: https://github.com/guarzo
# Additional metadata
author: Guarzo
lang: en
show_downloads: false
google_analytics: # add your tracking ID here if needed

# Navigation
navigation:
  - name: Home
    link: /
  - name: Notifications
    link: /notifications.html
  - name: Wanderer
    link: https://wanderer.ltd/
  - name: GitHub
    link: https://github.com/guarzo/wanderer-notifier</file><file path=".coderabbit.yaml"># yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json

language: &quot;en-US&quot;
early_access: true  
reviews:
  profile: &quot;assertive&quot;
  request_changes_workflow: true 
  high_level_summary: true
  poem: true                      
  review_status: true              
  collapse_walkthrough: false      
  path_filters:
    - &quot;!node_modules/**&quot;   # Ignore dependencies
    - &quot;!dist/**&quot;           # Ignore build output
    - &quot;!**/*.min.js&quot;       # Ignore minified files
    - &quot;!**/*.bundle.js&quot;    # Ignore bundled assets
    - &quot;!.notes/**&quot;
    - &quot;!.cursor/**&quot;

  path_instructions:
    # Global project guidelines (apply to all files)
    - path: &quot;**/*&quot;
      instructions: |
        **General Code Quality**  Ensure the code follows global best practices:
        - Keep functions and modules small and focused (single responsibility).
        - Use consistent naming conventions and meaningful identifiers for clarity.
        - Look for unused code or files that can be removed
        - Avoid duplicate code  refactor common logic into reusable functions.
        - Maintain code readability (proper indentation, avoid deep nesting of code).
        - Write comments where necessary to explain intent, but keep code self-explanatory.
        - Use early exit strategy, avoid else use pattern matching

  auto_review:
    enabled: true        # Enable automatic AI review on pull requests
    drafts: false        # Skip reviews on draft PRs (only review ready PRs)
    base_branches: [&quot;main&quot;, &quot;develop&quot;]  # Only run auto-reviews for PRs targeting these branches (adjust to your workflow)

chat:
  auto_reply: true  # Enable the AI to answer follow-up questions in PR comments</file><file path=".credo.exs"># This file contains the configuration for Credo and you are probably reading
# this after creating it with `mix credo.gen.config`.
#
# If you find anything wrong or unclear in this file, please report an
# issue on GitHub: https://github.com/rrrene/credo/issues
#
%{
  #
  # You can have as many configs as you like in the `configs:` field.
  configs: [
    %{
      #
      # Run any config using `mix credo -C &lt;name&gt;`. If no config name is given
      # &quot;default&quot; is used.
      #
      name: &quot;default&quot;,
      #
      # These are the files included in the analysis:
      files: %{
        #
        # You can give explicit globs or simply directories.
        # In the latter case `**/*.{ex,exs}` will be used.
        #
        included: [
          &quot;lib/&quot;,
          &quot;src/&quot;,
          &quot;test/&quot;,
          &quot;web/&quot;,
          &quot;apps/*/lib/&quot;,
          &quot;apps/*/src/&quot;,
          &quot;apps/*/test/&quot;,
          &quot;apps/*/web/&quot;
        ],
        excluded: [~r&quot;/_build/&quot;, ~r&quot;/deps/&quot;, ~r&quot;/node_modules/&quot;]
      },
      #
      # Load and configure plugins here:
      #
      plugins: [],
      #
      # If you create your own checks, you must specify the source files for
      # them here, so they can be loaded by Credo before running the analysis.
      #
      requires: [],
      #
      # If you want to enforce a style guide and need a more traditional linting
      # experience, you can change `strict` to `true` below:
      #
      strict: false,
      #
      # To modify the timeout for parsing files, change this value:
      #
      parse_timeout: 5000,
      #
      # If you want to use uncolored output by default, you can change `color`
      # to `false` below:
      #
      color: false,
      #
      # You can customize the parameters of any check by adding a second element
      # to the tuple.
      #
      # To disable a check put `false` as second element:
      #
      #     {Credo.Check.Design.DuplicatedCode, false}
      #
      checks: %{
        enabled: [
          #
          ## Consistency Checks
          #
          {Credo.Check.Consistency.ExceptionNames, []},
          {Credo.Check.Consistency.LineEndings, []},
          {Credo.Check.Consistency.ParameterPatternMatching, []},
          {Credo.Check.Consistency.SpaceAroundOperators, []},
          {Credo.Check.Consistency.SpaceInParentheses, []},
          {Credo.Check.Consistency.TabsOrSpaces, []},

          #
          ## Design Checks
          #
          # You can customize the priority of any check
          # Priority values are: `low, normal, high, higher`
          #
          {Credo.Check.Design.AliasUsage,
           [priority: :low, if_nested_deeper_than: 2, if_called_more_often_than: 0]},
          {Credo.Check.Design.TagFIXME, []},
          # You can also customize the exit_status of each check.
          # If you don&apos;t want TODO comments to cause `mix credo` to fail, just
          # set this value to 0 (zero).
          #
          {Credo.Check.Design.TagTODO, [exit_status: 2]},

          #
          ## Readability Checks
          #
          {Credo.Check.Readability.AliasOrder, []},
          {Credo.Check.Readability.FunctionNames, []},
          {Credo.Check.Readability.LargeNumbers, []},
          {Credo.Check.Readability.MaxLineLength, [priority: :low, max_length: 120]},
          {Credo.Check.Readability.ModuleAttributeNames, []},
          {Credo.Check.Readability.ModuleDoc, []},
          {Credo.Check.Readability.ModuleNames, []},
          {Credo.Check.Readability.ParenthesesInCondition, []},
          {Credo.Check.Readability.ParenthesesOnZeroArityDefs, []},
          {Credo.Check.Readability.PipeIntoAnonymousFunctions, []},
          {Credo.Check.Readability.PredicateFunctionNames, []},
          {Credo.Check.Readability.PreferImplicitTry, []},
          {Credo.Check.Readability.RedundantBlankLines, []},
          {Credo.Check.Readability.Semicolons, []},
          {Credo.Check.Readability.SpaceAfterCommas, []},
          {Credo.Check.Readability.StringSigils, []},
          {Credo.Check.Readability.TrailingBlankLine, []},
          {Credo.Check.Readability.TrailingWhiteSpace, []},
          {Credo.Check.Readability.UnnecessaryAliasExpansion, []},
          {Credo.Check.Readability.VariableNames, []},
          {Credo.Check.Readability.WithSingleClause, []},

          #
          ## Refactoring Opportunities
          #
          {Credo.Check.Refactor.Apply, []},
          {Credo.Check.Refactor.CondStatements, []},
          {Credo.Check.Refactor.CyclomaticComplexity, []},
          {Credo.Check.Refactor.FilterCount, []},
          {Credo.Check.Refactor.FilterFilter, []},
          {Credo.Check.Refactor.FunctionArity, []},
          {Credo.Check.Refactor.LongQuoteBlocks, []},
          {Credo.Check.Refactor.MapJoin, []},
          {Credo.Check.Refactor.MatchInCondition, []},
          {Credo.Check.Refactor.NegatedConditionsInUnless, []},
          {Credo.Check.Refactor.NegatedConditionsWithElse, []},
          {Credo.Check.Refactor.Nesting, []},
          {Credo.Check.Refactor.RedundantWithClauseResult, []},
          {Credo.Check.Refactor.RejectReject, []},
          {Credo.Check.Refactor.UnlessWithElse, []},
          {Credo.Check.Refactor.WithClauses, []},

          #
          ## Warnings
          #
          {Credo.Check.Warning.ApplicationConfigInModuleAttribute, []},
          {Credo.Check.Warning.BoolOperationOnSameValues, []},
          {Credo.Check.Warning.Dbg, []},
          {Credo.Check.Warning.ExpensiveEmptyEnumCheck, []},
          {Credo.Check.Warning.IExPry, []},
          {Credo.Check.Warning.IoInspect, []},
          {Credo.Check.Warning.MissedMetadataKeyInLoggerConfig, []},
          {Credo.Check.Warning.OperationOnSameValues, []},
          {Credo.Check.Warning.OperationWithConstantResult, []},
          {Credo.Check.Warning.RaiseInsideRescue, []},
          {Credo.Check.Warning.SpecWithStruct, []},
          {Credo.Check.Warning.UnsafeExec, []},
          {Credo.Check.Warning.UnusedEnumOperation, []},
          {Credo.Check.Warning.UnusedFileOperation, []},
          {Credo.Check.Warning.UnusedKeywordOperation, []},
          {Credo.Check.Warning.UnusedListOperation, []},
          {Credo.Check.Warning.UnusedPathOperation, []},
          {Credo.Check.Warning.UnusedRegexOperation, []},
          {Credo.Check.Warning.UnusedStringOperation, []},
          {Credo.Check.Warning.UnusedTupleOperation, []},
          {Credo.Check.Warning.WrongTestFileExtension, []}
        ],
        disabled: [
          #
          # Checks scheduled for next check update (opt-in for now)
          {Credo.Check.Refactor.UtcNowTruncate, []},

          #
          # Controversial and experimental checks (opt-in, just move the check to `:enabled`
          #   and be sure to use `mix credo --strict` to see low priority checks)
          #
          {Credo.Check.Consistency.MultiAliasImportRequireUse, []},
          {Credo.Check.Consistency.UnusedVariableNames, []},
          {Credo.Check.Design.DuplicatedCode, []},
          {Credo.Check.Design.SkipTestWithoutComment, []},
          {Credo.Check.Readability.AliasAs, []},
          {Credo.Check.Readability.BlockPipe, []},
          {Credo.Check.Readability.ImplTrue, []},
          {Credo.Check.Readability.MultiAlias, []},
          {Credo.Check.Readability.NestedFunctionCalls, []},
          {Credo.Check.Readability.OneArityFunctionInPipe, []},
          {Credo.Check.Readability.OnePipePerLine, []},
          {Credo.Check.Readability.SeparateAliasRequire, []},
          {Credo.Check.Readability.SingleFunctionToBlockPipe, []},
          {Credo.Check.Readability.SinglePipe, []},
          {Credo.Check.Readability.Specs, []},
          {Credo.Check.Readability.StrictModuleLayout, []},
          {Credo.Check.Readability.WithCustomTaggedTuple, []},
          {Credo.Check.Refactor.ABCSize, []},
          {Credo.Check.Refactor.AppendSingleItem, []},
          {Credo.Check.Refactor.DoubleBooleanNegation, []},
          {Credo.Check.Refactor.FilterReject, []},
          {Credo.Check.Refactor.IoPuts, []},
          {Credo.Check.Refactor.MapMap, []},
          {Credo.Check.Refactor.ModuleDependencies, []},
          {Credo.Check.Refactor.NegatedIsNil, []},
          {Credo.Check.Refactor.PassAsyncInTestCases, []},
          {Credo.Check.Refactor.PipeChainStart, []},
          {Credo.Check.Refactor.RejectFilter, []},
          {Credo.Check.Refactor.VariableRebinding, []},
          {Credo.Check.Warning.LazyLogging, []},
          {Credo.Check.Warning.LeakyEnvironment, []},
          {Credo.Check.Warning.MapGetUnsafePass, []},
          {Credo.Check.Warning.MixEnv, []},
          {Credo.Check.Warning.UnsafeToAtom, []}

          # {Credo.Check.Refactor.MapInto, []},

          #
          # Custom checks can be created using `mix credo.gen.check`.
          #
        ]
      }
    }
  ]
}</file><file path=".cursorignore"># Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)
# Build artifacts
*.bak
node_modules/
repomix.*
/priv/charts/node_modules
/_build/
/cover/
/deps/
/doc/
/.fetch
chart-service/node_modules/

# Crash dumps and archives
erl_crash.dump
*.ez

# Compiled files (BEAM bytecode)
*.beam

# Application config secrets (should not be committed)
config/*.secret.exs

# Environment and tool files
.tool-versions

# Editor/IDE directories and swap files
.vscode/
.idea/
*.swp
*.swo

# Elixir language server artifacts
.elixir_ls/

# Cache directory
/tmp/

# Don&apos;t ignore priv directory
priv/static/app/**/*
!/priv/
!/priv/templates/</file><file path=".cursorrules">## Instructions for Using Graphiti&apos;s MCP Tools for Agent Memory

### Before Starting Any Task

- **Always search first:** Use the `search_nodes` tool to look for relevant preferences and procedures before beginning work.
- **Search for facts too:** Use the `search_facts` tool to discover relationships and factual information that may be relevant to your task.
- **Filter by entity type:** Specify `Preference`, `Procedure`, or `Requirement` in your node search to get targeted results.
- **Review all matches:** Carefully examine any preferences, procedures, or facts that match your current task.

### Always Save New or Updated Information

- **Capture requirements and preferences immediately:** When a user expresses a requirement or preference, use `add_episode` to store it right away.
  - _Best practice:_ Split very long requirements into shorter, logical chunks.
- **Be explicit if something is an update to existing knowledge.** Only add what&apos;s changed or new to the graph.
- **Document procedures clearly:** When you discover how a user wants things done, record it as a procedure.
- **Record factual relationships:** When you learn about connections between entities, store these as facts.
- **Be specific with categories:** Label preferences and procedures with clear categories for better retrieval later.

### During Your Work

- **Respect discovered preferences:** Align your work with any preferences you&apos;ve found.
- **Follow procedures exactly:** If you find a procedure for your current task, follow it step by step.
- **Apply relevant facts:** Use factual information to inform your decisions and recommendations.
- **Stay consistent:** Maintain consistency with previously identified preferences, procedures, and facts.

### Best Practices

- **Search before suggesting:** Always check if there&apos;s established knowledge before making recommendations.
- **Combine node and fact searches:** For complex tasks, search both nodes and facts to build a complete picture.
- **Use `center_node_uuid`:** When exploring related information, center your search around a specific node.
- **Prioritize specific matches:** More specific information takes precedence over general information.
- **Be proactive:** If you notice patterns in user behavior, consider storing them as preferences or procedures.

**Remember:** The knowledge graph is your memory. Use it consistently to provide personalized assistance that respects the user&apos;s established preferences, procedures, and factual context.</file><file path=".dockerignore">.git
_build
deps
test
node_modules
renderer/node_modules
chart-service/node_modules
*.DS_Store</file><file path=".env.example">WANDERER_DISCORD_BOT_TOKEN=your_discord_bot_token_here
WANDERER_LICENSE_KEY=your_license_key_here
WANDERER_DISCORD_CHANNEL_ID=your_notification_discord_channel_id

WANDERER_MAP_URL=https://wanderer.example.com/your-map-name
WANDERER_MAP_TOKEN=your_map_token_here</file><file path=".env.template">## Wanderer Notifier Environment Configuration

## Required Core Configuration
WANDERER_DISCORD_BOT_TOKEN=    # Discord bot token
WANDERER_DISCORD_CHANNEL_ID=    # Main Discord channel ID
WANDERER_LICENSE_KEY=                # License key for the application
WANDERER_MAP_URL=                    # URL to the Wanderer map (e.g., https://wanderer.example.com/your-map)
WANDERER_MAP_TOKEN=                  # Token for authenticating with the map

## Web Server Configuration 
WANDERER_PORT=4000                   # Port for the application web server
WANDERER_HOST=localhost              # Host for the application web server
WANDERER_SCHEME=http                 # URL scheme (http/https)

## Feature Flags (set to &quot;true&quot; or &quot;false&quot;)
WANDERER_FEATURE_TRACK_KSPACE=true   # Enable tracking of K-Space systems
WANDERER_DISABLE_STATUS_MESSAGES=false # Disable startup and status notifications

## Character Tracking Configuration
WANDERER_CHARACTER_EXCLUDE_LIST=        # Comma-separated list of character IDs to exclude from tracking

## Discord Channel Configuration (Optional - defaults to WANDERER_DISCORD_CHANNEL_ID)
WANDERER_DISCORD_SYSTEM_KILL_CHANNEL_ID=    # Channel for system-related kill notifications
WANDERER_DISCORD_CHARACTER_KILL_CHANNEL_ID=    # Channel for character-related kill notifications
WANDERER_DISCORD_SYSTEM_CHANNEL_ID=    # Channel for system notifications
WANDERER_DISCORD_CHARACTER_CHANNEL_ID=    # Channel for character notifications

## Cache Configuration
WANDERER_CACHE_DIR=/app/data/cache   # Directory for cached data

## API Integration
WANDERER_NOTIFIER_API_TOKEN=  # Generated in production builds 
WANDERER_LICENSE_MANAGER_URL= # Provided for production build</file><file path=".formatter.exs"># .formatter.exs
[
  inputs: [&quot;{mix,.formatter}.exs&quot;, &quot;{config,lib,test}/**/*.{ex,exs}&quot;]
]</file><file path=".gitignore">log/
# Build artifacts
*.bak
.cursor
notes
node_modules/
repomix.*
.cursor
/priv/charts/node_modules
/_build/
/cover/
/deps/
/doc/
/.fetch
chart-service/node_modules/

# Crash dumps and archives
erl_crash.dump
*.ez

# Compiled files (BEAM bytecode)
*.beam

# Application config secrets (should not be committed)
config/*.secret.exs

# Environment and tool files
.env
.tool-versions

# Editor/IDE directories and swap files
.vscode/
.idea/
*.swp
*.swo

# Elixir language server artifacts
.elixir_ls/

# Cache directory
/tmp/

# Don&apos;t ignore priv directory
priv/static/app/**/*
!/priv/
!/priv/templates/</file><file path="cicd.txt">A. Goals
Single Source of Truth for build, test, lint, and release steps.

Reusable Workflows with workflow_call to avoid duplication.

Parameterization for adhoc vs automatic vs release modes.

Fail-Fast &amp; Readability: clear jobs, inputs, and outputs.

B. Create a Reusable build-and-test Workflow
File: .github/workflows/build-and-test.yml

yaml
Copy
Edit
name: Build &amp; Test

on:
  workflow_call:
    inputs:
      mode:
        type: choice
        required: true
        options: [adhoc, automatic, release]
      branch:
        type: string
        required: false
      version_type:
        type: choice
        required: false
        options: [patch, minor, major]
    secrets:
      DOCKERHUB_PAT:
        required: false
      NOTIFIER_API_TOKEN:
        required: true
      FAKE_DISCORD_TOKEN:
        required: true

jobs:
  checkout:
    name: Checkout &amp; Cache
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-key.outputs.value }}
    steps:
      - uses: actions/checkout@v3
        with: { fetch-depth: 0 }
      - id: cache-key
        run: echo &quot;value=${{ runner.os }}-mix-${{ hashFiles(&apos;**/mix.lock&apos;) }}-1.18-27&quot; &gt;&gt; $GITHUB_OUTPUT
      - name: Restore Cache
        uses: actions/cache@v3
        with:
          key: ${{ steps.cache-key.outputs.value }}
          path: |
            deps
            _build
            priv/static

  setup:
    name: Setup Erlang, Elixir &amp; Node
    runs-on: ubuntu-latest
    needs: checkout
    steps:
      - uses: erlef/setup-beam@v1
        with: { elixir-version: &quot;1.18&quot;, otp-version: &quot;27&quot; }
      - uses: actions/setup-node@v4
        with: { node-version: &quot;20&quot;, cache: &quot;npm&quot;, cache-dependency-path: &quot;renderer/package-lock.json&quot; }

  build:
    name: Compile &amp; Test
    runs-on: ubuntu-latest
    needs: setup
    env:
      MIX_ENV: test
      WANDERER_NOTIFIER_API_TOKEN: ${{ secrets.NOTIFIER_API_TOKEN }}
    steps:
      - name: Mix deps.get &amp; compile
        run: |
          mix local.hex --force
          mix local.rebar --force
          mix deps.get
          mix deps.compile
      - name: Compile (warnings as errors)
        run: mix compile --warnings-as-errors
      - name: Run tests
        run: mix test

  lint:
    name: Format &amp; Lint
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Mix format check
        run: mix format --check-formatted
      - name: Credo strict
        run: mix credo --strict

  docker-validate:
    name: Build &amp; Validate Docker
    runs-on: ubuntu-latest
    needs: lint
    env:
      MIX_ENV: prod
      DISCORD_BOT_TOKEN: ${{ secrets.FAKE_DISCORD_TOKEN }}
      WANDERER_NOTIFIER_API_TOKEN: ${{ secrets.NOTIFIER_API_TOKEN }}
    steps:
      - uses: docker/setup-buildx-action@v3
        with: { buildkitd-flags: &quot;--debug&quot; }
      - name: Build image
        uses: ./.github/actions/common-docker-build
        with:
          context: .
          push: false
          load: true
          tags: &quot;wanderer-notifier:ci-${{ github.run_id }}&quot;
          build-args: |
            APP_VERSION=ci-test
            WANDERER_NOTIFIER_API_TOKEN=${{ secrets.NOTIFIER_API_TOKEN }}
      - name: Run container smoke tests
        run: |
          chmod +x ./scripts/test_docker_image.sh
          ./scripts/test_docker_image.sh -i wanderer-notifier -t ci-${{ github.run_id }} \
            --discord-token &quot;${{ secrets.FAKE_DISCORD_TOKEN }}&quot;
C. Main Orchestrator Workflow
File: .github/workflows/ci.yml

yaml
Copy
Edit
name: CI Pipeline

on:
  push:
    branches: [main]
    paths-ignore: [&quot;mix.exs&quot;]        # skip version bumps
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      mode:
        description: &quot;Run mode&quot;
        required: false
        default: &quot;automatic&quot;
        type: choice
        options: [adhoc, automatic, release]
      branch:
        description: &quot;Branch for adhoc&quot;
        required: false
      version_type:
        description: &quot;Bump type for release&quot;
        required: false
        default: &quot;patch&quot;
        type: choice
        options: [patch, minor, major]

jobs:
  run:
    uses: ./.github/workflows/build-and-test.yml
    with:
      mode: ${{ github.event.inputs.mode || &apos;automatic&apos; }}
      branch: ${{ github.event.inputs.branch }}
      version_type: ${{ github.event.inputs.version_type }}
    secrets: inherit
Push/PR to main triggers the full CI.

Manual dispatch (workflow_dispatch) allows adhoc or release flows.

D. Release Steps in Same Orchestrator
You can extend build-and-test.yml with conditional jobs:

yaml
Copy
Edit
  release:
    name: Bump Version &amp; Tag
    needs: docker-validate
    if: inputs.mode == &apos;release&apos;
    steps:
      - name: Bump version in files
        run: ./scripts/version.sh bump ${{ inputs.version_type }}
      - name: Commit &amp; Tag
        run: |
          git config user.email &quot;actions@github.com&quot;
          git config user.name &quot;GitHub Actions&quot;
          git add VERSION mix.exs
          git commit -m &quot;Release v$(cat VERSION) [skip ci]&quot;
          git tag -a &quot;v$(cat VERSION)&quot; -m &quot;Release v$(cat VERSION)&quot;
          git push origin main --tags
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: &quot;v$(cat VERSION)&quot;
          name: &quot;Release v$(cat VERSION)&quot;
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
E. Remove Redundant Workflow Files
After this:

Delete .github/workflows/adhoc.yml, automatic.yml, release.yml, test.yml.

Eliminate custom composite actions that duplicate build-and-test.yml steps.

F. Milestones &amp; Checklist

Task	Done
[ ] Create build-and-test.yml reusable workflow	
[ ] Create ci.yml to call the reusable workflow	
[ ] Add release job conditioned on mode == &apos;release&apos;	
[ ] Remove old adhoc/automatic/release/test workflow files	
[ ] Verify secrets and inputs are properly passed through	
[ ] Update README-GH-PAGES.md or docs to reflect new usage	
[ ] Confirm pipeline runs successfully on push, PR, manual	
By consolidating into one reusable build-and-test workflow and a thin orchestrator, youll drastically cut duplication, simplify maintenance, and make it easy to extend or debug your CI/CD pipelin</file><file path="docker-compose.yml">services:
  wanderer_notifier:
    image: guarzo/wanderer-notifier:v1
    container_name: wanderer-notifier
    restart: unless-stopped
    env_file:
      - .env
    ports:
      - &quot;${WANDERER_PORT:-4000}:4000&quot;
    deploy:
      resources:
        limits:
          memory: 512M
      restart_policy:
        condition: unless-stopped
    healthcheck:
      test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--no-verbose&quot;, &quot;--tries=1&quot;, &quot;--spider&quot;, &quot;http://localhost:4000/health&quot;]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 15s
    logging:
      driver: &quot;json-file&quot;
      options:
        max-size: &quot;10m&quot;
        max-file: &quot;3&quot;
    volumes:
      - wanderer_data:/app/data

volumes:
  wanderer_data:
    name: wanderer_data</file><file path="Dockerfile"># syntax=docker/dockerfile:1.4

# ----------------------------------------
# 0. BASE
# ----------------------------------------
FROM elixir:1.18-otp-27-slim AS base

ENV MIX_ENV=prod \
    LANG=C.UTF-8 \
    HOME=/app

WORKDIR /app

# ----------------------------------------
# 1. NODE STAGE
# ----------------------------------------
FROM node:18-slim AS node_builder
WORKDIR /renderer

# Install required fonts and dependencies for canvas
RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
    libcairo2-dev \
    libpango1.0-dev \
    libjpeg-dev \
    libgif-dev \
    librsvg2-dev \
    fonts-liberation \
    fonts-dejavu \
    fontconfig \
    &amp;&amp; apt-get clean \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Copy package files first for effective caching
COPY renderer/package*.json ./
RUN npm ci

# Copy the rest of the renderer code and build frontend assets
COPY renderer/ ./
RUN npm run build &amp;&amp; npm run postbuild

# Set up chart-service
WORKDIR /chart-service

# Copy package files first for effective caching
COPY chart-service/package*.json ./
RUN npm install

# Copy the rest of the chart-service code
COPY chart-service/ ./

# ----------------------------------------
# 2. DEPS STAGE
# ----------------------------------------
FROM base AS deps

# Update and install dependencies
RUN apt-get update -y &amp;&amp; \
    apt-get install -y --no-install-recommends \
        ca-certificates \
        build-essential \
        git

# Install hex and rebar
RUN mix local.hex --force &amp;&amp; \
    mix local.rebar --force

# Copy dependency files and fetch dependencies
COPY mix.exs mix.lock ./
RUN mix deps.get --only prod &amp;&amp; mix deps.compile

# ----------------------------------------
# 3. BUILDER STAGE
# ----------------------------------------
FROM deps AS builder

ARG WANDERER_NOTIFIER_API_TOKEN
ENV WANDERER_NOTIFIER_API_TOKEN=${WANDERER_NOTIFIER_API_TOKEN}

# Copy application code and configuration
COPY config config/
COPY lib lib/
COPY priv priv/
COPY rel rel/
COPY VERSION /app/version

# Copy built assets from the node stage&apos;s postbuild output (priv/static/app)
COPY --from=node_builder /renderer/dist/* /app/priv/static/app/

# Compile and build the release
RUN mix compile --warnings-as-errors &amp;&amp; \
    mix release --overwrite

# ----------------------------------------
# 4. RUNTIME STAGE
# ----------------------------------------
FROM elixir:1.18-otp-27-slim AS runtime

ENV LANG=C.UTF-8 \
    HOME=/app \
    MIX_ENV=prod

ARG WANDERER_NOTIFIER_API_TOKEN
ENV WANDERER_NOTIFIER_API_TOKEN=${WANDERER_NOTIFIER_API_TOKEN}

# Update and install runtime packages
RUN apt-get update -y &amp;&amp; \
    apt-get install -y --no-install-recommends \
        postgresql-client \
        openssl \
        ca-certificates \
        wget \
        lsof \
        net-tools \
        gnupg \
        curl \
        # Canvas dependencies
        libcairo2-dev \
        libpango1.0-dev \
        libjpeg-dev \
        libgif-dev \
        librsvg2-dev \
        fonts-liberation \
        fonts-dejavu \
        fontconfig &amp;&amp; \
    # Install Node.js
    curl -fsSL https://deb.nodesource.com/setup_18.x | bash - &amp;&amp; \
    apt-get install -y nodejs &amp;&amp; \
    # Clean up
    apt-get clean &amp;&amp; \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy the full release directory from the builder stage to /app/wanderer_notifier
COPY --from=builder /app/_build/prod/rel/wanderer_notifier /app/wanderer_notifier

# Create necessary directories with appropriate permissions
RUN mkdir -p /app/data/cache /app/data/backups /app/etc &amp;&amp; \
    chmod -R 777 /app/data

# Copy static assets from builder (if needed)
COPY --from=builder /app/priv/static /app/priv/static

# Copy chart-service from node builder
COPY --from=node_builder /chart-service /app/chart-service

# Copy runtime scripts and set executable permissions
COPY scripts/start_with_db.sh scripts/db_operations.sh /app/bin/
RUN chmod +x /app/bin/*.sh

COPY scripts/validate_and_start.sh /app/bin/validate_and_start.sh
RUN chmod +x /app/bin/validate_and_start.sh

# Create a symlink so that /app/bin/wanderer_notifier points to the release binary
RUN mkdir -p /app/bin &amp;&amp; \
    ln -s /app/wanderer_notifier/bin/wanderer_notifier /app/bin/wanderer_notifier

EXPOSE 4000
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD wget -q -O- http://localhost:4000/health || exit 1

ENTRYPOINT [&quot;/app/bin/validate_and_start.sh&quot;]
CMD [&quot;/app/bin/start_with_db.sh&quot;]</file><file path="index.md">---
layout: default
title: Wanderer Notifier
description: Get real-time EVE Online notifications directly to your Discord channel
---

# Wanderer Notifier

Wanderer Notifier delivers real-time alerts directly to your Discord channel, ensuring you never miss critical in-game events. Whether it&apos;s a significant kill, a newly tracked character, or a fresh system discovery, our notifier keeps you informed with rich, detailed notifications.

In the fast-paced universe of EVE Online, timely information can mean the difference between success and failure. When a hostile fleet enters your territory, when a high-value target appears in your hunting grounds, or when a new wormhole connection opens up valuable opportunities - knowing immediately gives you the edge. Wanderer Notifier bridges this information gap, bringing critical intel directly to your Discord where your team is already coordinating.

## Prerequisites

Before setting up Wanderer Notifier, ensure you have the following:

- A Discord server where you have administrator permissions
- Docker and Docker Compose installed on your system
- Basic knowledge of terminal/command line operations
- Your Wanderer map URL and API token
- A Discord bot token (see our [guide on creating a Discord bot](https://gist.github.com/guarzo/a4d238b932b6a168ad1c5f0375c4a561))

## How to Get Started

There are two ways to install Wanderer Notifier: a **Quick Install** option using a one-liner, or a **Manual Setup** for those who prefer step-by-step control.

### Quick Install Option

For a streamlined installation that creates the necessary directory and files automatically, run:

```bash
curl -fsSL https://gist.githubusercontent.com/guarzo/3f05f3c57005c3cf3585869212caecfe/raw/wanderer-notifier-setup.sh | bash
```

Once the script finishes, update the `wanderer-notifier/.env` file with your configuration values, then run the container. The setup includes a PostgreSQL database which is now required for the application to function properly.

### Manual Setup

If you&apos;d rather set up everything manually, follow these steps:

#### 1. Download the Docker Image

Pull the latest Docker image:

```bash
docker pull guarzo/wanderer-notifier:v1
```

#### 2. Configure Your Environment

Create a `.env` file in your working directory with the following content. Replace the placeholder values with your actual credentials:

```dotenv
# Discord Configuration
WANDERER_DISCORD_BOT_TOKEN=your_discord_bot_token
WANDERER_DISCORD_CHANNEL_ID=your_discord_channel_id

# Map Configuration
WANDERER_MAP_URL_WITH_NAME=&quot;https://wanderer.ltd/&lt;yourmap&gt;&quot;
WANDERER_MAP_TOKEN=your_map_api_token

# Note: Premium features are enabled with your map subscription
WANDERER_LICENSE_KEY=your_map_license_key  # Provided with your map subscription

# Feature Flags (default values shown below)
# WANDERER_FEATURE_KILL_NOTIFICATIONS=true
# WANDERER_FEATURE_CHARACTER_NOTIFICATIONS=true
# WANDERER_FEATURE_SYSTEM_NOTIFICATIONS=true
# WANDERER_DISABLE_STATUS_MESSAGES=false # Disable startup and status notifications
# WANDERER_FEATURE_TRACK_KSPACE=false  # Set to &apos;true&apos; to track K-Space systems in addition to wormholes
```


&gt; **Note:** If you don&apos;t have a Discord bot yet, follow our [guide on creating a Discord bot](https://gist.github.com/guarzo/a4d238b932b6a168ad1c5f0375c4a561) or search the web for more information.

#### 3. Create the Docker Compose Configuration

Create a file named `docker-compose.yml` with the following content:

```yaml
services:
  wanderer_notifier:
    image: guarzo/wanderer-notifier:v1
    container_name: wanderer-notifier
    restart: unless-stopped
    env_file:
      - .env
    ports:
      - &quot;${WANDERER_PORT:-4000}:4000&quot;
    deploy:
      resources:
        limits:
          memory: 512M
      restart_policy:
        condition: unless-stopped
    healthcheck:
      test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--no-verbose&quot;, &quot;--tries=1&quot;, &quot;--spider&quot;, &quot;http://localhost:4000/health&quot;]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 15s
    logging:
      driver: &quot;json-file&quot;
      options:
        max-size: &quot;10m&quot;
        max-file: &quot;3&quot;
    volumes:
      - wanderer_data:/app/data

volumes:
  wanderer_data:
    name: wanderer_data
```

#### 4. Run It

Start the service with Docker Compose:

```bash
docker-compose up -d
```

Your notifier is now up and running, delivering alerts to your Discord channel automatically!

## Configuration Validation

On startup, the application validates all configuration settings. If there are issues with your configuration, detailed error messages will be displayed in the logs to help you resolve them. This ensures that your notifier is properly configured before it begins operation.

## Features

- **Real-Time Monitoring:** Listens to live kill data via a WebSocket from ZKillboard
- **Data Enrichment:** Retrieves detailed killmail information from ESI
- **Map-Based Filtering:** Uses a custom map API to track wormhole systems (with option to include K-Space systems) and process only kills from systems you care about
- **Periodic Maintenance:** Automatically updates system data and processes backup kills
- **Discord Integration:** Sends beautifully formatted notifications to your Discord channel
- **Web Dashboard:** Access system status and notification statistics via the built-in web interface
- **Fault Tolerance:** Leverages Elixir&apos;s OTP and supervision trees for a robust and resilient system

[Learn more about notification types](./notifications.html)

[View on GitHub](https://github.com/guarzo/wanderer-notifier)</file><file path="Makefile"># Common Mix tasks for an Elixir project
.PHONY: compile clean test test.% format shell run deps.get deps.update build.npm dev watch

# ============================
# BUILD TASKS
# ============================
compile:
	@mix compile

compile.strict:
	@mix compile --warnings-as-errors

clean:
	@mix clean

# ============================
# TESTING AND FORMATTING TASKS
# ============================
test:
	@./test/run_tests.sh

# Pattern matching for test targets
test.%:
	@MIX_ENV=test mix test test/wanderer_notifier/$*_test.exs

test.all:
	@MIX_ENV=test mix test --trace

test.watch:
	@mix test.watch

test.cover:
	@mix test --cover

format:
	@mix format

# ============================
# RUNNING THE APPLICATION
# ============================
shell:
	@iex -S mix

run:
	@mix run

# ============================
# FRONTEND DEVELOPMENT TASKS
# ============================
# Build tasks for NPM components
build.npm: build.frontend

build.frontend:
	@echo &quot;Building frontend assets...&quot;
	@cd renderer &amp;&amp; npm run build


# Development commands with automatic asset rebuilding
dev: build.npm
	@iex -S mix

# Watch both frontend and start the application
watch:
	@echo &quot;Starting watchers for both Elixir and frontend with auto-sync...&quot;
	@(cd renderer &amp;&amp; npm run sync) &amp; (iex -S mix)

watch.frontend:
	@cd renderer &amp;&amp; npm run watch

# ============================
# DEPENDENCY MANAGEMENT
# ============================
deps.get:
	@mix deps.get

deps.update:
	@mix deps.update --all

# ============================
# PRODUCTION TASKS
# ============================
release:
	@MIX_ENV=prod mix release

# Build Docker image
docker.build:
	@docker build -t guarzo/wanderer-notifier:latest .

# Test Docker image
docker.test:
	@./scripts/test_docker_image.sh

# Build and test Docker image
docker: docker.build docker.test

# Generate version
version.get:
	@./scripts/version.sh get

version.bump:
	@./scripts/version.sh bump $(type)

version.update:
	@./scripts/version.sh update $(type)

# ============================
# SHORTCUTS
# ============================
# Alias for watch with initial clean+compile and npm build
s: clean compile build.npm
	@echo &quot;Starting watchers for both Elixir and frontend with auto-sync...&quot;
	@(cd renderer &amp;&amp; npm run sync) &amp; (iex -S mix)</file><file path="mix.exs">defmodule WandererNotifier.MixProject do
  use Mix.Project

  def project do
    [
      app: :wanderer_notifier,
      version: &quot;1.0.10&quot;,
      elixir: &quot;~&gt; 1.18&quot;,
      start_permanent: Mix.env() == :prod,
      deps: deps(),
      releases: releases(),
      elixirc_paths: elixirc_paths(Mix.env()),
      overrides: overrides()
    ]
  end

  # Specifies which paths to compile per environment
  defp elixirc_paths(:test), do: [&quot;lib&quot;, &quot;test/support&quot;]
  defp elixirc_paths(_), do: [&quot;lib&quot;]

  def application do
    [
      extra_applications: [:logger, :nostrum],
      mod: {WandererNotifier.Application, []},
      included_applications: [],
      env: [],
      registered: [],
      priv_dir: &quot;priv&quot;
    ]
  end

  defp deps do
    [
      {:dotenvy, &quot;~&gt; 1.1&quot;},
      {:httpoison, &quot;~&gt; 2.2&quot;},
      {:cachex, &quot;~&gt; 4.0&quot;},
      {:nostrum, &quot;~&gt; 0.10&quot;},
      {:websockex, &quot;~&gt; 0.4&quot;},
      {:jason, &quot;~&gt; 1.3&quot;},
      {:plug, &quot;~&gt; 1.14&quot;},
      {:plug_cowboy, &quot;~&gt; 2.6&quot;},
      {:mime, &quot;~&gt; 2.0&quot;},
      {:decimal, &quot;~&gt; 2.1&quot;},
      {:logger_file_backend, &quot;~&gt; 0.0.13&quot;},
      {:credo, &quot;~&gt; 1.7&quot;, only: [:dev, :test], runtime: false},
      {:bunt, &quot;~&gt; 0.2.1&quot;},
      {:exsync, &quot;~&gt; 0.2&quot;, only: :dev},
      {:mox, &quot;~&gt; 1.0&quot;, only: :test},
      {:crontab, &quot;~&gt; 1.1&quot;}
    ]
  end

  defp releases do
    [
      wanderer_notifier: [
        include_executables_for: [:unix],
        applications: [runtime_tools: :permanent],
        steps: [:assemble, :tar],
        validate_compile_env: false,
        overlays: [&quot;rel/overlays&quot;]
      ]
    ]
  end

  defp overrides do
    [
      {:ranch, &quot;2.1.0&quot;, override: true}
    ]
  end
end</file><file path="NOTIFICATION_TROUBLESHOOTING_PLAN.md"># Notification Troubleshooting Plan

This document outlines a comprehensive, step-by-step plan to troubleshoot and resolve notification issues after a major refactor.

---

## 1. Understand the Notification Flow

- What triggers each notification? (e.g., system/character added, killmail received)
- What is the expected notification output? (e.g., log, email, webhook, etc.)
- What are the main components involved? (e.g., event emitters, notification service/module, websocket handlers)

---

## 2. Check for Obvious Errors

- **Review logs** for errors or warnings related to notifications.
- **Check for exceptions** in the notification code paths.
- **Look for silent failures** (e.g., try/catch blocks that swallow errors).

---

## 3. Verify Notification Triggers

### a. System/Character Added

- Confirm that the code responsible for adding systems/characters still calls the notification logic.
- Add debug logs or breakpoints to ensure the notification function is invoked.

### b. Killmail Received

- Confirm the websocket handler is still receiving killmail events.
- Ensure the logic that checks for tracked characters/systems is still correct and being called.

---

## 4. Check Notification Dispatch Logic

- Ensure the notification dispatch function is being called with the correct parameters.
- Add debug logs to the entry and exit points of the notification dispatch function.
- If using a queue or async job, ensure jobs are being enqueued and processed.

---

## 5. Check Notification Delivery

- If notifications are sent via external services (email, webhook, etc.), ensure those services are reachable and responding.
- Check for configuration changes (API keys, endpoints, etc.) that may have broken after the refactor.

---

## 6. Test Each Notification Type in Isolation

- Manually trigger each notification type (system added, character added, killmail received).
- Use unit tests or direct function calls to verify the notification logic in isolation.

---

## 7. Review Refactor Changes

- Review the diff/commit history for the refactor, focusing on:
  - Event emission and handling
  - Notification service/module
  - Data models for systems, characters, and killmails
- Look for removed or changed function calls, renamed variables, or altered logic.

---

## 8. Check for Dependency Injection/Registration Issues

- If using dependency injection or service registration, ensure the notification service is still properly registered and injected where needed.

---

## 9. Check for Configuration/Environment Issues

- Ensure all environment variables and configuration files are correct post-refactor.
- Check for missing or changed config keys related to notifications.

---

## 10. Write/Run Automated Tests

- If not already present, write tests for each notification scenario.
- Run the full test suite to catch any missed edge cases.

---

## 11. Document and Fix

- As you find issues, document them and fix them one by one.
- After each fix, re-test the relevant notification flow.

---

## 12. Post-Fix Monitoring

- After resolving, add extra logging/monitoring to notification flows to catch future regressions early.

---

## Summary Table

| Step | What to Check     | How to Check              |
| ---- | ----------------- | ------------------------- |
| 1    | Notification flow | Review code/docs          |
| 2    | Errors            | Logs, error handling      |
| 3    | Triggers          | Debug logs, breakpoints   |
| 4    | Dispatch logic    | Logs, function calls      |
| 5    | Delivery          | Service health, config    |
| 6    | Isolated tests    | Unit tests, manual calls  |
| 7    | Refactor changes  | Code diff, commit history |
| 8    | DI/Registration   | Service registration      |
| 9    | Config/env        | Env vars, config files    |
| 10   | Automated tests   | Write/run tests           |
| 11   | Document/fix      | Track and resolve         |
| 12   | Monitoring        | Add logs/alerts           |</file><file path="notifications.md">---
layout: default
title: Notification Types - Wanderer Notifier
description: Learn about the different types of notifications provided by Wanderer Notifier
---

# Notification Types

Wanderer Notifier supports three main notification types, each tailored based on your map subscription status. The first notification sent on application startup is always in rich format, regardless of subscription status.

## Kill Notifications

When a kill occurs in a tracked system or involves a tracked character:

### With Premium Map Subscription

Receives a rich embed that includes:
- **Visual Elements:**
  - Ship thumbnail image from ESI
  - Character portraits for victim 
  - Corporation logos if available
  
- **Victim Information:**
  - Character name with clickable link to zKillboard profile
  - Corporation name and alliance (if applicable)
  - Ship type lost with icon
  
- **Attack Information:**
  - Number of attackers involved
  - Final blow details with clickable link to zKillboard
  - Final blow ship type
  
- **Kill Details:**
  - System name where kill occurred
  - ISK value of the kill formatted appropriately
  - Timestamp of the kill
  - Kill ID with link to zKillboard

![Premium Kill Notification Example](./assets/images/paid-kill.png)

### With Free Map

Displays a basic text notification containing:
- Victim name
- Ship type lost
- System name
- Simplified format without images or embeds

![Free Kill Notification Example](./assets/images/free-kill.png)

### Data Sources
- Initial kill data from zKillboard WebSocket
- Enrichment from ESI for character, corporation, and ship details
- Additional details from zkillboard API when needed

## Character Tracking Notifications

When a new character is added to your tracked list:

### With Premium Map Subscription

You get a rich embed featuring:
- **Visual Elements:**
  - Character portrait from EVE Image Server
  
- **Character Information:**
  - Character name with link to zKillboard profile
  - Character EVE ID for reference
  - Corporation name and ticker
  - Alliance name (if applicable)
  
- **Metadata:**
  - Formatted timestamp of when character was added
  - Clear visual formatting with appropriate color scheme

![Premium Character Notification Example](./assets/images/paid-character.png)

### With Free Map

Receives a simple text notification that includes:
- Character name
- Corporation name and ticker (if available)
- No images or rich formatting

![Free Character Notification Example](./assets/images/free-character.png)

### Data Sources
- Initial character data from Map API
- Enrichment from ESI for character and corporation details
- Corporation name fallback to ticker if full name unavailable

## System Notifications

When a new system is discovered or added to your map:

### With Premium Map Subscription

Shows a rich embed with:
- **Visual Elements:**
  - System type icon (appropriate for wormhole class, highsec, lowsec, or nullsec)
  - Color coding based on system type and security status
  
- **System Information:**
  - System name (including aliases/temporary names)
  - System ID with link to zKillboard
  - Security status and system type description
  
- **Space-Type Specific Details:**
  - **For Wormholes:**
    - Wormhole class (C1-C6, Thera, etc.)
    - Static wormhole connections listed with destination types
    - Effect information (Red Giant, Black Hole, etc.)
    - Shattered status if applicable
  
  - **For Known Space:**
    - Region name with link to Dotlan
    - Security classification (High-sec, Low-sec, Null-sec)
    - Sovereignty information if available
  
- **Activity Information:**
  - Recent kills in the system from zKillboard
  - For each kill: victim, ship type, value, and time
  - Links to individual killmails

![Premium System Notification Example](./assets/images/paid-system.png)

### With Free Map

Provides a basic text notification including:
- Original system name (for wormholes)
- System name (for k-space)
- Minimal type information (wormhole/k-space)

![Free System Notification Example](./assets/images/free-system.png)

### Data Sources
- Initial system data from Map API
- Static system information from Map API or internal database
- Kill data enrichment from zKillboard API
- Region information from ESI when needed

## Special First Message Behavior

The very first notification of each type sent after application startup is always sent in rich format with full details, regardless of license/subscription status. This helps demonstrate the premium features available with a valid license.

## Web Dashboard

Wanderer Notifier includes a web dashboard that provides real-time insights into your notification system:

- **Access:** Visit `http://localhost:4000` to view the dashboard.
- **System Status:** Monitor system details, subscription information, and notification statistics.
- **Resource Monitoring:** Keep an eye on resource usage and feature availability.
- **Notification Testing:** Test notifications directly from the dashboard.

Premium map subscribers also gain access to detailed statistics and advanced visualization tools.

![Dashboard](./assets/images/dashboard.png)

## Configuration Options

Customize your notification experience with several configuration options available through environment variables.

### Notification Control Variables

- **ENABLE_KILL_NOTIFICATIONS:** Enable/disable kill notifications (default: true).
- **ENABLE_CHARACTER_TRACKING:** Enable/disable character tracking (default: true).
- **ENABLE_CHARACTER_NOTIFICATIONS:** Enable/disable notifications when new characters are added (default: true).
- **ENABLE_SYSTEM_NOTIFICATIONS:** Enable/disable system notifications (default: true).


To disable a notification type, set the corresponding variable to `false` or `0` in your `.env` file:

```dotenv
# Example: Disable kill notifications while keeping other notifications enabled
ENABLE_KILL_NOTIFICATIONS=false
```

## Troubleshooting

If you encounter issues with Wanderer Notifier, here are solutions to common problems:

### No Notifications Appearing

1. **Check Bot Permissions:** Ensure your bot has the &quot;Send Messages&quot; and &quot;Embed Links&quot; permissions in the Discord channel.
2. **Verify Channel ID:** Double-check your DISCORD_CHANNEL_ID in the .env file.
3. **Check Container Logs:** Run `docker logs wanderer_notifier` to see if there are any error messages.
4. **Test API Connection:** Visit `http://localhost:4000/health` to verify the service is running.

### Connection Issues

1. **Network Configuration:** Ensure port 4000 is not blocked by your firewall.
2. **Docker Status:** Run `docker ps` to verify the container is running.
3. **Restart Service:** Try `docker-compose restart` to refresh the connection.

### Subscription Not Recognized

1. **Check Map Token:** Ensure your MAP_TOKEN is correct and associated with your map.
2. **Verify LICENSE_KEY:** Make sure you&apos;ve entered the correct map subscription key in your .env file.
3. **Verify Status:** Check the dashboard at `http://localhost:4000` to see subscription status.
4. **Restart After Subscribing:** If you&apos;ve recently subscribed, restart the notifier with `docker-compose restart`.

For additional support, join our [Discord community](https://discord.gg/wanderer)

[Back to home](./index.html) | [See subscription options](https://wanderer.ltd/news/map-subscriptions) | [View on GitHub](https://github.com/guarzo/wanderer-notifier)</file><file path="originalformatter.ex">defmodule WandererNotifier.Notifiers.StructuredFormatter do
  @moduledoc &quot;&quot;&quot;
  Structured notification formatting utilities for Discord notifications.

  This module provides standardized formatting specifically designed to work with
  the domain data structures like Character, MapSystem, and Killmail.
  It eliminates the complex extraction logic of the original formatter by relying
  on the structured data provided by these schemas.
  &quot;&quot;&quot;

  alias WandererNotifier.Api.Map.SystemStaticInfo
  alias WandererNotifier.Data.{Character, MapSystem}
  alias WandererNotifier.Data.Killmail
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Get configured services
  defp zkill_service, do: Application.get_env(:wanderer_notifier, :zkill_service)
  defp esi_service, do: Application.get_env(:wanderer_notifier, :esi_service)

  # Color constants for Discord notifications
  # Default blue
  @default_color 0x3498DB
  # Green
  @success_color 0x2ECC71
  # Orange
  @warning_color 0xF39C12
  # Red
  @error_color 0xE74C3C
  # Blue
  @info_color 0x3498DB

  # Wormhole and security colors
  # Blue for Pulsar
  @wormhole_color 0x428BCA
  # Green for highsec
  @highsec_color 0x5CB85C
  # Yellow/orange for lowsec
  @lowsec_color 0xE28A0D
  # Red for nullsec
  @nullsec_color 0xD9534F

  # System notification icons
  # Wormhole icon
  @wormhole_icon &quot;https://images.evetech.net/types/45041/icon&quot;
  # Highsec icon
  @highsec_icon &quot;https://images.evetech.net/types/3802/icon&quot;
  # Lowsec icon
  @lowsec_icon &quot;https://images.evetech.net/types/3796/icon&quot;
  # Nullsec icon
  @nullsec_icon &quot;https://images.evetech.net/types/3799/icon&quot;
  # Default icon
  @default_icon &quot;https://images.evetech.net/types/3802/icon&quot;

  @doc &quot;&quot;&quot;
  Returns a standardized set of colors for notification embeds.

  ## Returns
    - A map with color constants for various notification types
  &quot;&quot;&quot;
  def colors do
    %{
      default: @default_color,
      success: @success_color,
      warning: @warning_color,
      error: @error_color,
      info: @info_color,
      wormhole: @wormhole_color,
      highsec: @highsec_color,
      lowsec: @lowsec_color,
      nullsec: @nullsec_color
    }
  end

  @doc &quot;&quot;&quot;
  Converts a color in one format to Discord format.

  ## Parameters
    - color: The color to convert (atom, integer, or hex string)

  ## Returns
    - The color in Discord format (integer)
  &quot;&quot;&quot;
  def convert_color(color) when is_atom(color) do
    Map.get(colors(), color, @default_color)
  end

  def convert_color(color) when is_integer(color), do: color

  def convert_color(&quot;#&quot; &lt;&gt; hex) do
    {color, _} = Integer.parse(hex, 16)
    color
  end

  def convert_color(_color), do: @default_color

  @doc &quot;&quot;&quot;
  Creates a standard formatted kill notification embed/attachment from a Killmail struct.
  Returns data in a generic format that can be converted to platform-specific format.

  ## Parameters
    - killmail: The Killmail struct

  ## Returns
    - A generic structured map that can be converted to platform-specific format
  &quot;&quot;&quot;
  def format_kill_notification(%Killmail{} = killmail) do
    # Log the structure of the killmail for debugging
    log_killmail_data(killmail)

    # Extract basic kill information
    kill_id = killmail.killmail_id
    kill_time = Map.get(killmail.esi_data || %{}, &quot;killmail_time&quot;)

    # Extract victim information
    victim_info = extract_victim_info(killmail)

    # Extract system, value and attackers info
    kill_context = extract_kill_context(killmail)

    # Final blow details
    final_blow_details = get_final_blow_details(killmail)

    # Build notification fields
    fields = build_kill_notification_fields(victim_info, kill_context, final_blow_details)

    # Build a platform-agnostic structure
    build_kill_notification(
      kill_id,
      kill_time,
      victim_info,
      kill_context,
      final_blow_details,
      fields
    )
  end

  # Log killmail data for debugging
  defp log_killmail_data(killmail) do
    AppLogger.processor_debug(
      &quot;[StructuredFormatter] Formatting killmail: #{inspect(killmail, limit: 200)}&quot;
    )
  end

  # Extract victim information
  defp extract_victim_info(killmail) do
    victim = Killmail.get_victim(killmail) || %{}

    victim_name = Map.get(victim, &quot;character_name&quot;, &quot;Unknown Pilot&quot;)
    victim_ship = Map.get(victim, &quot;ship_type_name&quot;, &quot;Unknown Ship&quot;)
    victim_corp = Map.get(victim, &quot;corporation_name&quot;, &quot;Unknown Corp&quot;)
    victim_alliance = Map.get(victim, &quot;alliance_name&quot;)
    victim_ship_type_id = Map.get(victim, &quot;ship_type_id&quot;)
    victim_character_id = Map.get(victim, &quot;character_id&quot;)

    # Log extracted values
    AppLogger.processor_debug(&quot;[StructuredFormatter] Extracted victim_name: #{victim_name}&quot;)
    AppLogger.processor_debug(&quot;[StructuredFormatter] Extracted victim_ship: #{victim_ship}&quot;)

    %{
      name: victim_name,
      ship: victim_ship,
      corp: victim_corp,
      alliance: victim_alliance,
      ship_type_id: victim_ship_type_id,
      character_id: victim_character_id
    }
  end

  # Extract kill context (system, value, attackers)
  defp extract_kill_context(killmail) do
    # System name and ID
    system_name = Map.get(killmail.esi_data || %{}, &quot;solar_system_name&quot;, &quot;Unknown System&quot;)
    system_id = Map.get(killmail.esi_data || %{}, &quot;solar_system_id&quot;)

    AppLogger.processor_debug(&quot;[StructuredFormatter] Extracted system_name: #{system_name}&quot;)

    # Get system security status if possible
    security_status = get_system_security_status(system_id)
    security_formatted = format_security_status(security_status)

    # Kill value
    zkb = killmail.zkb || %{}
    kill_value = Map.get(zkb, &quot;totalValue&quot;, 0)
    formatted_value = format_isk_value(kill_value)

    # Attackers information
    attackers = Map.get(killmail.esi_data || %{}, &quot;attackers&quot;, [])
    attackers_count = length(attackers)

    %{
      system_name: system_name,
      system_id: system_id,
      security_status: security_status,
      security_formatted: security_formatted,
      formatted_value: formatted_value,
      attackers_count: attackers_count,
      is_npc_kill: Map.get(zkb, &quot;npc&quot;, false) == true
    }
  end

  # Get system security status from ESI if possible
  defp get_system_security_status(nil), do: nil

  defp get_system_security_status(system_id) do
    case SystemStaticInfo.get_system_static_info(system_id) do
      {:ok, static_info} -&gt;
        data = Map.get(static_info, &quot;data&quot;, %{})

        # Return a map with both the security status value and type description
        %{
          value: Map.get(data, &quot;security&quot;),
          type: Map.get(data, &quot;type_description&quot;)
        }

      _ -&gt;
        nil
    end
  end

  # Format security status for display
  defp format_security_status(nil), do: nil

  # Handle the case where we have a map with both security value and type
  defp format_security_status(%{value: value, type: type}) when not is_nil(type) do
    # If we have a pre-defined type from static data, use it
    if is_binary(value) do
      # Also include the numerical value
      &quot;#{type} (#{value})&quot;
    else
      type
    end
  end

  defp format_security_status(%{value: value}) when not is_nil(value) do
    # If we only have the value but not the type, fall back to the old method
    format_security_status(value)
  end

  defp format_security_status(security) when is_binary(security) do
    # Try to parse as float
    case Float.parse(security) do
      {value, _} -&gt; format_security_status(value)
      :error -&gt; security
    end
  end

  defp format_security_status(security) when is_float(security) do
    cond do
      security &gt;= 0.5 -&gt; &quot;High-sec (#{Float.round(security, 1)})&quot;
      security &gt; 0.0 -&gt; &quot;Low-sec (#{Float.round(security, 1)})&quot;
      security &lt;= 0.0 -&gt; &quot;Null-sec (#{Float.round(security, 1)})&quot;
      true -&gt; nil
    end
  end

  defp format_security_status(_), do: nil

  # Get final blow details
  defp get_final_blow_details(killmail) do
    attackers = Map.get(killmail.esi_data || %{}, &quot;attackers&quot;, [])
    zkb = killmail.zkb || %{}

    # Find final blow attacker
    final_blow_attacker =
      Enum.find(attackers, fn attacker -&gt;
        Map.get(attacker, &quot;final_blow&quot;) in [true, &quot;true&quot;]
      end)

    is_npc_kill = Map.get(zkb, &quot;npc&quot;, false) == true

    # Extract final blow details
    extract_final_blow_details(final_blow_attacker, is_npc_kill)
  end

  # Build kill notification fields
  defp build_kill_notification_fields(victim_info, kill_context, final_blow_details) do
    # Base fields that are always present
    base_fields = [
      %{name: &quot;Value&quot;, value: kill_context.formatted_value, inline: true},
      %{name: &quot;Attackers&quot;, value: &quot;#{kill_context.attackers_count}&quot;, inline: true},
      %{name: &quot;Final Blow&quot;, value: final_blow_details.text, inline: true}
    ]

    # Add alliance field if available
    if victim_info.alliance do
      base_fields ++ [%{name: &quot;Alliance&quot;, value: victim_info.alliance, inline: true}]
    else
      # If no alliance, add location to keep the field count consistent
      system_with_link =
        if kill_context.system_id do
          &quot;[#{kill_context.system_name}](https://zkillboard.com/system/#{kill_context.system_id}/)&quot;
        else
          kill_context.system_name
        end

      base_fields ++ [%{name: &quot;Location&quot;, value: system_with_link, inline: true}]
    end
  end

  # Extract final blow details from attacker data
  defp extract_final_blow_details(nil, true) do
    # This is an NPC kill
    %{text: &quot;NPC&quot;, icon_url: nil}
  end

  defp extract_final_blow_details(nil, _) do
    # No final blow attacker found
    %{text: &quot;Unknown&quot;, icon_url: nil}
  end

  defp extract_final_blow_details(attacker, _) do
    # Get character and ship details
    character_name = Map.get(attacker, &quot;character_name&quot;, &quot;Unknown&quot;)
    ship_name = Map.get(attacker, &quot;ship_type_name&quot;, &quot;Unknown Ship&quot;)
    character_id = Map.get(attacker, &quot;character_id&quot;)

    # Format the final blow text
    text = &quot;#{character_name} (#{ship_name})&quot;

    # Determine icon URL
    icon_url =
      if character_id do
        &quot;https://imageserver.eveonline.com/Character/#{character_id}_64.jpg&quot;
      else
        nil
      end

    %{text: text, icon_url: icon_url}
  end

  # Build the kill notification structure
  defp build_kill_notification(
         kill_id,
         kill_time,
         victim_info,
         kill_context,
         _final_blow_details,
         fields
       ) do
    AppLogger.processor_debug(&quot;Building kill notification for kill #{kill_id}&quot;)

    # Determine author name
    author_name =
      if victim_info.name == &quot;Unknown Pilot&quot; and victim_info.corp == &quot;Unknown Corp&quot; do
        &quot;Kill in #{kill_context.system_name}&quot;
      else
        &quot;#{victim_info.name} (#{victim_info.corp})&quot;
      end

    # Determine author icon URL
    author_icon_url =
      if victim_info.name == &quot;Unknown Pilot&quot; and victim_info.corp == &quot;Unknown Corp&quot; do
        &quot;https://images.evetech.net/types/30_371/icon&quot;
      else
        if victim_info.character_id do
          &quot;https://imageserver.eveonline.com/Character/#{victim_info.character_id}_64.jpg&quot;
        else
          nil
        end
      end

    # Determine thumbnail URL
    thumbnail_url =
      if victim_info.ship_type_id do
        &quot;https://images.evetech.net/types/#{victim_info.ship_type_id}/render&quot;
      else
        nil
      end

    # Create system link if system ID is available
    system_with_link =
      if kill_context.system_id do
        &quot;[#{kill_context.system_name}](https://zkillboard.com/system/#{kill_context.system_id}/)&quot;
      else
        kill_context.system_name
      end

    # Enhanced description with linked system name
    description = &quot;#{victim_info.name} lost a #{victim_info.ship} in #{system_with_link}&quot;

    # Build the notification
    %{
      type: :kill_notification,
      title: &quot;Kill Notification&quot;,
      description: description,
      color: @error_color,
      url: &quot;https://zkillboard.com/kill/#{kill_id}/&quot;,
      timestamp: kill_time,
      footer: %{
        text: &quot;Kill ID: #{kill_id}&quot;
      },
      thumbnail: %{
        url: thumbnail_url
      },
      author: %{
        name: author_name,
        icon_url: author_icon_url
      },
      fields: fields
    }
  end

  @doc &quot;&quot;&quot;
  Creates a standard formatted new tracked character notification from a Character struct.

  ## Parameters
    - character: The Character struct

  ## Returns
    - A Discord-formatted embed for the notification
  &quot;&quot;&quot;
  def format_character_notification(%Character{} = character) do
    # Build notification structure
    %{
      type: :character_notification,
      title: &quot;New Character Tracked&quot;,
      description: &quot;A new character has been added to the tracking list.&quot;,
      color: @info_color,
      timestamp: DateTime.utc_now() |&gt; DateTime.to_iso8601(),
      thumbnail: %{
        url: &quot;https://imageserver.eveonline.com/Character/#{character.character_id}_128.jpg&quot;
      },
      fields:
        [
          %{
            name: &quot;Character&quot;,
            value:
              &quot;[#{character.name}](https://zkillboard.com/character/#{character.character_id}/)&quot;,
            inline: true
          }
        ] ++
          if Character.has_corporation?(character) do
            corporation_link =
              &quot;[#{character.corporation_ticker}](https://zkillboard.com/corporation/#{character.corporation_id}/)&quot;

            AppLogger.processor_info(
              &quot;[StructuredFormatter] Adding corporation field with value: #{corporation_link}&quot;
            )

            [%{name: &quot;Corporation&quot;, value: corporation_link, inline: true}]
          else
            AppLogger.processor_info(
              &quot;[StructuredFormatter] No corporation data available for inclusion&quot;
            )

            []
          end
    }
  end

  @doc &quot;&quot;&quot;
  Creates a standard formatted system notification from a MapSystem struct.

  ## Parameters
    - system: The MapSystem struct

  ## Returns
    - A generic structured map that can be converted to platform-specific format
  &quot;&quot;&quot;
  def format_system_notification(%MapSystem{} = system) do
    # Validate required fields
    validate_system_fields(system)

    # Generate basic notification elements
    is_wormhole = MapSystem.wormhole?(system)
    display_name = MapSystem.format_display_name(system)

    # Generate notification elements
    {title, description, color, icon_url} =
      generate_notification_elements(system, is_wormhole, display_name)

    # Format statics list and system link
    formatted_statics = format_statics_list(system.static_details || system.statics)
    system_name_with_link = create_system_name_link(system, display_name)

    # Build notification fields
    fields =
      build_system_notification_fields(
        system,
        is_wormhole,
        formatted_statics,
        system_name_with_link
      )

    # Create the generic notification structure
    %{
      type: :system_notification,
      title: title,
      description: description,
      color: color,
      timestamp: DateTime.utc_now() |&gt; DateTime.to_iso8601(),
      thumbnail: %{url: icon_url},
      fields: fields,
      footer: %{
        text: &quot;System ID: #{system.solar_system_id}&quot;
      }
    }
  rescue
    e -&gt;
      AppLogger.processor_error(&quot;[StructuredFormatter] Error formatting system notification&quot;,
        system: system.name,
        error: Exception.message(e),
        stacktrace: Exception.format_stacktrace(__STACKTRACE__)
      )

      reraise e, __STACKTRACE__
  end

  # Helper function to validate required system fields
  defp validate_system_fields(system) do
    if is_nil(system.solar_system_id) do
      raise &quot;Cannot format system notification: solar_system_id is missing in MapSystem struct&quot;
    end

    if is_nil(system.name) do
      raise &quot;Cannot format system notification: name is missing in MapSystem struct&quot;
    end
  end

  # Generate notification elements (title, description, color, icon)
  defp generate_notification_elements(system, is_wormhole, display_name) do
    title = generate_system_title(display_name)

    description =
      generate_system_description(is_wormhole, system.class_title, system.type_description)

    system_color = determine_system_color(system.type_description, is_wormhole)
    icon_url = determine_system_icon(is_wormhole, system.type_description, system.sun_type_id)

    {title, description, system_color, icon_url}
  end

  # Create system name with zkillboard link
  defp create_system_name_link(system, display_name) do
    has_numeric_id =
      is_integer(system.solar_system_id) ||
        (is_binary(system.solar_system_id) &amp;&amp; Integer.parse(system.solar_system_id) != :error)

    if has_numeric_id do
      system_id_str = to_string(system.solar_system_id)

      has_temp_and_original =
        system.temporary_name &amp;&amp; system.temporary_name != &quot;&quot; &amp;&amp;
          system.original_name &amp;&amp; system.original_name != &quot;&quot;

      if has_temp_and_original do
        &quot;[#{system.temporary_name} (#{system.original_name})](https://zkillboard.com/system/#{system_id_str}/)&quot;
      else
        &quot;[#{system.name}](https://zkillboard.com/system/#{system_id_str}/)&quot;
      end
    else
      display_name
    end
  end

  # Build notification fields
  defp build_system_notification_fields(
         system,
         is_wormhole,
         formatted_statics,
         system_name_with_link
       ) do
    fields = [%{name: &quot;System&quot;, value: system_name_with_link, inline: true}]
    fields = add_shattered_field(fields, is_wormhole, system.is_shattered)
    fields = add_statics_field(fields, is_wormhole, formatted_statics)
    fields = add_region_field(fields, system.region_name)
    fields = add_effect_field(fields, is_wormhole, system.effect_name)
    fields = add_zkill_system_kills(fields, system.solar_system_id)
    fields
  end

  # Add recent kills from ZKill API
  defp add_zkill_system_kills(fields, system_id) do
    system_id_int = parse_system_id(system_id)

    if is_nil(system_id_int) do
      fields
    else
      case zkill_service().get_system_kills(system_id_int, 3) do
        {:ok, []} -&gt; fields
        {:ok, zkill_kills} when is_list(zkill_kills) -&gt; process_kill_data(fields, zkill_kills)
        {:error, _} -&gt; fields
      end
    end
  end

  # Helper for parsing system_id
  defp parse_system_id(id) when is_binary(id) do
    case Integer.parse(id) do
      {int_val, _} -&gt; int_val
      :error -&gt; nil
    end
  end

  defp parse_system_id(id) when is_integer(id), do: id
  defp parse_system_id(_), do: nil

  defp generate_system_title(display_name) when is_binary(display_name) and display_name != &quot;&quot; do
    &quot;New System Mapped: #{display_name}&quot;
  end

  defp generate_system_title(_) do
    &quot;New System Mapped&quot;
  end

  defp generate_system_description(true, class_title, _)
       when is_binary(class_title) and class_title != &quot;&quot; do
    &quot;#{class_title} wormhole added to the map.&quot;
  end

  defp generate_system_description(true, _, _) do
    &quot;Wormhole added to the map.&quot;
  end

  defp generate_system_description(_, _, type_description)
       when is_binary(type_description) and type_description != &quot;&quot; do
    &quot;#{type_description} system added to the map.&quot;
  end

  defp generate_system_description(_, _, _) do
    &quot;New system added to the map.&quot;
  end

  # Helper to determine system icon URL based on MapSystem data
  defp determine_system_icon(is_wormhole, type_description, sun_type_id) do
    sun_id = parse_sun_type_id(sun_type_id)

    if sun_id &amp;&amp; sun_id &gt; 0 do
      &quot;https://images.evetech.net/types/#{sun_id}/icon&quot;
    else
      get_system_type_icon(is_wormhole, type_description)
    end
  end

  # Helper to get the appropriate icon based on system type
  defp get_system_type_icon(is_wormhole, type_description) do
    cond do
      is_wormhole -&gt; @wormhole_icon
      type_description &amp;&amp; String.contains?(type_description, &quot;High-sec&quot;) -&gt; @highsec_icon
      type_description &amp;&amp; String.contains?(type_description, &quot;Low-sec&quot;) -&gt; @lowsec_icon
      type_description &amp;&amp; String.contains?(type_description, &quot;Null-sec&quot;) -&gt; @nullsec_icon
      true -&gt; @default_icon
    end
  end

  # Helper to parse sun_type_id values which might be strings
  defp parse_sun_type_id(nil), do: nil
  defp parse_sun_type_id(id) when is_integer(id), do: id

  defp parse_sun_type_id(id) when is_binary(id) do
    case Integer.parse(id) do
      {int_val, _} -&gt; int_val
      :error -&gt; nil
    end
  end

  defp parse_sun_type_id(_), do: nil

  # Helper to determine system color based on type_description and is_wormhole
  defp determine_system_color(type_description, is_wormhole) do
    cond do
      is_wormhole -&gt; @wormhole_color
      type_description &amp;&amp; String.contains?(type_description, &quot;High-sec&quot;) -&gt; @highsec_color
      type_description &amp;&amp; String.contains?(type_description, &quot;Low-sec&quot;) -&gt; @lowsec_color
      type_description &amp;&amp; String.contains?(type_description, &quot;Null-sec&quot;) -&gt; @nullsec_color
      true -&gt; @default_color
    end
  end

  # Format a list of statics for system notification with clear error handling
  defp format_statics_list(nil) do
    AppLogger.processor_debug(&quot;[StructuredFormatter.format_statics_list] Nil statics list&quot;)
    &quot;None&quot;
  end

  defp format_statics_list([]) do
    AppLogger.processor_debug(&quot;[StructuredFormatter.format_statics_list] Empty statics list&quot;)
    &quot;None&quot;
  end

  defp format_statics_list(statics) when is_list(statics) do
    formatted =
      Enum.map(statics, fn static -&gt;
        format_single_static(static)
      end)
      |&gt; Enum.reject(&amp;is_nil/1)
      |&gt; Enum.join(&quot;, &quot;)

    if formatted == &quot;&quot; do
      &quot;None&quot;
    else
      formatted
    end
  end

  # Formats a single static wormhole for display
  # Handles both map and struct formats
  defp format_single_static(static) when is_map(static) do
    cond do
      has_destination_info?(static) -&gt; format_static_with_destination(static)
      has_name_info?(static) -&gt; get_static_name(static)
      is_binary(static) -&gt; static
      true -&gt; log_unrecognized_static(static)
    end
  end

  defp format_single_static(static) when is_binary(static) do
    static
  end

  defp format_single_static(static) do
    log_unrecognized_static(static)
  end

  # Helper function to check if static has destination info
  defp has_destination_info?(static) do
    Map.has_key?(static, &quot;destination&quot;) || Map.has_key?(static, :destination)
  end

  # Helper function to check if static has name info
  defp has_name_info?(static) do
    Map.has_key?(static, &quot;name&quot;) || Map.has_key?(static, :name)
  end

  # Helper function to get static name
  defp get_static_name(static) do
    Map.get(static, &quot;name&quot;) || Map.get(static, :name)
  end

  # Helper function to format static with destination info
  defp format_static_with_destination(static) do
    name = get_static_name(static)
    destination = Map.get(static, &quot;destination&quot;) || Map.get(static, :destination)
    dest_short = get_in(destination, [&quot;short_name&quot;]) || get_in(destination, [:short_name])

    if name &amp;&amp; dest_short do
      &quot;#{name} (#{dest_short})&quot;
    else
      name
    end
  end

  # Helper function to log unrecognized static format
  defp log_unrecognized_static(static) do
    AppLogger.processor_warn(
      &quot;[StructuredFormatter.format_single_static] Unrecognized static format: #{inspect(static)}&quot;
    )

    nil
  end

  # Formats ISK value for display
  defp format_isk_value(value) when is_float(value) or is_integer(value) do
    cond do
      value &lt; 1000 -&gt; &quot;&lt;1k ISK&quot;
      value &lt; 1_000_000 -&gt; &quot;#{custom_round(value / 1000)}k ISK&quot;
      true -&gt; &quot;#{custom_round(value / 1_000_000)}M ISK&quot;
    end
  end

  defp format_isk_value(_), do: &quot;0 ISK&quot;

  # Round a float to the nearest integer
  defp custom_round(float) when is_float(float), do: trunc(float + 0.5)
  defp custom_round(int) when is_integer(int), do: int

  # Get application version from Version module
  defp get_app_version do
    # Use our new Version module which reads the version from mix.exs at compile time
    # This eliminates the need for environment variables for versioning
    WandererNotifier.Config.Version.version()
  end

  @doc &quot;&quot;&quot;
  Creates a rich formatted status/startup message with enhanced visual elements.

  ## Parameters
    - title: The title for the message (e.g., &quot;WandererNotifier Started&quot; or &quot;Service Status Report&quot;)
    - description: Brief description of the message purpose
    - stats: The stats map containing notification counts and websocket info
    - uptime: Optional uptime in seconds (for status messages, nil for startup)
    - features_status: Map of feature statuses
    - license_status: Map with license information
    - systems_count: Number of tracked systems
    - characters_count: Number of tracked characters

  ## Returns
    - A generic structured map that can be converted to platform-specific format
  &quot;&quot;&quot;
  def format_system_status_message(
        title,
        description,
        stats,
        uptime \\ nil,
        features_status,
        license_status,
        systems_count,
        characters_count
      ) do
    AppLogger.processor_info(&quot;[StructuredFormatter] Creating status message with title: #{title}&quot;)

    # Prepare all the data needed for the status message
    uptime_str = format_uptime(uptime)
    license_icon = get_license_icon(license_status)
    websocket_icon = get_websocket_status_icon(stats)
    notification_info = get_notification_info(stats)
    formatted_features = format_feature_statuses(features_status)

    # Prepare fields data as a map to reduce parameter count
    notification_data = %{
      title: title,
      description: description,
      uptime_str: uptime_str,
      license_icon: license_icon,
      websocket_icon: websocket_icon,
      systems_count: systems_count,
      characters_count: characters_count,
      notification_info: notification_info,
      formatted_features: formatted_features
    }

    # Build the response structure
    build_status_notification(notification_data)
  end

  # Format uptime for display
  defp format_uptime(nil), do: &quot; Just started&quot;

  defp format_uptime(uptime) do
    days = div(uptime, 86_400)
    hours = div(rem(uptime, 86_400), 3600)
    minutes = div(rem(uptime, 3600), 60)
    seconds = rem(uptime, 60)
    &quot; #{days}d #{hours}h #{minutes}m #{seconds}s&quot;
  end

  # Get license icon based on validity and premium status
  defp get_license_icon(license_status) do
    # Since premium tier is removed, we only check for license validity
    if license_status.valid do
      &quot;&quot;
    else
      &quot;&quot;
    end
  end

  # Get notification info string
  defp get_notification_info(stats) do
    if Map.has_key?(stats, :notifications) do
      format_notification_counts(stats.notifications)
    else
      &quot;No notifications sent yet&quot;
    end
  end

  # Extract and format feature statuses
  defp format_feature_statuses(features_status) do
    # Extract primary feature statuses
    primary_features = %{
      kill_notifications: Map.get(features_status, :kill_notifications_enabled, true),
      tracked_systems_notifications: Map.get(features_status, :system_tracking_enabled, true),
      tracked_characters_notifications:
        Map.get(features_status, :character_tracking_enabled, true),
      activity_charts: Map.get(features_status, :activity_charts, false)
    }

    # For debugging display
    AppLogger.processor_debug(
      &quot;[StructuredFormatter] Found feature statuses: #{inspect(features_status)}&quot;
    )

    AppLogger.processor_debug(
      &quot;[StructuredFormatter] Extracted primary features: #{inspect(primary_features)}&quot;
    )

    # Format primary feature statuses
    [
      format_feature_item(&quot;Kill Notifications&quot;, primary_features.kill_notifications),
      format_feature_item(
        &quot;System Notifications&quot;,
        primary_features.tracked_systems_notifications
      ),
      format_feature_item(
        &quot;Character Notifications&quot;,
        primary_features.tracked_characters_notifications
      ),
      format_feature_item(
        &quot;Activity Charts&quot;,
        primary_features.activity_charts
      )
    ]
    |&gt; Enum.join(&quot;\n&quot;)
  end

  # Build the final status notification structure
  defp build_status_notification(data) do
    %{
      type: :status_notification,
      title: data.title,
      description: &quot;#{data.description}\n\n**System Status Overview:**&quot;,
      color: @info_color,
      timestamp: DateTime.utc_now() |&gt; DateTime.to_iso8601(),
      thumbnail: %{
        # Use the EVE Online logo or similar icon
        url: &quot;https://images.evetech.net/corporations/1_000_001/logo?size=128&quot;
      },
      footer: %{
        text: &quot;Wanderer Notifier v#{get_app_version()}&quot;
      },
      fields: [
        %{name: &quot;Uptime&quot;, value: data.uptime_str, inline: true},
        %{name: &quot;License&quot;, value: data.license_icon, inline: true},
        %{name: &quot;WebSocket&quot;, value: data.websocket_icon, inline: true},
        %{name: &quot;Systems&quot;, value: &quot; #{data.systems_count}&quot;, inline: true},
        %{name: &quot;Characters&quot;, value: &quot; #{data.characters_count}&quot;, inline: true},
        %{name: &quot; Notifications&quot;, value: data.notification_info, inline: false},
        %{name: &quot; Primary Features&quot;, value: data.formatted_features, inline: false}
      ]
    }
  end

  # Helper to format a single feature item
  defp format_feature_item(name, enabled) do
    if enabled do
      &quot; #{name}&quot;
    else
      &quot; #{name}&quot;
    end
  end

  # Helper to format notification counts
  defp format_notification_counts(%{} = notifications) do
    total = Map.get(notifications, :total, 0)
    kills = Map.get(notifications, :kills, 0)
    systems = Map.get(notifications, :systems, 0)
    characters = Map.get(notifications, :characters, 0)

    &quot;Total: **#{total}** (Kills: **#{kills}**, Systems: **#{systems}**, Characters: **#{characters}**)&quot;
  end

  # Helper to get websocket status icon based on connection state and last message time
  defp get_websocket_status_icon(stats) do
    if Map.has_key?(stats, :websocket) do
      ws_status = stats.websocket
      get_icon_by_connection_state(ws_status)
    else
      &quot;&quot;
    end
  end

  defp get_icon_by_connection_state(%{connected: false}), do: &quot;&quot;

  defp get_icon_by_connection_state(%{connected: true, last_message: nil}), do: &quot;&quot;

  defp get_icon_by_connection_state(%{connected: true, last_message: last_message}) do
    time_diff = DateTime.diff(DateTime.utc_now(), last_message, :second)

    cond do
      time_diff &lt; 60 -&gt; &quot;&quot;
      time_diff &lt; 300 -&gt; &quot;&quot;
      true -&gt; &quot;&quot;
    end
  end

  @doc &quot;&quot;&quot;
  Converts a generic notification structure to Discord&apos;s specific format.
  This is the interface between our internal notification format and Discord&apos;s requirements.

  ## Parameters
    - notification: The generic notification structure

  ## Returns
    - A map in Discord&apos;s expected format
  &quot;&quot;&quot;
  def to_discord_format(notification) do
    # Extract components if available
    components = Map.get(notification, :components, [])

    # Convert to Discord embed format with safe field access
    embed = %{
      &quot;title&quot; =&gt; Map.get(notification, :title, &quot;&quot;),
      &quot;description&quot; =&gt; Map.get(notification, :description, &quot;&quot;),
      &quot;color&quot; =&gt; Map.get(notification, :color, @default_color),
      &quot;url&quot; =&gt; Map.get(notification, :url),
      &quot;timestamp&quot; =&gt; Map.get(notification, :timestamp),
      &quot;footer&quot; =&gt; Map.get(notification, :footer),
      &quot;thumbnail&quot; =&gt; Map.get(notification, :thumbnail),
      &quot;image&quot; =&gt; Map.get(notification, :image),
      &quot;author&quot; =&gt; Map.get(notification, :author),
      &quot;fields&quot; =&gt;
        case Map.get(notification, :fields) do
          fields when is_list(fields) -&gt;
            Enum.map(fields, fn field -&gt;
              %{
                &quot;name&quot; =&gt; Map.get(field, :name, &quot;&quot;),
                &quot;value&quot; =&gt; Map.get(field, :value, &quot;&quot;),
                &quot;inline&quot; =&gt; Map.get(field, :inline, false)
              }
            end)

          _ -&gt;
            []
        end
    }

    # Add components if present
    add_components_if_present(embed, components)
  end

  # Helper to add components if present
  defp add_components_if_present(embed, []), do: embed
  defp add_components_if_present(embed, components), do: Map.put(embed, &quot;components&quot;, components)

  # Add shattered field if applicable
  defp add_shattered_field(fields, true, true) do
    fields ++ [%{name: &quot;Shattered&quot;, value: &quot;Yes&quot;, inline: true}]
  end

  defp add_shattered_field(fields, _, _), do: fields

  # Add statics field if applicable
  defp add_statics_field(fields, true, formatted_statics)
       when formatted_statics != nil and formatted_statics != &quot;None&quot; do
    fields ++ [%{name: &quot;Statics&quot;, value: formatted_statics, inline: true}]
  end

  defp add_statics_field(fields, _, _), do: fields

  # Add region field if available
  defp add_region_field(fields, nil), do: fields

  defp add_region_field(fields, region_name) do
    encoded_region_name = URI.encode(region_name)
    region_link = &quot;[#{region_name}](https://evemaps.dotlan.net/region/#{encoded_region_name})&quot;
    fields ++ [%{name: &quot;Region&quot;, value: region_link, inline: true}]
  end

  # Add effect field if available for wormhole systems
  defp add_effect_field(fields, true, effect_name)
       when effect_name != nil and effect_name != &quot;&quot; do
    fields ++ [%{name: &quot;Effect&quot;, value: effect_name, inline: true}]
  end

  defp add_effect_field(fields, _, _), do: fields

  # Process kill data and add to fields
  defp process_kill_data(fields, zkill_kills) do
    # Enrich each killmail with complete data from ESI
    detailed_kills = Enum.map(zkill_kills, &amp;fetch_complete_killmail/1)

    # Format the kills and add to fields if we got any valid kills
    if Enum.any?(detailed_kills) do
      formatted_kills = format_system_kills(detailed_kills)
      fields ++ [%{name: &quot;Recent Kills&quot;, value: formatted_kills, inline: false}]
    else
      fields
    end
  end

  # Fetch complete killmail details using ESI API
  defp fetch_complete_killmail(zkill_data) do
    kill_id = Map.get(zkill_data, &quot;killmail_id&quot;)
    hash = get_in(zkill_data, [&quot;zkb&quot;, &quot;hash&quot;])

    if kill_id &amp;&amp; hash do
      case esi_service().get_killmail(kill_id, hash) do
        {:ok, esi_data} -&gt; Map.merge(zkill_data, %{&quot;esi_killmail&quot; =&gt; esi_data})
        _ -&gt; zkill_data
      end
    else
      zkill_data
    end
  end

  # Format kills list for system notification
  defp format_system_kills(kills) do
    Enum.map_join(kills, &quot;\n&quot;, fn kill -&gt;
      kill_id = Map.get(kill, &quot;killmail_id&quot;)
      total_value = get_in(kill, [&quot;zkb&quot;, &quot;totalValue&quot;]) || 0

      # Try to get victim and ship info from ESI data if available
      esi_data = Map.get(kill, &quot;esi_killmail&quot;, %{})
      victim_data = Map.get(esi_data, &quot;victim&quot;, %{})
      victim_id = Map.get(victim_data, &quot;character_id&quot;)
      ship_type_id = Map.get(victim_data, &quot;ship_type_id&quot;)

      {victim_name, ship_name} = get_victim_and_ship_names(victim_id, ship_type_id)
      formatted_value = format_compact_isk_value(total_value)

      &quot;[#{victim_name} (#{ship_name})](https://zkillboard.com/kill/#{kill_id}/) - #{formatted_value}&quot;
    end)
  end

  # Get victim and ship names using ESI API
  defp get_victim_and_ship_names(victim_id, ship_type_id) do
    victim_name = get_victim_name(victim_id)
    ship_name = get_ship_name(ship_type_id)

    {victim_name, ship_name}
  end

  # Get the victim name using either tracking data or ESI
  defp get_victim_name(nil), do: &quot;Unknown&quot;

  defp get_victim_name(victim_id) do
    # First check if this is a tracked character
    case check_tracked_character(victim_id) do
      {:ok, name} when is_binary(name) and name != &quot;&quot; and name != &quot;Unknown&quot; -&gt;
        # We found the character in our tracked characters with a valid name, use that data
        AppLogger.processor_debug(&quot;[StructuredFormatter] Using tracked character name: #{name}&quot;)
        name

      _ -&gt;
        # Fall back to ESI lookup only if we couldn&apos;t get name from tracking system
        AppLogger.processor_debug(
          &quot;[StructuredFormatter] Character #{victim_id} not found in tracking or has invalid name, using ESI&quot;
        )

        lookup_character_from_esi(victim_id)
    end
  end

  # Lookup character from ESI
  defp lookup_character_from_esi(victim_id) do
    case esi_service().get_character_info(victim_id) do
      {:ok, char_info} -&gt; Map.get(char_info, &quot;name&quot;, &quot;Unknown&quot;)
      _ -&gt; &quot;Unknown&quot;
    end
  end

  # Get the ship name from ESI
  defp get_ship_name(nil), do: &quot;Unknown Ship&quot;

  defp get_ship_name(ship_type_id) do
    case esi_service().get_ship_type_name(ship_type_id) do
      {:ok, ship_info} -&gt; Map.get(ship_info, &quot;name&quot;, &quot;Unknown Ship&quot;)
      _ -&gt; &quot;Unknown Ship&quot;
    end
  end

  # Helper function to check if a character is in our tracked characters
  defp check_tracked_character(victim_id) do
    alias WandererNotifier.Data.Cache.{Keys, Repository}
    alias WandererNotifier.Data.Repository, as: DataRepository

    # First check if character is in tracking list
    cache_key = Keys.tracked_character(to_string(victim_id))
    is_tracked = Repository.get(cache_key) != nil

    if is_tracked do
      # If character is tracked, get full character data from appropriate repository
      case DataRepository.get_character_name(victim_id) do
        {:ok, name} when is_binary(name) and name != &quot;&quot; -&gt;
          {:ok, name}

        _ -&gt;
          # Fall back to character list cache
          get_name_from_character_list(victim_id)
      end
    else
      {:error, :not_tracked}
    end
  end

  # Helper to try getting character name from the character list cache
  defp get_name_from_character_list(victim_id) do
    alias WandererNotifier.Data.Cache.{Keys, Repository}

    # Get the full character list
    character_list =
      Repository.get(Keys.character_list()) || []

    # Try to find the character in the list
    victim_id_str = to_string(victim_id)

    character =
      Enum.find(character_list, fn char -&gt;
        char_id = Map.get(char, &quot;character_id&quot;) || Map.get(char, :character_id)
        to_string(char_id) == victim_id_str
      end)

    if character do
      name = Map.get(character, &quot;name&quot;) || Map.get(character, :name) || &quot;Unknown&quot;
      {:ok, name}
    else
      {:error, :not_in_character_list}
    end
  end

  # Format ISK value in a compact way
  defp format_compact_isk_value(value) when is_number(value) do
    cond do
      value &gt;= 1_000_000_000 -&gt; &quot;#{Float.round(value / 1_000_000_000, 1)}B ISK&quot;
      value &gt;= 1_000_000 -&gt; &quot;#{Float.round(value / 1_000_000, 1)}M ISK&quot;
      value &gt;= 1_000 -&gt; &quot;#{Float.round(value / 1_000, 1)}K ISK&quot;
      true -&gt; &quot;#{Float.round(value, 1)} ISK&quot;
    end
  end

  defp format_compact_isk_value(_), do: &quot;Unknown Value&quot;

  @doc &quot;&quot;&quot;
  Creates a standard formatted kill notification specifically for character channel.
  Similar to format_kill_notification but uses green color for kills where tracked characters are attackers,
  and red for when tracked characters are victims.

  ## Parameters
    - killmail: The Killmail struct
    - tracked_characters: List of tracked character IDs involved in this kill
    - are_victims: Boolean indicating if tracked characters are victims (true) or attackers (false)

  ## Returns
    - A generic structured map that can be converted to platform-specific format
  &quot;&quot;&quot;
  def format_character_kill_notification(%Killmail{} = killmail, _tracked_characters, are_victims) do
    # Use the standard formatting logic
    standard_notification = format_kill_notification(killmail)

    # Override the color based on victim/attacker status
    color = if are_victims, do: @error_color, else: @success_color

    # Update the notification with the new color
    Map.put(standard_notification, :color, color)
  end
end</file><file path="react.txt">A. Audit &amp; Extract Shared UI Components
1. Identify Repeated Patterns
Cards: ActivityChartCard.jsx, KillComparison.tsx, KillmailChartCard.jsx all wrap a title + chart + footer.

Dashboard Layout: Dashboard.jsx and SchedulerDashboard.jsx share grid layouts and padding.

2. Create a components/ui Library
Directory: renderer/src/components/ui/

Card.jsx

jsx
Copy
Edit
import { Card, CardContent, CardHeader } from &quot;@/components/ui/card&quot;;

export function DataCard({ title, children, footer }) {
  return (
    &lt;Card className=&quot;p-4 rounded-2xl shadow-sm&quot;&gt;
      &lt;CardHeader className=&quot;text-xl font-semibold&quot;&gt;{title}&lt;/CardHeader&gt;
      &lt;CardContent&gt;{children}&lt;/CardContent&gt;
      {footer &amp;&amp; &lt;div className=&quot;mt-4 text-sm text-gray-500&quot;&gt;{footer}&lt;/div&gt;}
    &lt;/Card&gt;
  );
}
GridLayout.jsx

jsx
Copy
Edit
export function GridLayout({ children }) {
  return (
    &lt;div className=&quot;grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3&quot;&gt;
      {children}
    &lt;/div&gt;
  );
}
3. Refactor Existing Components
Before in ActivityChartCard.jsx:

jsx
Copy
Edit
&lt;div className=&quot;rounded-lg shadow p-4 bg-white&quot;&gt;
  &lt;h2 className=&quot;text-lg&quot;&gt;{title}&lt;/h2&gt;
  &lt;Chart ... /&gt;
&lt;/div&gt;
After:

jsx
Copy
Edit
import { DataCard } from &quot;@/components/ui/Card&quot;;
export default function ActivityChartCard({ title, data }) {
  return (
    &lt;DataCard title={title}&gt;
      &lt;Chart data={data} /&gt;
    &lt;/DataCard&gt;
  );
}
B. Introduce PropTypes or Migrate to TypeScript
Why
Catch mismatched props early.

Improve IDE autocompletion.

1. PropTypes (JSX)
Install:

bash
Copy
Edit
npm install prop-types
Example in KillComparison.jsx:

jsx
Copy
Edit
import PropTypes from &quot;prop-types&quot;;

function KillComparison({ kills, timeframe }) {  }

KillComparison.propTypes = {
  kills: PropTypes.arrayOf(PropTypes.shape({
    date: PropTypes.string.isRequired,
    count: PropTypes.number.isRequired
  })).isRequired,
  timeframe: PropTypes.oneOf([&quot;daily&quot;,&quot;weekly&quot;,&quot;monthly&quot;])
};

export default KillComparison;
2. Or Full TS Migration
Rename .jsx  .tsx and add interfaces:

ts
Copy
Edit
interface KillComparisonProps {
  kills: { date: string; count: number }[];
  timeframe: &quot;daily&quot; | &quot;weekly&quot; | &quot;monthly&quot;;
}

export default function KillComparison({ kills, timeframe }: KillComparisonProps) {  }
C. Centralize Tailwind Configuration
Why
Enforce a consistent design system (colors, spacing).

Prevent magic classes scattered across files.

1. Edit tailwind.config.cjs
js
Copy
Edit
module.exports = {
  theme: {
    extend: {
      colors: {
        primary: &quot;#2f3136&quot;,
        accent: &quot;#88c0d0&quot;,
        cardBg: &quot;#ffffff&quot;,
        cardShadow: &quot;0 2px 8px rgba(0,0,0,0.1)&quot;
      },
      spacing: {
        card: &quot;1rem&quot;,
        layout: &quot;2rem&quot;
      }
    }
  }
};
2. Use Tokens in Components
jsx
Copy
Edit
&lt;div className=&quot;bg-cardBg shadow-[cardShadow] p-card rounded-2xl&quot;&gt;
  
&lt;/div&gt;
D. Add Storybook for Component QA
1. Install &amp; Initialize
bash
Copy
Edit
npx sb init --builder vite
2. Write Stories in components/ui/__stories__
jsx
Copy
Edit
import React from &quot;react&quot;;
import { DataCard } from &quot;../Card&quot;;

export default { title: &quot;UI/DataCard&quot;, component: DataCard };

export const Default = () =&gt; (
  &lt;DataCard title=&quot;Sample Card&quot;&gt;
    &lt;p&gt;Card content here.&lt;/p&gt;
  &lt;/DataCard&gt;
);
3. Run &amp; Validate
bash
Copy
Edit
npm run storybook
E. Linting &amp; Formatting
1. ESLint + Prettier
Ensure rules enforce:

No unused imports.

Consistent JSX quotes.

Sort-tailwind-classes (via eslint-plugin-tailwindcss).

.eslintrc.js snippet:

js
Copy
Edit
extends: [
  &quot;plugin:react/recommended&quot;,
  &quot;plugin:tailwindcss/recommended&quot;,
  &quot;prettier&quot;
],
rules: {
  &quot;react/prop-types&quot;: &quot;off&quot; // if using TS
}
2. Husky Pre-commit
bash
Copy
Edit
npx husky-init &amp;&amp; npm install
npx husky set .husky/pre-commit &quot;npm run lint &amp;&amp; npm run format&quot;
F. Milestones &amp; Checklist

Task	Done
[ ] Extract DataCard, GridLayout, and other shared components	
[ ] Refactor all cards and layouts to use shared components	
[ ] Add PropTypes or migrate key files to TS	
[ ] Centralize Tailwind tokens in tailwind.config.cjs	
[ ] Install &amp; configure Storybook, write stories for UI library	
[ ] Configure ESLint, Prettier, and Husky pre-commit	
[ ] Update README in renderer/ with dev &amp; testing instructions	
By modularizing UI patterns, enforcing types, and consolidating styles, your React codebase will become more DRY, easier to maintain, and safer to evolve</file><file path="README-GH-PAGES.md"># Wanderer Notifier Documentation

This branch contains the GitHub Pages documentation website for the Wanderer Notifier project.

## Website Structure

- `index.md`: Main landing page
- `notifications.md`: Details about notification types
- `license.md`: Map subscription comparison and features
- `_layouts/default.html`: Custom layout template
- `assets/css/style.scss`: Custom styling
- `assets/images/`: Screenshots and images

## Local Development

To test the site locally:

1. Install Ruby and Jekyll: https://jekyllrb.com/docs/installation/
2. Clone this branch: `git clone -b gh-pages https://github.com/guarzo/wanderer-notifier.git`
3. Navigate to the project directory: `cd wanderer-notifier`
4. Install dependencies: `bundle install`
5. Start the local server: `bundle exec jekyll serve`
6. Visit `http://localhost:4000` in your browser

## Updating the Website

The website is automatically updated when changes are pushed to the gh-pages branch. The GitHub Action workflow in the main branch deploys to this branch when triggered.

## Image References

The following image placeholders need to be replaced with actual screenshots:

- `assets/images/paid-kill.png`: Licensed kill notification example
- `assets/images/free-kill.png`: Free kill notification example
- `assets/images/paid-character.png`: Licensed character notification example
- `assets/images/free-character.png`: Free character notification example
- `assets/images/paid-system.png`: Licensed system notification example
- `assets/images/free-system.png`: Free system notification example
- `assets/images/dashboard.png`: Wanderer Notifier dashboard</file><file path="README.md"># Wanderer Notifier

Wanderer Notifier is an Elixir-based application that monitors EVE Online kill data and notifies designated Discord channels about significant events. It integrates with multiple external services to retrieve, enrich, and filter kill information before sending alerts.

## Features

- **Real-Time Monitoring:** Listens to live kill data via a WebSocket from ZKillboard
- **Data Enrichment:** Retrieves detailed killmail information from ESI
- **Map-Based Filtering:** Uses a custom map API to track wormhole systems and process kills originating from systems you care about
- **Character Tracking:** Monitors specific characters and notifies on their activities
- **Periodic Maintenance:** Automatically updates system data, processes backup kills, and sends heartbeat notifications
- **Caching:** Implements efficient caching with Cachex to minimize redundant API calls
- **Fault Tolerance:** Leverages Elixir&apos;s OTP and supervision trees for robust, resilient operation
- **Containerized Deployment:** Easy setup using Docker and docker-compose

## Notification System

The application provides several types of Discord notifications:

1. **Kill Notifications**

   - Real-time alerts for ship destructions in tracked systems
   - Rich embed format with detailed information:
     - System location and kill value
     - Victim details (character, corporation, ship type)
     - Final blow attacker information
     - Top damage dealer (if different)
   - Visual elements including ship thumbnails and corporation icons
   - Direct links to zKillboard

2. **System Notifications**

   - Alerts when new systems are added to tracking
   - System identification and zKillboard links
   - Distinctive orange color scheme for easy identification

3. **Character Notifications**

   - Notifications for newly tracked characters
   - Character portraits and corporation affiliations
   - Links to character profiles
   - Green color scheme for visual distinction

4. **Service Status Updates**
   - System startup confirmations
   - Connection status monitoring
   - Error reporting and diagnostic information

## Kill Notifications

The notifier supports configurable kill notifications based on tracked systems and tracked characters. Notifications can be sent to separate channels:

- **System kill notifications**: Sent to `WANDERER_DISCORD_SYSTEM_KILL_CHANNEL_ID` when a kill happens in a tracked system
- **Character kill notifications**: Sent to `WANDERER_DISCORD_CHARACTER_KILL_CHANNEL_ID` when tracked characters are involved in a kill
  - Green color: When tracked characters are attackers (successful kills)
  - Red color: When tracked characters are victims (losses)

If a kill involves both tracked systems and tracked characters, notifications will be sent to both channels. This allows for more targeted monitoring of activity.

## Requirements

- Elixir (&gt;= 1.14 recommended)
- Erlang/OTP (compatible version)
- [Docker](https://www.docker.com/) (recommended for deployment)
- Discord Bot Token (with proper permissions)

## Quick Start with Docker

The simplest way to get started is using Docker and docker-compose:

1. **Clone the repository:**

   ```bash
   git clone https://github.com/yourusername/wanderer-notifier.git
   cd wanderer-notifier
   ```

2. **Configure environment:**

   ```bash
   cp .env.example .env
   ```

   Edit `.env` file with your Discord bot token and other configuration.

3. **Start the application:**

   ```bash
   docker-compose up -d
   ```

4. **Check logs:**
   ```bash
   docker-compose logs -f
   ```

## Manual Installation

If you prefer to run without Docker:

1. **Clone the repository:**

   ```bash
   git clone https://github.com/yourusername/wanderer-notifier.git
   cd wanderer-notifier
   ```

2. **Setup Environment Variables:**
   Create a `.env` file using the provided `.env.example` as a template.

3. **Install Dependencies:**

   ```bash
   mix deps.get
   ```

4. **Compile the Project:**

   ```bash
   mix compile
   ```

5. **Run the Application:**
   ```bash
   mix run --no-halt
   ```

## Configuration

All configuration is managed through environment variables in the `.env` file. A template is provided as `.env.example`.

### Configuration Validation

On startup, the application validates all configuration settings. If there are issues with your configuration, detailed error messages will be displayed in the logs to help you resolve them.

### Standardized Environment Variables

All environment variables now use a standardized `WANDERER_` prefix.

### Key Configuration Options

1. **Discord Configuration**

   - `WANDERER_DISCORD_BOT_TOKEN`: Your Discord bot&apos;s authentication token
   - `WANDERER_DISCORD_CHANNEL_ID`: Main Discord channel ID for notifications
   - `WANDERER_DISCORD_KILL_CHANNEL_ID`: Channel for kill notifications
   - `WANDERER_DISCORD_SYSTEM_CHANNEL_ID`: Channel for system tracking notifications
   - `WANDERER_DISCORD_CHARACTER_CHANNEL_ID`: Channel for character tracking notifications
   - `WANDERER_DISCORD_CHARTS_CHANNEL_ID`: Channel for chart notifications

2. **License Configuration**

   - `WANDERER_LICENSE_KEY`: Your license key for accessing premium features
   - `WANDERER_LICENSE_MANAGER_URL`: URL for the license manager service (defaults to production service)

3. **Map API Configuration**

   - `WANDERER_MAP_URL_WITH_NAME`: URL for the wanderer map
   - `WANDERER_MAP_TOKEN`: Authentication token for map API

4. **Database Configuration**

   - `WANDERER_DB_USERNAME`: Database username (default: postgres)
   - `WANDERER_DB_PASSWORD`: Database password (default: postgres)
   - `WANDERER_DB_HOSTNAME`: Database hostname (default: postgres)
   - `WANDERER_DB_NAME`: Database name (default: wanderer*notifier*[environment])
   - `WANDERER_DB_PORT`: Database port (default: 5432)
   - `WANDERER_DB_POOL_SIZE`: Connection pool size (default: 10)

5. **Web Server Configuration**

   - `WANDERER_WEB_PORT`: Port for the web server (default: 4000)
   - `WANDERER_WEB_HOST`: Host for the web server (default: localhost)
   - `WANDERER_PUBLIC_URL`: Public URL for the web interface

6. **WebSocket Configuration**

   - `WANDERER_WEBSOCKET_ENABLED`: Enable/disable websocket connection (default: true)
   - `WANDERER_WEBSOCKET_RECONNECT_DELAY`: Delay between reconnection attempts in ms (default: 5000)

7. **Feature Flags**

   - `WANDERER_FEATURE_KILL_NOTIFICATIONS`: Enable kill notifications (default: true)
   - `WANDERER_FEATURE_SYSTEM_NOTIFICATIONS`: Enable system notifications (default: true)
   - `WANDERER_FEATURE_CHARACTER_NOTIFICATIONS`: Enable character notifications (default: true)
   - `WANDERER_FEATURE_TRACK_KSPACE`: Track K-Space systems in addition to wormholes (default: false)
   - `WANDERER_FEATURE_KILL_CHARTS`: Enable kill charts (default: false)
   - `WANDERER_FEATURE_MAP_CHARTS`: Enable map charts (default: false)
   - `WANDERER_FEATURE_ACTIVITY_CHARTS`: Enable activity charts (default: false)
   - `WANDERER_DISABLE_STATUS_MESSAGES`: Disable startup and status notifications (default: false)

8. **Character Configuration**

   - `WANDERER_CHARACTER_EXCLUDE_LIST`: Comma-separated list of character IDs to exclude from tracking

## Development

### Using the Dev Container

This project includes a development container configuration for VS Code:

1. Install the [Remote - Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)
2. Open the repository in VS Code
3. When prompted, reopen the project in the container

### Makefile Commands

The Makefile provides shortcuts for common tasks:

- **Compile:** `make compile`
- **Clean:** `make clean`
- **Test:** `make test`
- **Format:** `make format`
- **Interactive Shell:** `make shell`
- **Run Application:** `make run`
- **Get Dependencies:** `make deps.get`
- **Update Dependencies:** `make deps.update`

## Architecture

Wanderer Notifier follows an event-driven, functional, and component-based architecture:

- The application receives real-time data via WebSocket from ZKillboard
- Data is enriched with information from EVE ESI API
- Notifications are determined based on configured rules
- Messages are formatted and sent to Discord channels


## License

This project is licensed according to the terms in the LICENSE file.

## Support

If you encounter issues or have questions, please open an issue on the project repository.

## Notes

```
 mix archive.install hex bunt
 
 docker buildx build . \
  --build-arg WANDERER_NOTIFIER_API_TOKEN=your_token_here \
  --build-arg APP_VERSION=local \
  -t notifier:local

  docker run \
    --publish=7474:7474 --publish=7687:7687 \
    --volume=$HOME/neo4j/data:/data \
    --volume=$HOME/neo4j/logs:/logs \
    neo4j:latest
```</file><file path="start.sh">#!/bin/bash
set -e

echo &quot;Starting Wanderer Notifier...&quot;
echo &quot;Elixir version: $(elixir --version | head -n 1)&quot;
echo &quot;Node.js version: $(node --version)&quot;

# In production, clear token environment variables to use baked-in values
if [ &quot;$MIX_ENV&quot; = &quot;prod&quot; ]; then
  unset WANDERER_NOTIFIER_API_TOKEN
  unset NOTIFIER_API_TOKEN
fi

# Show configured ports
echo &quot;Web server port: ${WANDERER_PORT:-4000}&quot;

# Set default cache directory if not specified
WANDERER_CACHE_DIR=${WANDERER_CACHE_DIR:-${CACHE_DIR:-&quot;/app/data/cache&quot;}}

# Ensure the cache directory exists with proper permissions
echo &quot;Ensuring cache directory exists: $WANDERER_CACHE_DIR&quot;
mkdir -p &quot;$WANDERER_CACHE_DIR&quot;
chmod -R 777 &quot;$WANDERER_CACHE_DIR&quot;

# Source any environment variables from .env file if it exists
if [ -f .env ]; then
  echo &quot;Loading environment from .env file&quot;
  set -a
  source .env
  set +a
fi

# Start the main application
echo &quot;Starting Elixir application on port ${WANDERER_PORT:-4000}...&quot;
cd /app &amp;&amp; exec /app/bin/wanderer_notifier start</file></files></repomix>