<repomix>This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where content has been formatted for parsing.<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: additional-folder, **/*.log
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style</notes><additional_info></additional_info></file_summary><directory_structure>.devcontainer/
  prometheus/
    prometheus.yml
  devcontainer.json
  docker-compose.yml
  Dockerfile
assets/
  css/
    app.css
  js/
    app.js
  vendor/
    topbar.js
  tailwind.config.js
config/
  config.exs
  dev.exs
  prod.exs
  runtime.exs
  test.exs
docs/
  sample_implementation.ex
  wanderer_integration_guide.md
lib/
  wanderer_licenses/
    accounts/
      user/
        senders/
          send_magic_link_email.ex
      token.ex
      user.ex
    analytics/
      bot_usage.ex
    bots/
      bot.ex
    licenses/
      license_bot.ex
      license.ex
    prom_ex/
      request_metrics.ex
    accounts.ex
    analytics.ex
    application.ex
    bots.ex
    licenses.ex
    mailer.ex
    prom_ex.ex
    release.ex
    repo.ex
    secrets.ex
  wanderer_licenses_web/
    components/
      layouts/
        app.html.heex
        root.html.heex
      core_components.ex
      layouts.ex
    controllers/
      page_html/
        home.html.heex
      api_controller.ex
      auth_controller.ex
      error_html.ex
      error_json.ex
      page_controller.ex
      page_html.ex
    live/
      analytics_live/
        index.ex
      bot_live/
        form_component.ex
        index.ex
      license_live/
        form_component.ex
        index.ex
    plugs/
      api_key_auth.ex
      request_logger.ex
    auth_overrides.ex
    endpoint.ex
    gettext.ex
    live_user_auth.ex
    router.ex
    telemetry.ex
  wanderer_licenses_web.ex
  wanderer_licenses.ex
priv/
  gettext/
    en/
      LC_MESSAGES/
        errors.po
    errors.pot
  grafana_dashboards/
    request_tracking.json
  repo/
    migrations/
      .formatter.exs
      20250218191247_initialize_and_add_authentication_resources_and_add_magic_link_auth_extensions_1.exs
      20250218191248_initialize_and_add_authentication_resources_and_add_magic_link_auth.exs
      20250221235038_add_license_and_bot.exs
      20250305163050_add_bot_usage_and_developer_info.exs
      20250305181122_rename_developer_info_to_email.exs
    seeds.exs
  resource_snapshots/
    repo/
      bot_usage/
        20250305181005.json
      bots/
        20250305181005.json
      licenses/
        20250221235038.json
      licenses_bots/
        20250221235038.json
      tokens/
        20250218191248.json
      users/
        20250218191248.json
      extensions.json
  static/
    robots.txt
rel/
  overlays/
    bin/
      createdb.sh
      migrate.sh
      rollback.sh
      server
  docker-entrypoint.sh
scripts/
  check_api_url.sh
  generate_analytics_data.sh
  manual_api_test.sh
  test_api.sh
test/
  support/
    conn_case.ex
    data_case.ex
  wanderer_licenses_web/
    controllers/
      error_html_test.exs
      error_json_test.exs
      page_controller_test.exs
    plugs/
      api_key_auth_simple_test.exs
      api_key_auth_test.exs
  test_helper.exs
.dockerignore
.env.example
.envrc
.formatter.exs
.gitignore
.gitmessage
.igniter.exs
.tool-versions
API.md
default.nix
docker-compose.yml
Dockerfile
flake.lock
flake.nix
LICENSE
m
Makefile
mix.exs
README.md
repomix.config.json</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".devcontainer/prometheus/prometheus.yml">global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: &quot;wanderer_licenses&quot;
    scrape_interval: 15s
    metrics_path: /metrics
    static_configs:
      - targets: [&quot;license-manager:4000&quot;]

  - job_name: &quot;prometheus&quot;
    scrape_interval: 15s
    static_configs:
      - targets: [&quot;localhost:9090&quot;]</file><file path=".devcontainer/devcontainer.json">{
  &quot;name&quot;: &quot;license-manager-dev&quot;,
  &quot;dockerComposeFile&quot;: [&quot;./docker-compose.yml&quot;],
  &quot;extensions&quot;: [
    &quot;jakebecker.elixir-ls&quot;,
    &quot;JakeBecker.elixir-ls&quot;,
    &quot;dbaeumer.vscode-eslint&quot;,
    &quot;esbenp.prettier-vscode&quot;,
    &quot;ms-vscode-remote.remote-containers&quot;
  ],
  &quot;service&quot;: &quot;license-manager&quot;,
  &quot;workspaceFolder&quot;: &quot;/app&quot;,
  &quot;shutdownAction&quot;: &quot;stopCompose&quot;,
  &quot;settings&quot;: {
    &quot;editor.formatOnSave&quot;: true,
    &quot;search.exclude&quot;: {
      &quot;**/doc&quot;: true
    },
    &quot;elixirLS.dialyzerEnabled&quot;: false
  }
}</file><file path=".devcontainer/docker-compose.yml">version: &quot;3&quot;

services:
  db:
    image: postgres:13-alpine
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: wanderer_licenses_dev
    ports:
      - &quot;5432:5432&quot;
    volumes:
      - db:/var/lib/postgresql/data
    healthcheck:
      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U postgres&quot;]
      interval: 5s
      timeout: 5s
      retries: 5

  prometheus:
    image: prom/prometheus:latest
    restart: always
    ports:
      - &quot;9090:9090&quot;
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - &quot;--config.file=/etc/prometheus/prometheus.yml&quot;
      - &quot;--storage.tsdb.path=/prometheus&quot;
      - &quot;--web.console.libraries=/etc/prometheus/console_libraries&quot;
      - &quot;--web.console.templates=/etc/prometheus/consoles&quot;
      - &quot;--web.enable-lifecycle&quot;
    depends_on:
      - license-manager

  grafana:
    image: grafana/grafana:latest
    restart: always
    ports:
      - &quot;3000:3000&quot;
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
    depends_on:
      - prometheus

  license-manager:
    environment:
      PORT: 8000
      DB_HOST: db
      WEB_APP_URL: &quot;http://localhost:8000&quot;
      ERL_AFLAGS: &quot;-kernel shell_history enabled&quot;
      GRAFANA_HOST: &quot;http://grafana:3000&quot;
      GRAFANA_AUTH_TOKEN: &quot;glsa_iQjrKsgq23VCi76rPHVEdtDCbDpVqp1O_2563e210&quot;
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 8000:8000
    volumes:
      - ..:/app:delegated
      - ~/.gitconfig:/root/.gitconfig
      - ~/.gitignore:/root/.gitignore
      - ~/.ssh:/root/.ssh
      - elixir-artifacts:/opt/elixir-artifacts
    command: sleep infinity
    depends_on:
      db:
        condition: service_healthy

volumes:
  elixir-artifacts: {}
  db: {}
  prometheus_data: {}
  grafana_data: {}</file><file path=".devcontainer/Dockerfile">FROM elixir:1.17-otp-27

RUN apt install -yq curl gnupg
RUN apt --fix-broken install

RUN mix local.hex --force

WORKDIR /app</file><file path="assets/css/app.css">@import &quot;tailwindcss/base&quot;;
@import &quot;tailwindcss/components&quot;;
@import &quot;tailwindcss/utilities&quot;;

/* This file is for your main application CSS */</file><file path="assets/js/app.js">// If you want to use Phoenix channels, run `mix help phx.gen.channel`
// to get started and then uncomment the line below.
// import &quot;./user_socket.js&quot;

// You can include dependencies in two ways.
//
// The simplest option is to put them in assets/vendor and
// import them using relative paths:
//
//     import &quot;../vendor/some-package.js&quot;
//
// Alternatively, you can `npm install some-package --prefix assets` and import
// them using a path starting with the package name:
//
//     import &quot;some-package&quot;
//

// Include phoenix_html to handle method=PUT/DELETE in forms and buttons.
import &quot;phoenix_html&quot;
// Establish Phoenix Socket and LiveView configuration.
import {Socket} from &quot;phoenix&quot;
import {LiveSocket} from &quot;phoenix_live_view&quot;
import topbar from &quot;../vendor/topbar&quot;

let csrfToken = document.querySelector(&quot;meta[name=&apos;csrf-token&apos;]&quot;).getAttribute(&quot;content&quot;)
let liveSocket = new LiveSocket(&quot;/live&quot;, Socket, {
  longPollFallbackMs: 2500,
  params: {_csrf_token: csrfToken}
})

// Show progress bar on live navigation and form submits
topbar.config({barColors: {0: &quot;#29d&quot;}, shadowColor: &quot;rgba(0, 0, 0, .3)&quot;})
window.addEventListener(&quot;phx:page-loading-start&quot;, _info =&gt; topbar.show(300))
window.addEventListener(&quot;phx:page-loading-stop&quot;, _info =&gt; topbar.hide())

// connect if there are any LiveViews on the page
liveSocket.connect()

// expose liveSocket on window for web console debug logs and latency simulation:
// &gt;&gt; liveSocket.enableDebug()
// &gt;&gt; liveSocket.enableLatencySim(1000)  // enabled for duration of browser session
// &gt;&gt; liveSocket.disableLatencySim()
window.liveSocket = liveSocket</file><file path="assets/vendor/topbar.js">/**
 * @license MIT
 * topbar 2.0.0, 2023-02-04
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
(function (window, document) {
  &quot;use strict&quot;;

  // https://gist.github.com/paulirish/1579671
  (function () {
    var lastTime = 0;
    var vendors = [&quot;ms&quot;, &quot;moz&quot;, &quot;webkit&quot;, &quot;o&quot;];
    for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame =
        window[vendors[x] + &quot;RequestAnimationFrame&quot;];
      window.cancelAnimationFrame =
        window[vendors[x] + &quot;CancelAnimationFrame&quot;] ||
        window[vendors[x] + &quot;CancelRequestAnimationFrame&quot;];
    }
    if (!window.requestAnimationFrame)
      window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    if (!window.cancelAnimationFrame)
      window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
      };
  })();

  var canvas,
    currentProgress,
    showing,
    progressTimerId = null,
    fadeTimerId = null,
    delayTimerId = null,
    addEvent = function (elem, type, handler) {
      if (elem.addEventListener) elem.addEventListener(type, handler, false);
      else if (elem.attachEvent) elem.attachEvent(&quot;on&quot; + type, handler);
      else elem[&quot;on&quot; + type] = handler;
    },
    options = {
      autoRun: true,
      barThickness: 3,
      barColors: {
        0: &quot;rgba(26,  188, 156, .9)&quot;,
        &quot;.25&quot;: &quot;rgba(52,  152, 219, .9)&quot;,
        &quot;.50&quot;: &quot;rgba(241, 196, 15,  .9)&quot;,
        &quot;.75&quot;: &quot;rgba(230, 126, 34,  .9)&quot;,
        &quot;1.0&quot;: &quot;rgba(211, 84,  0,   .9)&quot;,
      },
      shadowBlur: 10,
      shadowColor: &quot;rgba(0,   0,   0,   .6)&quot;,
      className: null,
    },
    repaint = function () {
      canvas.width = window.innerWidth;
      canvas.height = options.barThickness * 5; // need space for shadow

      var ctx = canvas.getContext(&quot;2d&quot;);
      ctx.shadowBlur = options.shadowBlur;
      ctx.shadowColor = options.shadowColor;

      var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      for (var stop in options.barColors)
        lineGradient.addColorStop(stop, options.barColors[stop]);
      ctx.lineWidth = options.barThickness;
      ctx.beginPath();
      ctx.moveTo(0, options.barThickness / 2);
      ctx.lineTo(
        Math.ceil(currentProgress * canvas.width),
        options.barThickness / 2
      );
      ctx.strokeStyle = lineGradient;
      ctx.stroke();
    },
    createCanvas = function () {
      canvas = document.createElement(&quot;canvas&quot;);
      var style = canvas.style;
      style.position = &quot;fixed&quot;;
      style.top = style.left = style.right = style.margin = style.padding = 0;
      style.zIndex = 100001;
      style.display = &quot;none&quot;;
      if (options.className) canvas.classList.add(options.className);
      document.body.appendChild(canvas);
      addEvent(window, &quot;resize&quot;, repaint);
    },
    topbar = {
      config: function (opts) {
        for (var key in opts)
          if (options.hasOwnProperty(key)) options[key] = opts[key];
      },
      show: function (delay) {
        if (showing) return;
        if (delay) {
          if (delayTimerId) return;
          delayTimerId = setTimeout(() =&gt; topbar.show(), delay);
        } else  {
          showing = true;
          if (fadeTimerId !== null) window.cancelAnimationFrame(fadeTimerId);
          if (!canvas) createCanvas();
          canvas.style.opacity = 1;
          canvas.style.display = &quot;block&quot;;
          topbar.progress(0);
          if (options.autoRun) {
            (function loop() {
              progressTimerId = window.requestAnimationFrame(loop);
              topbar.progress(
                &quot;+&quot; + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2)
              );
            })();
          }
        }
      },
      progress: function (to) {
        if (typeof to === &quot;undefined&quot;) return currentProgress;
        if (typeof to === &quot;string&quot;) {
          to =
            (to.indexOf(&quot;+&quot;) &gt;= 0 || to.indexOf(&quot;-&quot;) &gt;= 0
              ? currentProgress
              : 0) + parseFloat(to);
        }
        currentProgress = to &gt; 1 ? 1 : to;
        repaint();
        return currentProgress;
      },
      hide: function () {
        clearTimeout(delayTimerId);
        delayTimerId = null;
        if (!showing) return;
        showing = false;
        if (progressTimerId != null) {
          window.cancelAnimationFrame(progressTimerId);
          progressTimerId = null;
        }
        (function loop() {
          if (topbar.progress(&quot;+.1&quot;) &gt;= 1) {
            canvas.style.opacity -= 0.05;
            if (canvas.style.opacity &lt;= 0.05) {
              canvas.style.display = &quot;none&quot;;
              fadeTimerId = null;
              return;
            }
          }
          fadeTimerId = window.requestAnimationFrame(loop);
        })();
      },
    };

  if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) {
    module.exports = topbar;
  } else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
    define(function () {
      return topbar;
    });
  } else {
    this.topbar = topbar;
  }
}.call(this, window, document));</file><file path="assets/tailwind.config.js">// See the Tailwind configuration guide for advanced usage
// https://tailwindcss.com/docs/configuration

const plugin = require(&quot;tailwindcss/plugin&quot;)
const fs = require(&quot;fs&quot;)
const path = require(&quot;path&quot;)

module.exports = {
  content: [
    &quot;../deps/ash_authentication_phoenix/**/*.*ex&quot;,
    &quot;./js/**/*.js&quot;,
    &quot;../lib/wanderer_licenses_web.ex&quot;,
    &quot;../lib/wanderer_licenses_web/**/*.*ex&quot;
  ],
  theme: {
    extend: {
      colors: {
        brand: &quot;#FD4F00&quot;,
      }
    },
  },
  plugins: [
    require(&quot;@tailwindcss/forms&quot;),
    // Allows prefixing tailwind classes with LiveView classes to add rules
    // only when LiveView classes are applied, for example:
    //
    //     &lt;div class=&quot;phx-click-loading:animate-ping&quot;&gt;
    //
    plugin(({addVariant}) =&gt; addVariant(&quot;phx-click-loading&quot;, [&quot;.phx-click-loading&amp;&quot;, &quot;.phx-click-loading &amp;&quot;])),
    plugin(({addVariant}) =&gt; addVariant(&quot;phx-submit-loading&quot;, [&quot;.phx-submit-loading&amp;&quot;, &quot;.phx-submit-loading &amp;&quot;])),
    plugin(({addVariant}) =&gt; addVariant(&quot;phx-change-loading&quot;, [&quot;.phx-change-loading&amp;&quot;, &quot;.phx-change-loading &amp;&quot;])),

    // Embeds Heroicons (https://heroicons.com) into your app.css bundle
    // See your `CoreComponents.icon/1` for more information.
    //
    plugin(function({matchComponents, theme}) {
      let iconsDir = path.join(__dirname, &quot;../deps/heroicons/optimized&quot;)
      let values = {}
      let icons = [
        [&quot;&quot;, &quot;/24/outline&quot;],
        [&quot;-solid&quot;, &quot;/24/solid&quot;],
        [&quot;-mini&quot;, &quot;/20/solid&quot;],
        [&quot;-micro&quot;, &quot;/16/solid&quot;]
      ]
      icons.forEach(([suffix, dir]) =&gt; {
        fs.readdirSync(path.join(iconsDir, dir)).forEach(file =&gt; {
          let name = path.basename(file, &quot;.svg&quot;) + suffix
          values[name] = {name, fullPath: path.join(iconsDir, dir, file)}
        })
      })
      matchComponents({
        &quot;hero&quot;: ({name, fullPath}) =&gt; {
          let content = fs.readFileSync(fullPath).toString().replace(/\r?\n|\r/g, &quot;&quot;)
          let size = theme(&quot;spacing.6&quot;)
          if (name.endsWith(&quot;-mini&quot;)) {
            size = theme(&quot;spacing.5&quot;)
          } else if (name.endsWith(&quot;-micro&quot;)) {
            size = theme(&quot;spacing.4&quot;)
          }
          return {
            [`--hero-${name}`]: `url(&apos;data:image/svg+xml;utf8,${content}&apos;)`,
            &quot;-webkit-mask&quot;: `var(--hero-${name})`,
            &quot;mask&quot;: `var(--hero-${name})`,
            &quot;mask-repeat&quot;: &quot;no-repeat&quot;,
            &quot;background-color&quot;: &quot;currentColor&quot;,
            &quot;vertical-align&quot;: &quot;middle&quot;,
            &quot;display&quot;: &quot;inline-block&quot;,
            &quot;width&quot;: size,
            &quot;height&quot;: size
          }
        }
      }, {values})
    })
  ]
}</file><file path="config/config.exs"># This file is responsible for configuring your application
# and its dependencies with the aid of the Config module.
#
# This configuration file is loaded before any dependency and
# is restricted to this project.

# General application configuration
import Config

config :ash,
  allow_forbidden_field_for_relationships_by_default?: true,
  include_embedded_source_by_default?: false,
  show_keysets_for_all_actions?: false,
  default_page_type: :keyset,
  policies: [no_filter_static_forbidden_reads?: false]

config :spark,
  formatter: [
    remove_parens?: true,
    &quot;Ash.Resource&quot;: [
      section_order: [
        :admin,
        :authentication,
        :tokens,
        :postgres,
        :resource,
        :code_interface,
        :actions,
        :policies,
        :pub_sub,
        :preparations,
        :changes,
        :validations,
        :multitenancy,
        :attributes,
        :relationships,
        :calculations,
        :aggregates,
        :identities
      ]
    ],
    &quot;Ash.Domain&quot;: [
      section_order: [:admin, :resources, :policies, :authorization, :domain, :execution]
    ]
  ]

config :wanderer_licenses,
  ecto_repos: [WandererLicenses.Repo],
  generators: [timestamp_type: :utc_datetime],
  ash_domains: [
    WandererLicenses.Licenses,
    WandererLicenses.Bots,
    WandererLicenses.Accounts,
    WandererLicenses.Analytics
  ]

# Configures the endpoint
config :wanderer_licenses, WandererLicensesWeb.Endpoint,
  url: [host: &quot;localhost&quot;],
  adapter: Bandit.PhoenixAdapter,
  render_errors: [
    formats: [html: WandererLicensesWeb.ErrorHTML, json: WandererLicensesWeb.ErrorJSON],
    layout: false
  ],
  pubsub_server: WandererLicenses.PubSub,
  live_view: [signing_salt: &quot;8fmZumC2&quot;]

# Configures the mailer
#
# By default it uses the &quot;Local&quot; adapter which stores the emails
# locally. You can see the emails in your browser, at &quot;/dev/mailbox&quot;.
#
# For production it&apos;s recommended to configure a different adapter
# at the `config/runtime.exs`.
config :wanderer_licenses, WandererLicenses.Mailer, adapter: Swoosh.Adapters.Local

# Configure esbuild (the version is required)
config :esbuild,
  version: &quot;0.17.11&quot;,
  wanderer_licenses: [
    args:
      ~w(js/app.js --bundle --target=es2017 --outdir=../priv/static/assets --external:/fonts/* --external:/images/*),
    cd: Path.expand(&quot;../assets&quot;, __DIR__),
    env: %{&quot;NODE_PATH&quot; =&gt; Path.expand(&quot;../deps&quot;, __DIR__)}
  ]

# Configure tailwind (the version is required)
config :tailwind,
  version: &quot;3.4.3&quot;,
  wanderer_licenses: [
    args: ~w(
      --config=tailwind.config.js
      --input=css/app.css
      --output=../priv/static/assets/app.css
    ),
    cd: Path.expand(&quot;../assets&quot;, __DIR__)
  ]

# Configures Elixir&apos;s Logger
config :logger, :console,
  format: &quot;$time $metadata[$level] $message\n&quot;,
  metadata: [:request_id]

# Use Jason for JSON parsing in Phoenix
config :phoenix, :json_library, Jason

# Configure PromEx for metrics collection and Grafana dashboard provisioning
config :wanderer_licenses, WandererLicenses.PromEx,
  disabled: false,
  manual_metrics_start_delay: :no_delay,
  drop_metrics_groups: [],
  grafana: [
    host: System.get_env(&quot;GRAFANA_HOST&quot;, &quot;http://localhost:3000&quot;),
    auth_token: System.get_env(&quot;GRAFANA_AUTH_TOKEN&quot;, &quot;&quot;),
    upload_dashboards_on_start: true,
    folder_name: &quot;WandererLicenses Dashboards&quot;,
    annotate_app_lifecycle: true
  ]

# Import environment specific config. This must remain at the bottom
# of this file so it overrides the configuration defined above.
import_config &quot;#{config_env()}.exs&quot;</file><file path="config/dev.exs">import Config

# Configure your database
config :wanderer_licenses, WandererLicenses.Repo,
  username: &quot;postgres&quot;,
  password: &quot;postgres&quot;,
  hostname: &quot;db&quot;,
  database: &quot;wanderer_licenses_dev&quot;,
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 10

# For development, we disable any cache and enable
# debugging and code reloading.
#
# The watchers configuration can be used to run external
# watchers to your application. For example, we can use it
# to bundle .js and .css sources.
# Binding to loopback ipv4 address prevents access from other machines.
config :wanderer_licenses, WandererLicensesWeb.Endpoint,
  # Change to `ip: {0, 0, 0, 0}` to allow access from other machines.
  http: [ip: {0, 0, 0, 0}, port: 4000],
  check_origin: false,
  code_reloader: true,
  debug_errors: true,
  secret_key_base: &quot;WvEwu5nZRI8mMVLSQEEUVqKrHfb+2nACEN+9hRxEETA3jWI/Z1wwXNveLHHYoV5N&quot;,
  watchers: [
    esbuild: {Esbuild, :install_and_run, [:wanderer_licenses, ~w(--sourcemap=inline --watch)]},
    tailwind: {Tailwind, :install_and_run, [:wanderer_licenses, ~w(--watch)]}
  ]

# ## SSL Support
#
# In order to use HTTPS in development, a self-signed
# certificate can be generated by running the following
# Mix task:
#
#     mix phx.gen.cert
#
# Run `mix help phx.gen.cert` for more information.
#
# The `http:` config above can be replaced with:
#
#     https: [
#       port: 4001,
#       cipher_suite: :strong,
#       keyfile: &quot;priv/cert/selfsigned_key.pem&quot;,
#       certfile: &quot;priv/cert/selfsigned.pem&quot;
#     ],
#
# If desired, both `http:` and `https:` keys can be
# configured to run both http and https servers on
# different ports.

# Watch static and templates for browser reloading.
config :wanderer_licenses, WandererLicensesWeb.Endpoint,
  live_reload: [
    patterns: [
      ~r&quot;priv/static/(?!uploads/).*(js|css|png|jpeg|jpg|gif|svg)$&quot;,
      ~r&quot;priv/gettext/.*(po)$&quot;,
      ~r&quot;lib/wanderer_licenses_web/(controllers|live|components)/.*(ex|heex)$&quot;
    ]
  ]

# Enable dev routes for dashboard and mailbox
config :wanderer_licenses,
  dev_routes: true,
  token_signing_secret: &quot;uI7kUmN5VVoCkUc9CjTot33amDE0MadH&quot;

# Do not include metadata nor timestamps in development logs
config :logger, :console, format: &quot;[$level] $message\n&quot;

# Set a higher stacktrace during development. Avoid configuring such
# in production as building large stacktraces may be expensive.
config :phoenix, :stacktrace_depth, 20

# Initialize plugs at runtime for faster development compilation
config :phoenix, :plug_init_mode, :runtime

config :phoenix_live_view,
  # Include HEEx debug annotations as HTML comments in rendered markup
  debug_heex_annotations: true,
  # Enable helpful, but potentially expensive runtime checks
  enable_expensive_runtime_checks: true

# Disable swoosh api client as it is only required for production adapters.
config :swoosh, :api_client, false</file><file path="config/prod.exs">import Config

# Note we also include the path to a cache manifest
# containing the digested version of static files. This
# manifest is generated by the `mix assets.deploy` task,
# which you should run after static files are built and
# before starting your production server.
config :wanderer_licenses, WandererLicensesWeb.Endpoint,
  cache_static_manifest: &quot;priv/static/cache_manifest.json&quot;

# Configures Swoosh API Client
config :swoosh, api_client: Swoosh.ApiClient.Finch, finch_name: WandererLicenses.Finch

# Disable Swoosh Local Memory Storage
config :swoosh, local: false

# Do not print debug messages in production
config :logger, level: :info

# Runtime production configuration, including reading
# of environment variables, is done on config/runtime.exs.</file><file path="config/runtime.exs">import Config

# config/runtime.exs is executed for all environments, including
# during releases. It is executed after compilation and before the
# system starts, so it is typically used to load production configuration
# and secrets from environment variables or elsewhere. Do not define
# any compile-time configuration in here, as it won&apos;t be applied.
# The block below contains prod specific runtime configuration.

# ## Using releases
#
# If you use `mix release`, you need to explicitly enable the server
# by passing the PHX_SERVER=true when you start it:
#
#     PHX_SERVER=true bin/wanderer_licenses start
#
# Alternatively, you can use `mix phx.gen.release` to generate a `bin/server`
# script that automatically sets the env var above.
if System.get_env(&quot;PHX_SERVER&quot;) do
  config :wanderer_licenses, WandererLicensesWeb.Endpoint, server: true
end

# Configure the API key for license management endpoints
lm_auth_key = System.get_env(&quot;LM_AUTH_KEY&quot;)
if is_nil(lm_auth_key) &amp;&amp; config_env() == :prod do
  raise &quot;&quot;&quot;
  environment variable LM_AUTH_KEY is missing.
  This key is required for authenticating license management API requests.
  You can generate one by running: mix phx.gen.secret or using OpenSSL.
  &quot;&quot;&quot;
end

config :wanderer_licenses, :api_auth, 
  key: lm_auth_key

if config_env() == :prod do
  database_url =
    System.get_env(&quot;DATABASE_URL&quot;) ||
      raise &quot;&quot;&quot;
      environment variable DATABASE_URL is missing.
      For example: ecto://USER:PASS@HOST/DATABASE
      &quot;&quot;&quot;

  maybe_ipv6 = if System.get_env(&quot;ECTO_IPV6&quot;) in ~w(true 1), do: [:inet6], else: []

  config :wanderer_licenses, WandererLicenses.Repo,
    # ssl: true,
    url: database_url,
    pool_size: String.to_integer(System.get_env(&quot;POOL_SIZE&quot;) || &quot;10&quot;),
    socket_options: maybe_ipv6

  # The secret key base is used to sign/encrypt cookies and other secrets.
  # A default value is used in config/dev.exs and config/test.exs but you
  # want to use a different value for prod and you most likely don&apos;t want
  # to check this value into version control, so we use an environment
  # variable instead.
  secret_key_base =
    System.get_env(&quot;SECRET_KEY_BASE&quot;) ||
      raise &quot;&quot;&quot;
      environment variable SECRET_KEY_BASE is missing.
      You can generate one by calling: mix phx.gen.secret
      &quot;&quot;&quot;

  host = System.get_env(&quot;PHX_HOST&quot;) || &quot;example.com&quot;
  port = String.to_integer(System.get_env(&quot;PORT&quot;) || &quot;4000&quot;)

  config :wanderer_licenses, :dns_cluster_query, System.get_env(&quot;DNS_CLUSTER_QUERY&quot;)

  config :wanderer_licenses, WandererLicensesWeb.Endpoint,
    url: [host: host, port: 443, scheme: &quot;https&quot;],
    http: [
      # Enable IPv6 and bind on all interfaces.
      # Set it to  {0, 0, 0, 0, 0, 0, 0, 1} for local network only access.
      # See the documentation on https://hexdocs.pm/bandit/Bandit.html#t:options/0
      # for details about using IPv6 vs IPv4 and loopback vs public addresses.
      ip: {0, 0, 0, 0, 0, 0, 0, 0},
      port: port
    ],
    secret_key_base: secret_key_base

  config :wanderer_licenses,
    token_signing_secret:
      System.get_env(&quot;TOKEN_SIGNING_SECRET&quot;) ||
        raise(&quot;Missing environment variable `TOKEN_SIGNING_SECRET`!&quot;)

  # ## SSL Support
  #
  # To get SSL working, you will need to add the `https` key
  # to your endpoint configuration:
  #
  #     config :wanderer_licenses, WandererLicensesWeb.Endpoint,
  #       https: [
  #         ...,
  #         port: 443,
  #         cipher_suite: :strong,
  #         keyfile: System.get_env(&quot;SOME_APP_SSL_KEY_PATH&quot;),
  #         certfile: System.get_env(&quot;SOME_APP_SSL_CERT_PATH&quot;)
  #       ]
  #
  # The `cipher_suite` is set to `:strong` to support only the
  # latest and more secure SSL ciphers. This means old browsers
  # and clients may not be supported. You can set it to
  # `:compatible` for wider support.
  #
  # `:keyfile` and `:certfile` expect an absolute path to the key
  # and cert in disk or a relative path inside priv, for example
  # &quot;priv/ssl/server.key&quot;. For all supported SSL configuration
  # options, see https://hexdocs.pm/plug/Plug.SSL.html#configure/1
  #
  # We also recommend setting `force_ssl` in your config/prod.exs,
  # ensuring no data is ever sent via http, always redirecting to https:
  #
  #     config :wanderer_licenses, WandererLicensesWeb.Endpoint,
  #       force_ssl: [hsts: true]
  #
  # Check `Plug.SSL` for all available options in `force_ssl`.

  # ## Configuring the mailer
  #
  # In production you need to configure the mailer to use a different adapter.
  # Also, you may need to configure the Swoosh API client of your choice if you
  # are not using SMTP. Here is an example of the configuration:
  #
  #     config :wanderer_licenses, WandererLicenses.Mailer,
  #       adapter: Swoosh.Adapters.Mailgun,
  #       api_key: System.get_env(&quot;MAILGUN_API_KEY&quot;),
  #       domain: System.get_env(&quot;MAILGUN_DOMAIN&quot;)
  #
  # For this example you need include a HTTP client required by Swoosh API client.
  # Swoosh supports Hackney and Finch out of the box:
  #
  #     config :swoosh, :api_client, Swoosh.ApiClient.Hackney
  #
  # See https://hexdocs.pm/swoosh/Swoosh.html#module-installation for details.
end</file><file path="config/test.exs">import Config
config :wanderer_licenses, token_signing_secret: &quot;XaZSPrxw78ox0ixYEsFZGPK+wmPqfj7J&quot;
config :ash, disable_async?: true

# Configure your database
#
# The MIX_TEST_PARTITION environment variable can be used
# to provide built-in test partitioning in CI environment.
# Run `mix help test` for more information.
config :wanderer_licenses, WandererLicenses.Repo,
  username: &quot;postgres&quot;,
  password: &quot;postgres&quot;,
  hostname: System.get_env(&quot;DB_HOST&quot;) || &quot;localhost&quot;,
  database: &quot;wanderer_licenses_test#{System.get_env(&quot;MIX_TEST_PARTITION&quot;)}&quot;,
  pool: Ecto.Adapters.SQL.Sandbox,
  pool_size: System.schedulers_online() * 2

# We don&apos;t run a server during test. If one is required,
# you can enable the server option below.
config :wanderer_licenses, WandererLicensesWeb.Endpoint,
  http: [ip: {127, 0, 0, 1}, port: 4002],
  secret_key_base: &quot;9UPMdq70h7EGnfBUkiBwW9KLHsO/Vh9i1QliHTGO/blIYBLWWUqKcR7DoYPchOMA&quot;,
  server: false

# In test we don&apos;t send emails
config :wanderer_licenses, WandererLicenses.Mailer, adapter: Swoosh.Adapters.Test

# Disable swoosh api client as it is only required for production adapters
config :swoosh, :api_client, false

# Print only warnings and errors during test
config :logger, level: :warning

# Initialize plugs at runtime for faster test compilation
config :phoenix, :plug_init_mode, :runtime

# Enable helpful, but potentially expensive runtime checks
config :phoenix_live_view,
  enable_expensive_runtime_checks: true</file><file path="docs/sample_implementation.ex">defmodule Wanderer.LicenseManager.Client do
  @moduledoc &quot;&quot;&quot;
  Client for interacting with the License Manager API.
  
  This module provides functions to create, update, and validate licenses
  through the License Manager API.
  
  ## Configuration
  
  Add the following to your config:
  
  ```elixir
  # config/runtime.exs
  config :wanderer, :license_manager,
    api_url: System.get_env(&quot;LICENSE_MANAGER_API_URL&quot;) || &quot;http://localhost:4000&quot;,
    auth_key: System.get_env(&quot;LICENSE_MANAGER_AUTH_KEY&quot;) || raise(&quot;LICENSE_MANAGER_AUTH_KEY is required&quot;)
  ```
  &quot;&quot;&quot;

  require Logger

  @doc &quot;&quot;&quot;
  Creates a new license in the License Manager.
  
  ## Parameters
  
  - `license_params` - Map containing license details:
    - `name` (required) - Name of the license
    - `description` (optional) - Description of the license
    - `is_valid` (optional) - Boolean indicating if the license is valid
    - `valid_to` (optional) - Expiration date in YYYY-MM-DD format
    - `link` (required) - URL associated with the license
    - `contact_email` (optional) - Contact email for the license
  
  ## Returns
  
  - `{:ok, license}` - On successful creation
  - `{:error, reason}` - On failure
  
  ## Examples
  
  ```elixir
  license_params = %{
    &quot;name&quot; =&gt; &quot;Premium Map License&quot;,
    &quot;description&quot; =&gt; &quot;License for premium map access&quot;,
    &quot;is_valid&quot; =&gt; true,
    &quot;valid_to&quot; =&gt; &quot;2025-12-31&quot;,
    &quot;link&quot; =&gt; &quot;https://wanderer.com/maps/123&quot;,
    &quot;contact_email&quot; =&gt; &quot;user@example.com&quot;
  }
  
  case Wanderer.LicenseManager.Client.create_license(license_params) do
    {:ok, license} -&gt;
      # License created successfully
      IO.puts(&quot;Created license with ID: #{license[&quot;id&quot;]} and key: #{license[&quot;key&quot;]}&quot;)
      
    {:error, reason} -&gt;
      # Handle error
      IO.puts(&quot;Failed to create license: #{reason}&quot;)
  end
  ```
  &quot;&quot;&quot;
  def create_license(license_params) do
    url = &quot;#{api_url()}/api/manage/licenses&quot;
    
    headers = [
      {&quot;Authorization&quot;, &quot;Bearer #{auth_key()}&quot;},
      {&quot;Content-Type&quot;, &quot;application/json&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;}
    ]
    
    log_request(&quot;POST&quot;, url, license_params)
    
    with {:ok, body} &lt;- Jason.encode(license_params),
         {:ok, %{status_code: status, body: response_body}} when status in 200..299 &lt;- 
           HTTPoison.post(url, body, headers),
         {:ok, license} &lt;- Jason.decode(response_body) do
      log_response(status, license)
      {:ok, license}
    else
      {:ok, %{status_code: status, body: body}} -&gt;
        Logger.error(&quot;Failed to create license. Status: #{status}, Body: #{body}&quot;)
        parse_error_response(status, body)
      
      {:error, %Jason.DecodeError{} = error} -&gt;
        Logger.error(&quot;Failed to decode response: #{inspect(error)}&quot;)
        {:error, :invalid_response}
      
      {:error, %HTTPoison.Error{} = error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  @doc &quot;&quot;&quot;
  Creates a new license with retry mechanism for transient failures.
  
  ## Parameters
  
  - `license_params` - Map containing license details (see `create_license/1`)
  - `max_attempts` - Maximum number of retry attempts (default: 3)
  
  ## Returns
  
  - `{:ok, license}` - On successful creation
  - `{:error, reason}` - On failure after all retry attempts
  &quot;&quot;&quot;
  def create_license_with_retry(license_params, max_attempts \\ 3) do
    retry_with_backoff(fn -&gt; create_license(license_params) end, max_attempts)
  end

  @doc &quot;&quot;&quot;
  Updates an existing license in the License Manager.
  
  ## Parameters
  
  - `license_id` - ID of the license to update
  - `update_params` - Map containing fields to update:
    - `is_valid` (optional) - Boolean indicating if the license is valid
    - `valid_to` (optional) - Expiration date in YYYY-MM-DD format
  
  ## Returns
  
  - `{:ok, license}` - On successful update
  - `{:error, reason}` - On failure
  
  ## Examples
  
  ```elixir
  update_params = %{
    &quot;is_valid&quot; =&gt; true,
    &quot;valid_to&quot; =&gt; &quot;2026-12-31&quot;
  }
  
  case Wanderer.LicenseManager.Client.update_license(&quot;license-id-123&quot;, update_params) do
    {:ok, license} -&gt;
      # License updated successfully
      IO.puts(&quot;Updated license: #{license[&quot;name&quot;]}&quot;)
      
    {:error, reason} -&gt;
      # Handle error
      IO.puts(&quot;Failed to update license: #{reason}&quot;)
  end
  ```
  &quot;&quot;&quot;
  def update_license(license_id, update_params) do
    url = &quot;#{api_url()}/api/manage/licenses/#{license_id}&quot;
    
    headers = [
      {&quot;Authorization&quot;, &quot;Bearer #{auth_key()}&quot;},
      {&quot;Content-Type&quot;, &quot;application/json&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;}
    ]
    
    log_request(&quot;PUT&quot;, url, update_params)
    
    with {:ok, body} &lt;- Jason.encode(update_params),
         {:ok, %{status_code: status, body: response_body}} when status in 200..299 &lt;- 
           HTTPoison.put(url, body, headers),
         {:ok, license} &lt;- Jason.decode(response_body) do
      log_response(status, license)
      {:ok, license}
    else
      {:ok, %{status_code: status, body: body}} -&gt;
        Logger.error(&quot;Failed to update license. Status: #{status}, Body: #{body}&quot;)
        parse_error_response(status, body)
      
      {:error, %Jason.DecodeError{} = error} -&gt;
        Logger.error(&quot;Failed to decode response: #{inspect(error)}&quot;)
        {:error, :invalid_response}
      
      {:error, %HTTPoison.Error{} = error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  @doc &quot;&quot;&quot;
  Updates a license with retry mechanism for transient failures.
  
  ## Parameters
  
  - `license_id` - ID of the license to update
  - `update_params` - Map containing fields to update (see `update_license/2`)
  - `max_attempts` - Maximum number of retry attempts (default: 3)
  
  ## Returns
  
  - `{:ok, license}` - On successful update
  - `{:error, reason}` - On failure after all retry attempts
  &quot;&quot;&quot;
  def update_license_with_retry(license_id, update_params, max_attempts \\ 3) do
    retry_with_backoff(fn -&gt; update_license(license_id, update_params) end, max_attempts)
  end

  @doc &quot;&quot;&quot;
  Validates a license using its key.
  
  ## Parameters
  
  - `license_key` - The license key to validate
  
  ## Returns
  
  - `{:ok, result}` - On successful validation, where result is a map containing:
    - `license_valid` - Boolean indicating if the license is valid
    - `valid_to` - Expiration date of the license
    - `license_id` - UUID of the license
    - `license_name` - Name of the license
    - `bots` - List of associated bots with their details (id, name, description, is_active, api_token)
  - `{:error, reason}` - On failure
  
  ## Examples
  
  ```elixir
  case Wanderer.LicenseManager.Client.validate_license(&quot;license-key-123&quot;) do
    {:ok, %{&quot;license_valid&quot; =&gt; true, &quot;valid_to&quot; =&gt; valid_to, &quot;bots&quot; =&gt; bots}} -&gt;
      # License is valid
      IO.puts(&quot;License is valid until #{valid_to}&quot;)
      IO.puts(&quot;Associated bots: #{length(bots)}&quot;)
      
      # Access bot details
      Enum.each(bots, fn bot -&gt;
        IO.puts(&quot;Bot: #{bot[&quot;name&quot;]} (#{bot[&quot;id&quot;]})&quot;)
        IO.puts(&quot;API Token: #{bot[&quot;api_token&quot;]}&quot;)
      end)
      
    {:ok, %{&quot;license_valid&quot; =&gt; false}} -&gt;
      # License is invalid
      IO.puts(&quot;License is invalid&quot;)
      
    {:error, reason} -&gt;
      # Handle error
      IO.puts(&quot;Failed to validate license: #{reason}&quot;)
  end
  ```
  &quot;&quot;&quot;
  def validate_license(license_key) do
    url = &quot;#{api_url()}/api/license/validate&quot;
    
    headers = [
      {&quot;Authorization&quot;, &quot;Bearer #{license_key}&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;}
    ]
    
    log_request(&quot;GET&quot;, url, nil)
    
    with {:ok, %{status_code: 200, body: response_body}} &lt;- HTTPoison.get(url, headers),
         {:ok, validation_result} &lt;- Jason.decode(response_body) do
      log_response(200, validation_result)
      {:ok, validation_result}
    else
      {:ok, %{status_code: 401}} -&gt;
        {:error, :invalid_license}
      
      {:ok, %{status_code: status, body: body}} -&gt;
        Logger.error(&quot;Failed to validate license. Status: #{status}, Body: #{body}&quot;)
        parse_error_response(status, body)
      
      {:error, %Jason.DecodeError{} = error} -&gt;
        Logger.error(&quot;Failed to decode response: #{inspect(error)}&quot;)
        {:error, :invalid_response}
      
      {:error, %HTTPoison.Error{} = error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  @doc &quot;&quot;&quot;
  Validates a license with caching to reduce API calls.
  
  ## Parameters
  
  - `license_key` - The license key to validate
  
  ## Returns
  
  - `{:ok, result}` - On successful validation, containing license details and associated bots
  - `{:error, reason}` - On failure
  
  The result includes license validity, expiration date, license ID, license name, and a list of 
  associated bots with their details (id, name, description, is_active, api_token).
  &quot;&quot;&quot;
  def validate_license_with_cache(license_key) do
    cache_key = &quot;license_validation:#{license_key}&quot;
    
    case Cachex.get(:wanderer_cache, cache_key) do
      {:ok, nil} -&gt;
        # Not in cache, call API
        case validate_license(license_key) do
          {:ok, result} = success -&gt;
            # Cache the result for 1 hour
            Cachex.put(:wanderer_cache, cache_key, result, ttl: :timer.hours(1))
            success
            
          error -&gt;
            error
        end
        
      {:ok, result} -&gt;
        # Return cached result
        {:ok, result}
    end
  end

  # Private helper functions
  
  defp api_url do
    Application.get_env(:wanderer, :license_manager)[:api_url]
  end
  
  defp auth_key do
    Application.get_env(:wanderer, :license_manager)[:auth_key]
  end
  
  defp parse_error_response(status, body) do
    case Jason.decode(body) do
      {:ok, %{&quot;error&quot; =&gt; error_message}} -&gt;
        {:error, error_message}
      
      _ -&gt;
        {:error, &quot;HTTP #{status}: #{body}&quot;}
    end
  end
  
  defp retry_with_backoff(func, attempts_left, delay \\ 1000) do
    case func.() do
      {:ok, result} -&gt;
        {:ok, result}
        
      {:error, reason} when attempts_left &gt; 1 -&gt;
        # Only retry for network-related errors
        if retryable_error?(reason) do
          :timer.sleep(delay)
          retry_with_backoff(func, attempts_left - 1, delay * 2)
        else
          {:error, reason}
        end
        
      error -&gt;
        error
    end
  end
  
  defp retryable_error?(:request_failed), do: true
  defp retryable_error?(_), do: false
  
  defp log_request(method, url, params) do
    Logger.info(&quot;License Manager API Request: #{method} #{url}&quot;)
    Logger.debug(&quot;License Manager API Params: #{inspect(params)}&quot;)
  end
  
  defp log_response(status, body) do
    Logger.info(&quot;License Manager API Response: Status #{status}&quot;)
    Logger.debug(&quot;License Manager API Response Body: #{inspect(body)}&quot;)
  end
end

defmodule Wanderer.LicenseManager.ErrorHandler do
  @moduledoc &quot;&quot;&quot;
  Handles errors from the License Manager API.
  &quot;&quot;&quot;
  
  require Logger
  
  @doc &quot;&quot;&quot;
  Handles errors from the License Manager API and returns user-friendly messages.
  
  ## Parameters
  
  - `error` - Error tuple from the License Manager client
  
  ## Returns
  
  - String containing a user-friendly error message
  
  ## Examples
  
  ```elixir
  case Wanderer.LicenseManager.Client.create_license(params) do
    {:ok, license} -&gt;
      # Handle success
      
    error -&gt;
      error_message = Wanderer.LicenseManager.ErrorHandler.handle_error(error)
      # Display error_message to the user
  end
  ```
  &quot;&quot;&quot;
  def handle_error({:error, reason}) do
    case reason do
      :request_failed -&gt;
        &quot;Could not connect to the license server. Please try again later.&quot;
        
      :invalid_response -&gt;
        &quot;Received an invalid response from the license server.&quot;
        
      :invalid_license -&gt;
        &quot;The license key is invalid or has expired.&quot;
        
      &quot;Missing required fields: &quot; &lt;&gt; fields -&gt;
        &quot;Missing required license information: #{fields}&quot;
        
      &quot;Invalid date format for valid_to&quot; &lt;&gt; _ -&gt;
        &quot;Invalid expiration date format. Please use YYYY-MM-DD format.&quot;
        
      &quot;License not found&quot; -&gt;
        &quot;The specified license could not be found.&quot;
        
      error when is_binary(error) -&gt;
        &quot;License error: #{error}&quot;
        
      _ -&gt;
        Logger.error(&quot;Unhandled license error: #{inspect(reason)}&quot;)
        &quot;An unexpected error occurred with the license. Please contact support.&quot;
    end
  end
end

defmodule Wanderer.Subscriptions do
  @moduledoc &quot;&quot;&quot;
  Example module showing integration with the License Manager.
  
  This module demonstrates how to create and manage licenses
  as part of the subscription process.
  &quot;&quot;&quot;
  
  alias Wanderer.LicenseManager.Client
  alias Wanderer.LicenseManager.ErrorHandler
  
  @doc &quot;&quot;&quot;
  Creates a new subscription and associated license.
  
  ## Parameters
  
  - `params` - Map containing subscription details
  
  ## Returns
  
  - `{:ok, %{subscription: subscription, license: license}}` - On success
  - `{:error, reason}` - On failure
  &quot;&quot;&quot;
  def create_subscription(params) do
    # Start a database transaction
    Ecto.Multi.new()
    |&gt; Ecto.Multi.run(:subscription, fn _repo, _changes -&gt;
      # Your existing subscription creation logic
      create_subscription_in_db(params)
    end)
    |&gt; Ecto.Multi.run(:license, fn _repo, %{subscription: subscription} -&gt;
      # Create a license for the subscription
      create_license_for_subscription(subscription)
    end)
    |&gt; Ecto.Multi.run(:update_subscription, fn repo, %{subscription: subscription, license: license} -&gt;
      # Update subscription with license information
      update_subscription_with_license(repo, subscription, license)
    end)
    |&gt; Wanderer.Repo.transaction()
    |&gt; case do
      {:ok, %{subscription: subscription, license: license, update_subscription: updated_subscription}} -&gt;
        {:ok, %{subscription: updated_subscription, license: license}}
        
      {:error, _failed_operation, reason, _changes} -&gt;
        {:error, reason}
    end
  end
  
  @doc &quot;&quot;&quot;
  Updates a subscription and its associated license.
  
  ## Parameters
  
  - `subscription_id` - ID of the subscription to update
  - `params` - Map containing subscription update details
  
  ## Returns
  
  - `{:ok, %{subscription: subscription, license: license}}` - On success
  - `{:error, reason}` - On failure
  &quot;&quot;&quot;
  def update_subscription(subscription_id, params) do
    # Get the current subscription
    with {:ok, subscription} &lt;- get_subscription(subscription_id),
         {:ok, updated_subscription} &lt;- update_subscription_in_db(subscription, params) do
      
      # Check if we need to update the license
      if should_update_license?(subscription, updated_subscription) do
        case update_license_for_subscription(updated_subscription) do
          {:ok, license} -&gt;
            {:ok, %{subscription: updated_subscription, license: license}}
            
          error -&gt;
            # Log the error but don&apos;t fail the subscription update
            Logger.error(&quot;Failed to update license: #{inspect(error)}&quot;)
            {:ok, %{subscription: updated_subscription, license: nil}}
        end
      else
        {:ok, %{subscription: updated_subscription, license: nil}}
      end
    end
  end
  
  # Private helper functions
  
  defp create_subscription_in_db(params) do
    # Your existing logic to create a subscription in the database
    # This is just a placeholder
    {:ok, %{
      id: &quot;sub_#{:rand.uniform(1000)}&quot;,
      map_id: params[&quot;map_id&quot;],
      map_name: params[&quot;map_name&quot;],
      user_email: params[&quot;user_email&quot;],
      expires_at: params[&quot;expires_at&quot;] || default_expiration(),
      status: &quot;active&quot;
    }}
  end
  
  defp create_license_for_subscription(subscription) do
    license_params = %{
      &quot;name&quot; =&gt; &quot;#{subscription.map_name} License&quot;,
      &quot;description&quot; =&gt; &quot;License for #{subscription.map_name}&quot;,
      &quot;is_valid&quot; =&gt; true,
      &quot;valid_to&quot; =&gt; format_date(subscription.expires_at),
      &quot;link&quot; =&gt; generate_map_link(subscription),
      &quot;contact_email&quot; =&gt; subscription.user_email
    }
    
    # Use the retry version for better reliability
    Client.create_license_with_retry(license_params)
  end
  
  defp update_subscription_with_license(_repo, subscription, license) do
    # Update the subscription with license information
    # This is just a placeholder
    {:ok, Map.put(subscription, :license_id, license[&quot;id&quot;])}
  end
  
  defp get_subscription(subscription_id) do
    # Your logic to get a subscription from the database
    # This is just a placeholder
    {:ok, %{
      id: subscription_id,
      map_id: &quot;map_123&quot;,
      map_name: &quot;Example Map&quot;,
      user_email: &quot;user@example.com&quot;,
      expires_at: default_expiration(),
      status: &quot;active&quot;,
      license_id: &quot;license_123&quot;
    }}
  end
  
  defp update_subscription_in_db(subscription, params) do
    # Your logic to update a subscription in the database
    # This is just a placeholder
    {:ok, Map.merge(subscription, params)}
  end
  
  defp should_update_license?(old_subscription, new_subscription) do
    # Check if relevant fields have changed that would require a license update
    old_subscription.expires_at != new_subscription.expires_at ||
      old_subscription.status != new_subscription.status
  end
  
  defp update_license_for_subscription(subscription) do
    # Only update fields that are relevant for the license
    update_params = %{
      &quot;is_valid&quot; =&gt; subscription.status == &quot;active&quot;,
      &quot;valid_to&quot; =&gt; format_date(subscription.expires_at)
    }
    
    # Use the retry version for better reliability
    Client.update_license_with_retry(subscription.license_id, update_params)
  end
  
  defp format_date(datetime) do
    # Format datetime as YYYY-MM-DD
    Calendar.strftime(datetime, &quot;%Y-%m-%d&quot;)
  end
  
  defp generate_map_link(subscription) do
    # Generate a link to the map
    &quot;https://wanderer.com/maps/#{subscription.map_id}&quot;
  end
  
  defp default_expiration do
    # One year from now
    DateTime.utc_now() |&gt; DateTime.add(365, :day)
  end
end

defmodule WandererWeb.MapLive.LicenseComponent do
  @moduledoc &quot;&quot;&quot;
  LiveView component for displaying license information.
  
  This component provides a UI for viewing and copying license keys,
  as well as displaying associated bots.
  &quot;&quot;&quot;
  
  use Phoenix.LiveComponent
  
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;license-info&quot;&gt;
      &lt;h3 class=&quot;text-lg font-semibold&quot;&gt;License Information&lt;/h3&gt;
      
      &lt;div class=&quot;mt-4 p-4 border rounded-md bg-gray-50&quot;&gt;
        &lt;div class=&quot;flex justify-between items-center&quot;&gt;
          &lt;span class=&quot;font-medium&quot;&gt;License Key:&lt;/span&gt;
          &lt;div class=&quot;flex items-center&quot;&gt;
            &lt;span class=&quot;font-mono bg-gray-100 px-2 py-1 rounded&quot;&gt;
              &lt;%= if @show_key, do: @license.key, else: &quot;&quot; %&gt;
            &lt;/span&gt;
            &lt;button 
              type=&quot;button&quot; 
              phx-click=&quot;toggle-key-visibility&quot; 
              phx-target={@myself}
              class=&quot;ml-2 text-blue-600 hover:text-blue-800&quot;
            &gt;
              &lt;%= if @show_key, do: &quot;Hide&quot;, else: &quot;Show&quot; %&gt;
            &lt;/button&gt;
            &lt;button 
              type=&quot;button&quot; 
              phx-click=&quot;copy-key&quot; 
              phx-target={@myself}
              class=&quot;ml-2 text-blue-600 hover:text-blue-800&quot;
            &gt;
              Copy
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class=&quot;mt-3 grid grid-cols-2 gap-2&quot;&gt;
          &lt;div&gt;
            &lt;span class=&quot;text-sm text-gray-500&quot;&gt;Status:&lt;/span&gt;
            &lt;span class={@license.is_valid &amp;&amp; &quot;text-green-600&quot; || &quot;text-red-600&quot;}&gt;
              &lt;%= @license.is_valid &amp;&amp; &quot;Active&quot; || &quot;Inactive&quot; %&gt;
            &lt;/span&gt;
          &lt;/div&gt;
          
          &lt;div&gt;
            &lt;span class=&quot;text-sm text-gray-500&quot;&gt;Expires:&lt;/span&gt;
            &lt;span&gt;&lt;%= @license.valid_to %&gt;&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;%= if @license.bots &amp;&amp; length(@license.bots) &gt; 0 do %&gt;
          &lt;div class=&quot;mt-4&quot;&gt;
            &lt;h4 class=&quot;font-medium mb-2&quot;&gt;Associated Bots&lt;/h4&gt;
            &lt;div class=&quot;border rounded-md overflow-hidden&quot;&gt;
              &lt;table class=&quot;min-w-full divide-y divide-gray-200&quot;&gt;
                &lt;thead class=&quot;bg-gray-100&quot;&gt;
                  &lt;tr&gt;
                    &lt;th class=&quot;px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;Name&lt;/th&gt;
                    &lt;th class=&quot;px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;Status&lt;/th&gt;
                    &lt;th class=&quot;px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;API Token&lt;/th&gt;
                    &lt;th class=&quot;px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;Actions&lt;/th&gt;
                  &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody class=&quot;bg-white divide-y divide-gray-200&quot;&gt;
                  &lt;%= for bot &lt;- @license.bots do %&gt;
                    &lt;tr&gt;
                      &lt;td class=&quot;px-4 py-2 whitespace-nowrap&quot;&gt;
                        &lt;div class=&quot;flex items-center&quot;&gt;
                          &lt;div&gt;
                            &lt;div class=&quot;text-sm font-medium text-gray-900&quot;&gt;&lt;%= bot.name %&gt;&lt;/div&gt;
                            &lt;div class=&quot;text-sm text-gray-500&quot;&gt;&lt;%= bot.description %&gt;&lt;/div&gt;
                          &lt;/div&gt;
                        &lt;/div&gt;
                      &lt;/td&gt;
                      &lt;td class=&quot;px-4 py-2 whitespace-nowrap&quot;&gt;
                        &lt;span class={&quot;px-2 inline-flex text-xs leading-5 font-semibold rounded-full #{bot.is_active &amp;&amp; &quot;bg-green-100 text-green-800&quot; || &quot;bg-red-100 text-red-800&quot;}&quot;}&gt;
                          &lt;%= bot.is_active &amp;&amp; &quot;Active&quot; || &quot;Inactive&quot; %&gt;
                        &lt;/span&gt;
                      &lt;/td&gt;
                      &lt;td class=&quot;px-4 py-2 whitespace-nowrap&quot;&gt;
                        &lt;div class=&quot;flex items-center&quot;&gt;
                          &lt;span class=&quot;font-mono text-sm bg-gray-100 px-2 py-1 rounded truncate max-w-xs&quot;&gt;
                            &lt;%= if @show_tokens[bot.id], do: bot.api_token, else: &quot;&quot; %&gt;
                          &lt;/span&gt;
                          &lt;button 
                            type=&quot;button&quot; 
                            phx-click=&quot;toggle-token-visibility&quot; 
                            phx-value-bot-id={bot.id}
                            phx-target={@myself}
                            class=&quot;ml-2 text-blue-600 hover:text-blue-800 text-sm&quot;
                          &gt;
                            &lt;%= if @show_tokens[bot.id], do: &quot;Hide&quot;, else: &quot;Show&quot; %&gt;
                          &lt;/button&gt;
                        &lt;/div&gt;
                      &lt;/td&gt;
                      &lt;td class=&quot;px-4 py-2 whitespace-nowrap text-sm&quot;&gt;
                        &lt;button 
                          type=&quot;button&quot; 
                          phx-click=&quot;copy-token&quot; 
                          phx-value-bot-id={bot.id}
                          phx-target={@myself}
                          class=&quot;text-blue-600 hover:text-blue-800&quot;
                        &gt;
                          Copy Token
                        &lt;/button&gt;
                      &lt;/td&gt;
                    &lt;/tr&gt;
                  &lt;% end %&gt;
                &lt;/tbody&gt;
              &lt;/table&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;% end %&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
  
  def mount(socket) do
    {:ok, assign(socket, show_key: false, show_tokens: %{})}
  end
  
  def update(assigns, socket) do
    # Initialize show_tokens map for all bots
    show_tokens = if assigns.license.bots do
      Enum.reduce(assigns.license.bots, %{}, fn bot, acc -&gt;
        Map.put(acc, bot.id, false)
      end)
    else
      %{}
    end
    
    {:ok, assign(socket, assigns) |&gt; assign(:show_tokens, show_tokens)}
  end
  
  def handle_event(&quot;toggle-key-visibility&quot;, _, socket) do
    {:noreply, assign(socket, show_key: !socket.assigns.show_key)}
  end
  
  def handle_event(&quot;toggle-token-visibility&quot;, %{&quot;bot-id&quot; =&gt; bot_id}, socket) do
    show_tokens = Map.update(socket.assigns.show_tokens, bot_id, false, &amp;(!&amp;1))
    {:noreply, assign(socket, show_tokens: show_tokens)}
  end
  
  def handle_event(&quot;copy-key&quot;, _, socket) do
    # Send JS command to copy the key to clipboard
    {:noreply, 
     push_event(socket, &quot;copy-to-clipboard&quot;, %{text: socket.assigns.license.key})}
  end
  
  def handle_event(&quot;copy-token&quot;, %{&quot;bot-id&quot; =&gt; bot_id}, socket) do
    # Find the bot and copy its token
    bot = Enum.find(socket.assigns.license.bots, &amp;(&amp;1.id == bot_id))
    
    if bot do
      {:noreply, 
       push_event(socket, &quot;copy-to-clipboard&quot;, %{text: bot.api_token})}
    else
      {:noreply, socket}
    end
  end
end</file><file path="docs/wanderer_integration_guide.md"># Wanderer Integration Guide for License Manager

This guide provides detailed instructions for integrating the Wanderer project with the License Manager API. It includes configuration steps, code examples, and best practices.

## Table of Contents

1. [Overview](#overview)
2. [Configuration Setup](#configuration-setup)
3. [Implementation Guide](#implementation-guide)
4. [UI Integration](#ui-integration)
5. [Error Handling](#error-handling)
6. [Testing](#testing)
7. [Best Practices](#best-practices)

## Overview

The License Manager API provides endpoints for creating and managing licenses. The Wanderer project needs to integrate with this API to:

1. Create licenses automatically when a new map subscription is created
2. Display license information in the map settings UI
3. Validate licenses when needed

## Configuration Setup

### Environment Variables

Add the following environment variables to your Wanderer project:

```elixir
# config/runtime.exs

# License Manager API Configuration
config :wanderer, :license_manager,
  api_url: System.get_env(&quot;LICENSE_MANAGER_API_URL&quot;) || &quot;http://localhost:4000&quot;,
  auth_key: System.get_env(&quot;LICENSE_MANAGER_AUTH_KEY&quot;) || raise(&quot;LICENSE_MANAGER_AUTH_KEY is required&quot;)
```

### Development Environment

For local development, you can set these variables in your `.env` file:

```
LICENSE_MANAGER_API_URL=http://localhost:4000
LICENSE_MANAGER_AUTH_KEY=your_lm_auth_key
```

### Production Environment

In production, ensure these variables are set in your deployment environment.

## Implementation Guide

### Create a License Manager Service Module

Create a new module to handle communication with the License Manager API:

```elixir
# lib/wanderer/license_manager/client.ex
defmodule Wanderer.LicenseManager.Client do
  @moduledoc &quot;&quot;&quot;
  Client for interacting with the License Manager API.
  &quot;&quot;&quot;

  require Logger

  @doc &quot;&quot;&quot;
  Creates a new license in the License Manager.

  ## Parameters

  - `license_params` - Map containing license details:
    - `name` (required) - Name of the license
    - `description` (optional) - Description of the license
    - `is_valid` (optional) - Boolean indicating if the license is valid
    - `valid_to` (optional) - Expiration date in YYYY-MM-DD format
    - `link` (required) - URL associated with the license
    - `contact_email` (optional) - Contact email for the license

  ## Returns

  - `{:ok, license}` - On successful creation
  - `{:error, reason}` - On failure
  &quot;&quot;&quot;
  def create_license(license_params) do
    url = &quot;#{api_url()}/api/manage/licenses&quot;

    headers = [
      {&quot;Authorization&quot;, &quot;Bearer #{auth_key()}&quot;},
      {&quot;Content-Type&quot;, &quot;application/json&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;}
    ]

    with {:ok, body} &lt;- Jason.encode(license_params),
         {:ok, %{status_code: status, body: response_body}} when status in 200..299 &lt;-
           HTTPoison.post(url, body, headers),
         {:ok, license} &lt;- Jason.decode(response_body) do
      {:ok, license}
    else
      {:ok, %{status_code: status, body: body}} -&gt;
        Logger.error(&quot;Failed to create license. Status: #{status}, Body: #{body}&quot;)
        parse_error_response(status, body)

      {:error, %Jason.DecodeError{} = error} -&gt;
        Logger.error(&quot;Failed to decode response: #{inspect(error)}&quot;)
        {:error, :invalid_response}

      {:error, %HTTPoison.Error{} = error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  @doc &quot;&quot;&quot;
  Updates an existing license in the License Manager.

  ## Parameters

  - `license_id` - ID of the license to update
  - `update_params` - Map containing fields to update:
    - `is_valid` (optional) - Boolean indicating if the license is valid
    - `valid_to` (optional) - Expiration date in YYYY-MM-DD format

  ## Returns

  - `{:ok, license}` - On successful update
  - `{:error, reason}` - On failure
  &quot;&quot;&quot;
  def update_license(license_id, update_params) do
    url = &quot;#{api_url()}/api/manage/licenses/#{license_id}&quot;

    headers = [
      {&quot;Authorization&quot;, &quot;Bearer #{auth_key()}&quot;},
      {&quot;Content-Type&quot;, &quot;application/json&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;}
    ]

    with {:ok, body} &lt;- Jason.encode(update_params),
         {:ok, %{status_code: status, body: response_body}} when status in 200..299 &lt;-
           HTTPoison.put(url, body, headers),
         {:ok, license} &lt;- Jason.decode(response_body) do
      {:ok, license}
    else
      {:ok, %{status_code: status, body: body}} -&gt;
        Logger.error(&quot;Failed to update license. Status: #{status}, Body: #{body}&quot;)
        parse_error_response(status, body)

      {:error, %Jason.DecodeError{} = error} -&gt;
        Logger.error(&quot;Failed to decode response: #{inspect(error)}&quot;)
        {:error, :invalid_response}

      {:error, %HTTPoison.Error{} = error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  @doc &quot;&quot;&quot;
  Validates a license using its key.

  ## Parameters

  - `license_key` - The license key to validate

  ## Returns

  - `{:ok, %{license_valid: boolean, valid_to: date}}` - On successful validation
  - `{:error, reason}` - On failure
  &quot;&quot;&quot;
  def validate_license(license_key) do
    url = &quot;#{api_url()}/api/license/validate&quot;

    headers = [
      {&quot;Authorization&quot;, &quot;Bearer #{license_key}&quot;},
      {&quot;Accept&quot;, &quot;application/json&quot;}
    ]

    with {:ok, %{status_code: 200, body: response_body}} &lt;- HTTPoison.get(url, headers),
         {:ok, validation_result} &lt;- Jason.decode(response_body) do
      {:ok, validation_result}
    else
      {:ok, %{status_code: 401}} -&gt;
        {:error, :invalid_license}

      {:ok, %{status_code: status, body: body}} -&gt;
        Logger.error(&quot;Failed to validate license. Status: #{status}, Body: #{body}&quot;)
        parse_error_response(status, body)

      {:error, %Jason.DecodeError{} = error} -&gt;
        Logger.error(&quot;Failed to decode response: #{inspect(error)}&quot;)
        {:error, :invalid_response}

      {:error, %HTTPoison.Error{} = error} -&gt;
        Logger.error(&quot;HTTP request failed: #{inspect(error)}&quot;)
        {:error, :request_failed}
    end
  end

  # Private helper functions

  defp api_url do
    Application.get_env(:wanderer, :license_manager)[:api_url]
  end

  defp auth_key do
    Application.get_env(:wanderer, :license_manager)[:auth_key]
  end

  defp parse_error_response(status, body) do
    case Jason.decode(body) do
      {:ok, %{&quot;error&quot; =&gt; error_message}} -&gt;
        {:error, error_message}

      _ -&gt;
        {:error, &quot;HTTP #{status}: #{body}&quot;}
    end
  end
end
```

### Integration with Subscription Creation

Modify your subscription creation logic to automatically create a license:

```elixir
# Example integration in a subscription context
defmodule Wanderer.Subscriptions do
  alias Wanderer.LicenseManager.Client

  def create_subscription(params) do
    # Your existing subscription creation logic
    with {:ok, subscription} &lt;- create_subscription_in_db(params),
         {:ok, license} &lt;- create_license_for_subscription(subscription) do
      # Update subscription with license information
      update_subscription_with_license(subscription, license)
    end
  end

  defp create_license_for_subscription(subscription) do
    license_params = %{
      &quot;name&quot; =&gt; &quot;#{subscription.map_name} License&quot;,
      &quot;description&quot; =&gt; &quot;License for #{subscription.map_name}&quot;,
      &quot;is_valid&quot; =&gt; true,
      &quot;valid_to&quot; =&gt; format_expiration_date(subscription.expires_at),
      &quot;link&quot; =&gt; generate_map_link(subscription),
      &quot;contact_email&quot; =&gt; subscription.user_email
    }

    Client.create_license(license_params)
  end

  defp format_expiration_date(datetime) do
    # Format datetime as YYYY-MM-DD
    Calendar.strftime(datetime, &quot;%Y-%m-%d&quot;)
  end

  defp generate_map_link(subscription) do
    # Generate a link to the map
    &quot;https://yourdomain.com/maps/#{subscription.map_id}&quot;
  end

  defp update_subscription_with_license(subscription, license) do
    # Update the subscription with license information
    # This depends on your data model
  end
end
```

## UI Integration

### Display License Information in Map Settings

Add a component to display license information in the map settings UI:

```elixir
# Example LiveView component
defmodule WandererWeb.MapLive.LicenseComponent do
  use WandererWeb, :live_component

  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;license-info&quot;&gt;
      &lt;h3 class=&quot;text-lg font-semibold&quot;&gt;License Information&lt;/h3&gt;

      &lt;div class=&quot;mt-4 p-4 border rounded-md bg-gray-50&quot;&gt;
        &lt;div class=&quot;flex justify-between items-center&quot;&gt;
          &lt;span class=&quot;font-medium&quot;&gt;License Key:&lt;/span&gt;
          &lt;div class=&quot;flex items-center&quot;&gt;
            &lt;span class=&quot;font-mono bg-gray-100 px-2 py-1 rounded&quot;&gt;
              &lt;%= if @show_key, do: @license.key, else: &quot;&quot; %&gt;
            &lt;/span&gt;
            &lt;button
              type=&quot;button&quot;
              phx-click=&quot;toggle-key-visibility&quot;
              phx-target={@myself}
              class=&quot;ml-2 text-blue-600 hover:text-blue-800&quot;
            &gt;
              &lt;%= if @show_key, do: &quot;Hide&quot;, else: &quot;Show&quot; %&gt;
            &lt;/button&gt;
            &lt;button
              type=&quot;button&quot;
              phx-click=&quot;copy-key&quot;
              phx-target={@myself}
              class=&quot;ml-2 text-blue-600 hover:text-blue-800&quot;
            &gt;
              Copy
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;mt-3 grid grid-cols-2 gap-2&quot;&gt;
          &lt;div&gt;
            &lt;span class=&quot;text-sm text-gray-500&quot;&gt;Status:&lt;/span&gt;
            &lt;span class={@license.is_valid &amp;&amp; &quot;text-green-600&quot; || &quot;text-red-600&quot;}&gt;
              &lt;%= @license.is_valid &amp;&amp; &quot;Active&quot; || &quot;Inactive&quot; %&gt;
            &lt;/span&gt;
          &lt;/div&gt;

          &lt;div&gt;
            &lt;span class=&quot;text-sm text-gray-500&quot;&gt;Expires:&lt;/span&gt;
            &lt;span&gt;&lt;%= @license.valid_to %&gt;&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def mount(socket) do
    {:ok, assign(socket, show_key: false)}
  end

  def handle_event(&quot;toggle-key-visibility&quot;, _, socket) do
    {:noreply, assign(socket, show_key: !socket.assigns.show_key)}
  end

  def handle_event(&quot;copy-key&quot;, _, socket) do
    # Send JS command to copy the key to clipboard
    {:noreply,
     push_event(socket, &quot;copy-to-clipboard&quot;, %{text: socket.assigns.license.key})}
  end
end
```

Add JavaScript to handle clipboard copying:

```javascript
// assets/js/app.js
window.addEventListener(&quot;phx:copy-to-clipboard&quot;, (e) =&gt; {
  const el = document.createElement(&quot;textarea&quot;);
  el.value = e.detail.text;
  document.body.appendChild(el);
  el.select();
  document.execCommand(&quot;copy&quot;);
  document.body.removeChild(el);

  // Show a notification
  const notification = document.createElement(&quot;div&quot;);
  notification.textContent = &quot;Copied to clipboard!&quot;;
  notification.className =
    &quot;fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded shadow&quot;;
  document.body.appendChild(notification);

  setTimeout(() =&gt; {
    notification.remove();
  }, 2000);
});
```

## Error Handling

Implement proper error handling for API calls:

```elixir
# lib/wanderer/license_manager/error_handler.ex
defmodule Wanderer.LicenseManager.ErrorHandler do
  @moduledoc &quot;&quot;&quot;
  Handles errors from the License Manager API.
  &quot;&quot;&quot;

  require Logger

  @doc &quot;&quot;&quot;
  Handles errors from the License Manager API and returns user-friendly messages.
  &quot;&quot;&quot;
  def handle_error({:error, reason}) do
    case reason do
      :request_failed -&gt;
        &quot;Could not connect to the license server. Please try again later.&quot;

      :invalid_response -&gt;
        &quot;Received an invalid response from the license server.&quot;

      :invalid_license -&gt;
        &quot;The license key is invalid or has expired.&quot;

      &quot;Missing required fields: &quot; &lt;&gt; fields -&gt;
        &quot;Missing required license information: #{fields}&quot;

      &quot;Invalid date format for valid_to&quot; &lt;&gt; _ -&gt;
        &quot;Invalid expiration date format. Please use YYYY-MM-DD format.&quot;

      &quot;License not found&quot; -&gt;
        &quot;The specified license could not be found.&quot;

      error when is_binary(error) -&gt;
        &quot;License error: #{error}&quot;

      _ -&gt;
        Logger.error(&quot;Unhandled license error: #{inspect(reason)}&quot;)
        &quot;An unexpected error occurred with the license. Please contact support.&quot;
    end
  end
end
```

## Testing

### Mock the License Manager API for Tests

Create a mock module for testing:

```elixir
# test/support/mocks/license_manager_mock.ex
defmodule Wanderer.LicenseManager.MockClient do
  @moduledoc &quot;&quot;&quot;
  Mock implementation of the License Manager client for testing.
  &quot;&quot;&quot;

  def create_license(params) do
    # Validate required fields
    if !Map.has_key?(params, &quot;name&quot;) or !Map.has_key?(params, &quot;link&quot;) do
      {:error, &quot;Missing required fields: name, link&quot;}
    else
      # Return a successful response with mock data
      {:ok, Map.merge(params, %{
        &quot;id&quot; =&gt; &quot;mock-license-id&quot;,
        &quot;key&quot; =&gt; &quot;mock-license-key-#{:rand.uniform(1000)}&quot;
      })}
    end
  end

  def update_license(_license_id, params) do
    # Return a successful response with mock data
    {:ok, %{
      &quot;id&quot; =&gt; &quot;mock-license-id&quot;,
      &quot;name&quot; =&gt; &quot;Mock License&quot;,
      &quot;description&quot; =&gt; &quot;Mock license for testing&quot;,
      &quot;is_valid&quot; =&gt; Map.get(params, &quot;is_valid&quot;, true),
      &quot;valid_to&quot; =&gt; Map.get(params, &quot;valid_to&quot;, &quot;2025-12-31&quot;),
      &quot;link&quot; =&gt; &quot;https://example.com&quot;,
      &quot;contact_email&quot; =&gt; &quot;test@example.com&quot;
    }}
  end

  def validate_license(_license_key) do
    # Return a successful validation response
    {:ok, %{
      &quot;license_valid&quot; =&gt; true,
      &quot;valid_to&quot; =&gt; &quot;2025-12-31&quot;
    }}
  end
end
```

Configure your application to use the mock in test environment:

```elixir
# config/test.exs
config :wanderer, :license_manager_client, Wanderer.LicenseManager.MockClient
```

Update your client module to use the configured module:

```elixir
# lib/wanderer/license_manager/client.ex
defmodule Wanderer.LicenseManager.Client do
  # ...existing code...

  # Use the configured client module or default to this module
  defp client_module do
    Application.get_env(:wanderer, :license_manager_client, __MODULE__)
  end

  # Delegate to the client module if not this module
  defp delegate_if_needed(function, args) do
    module = client_module()

    if module == __MODULE__ do
      apply(__MODULE__, function, args)
    else
      apply(module, function, args)
    end
  end
end
```

## Best Practices

1. **Error Handling**: Always handle API errors gracefully and provide user-friendly messages.

2. **Retry Mechanism**: Implement a retry mechanism for transient failures:

   ```elixir
   def create_license_with_retry(params, max_attempts \\ 3) do
     retry_with_backoff(fn -&gt; create_license(params) end, max_attempts)
   end

   defp retry_with_backoff(func, attempts_left, delay \\ 1000) do
     case func.() do
       {:ok, result} -&gt;
         {:ok, result}

       {:error, reason} when attempts_left &gt; 1 -&gt;
         # Only retry for network-related errors
         if retryable_error?(reason) do
           :timer.sleep(delay)
           retry_with_backoff(func, attempts_left - 1, delay * 2)
         else
           {:error, reason}
         end

       error -&gt;
         error
     end
   end

   defp retryable_error?(:request_failed), do: true
   defp retryable_error?(_), do: false
   ```

3. **Logging**: Log all API interactions for debugging and auditing:

   ```elixir
   # Add to your client module
   defp log_request(method, url, params) do
     Logger.info(&quot;License Manager API Request: #{method} #{url}&quot;)
     Logger.debug(&quot;License Manager API Params: #{inspect(params)}&quot;)
   end

   defp log_response(status, body) do
     Logger.info(&quot;License Manager API Response: Status #{status}&quot;)
     Logger.debug(&quot;License Manager API Response Body: #{inspect(body)}&quot;)
   end
   ```

4. **Caching**: Consider caching license validation results to reduce API calls:

   ```elixir
   # Add to your client module
   def validate_license_with_cache(license_key) do
     cache_key = &quot;license_validation:#{license_key}&quot;

     case Cachex.get(:wanderer_cache, cache_key) do
       {:ok, nil} -&gt;
         # Not in cache, call API
         case validate_license(license_key) do
           {:ok, result} = success -&gt;
             # Cache the result for 1 hour
             Cachex.put(:wanderer_cache, cache_key, result, ttl: :timer.hours(1))
             success

           error -&gt;
             error
         end

       {:ok, result} -&gt;
         # Return cached result
         {:ok, result}
     end
   end
   ```

5. **Security**: Never expose the License Manager API key in client-side code or logs.

6. **Monitoring**: Set up monitoring for API calls to track performance and errors.

## Conclusion

This integration guide provides a comprehensive approach to integrating the Wanderer project with the License Manager API. By following these steps and best practices, you can ensure a smooth and reliable integration.

For any questions or issues, please contact the License Manager team.</file><file path="lib/wanderer_licenses/accounts/user/senders/send_magic_link_email.ex">defmodule WandererLicenses.Accounts.User.Senders.SendMagicLinkEmail do
  @moduledoc &quot;&quot;&quot;
  Sends a magic link email
  &quot;&quot;&quot;

  use AshAuthentication.Sender
  use WandererLicensesWeb, :verified_routes

  import Swoosh.Email
  alias WandererLicenses.Mailer

  @impl true
  def send(user_or_email, token, _) do
    # if you get a user, its for a user that already exists.
    # if you get an email, then the user does not yet exist.

    email =
      case user_or_email do
        %{email: email} -&gt; email
        email -&gt; email
      end

    new()
    # TODO: Replace with your email
    |&gt; from({&quot;noreply&quot;, &quot;noreply@example.com&quot;})
    |&gt; to(to_string(email))
    |&gt; subject(&quot;Your login link&quot;)
    |&gt; html_body(body(token: token, email: email))
    |&gt; Mailer.deliver!()
  end

  defp body(params) do
    url = url(~p&quot;/auth/user/magic_link/?token=#{params[:token]}&quot;)

    &quot;&quot;&quot;
    &lt;p&gt;Hello, #{params[:email]}! Click this link to sign in:&lt;/p&gt;
    &lt;p&gt;&lt;a href=&quot;#{url}&quot;&gt;#{url}&lt;/a&gt;&lt;/p&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_licenses/accounts/token.ex">defmodule WandererLicenses.Accounts.Token do
  use Ash.Resource,
    otp_app: :wanderer_licenses,
    domain: WandererLicenses.Accounts,
    authorizers: [Ash.Policy.Authorizer],
    extensions: [AshAuthentication.TokenResource],
    data_layer: AshPostgres.DataLayer

  postgres do
    table &quot;tokens&quot;
    repo WandererLicenses.Repo
  end

  actions do
    defaults [:read]

    read :expired do
      description &quot;Look up all expired tokens.&quot;
      filter expr(expires_at &lt; now())
    end

    read :get_token do
      description &quot;Look up a token by JTI or token, and an optional purpose.&quot;
      get? true
      argument :token, :string, sensitive?: true
      argument :jti, :string, sensitive?: true
      argument :purpose, :string, sensitive?: false

      prepare AshAuthentication.TokenResource.GetTokenPreparation
    end

    action :revoked?, :boolean do
      description &quot;Returns true if a revocation token is found for the provided token&quot;
      argument :token, :string, sensitive?: true
      argument :jti, :string, sensitive?: true

      run AshAuthentication.TokenResource.IsRevoked
    end

    create :revoke_token do
      description &quot;Revoke a token. Creates a revocation token corresponding to the provided token.&quot;
      accept [:extra_data]
      argument :token, :string, allow_nil?: false, sensitive?: true

      change AshAuthentication.TokenResource.RevokeTokenChange
    end

    create :store_token do
      description &quot;Stores a token used for the provided purpose.&quot;
      accept [:extra_data, :purpose]
      argument :token, :string, allow_nil?: false, sensitive?: true
      change AshAuthentication.TokenResource.StoreTokenChange
    end

    destroy :expunge_expired do
      description &quot;Deletes expired tokens.&quot;
      change filter expr(expires_at &lt; now())
    end

    update :revoke_all_stored_for_subject do
      description &quot;Revokes all stored tokens for a specific subject.&quot;
      accept [:extra_data]
      argument :subject, :string, allow_nil?: false, sensitive?: true
      change AshAuthentication.TokenResource.RevokeAllStoredForSubjectChange
    end
  end

  policies do
    bypass AshAuthentication.Checks.AshAuthenticationInteraction do
      description &quot;AshAuthentication can interact with the token resource&quot;
      authorize_if always()
    end

    policy always() do
      description &quot;No one aside from AshAuthentication can interact with the tokens resource.&quot;
      forbid_if always()
    end
  end

  attributes do
    attribute :jti, :string do
      primary_key? true
      public? true
      allow_nil? false
      sensitive? true
    end

    attribute :subject, :string do
      allow_nil? false
      public? true
    end

    attribute :expires_at, :utc_datetime do
      allow_nil? false
      public? true
    end

    attribute :purpose, :string do
      allow_nil? false
      public? true
    end

    attribute :extra_data, :map do
      public? true
    end

    timestamps()
  end
end</file><file path="lib/wanderer_licenses/accounts/user.ex">defmodule WandererLicenses.Accounts.User do
  use Ash.Resource,
    otp_app: :wanderer_licenses,
    domain: WandererLicenses.Accounts,
    authorizers: [Ash.Policy.Authorizer],
    extensions: [AshAuthentication],
    data_layer: AshPostgres.DataLayer

  authentication do
    add_ons do
      log_out_everywhere do
        apply_on_password_change?(true)
      end
    end

    tokens do
      enabled? true
      token_resource WandererLicenses.Accounts.Token
      signing_secret WandererLicenses.Secrets
      store_all_tokens? true
      require_token_presence_for_authentication? true
    end

    strategies do
      magic_link do
        identity_field :email
        registration_enabled? true

        sender WandererLicenses.Accounts.User.Senders.SendMagicLinkEmail
      end
    end
  end

  postgres do
    table &quot;users&quot;
    repo WandererLicenses.Repo
  end

  actions do
    defaults [:read]

    read :get_by_subject do
      description &quot;Get a user by the subject claim in a JWT&quot;
      argument :subject, :string, allow_nil?: false
      get? true
      prepare AshAuthentication.Preparations.FilterBySubject
    end

    read :get_by_email do
      description &quot;Looks up a user by their email&quot;
      get? true

      argument :email, :ci_string do
        allow_nil? false
      end

      filter expr(email == ^arg(:email))
    end

    create :sign_in_with_magic_link do
      description &quot;Sign in or register a user with magic link.&quot;

      argument :token, :string do
        description &quot;The token from the magic link that was sent to the user&quot;
        allow_nil? false
      end

      upsert? true
      upsert_identity :unique_email
      upsert_fields [:email]

      # Uses the information from the token to create or sign in the user
      change AshAuthentication.Strategy.MagicLink.SignInChange

      metadata :token, :string do
        allow_nil? false
      end
    end

    action :request_magic_link do
      argument :email, :ci_string do
        allow_nil? false
      end

      run AshAuthentication.Strategy.MagicLink.Request
    end
  end

  policies do
    bypass AshAuthentication.Checks.AshAuthenticationInteraction do
      authorize_if always()
    end

    policy always() do
      forbid_if always()
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :email, :ci_string do
      allow_nil? false
      public? true
    end
  end

  identities do
    identity :unique_email, [:email]
  end
end</file><file path="lib/wanderer_licenses/analytics/bot_usage.ex">defmodule WandererLicenses.Analytics.BotUsage do
  @moduledoc &quot;&quot;&quot;
  Resource for tracking bot usage.
  
  This resource tracks when bots are used, storing:
  - bot_id: The ID of the bot
  - license_id: The ID of the license (if applicable)
  - used_at: When the bot was used
  - ip_address: The IP address that used the bot (optional)
  - user_agent: The user agent that used the bot (optional)
  &quot;&quot;&quot;
  use Ash.Resource,
    otp_app: :wanderer_licenses,
    domain: WandererLicenses.Analytics,
    data_layer: AshPostgres.DataLayer

  postgres do
    table &quot;bot_usage&quot;
    repo WandererLicenses.Repo
  end

  attributes do
    uuid_primary_key :id
    
    attribute :bot_id, :uuid, allow_nil?: false
    attribute :license_id, :uuid, allow_nil?: true
    attribute :used_at, :utc_datetime, allow_nil?: false, default: &amp;DateTime.utc_now/0
    attribute :ip_address, :string, allow_nil?: true
    attribute :user_agent, :string, allow_nil?: true
    
    # Add timestamps to match database schema requirements
    timestamps()
  end

  relationships do
    belongs_to :bot, WandererLicenses.Bots.Bot,
      primary_key?: false,
      allow_nil?: false
      
    belongs_to :license, WandererLicenses.Licenses.License,
      primary_key?: false,
      allow_nil?: true
  end

  actions do
    create :create do
      primary? true
      accept [:bot_id, :license_id, :ip_address, :user_agent]
    end

    defaults [:read]
  end
end</file><file path="lib/wanderer_licenses/bots/bot.ex">defmodule WandererLicenses.Bots.Bot do
  use Ash.Resource,
    otp_app: :wanderer_licenses,
    domain: WandererLicenses.Bots,
    data_layer: AshPostgres.DataLayer

  postgres do
    table &quot;bots&quot;
    repo WandererLicenses.Repo
  end

  attributes do
    uuid_primary_key :id
    attribute :name, :string, allow_nil?: false
    attribute :description, :string, allow_nil?: true
    attribute :api_token, :string, sensitive?: true, default: &amp;Ecto.UUID.generate/0
    attribute :is_active, :boolean, default: true
    attribute :developer_email, :string, allow_nil?: false
  end

  actions do
    create :create do
      primary? true
      accept [:name, :description, :developer_email]
      
      # Validate email format
      validate match(:developer_email, ~r/^[^\s]+@[^\s]+\.[^\s]+$/), message: &quot;must be a valid email address&quot;
    end

    update :update do
      primary? true
      accept [:name, :description, :developer_email]
      
      # Validate email format
      validate match(:developer_email, ~r/^[^\s]+@[^\s]+\.[^\s]+$/), message: &quot;must be a valid email address&quot;
    end

    update :activate do
      change set_attribute(:is_active, true)
    end

    update :deactivate do
      change set_attribute(:is_active, false)
    end

    defaults [:read, :destroy]
  end
end</file><file path="lib/wanderer_licenses/licenses/license_bot.ex">defmodule WandererLicenses.Licenses.LicenseBot do
  use Ash.Resource,
    otp_app: :wanderer_licenses,
    domain: WandererLicenses.Licenses,
    data_layer: AshPostgres.DataLayer

  postgres do
    table &quot;licenses_bots&quot;
    repo WandererLicenses.Repo
  end

  attributes do
    uuid_primary_key :id
    attribute :license_id, :uuid, allow_nil?: false
    attribute :bot_id, :uuid, allow_nil?: false
  end

  relationships do
    belongs_to :license, WandererLicenses.Licenses.License,
      primary_key?: true,
      allow_nil?: false
    belongs_to :bot, WandererLicenses.Bots.Bot,
      primary_key?: true,
      allow_nil?: false
  end

  actions do
    create :create do
      accept [:license_id, :bot_id]
      primary? true
    end

    defaults [:read, :update, :destroy]
  end
end</file><file path="lib/wanderer_licenses/licenses/license.ex">defmodule WandererLicenses.Licenses.License do
  @moduledoc &quot;&quot;&quot;
  A License resource with fields:
    - name (string)
    - description (string)
    - is_valid (boolean, default = false)
    - valid_to (date)
    - link (string)
    - contact_email (optional)
    - key (UUID, auto-generated; cleared when revoked)
  &quot;&quot;&quot;
  require Ash.Query

  use Ash.Resource,
    otp_app: :wanderer_licenses,
    domain: WandererLicenses.Licenses,
    data_layer: AshPostgres.DataLayer

  postgres do
    table &quot;licenses&quot;
    repo WandererLicenses.Repo
  end

  attributes do
    attribute :id, :uuid,
      primary_key?: true,
      allow_nil?: false,
      default: &amp;Ecto.UUID.generate/0

    attribute :name, :string, allow_nil?: false
    attribute :description, :string

    attribute :is_valid, :boolean,
      writable?: true,
      default: false

    attribute :valid_to, :date, allow_nil?: true
    attribute :link, :string, allow_nil?: false
    attribute :contact_email, :ci_string, allow_nil?: true

    attribute :key, :uuid,
      allow_nil?: true,
      sensitive?: true,
      default: &amp;Ecto.UUID.generate/0
  end

  actions do
    create :create do
      primary? true
      accept [:name, :description, :is_valid, :valid_to, :link, :contact_email]
    end

    update :update do
      accept [:name, :description, :is_valid, :valid_to, :link, :contact_email, :key]
    end

    update :enable do
      description &quot;Enable the license by setting is_valid and regenerating key&quot;
      change set_attribute(:is_valid, true)
      change set_attribute(:key, &amp;Ecto.UUID.generate/0)
    end

    update :revoke do
      description &quot;Revoke the license by clearing its key and marking it invalid.&quot;
      change set_attribute(:is_valid, false)
      change set_attribute(:valid_to, nil)
      change set_attribute(:key, nil)
    end

    defaults [:read, :destroy]
  end
end</file><file path="lib/wanderer_licenses/prom_ex/request_metrics.ex">defmodule WandererLicenses.PromEx.RequestMetrics do
  @moduledoc &quot;&quot;&quot;
  Custom PromEx plugin for tracking request metrics with user attribution.

  This plugin captures detailed information about API and web requests,
  including which endpoints are called and by which users.
  &quot;&quot;&quot;

  use PromEx.Plugin

  alias Telemetry.Metrics

  @impl true
  def event_metrics(opts) do
    metric_prefix = Keyword.get(opts, :metric_prefix, [:wanderer_licenses, :request])

    [
      # Request duration metrics
      Metrics.distribution(
        metric_prefix ++ [:duration_milliseconds],
        event_name: [:wanderer_licenses, :request],
        measurement: :duration,
        description: &quot;The time spent processing a request in milliseconds&quot;,
        reporter_options: [
          buckets: [10, 50, 100, 250, 500, 1000, 2500, 5000, 10000]
        ],
        tags: [:path, :method, :status, :user]
      ),

      # Request count metrics
      Metrics.counter(
        metric_prefix ++ [:count],
        event_name: [:wanderer_licenses, :request],
        description: &quot;The total number of requests&quot;,
        tags: [:path, :method, :status, :user]
      )
    ]
  end

  @impl true
  def polling_metrics(_opts), do: []

  @impl true
  def dashboard(opts) do
    metric_prefix = Keyword.get(opts, :metric_prefix, [:wanderer_licenses, :request])

    # Convert metric prefix to string format for Grafana
    metric_prefix_str =
      metric_prefix
      |&gt; Enum.map(&amp;to_string/1)
      |&gt; Enum.join(&quot;_&quot;)

    # Create a dashboard for request tracking
    {:ok, dashboard} =
      PromEx.Dashboard.Base.create(
        title: &quot;WandererLicenses Request Tracking&quot;,
        uid: &quot;wanderer-licenses-request-tracking&quot;,
        description: &quot;Request tracking metrics with user attribution&quot;,
        tags: [&quot;wanderer_licenses&quot;, &quot;requests&quot;, &quot;users&quot;],
        variables: [],
        panels: [
          # Request count by path
          %{
            title: &quot;Request Count by Path&quot;,
            type: &quot;barchart&quot;,
            description: &quot;Number of requests by path&quot;,
            width: 12,
            height: 8,
            targets: [
              %{
                expr: &quot;sum by (path) (#{metric_prefix_str}_count)&quot;,
                legend_format: &quot;{{path}}&quot;
              }
            ]
          },
          # Request count by user
          %{
            title: &quot;Request Count by User&quot;,
            type: &quot;piechart&quot;,
            description: &quot;Number of requests by user&quot;,
            width: 12,
            height: 8,
            targets: [
              %{
                expr: &quot;sum by (user) (#{metric_prefix_str}_count)&quot;,
                legend_format: &quot;{{user}}&quot;
              }
            ]
          },
          # Request duration by path
          %{
            title: &quot;Request Duration by Path&quot;,
            type: &quot;heatmap&quot;,
            description: &quot;Request duration by path&quot;,
            width: 24,
            height: 8,
            targets: [
              %{
                expr: &quot;sum by (path, le) (rate(#{metric_prefix_str}_duration_milliseconds_bucket[5m]))&quot;,
                legend_format: &quot;{{path}}&quot;
              }
            ]
          },
          # Top users by request count
          %{
            title: &quot;Top Users by Request Count&quot;,
            type: &quot;table&quot;,
            description: &quot;Top users by request count&quot;,
            width: 12,
            height: 8,
            targets: [
              %{
                expr: &quot;topk(10, sum by (user) (#{metric_prefix_str}_count))&quot;,
                legend_format: &quot;{{user}}&quot;
              }
            ]
          },
          # Top paths by request count
          %{
            title: &quot;Top Paths by Request Count&quot;,
            type: &quot;table&quot;,
            description: &quot;Top paths by request count&quot;,
            width: 12,
            height: 8,
            targets: [
              %{
                expr: &quot;topk(10, sum by (path) (#{metric_prefix_str}_count))&quot;,
                legend_format: &quot;{{path}}&quot;
              }
            ]
          }
        ]
      )

    dashboard
  end
end</file><file path="lib/wanderer_licenses/accounts.ex">defmodule WandererLicenses.Accounts do
  use Ash.Domain, otp_app: :wanderer_licenses, extensions: [AshAdmin.Domain]

  admin do
    show? true
  end

  resources do
    resource WandererLicenses.Accounts.Token
    resource WandererLicenses.Accounts.User
  end
end</file><file path="lib/wanderer_licenses/analytics.ex">defmodule WandererLicenses.Analytics do
  @moduledoc &quot;&quot;&quot;
  Analytics domain for tracking bot usage and generating reports.
  &quot;&quot;&quot;
  use Ash.Domain, validate_config_inclusion?: false
  require Logger

  resources do
    resource WandererLicenses.Analytics.BotUsage
  end

  @doc &quot;&quot;&quot;
  Get a report of active bots within a date range with optional filtering by bot IDs.
  
  ## Parameters
  
  * `date_from` - Start date for the report (inclusive)
  * `date_to` - End date for the report (inclusive)
  * `filter_bot_ids` - Optional list of bot IDs to filter by (if nil, all bots are included)
  * `filter_developer` - Optional developer email to filter by (if nil, all developers are included)
  
  ## Returns
  
  A list of maps with bot usage information, including:
  * bot_id - The ID of the bot
  * bot_name - The name of the bot
  * usage_count - The number of times the bot was used in the date range
  * last_used_at - The last time the bot was used in the date range
  * developer_email - Email of the bot developer
  &quot;&quot;&quot;
  def get_active_bots_report(date_from, date_to, filter_bot_ids \\ nil, filter_developer \\ nil) do
    import Ash.Query
    
    # Convert dates to datetime with proper time boundaries
    # Start of day for date_from (00:00:00)
    datetime_from = DateTime.new!(date_from, ~T[00:00:00], &quot;Etc/UTC&quot;)
    # End of day for date_to (23:59:59)
    datetime_to = DateTime.new!(date_to, ~T[23:59:59], &quot;Etc/UTC&quot;)
    
    Logger.info(&quot;Analytics: Generating report from #{DateTime.to_string(datetime_from)} to #{DateTime.to_string(datetime_to)}&quot;)
    Logger.info(&quot;Analytics: Filter bot IDs: #{inspect(filter_bot_ids)}&quot;)
    Logger.info(&quot;Analytics: Filter developer: #{inspect(filter_developer)}&quot;)

    # Start with a basic query filtering by date range
    query = WandererLicenses.Analytics.BotUsage
            |&gt; filter(used_at &gt;= ^datetime_from and used_at &lt;= ^datetime_to)

    # Apply bot ID filter if provided
    query = if filter_bot_ids &amp;&amp; length(filter_bot_ids) &gt; 0 do
      Logger.info(&quot;Analytics: Applying bot ID filter for #{length(filter_bot_ids)} bots&quot;)
      filter(query, bot_id in ^filter_bot_ids)
    else
      Logger.info(&quot;Analytics: No bot ID filter applied&quot;)
      query
    end

    # Execute the query to get all usage records in the date range
    usage_records = Ash.read!(query)
    Logger.info(&quot;Analytics: Found #{length(usage_records)} usage records in the database&quot;)
    
    # Log the first few records for debugging
    Enum.take(usage_records, 5)
    |&gt; Enum.each(fn record -&gt;
      Logger.info(&quot;Analytics: Usage record - Bot ID: #{record.bot_id}, Used at: #{DateTime.to_string(record.used_at)}&quot;)
    end)

    # Group by bot_id and calculate metrics manually
    usage_by_bot = Enum.reduce(usage_records, %{}, fn record, acc -&gt;
      bot_id = record.bot_id
      
      bot_data = Map.get(acc, bot_id, %{
        bot_id: bot_id,
        usage_count: 0,
        last_used_at: nil
      })
      
      # Update usage count
      updated_count = bot_data.usage_count + 1
      
      # Update last_used_at if this record is more recent
      updated_last_used = cond do
        bot_data.last_used_at == nil -&gt; record.used_at
        DateTime.compare(record.used_at, bot_data.last_used_at) == :gt -&gt; record.used_at
        true -&gt; bot_data.last_used_at
      end
      
      # Update the accumulator
      Map.put(acc, bot_id, %{
        bot_id: bot_id,
        usage_count: updated_count,
        last_used_at: updated_last_used
      })
    end)
    
    # Convert to list and sort by last_used_at
    usage_list = usage_by_bot
                 |&gt; Map.values()
                 |&gt; Enum.sort_by(fn %{last_used_at: last_used_at} -&gt; 
                      last_used_at
                    end, {:desc, DateTime})
    
    Logger.info(&quot;Analytics: Grouped data into #{length(usage_list)} unique bots&quot;)

    # Fetch bot details for each result
    result = Enum.map(usage_list, fn usage -&gt;
      # Use Ash.get! to retrieve the bot
      bot = Ash.get!(WandererLicenses.Bots.Bot, usage.bot_id)
      
      %{
        bot_id: usage.bot_id,
        bot_name: bot.name,
        usage_count: usage.usage_count,
        last_used_at: usage.last_used_at,
        is_active: bot.is_active,
        developer_email: bot.developer_email
      }
    end)
    
    # Apply developer filter if provided
    result = if filter_developer &amp;&amp; filter_developer != &quot;&quot; do
      Logger.info(&quot;Analytics: Applying developer filter for #{filter_developer}&quot;)
      Enum.filter(result, fn bot -&gt; 
        String.downcase(bot.developer_email) == String.downcase(filter_developer)
      end)
    else
      Logger.info(&quot;Analytics: No developer filter applied&quot;)
      result
    end
    
    Logger.info(&quot;Analytics: Final report contains #{length(result)} bots with usage data&quot;)
    result
  end
end</file><file path="lib/wanderer_licenses/application.ex">defmodule WandererLicenses.Application do
  # See https://hexdocs.pm/elixir/Application.html
  # for more information on OTP Applications
  @moduledoc false

  use Application

  @impl true
  def start(_type, _args) do
    children = [
      WandererLicensesWeb.Telemetry,
      # Start PromEx before other components to capture all telemetry events
      WandererLicenses.PromEx,
      WandererLicenses.Repo,
      {DNSCluster, query: Application.get_env(:wanderer_licenses, :dns_cluster_query) || :ignore},
      {Phoenix.PubSub, name: WandererLicenses.PubSub},
      # Start the Finch HTTP client for sending emails
      {Finch, name: WandererLicenses.Finch},
      # Start a worker by calling: WandererLicenses.Worker.start_link(arg)
      # {WandererLicenses.Worker, arg},
      # Start to serve requests, typically the last entry
      WandererLicensesWeb.Endpoint,
      {AshAuthentication.Supervisor, [otp_app: :wanderer_licenses]}
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: WandererLicenses.Supervisor]
    Supervisor.start_link(children, opts)
  end

  # Tell Phoenix to update the endpoint configuration
  # whenever the application is updated.
  @impl true
  def config_change(changed, _new, removed) do
    WandererLicensesWeb.Endpoint.config_change(changed, removed)
    :ok
  end
end</file><file path="lib/wanderer_licenses/bots.ex">defmodule WandererLicenses.Bots do
  use Ash.Domain

  resources do
    resource WandererLicenses.Bots.Bot
  end
end</file><file path="lib/wanderer_licenses/licenses.ex">defmodule WandererLicenses.Licenses do
  use Ash.Domain, otp_app: :wanderer_licenses

  resources do
    resource WandererLicenses.Licenses.License
    resource WandererLicenses.Licenses.LicenseBot
  end
end</file><file path="lib/wanderer_licenses/mailer.ex">defmodule WandererLicenses.Mailer do
  use Swoosh.Mailer, otp_app: :wanderer_licenses
end</file><file path="lib/wanderer_licenses/prom_ex.ex">defmodule WandererLicenses.PromEx do
  @moduledoc &quot;&quot;&quot;
  PromEx is a Prometheus metrics collection and Grafana dashboard library for Elixir applications.
  This module configures PromEx for the WandererLicenses application.
  &quot;&quot;&quot;

  use PromEx, otp_app: :wanderer_licenses

  alias PromEx.Plugins

  @impl true
  def plugins do
    [
      # Phoenix plugin for monitoring HTTP requests and LiveView metrics
      {Plugins.Phoenix, router: WandererLicensesWeb.Router, endpoint: WandererLicensesWeb.Endpoint},
      
      # Ecto plugin for monitoring database queries and connections
      {Plugins.Ecto, repos: [WandererLicenses.Repo]},
      
      # Beam plugin for monitoring the Erlang VM
      Plugins.Beam,
      
      # Application metrics for monitoring application-specific metrics
      {Plugins.Application, [
        metric_prefix: [:wanderer_licenses, :application],
        metadata_metrics: []
      ]},
      
      # Custom metrics for request tracking with user attribution - temporarily disabled
      # {WandererLicenses.PromEx.RequestMetrics, []}
    ]
  end

  @impl true
  def dashboard_assigns do
    [
      datasource_id: &quot;prometheus&quot;,
      default_selected_interval: &quot;30s&quot;
    ]
  end

  @impl true
  def dashboards do
    [
      # Phoenix dashboard
      {:prom_ex, &quot;phoenix.json&quot;},
      
      # Ecto dashboard
      {:prom_ex, &quot;ecto.json&quot;},
      
      # Beam dashboard
      {:prom_ex, &quot;beam.json&quot;},
      
      # Application dashboard
      {:prom_ex, &quot;application.json&quot;},
      
      # Custom request tracking dashboard - temporarily disabled
      # {:wanderer_licenses, &quot;request_tracking.json&quot;}
    ]
  end
end</file><file path="lib/wanderer_licenses/release.ex">defmodule WandererLicenses.Release do
  @moduledoc &quot;&quot;&quot;
  Used for executing DB release tasks when run in production without Mix
  installed.
  &quot;&quot;&quot;
  @app :wanderer_licenses
  @start_apps [
    :postgrex,
    :ecto
  ]

  def createdb(repos \\ repos()) do
    prepare()

    for repo &lt;- repos do
      :ok = ensure_repo_created(repo)
    end

    IO.puts(&quot;Creation of Db successful!&quot;)
  end

  def migrate(repos \\ repos()) do
    IO.puts(&quot;Run migrations..&quot;)
    prepare()

    for repo &lt;- repos() do
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :up, all: true))
    end

    :init.stop()
  end

  @doc &quot;&quot;&quot;
  `interweave_migrate/0` is a migration function that:

  - Lists all pending migrations across multiple repositories.
  - Sorts these migrations into a single list.
  - Groups consecutive migrations by repository into &quot;streaks&quot;.
  - Executes the migrations in the correct order by processing each streak sequentially.

  ### Why Use This Approach?

  This function resolves dependencies between migrations that span across different repositories.
  The default `migrate/0` function migrates each repository independently, which may result in
  migrations running in the wrong order when there are cross-repository dependencies.

  Consider the following example (adapted from reality, not 100% accurate):

  - **Migration 1**: The PostgreSQL (PG) repository creates a table named `site_imports`.
  - **Migration 2**: The ClickHouse (CH) repository creates `import_id` columns in `imported_*` tables.
  - **Migration 3**: The PG repository runs a data migration that utilizes both PG and CH databases,
    reading from the `import_id` column in `imported_*` tables.

  The default `migrate/0` would execute these migrations by repository, resulting in the following order:

  1. Migration 1 (PG)
  2. Migration 3 (PG)
  3. Migration 2 (CH)

  This sequence would fail at Migration 3, as the `import_id` columns in the CH repository have not been created yet.

  `interweave_migrate/0` addresses this issue by consolidating all pending migrations into a single, ordered queue:

  1. Migration 1 (PG)
  2. Migration 2 (CH)
  3. Migration 3 (PG)

  This ensures all dependencies are resolved in the correct order.
  &quot;&quot;&quot;
  def interweave_migrate(repos \\ repos()) do
    prepare()

    pending = all_pending_migrations(repos)
    streaks = migration_streaks(pending)

    Enum.each(streaks, fn {repo, up_to_version} -&gt;
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :up, to: up_to_version))
    end)
  end

  defp migration_streaks(pending_migrations) do
    sorted_migrations =
      pending_migrations
      |&gt; Enum.map(fn {repo, version, _name} -&gt; {repo, version} end)
      |&gt; Enum.sort_by(fn {_repo, version} -&gt; version end, :asc)

    streaks_reversed =
      Enum.reduce(sorted_migrations, [], fn {repo, _version} = latest_migration, streaks_acc -&gt;
        case streaks_acc do
          # start the streak for repo
          [] -&gt; [latest_migration]
          # extend the streak
          [{^repo, _prev_version} | rest] -&gt; [latest_migration | rest]
          # end the streak for prev_repo, start the streak for repo
          [{_prev_repo, _prev_version} | _rest] -&gt; [latest_migration | streaks_acc]
        end
      end)

    :lists.reverse(streaks_reversed)
  end

  @spec all_pending_migrations([Ecto.Repo.t()]) :: [{Ecto.Repo.t(), integer, String.t()}]
  defp all_pending_migrations(repos) do
    Enum.flat_map(repos, fn repo -&gt;
      # credo:disable-for-lines:6 Credo.Check.Refactor.Nesting
      {:ok, pending, _started} =
        Ecto.Migrator.with_repo(repo, fn repo -&gt;
          Ecto.Migrator.migrations(repo)
          |&gt; Enum.filter(fn {status, _version, _name} -&gt; status == :down end)
          |&gt; Enum.map(fn {_status, version, name} -&gt; {repo, version, name} end)
        end)

      pending
    end)
  end

  def pending_streaks(repos \\ repos()) do
    prepare()
    IO.puts(&quot;Collecting pending migrations..&quot;)

    pending = all_pending_migrations(repos)

    if pending == [] do
      IO.puts(&quot;No pending migrations!&quot;)
    else
      streaks = migration_streaks(pending)
      print_migration_streaks(streaks, pending)
    end
  end

  defp print_migration_streaks([{repo, up_to_version} | streaks], pending) do
    {streak, pending} =
      Enum.split_with(pending, fn {pending_repo, version, _name} -&gt;
        pending_repo == repo and version &lt;= up_to_version
      end)

    IO.puts(
      &quot;\n#{inspect(repo)} [#{Path.relative_to_cwd(Ecto.Migrator.migrations_path(repo))}] streak up to version #{up_to_version}:&quot;
    )

    Enum.each(streak, fn {_repo, version, name} -&gt; IO.puts(&quot;  * #{version}_#{name}&quot;) end)
    print_migration_streaks(streaks, pending)
  end

  defp print_migration_streaks([], []), do: :ok

  def rollback do
    prepare()

    get_step =
      IO.gets(&quot;Enter the number of steps: &quot;)
      |&gt; String.trim()
      |&gt; Integer.parse()

    case get_step do
      {int, _trailing} -&gt;
        Enum.each(repos(), fn repo -&gt; run_rollbacks_for(repo, int) end)
        IO.puts(&quot;Rollback successful!&quot;)

      :error -&gt;
        IO.puts(&quot;Invalid integer&quot;)
    end
  end

  def rollback(repo, version) do
    prepare()
    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :down, to: version))
  end

  defp repos do
    Application.fetch_env!(@app, :ecto_repos)
  end

  defp ensure_repo_created(repo) do
    config = repo.config()
    adapter = repo.__adapter__()

    case adapter.storage_status(config) do
      :up -&gt;
        IO.puts(&quot;#{inspect(repo)} database already exists&quot;)
        :ok

      :down -&gt;
        IO.puts(&quot;Creating #{inspect(repo)} database..&quot;)

        case adapter.storage_up(config) do
          :ok -&gt; :ok
          {:error, :already_up} -&gt; :ok
          {:error, _reason} = error -&gt; error
        end

      {:error, _reason} = error -&gt;
        error
    end
  end

  defp run_rollbacks_for(repo, step) do
    app = Keyword.get(repo.config, :otp_app)
    IO.puts(&quot;Running rollbacks for #{app} (STEP=#{step})&quot;)

    {:ok, _, _} =
      Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :down, all: false, step: step))
  end

  defp prepare do
    IO.puts(&quot;Loading #{@app}..&quot;)
    # Load the code for myapp, but don&apos;t start it
    :ok = Application.ensure_loaded(@app)

    IO.puts(&quot;Starting dependencies..&quot;)
    # Start apps necessary for executing migrations
    Enum.each(@start_apps, &amp;Application.ensure_all_started/1)

    # Start the Repo(s) for myapp
    IO.puts(&quot;Starting repos..&quot;)
    Enum.each(repos(), &amp; &amp;1.start_link(pool_size: 2))
  end
end</file><file path="lib/wanderer_licenses/repo.ex">defmodule WandererLicenses.Repo do
  use AshPostgres.Repo,
    otp_app: :wanderer_licenses

  def installed_extensions do
    # Add extensions here, and the migration generator will install them.
    [&quot;ash-functions&quot;, &quot;citext&quot;]
  end

  # Don&apos;t open unnecessary transactions
  # will default to `false` in 4.0
  def prefer_transaction? do
    false
  end

  def min_pg_version do
    %Version{major: 16, minor: 0, patch: 0}
  end
end</file><file path="lib/wanderer_licenses/secrets.ex">defmodule WandererLicenses.Secrets do
  use AshAuthentication.Secret

  def secret_for(
        [:authentication, :tokens, :signing_secret],
        WandererLicenses.Accounts.User,
        _opts
      ) do
    Application.fetch_env(:wanderer_licenses, :token_signing_secret)
  end
end</file><file path="lib/wanderer_licenses_web/components/layouts/app.html.heex">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Wanderer Licenses&lt;/title&gt;
    &lt;link phx-track-static rel=&quot;stylesheet&quot; href={~p&quot;/assets/app.css&quot;} /&gt;
    &lt;script defer phx-track-static type=&quot;text/javascript&quot; src={~p&quot;/assets/app.js&quot;}&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body class=&quot;antialiased text-gray-800 bg-gray-50&quot;&gt;
    &lt;main class=&quot;px-4 py-10 sm:px-6 lg:px-8&quot;&gt;
      &lt;div class=&quot;mx-auto max-w-7xl&quot;&gt;
        &lt;%= @inner_content %&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;</file><file path="lib/wanderer_licenses_web/components/layouts/root.html.heex">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;csrf-token&quot; content={get_csrf_token()}/&gt;
    &lt;title&gt;Wanderer Licenses&lt;/title&gt;

    &lt;link
      rel=&quot;stylesheet&quot;
      href=&quot;https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&amp;display=swap&quot;
    /&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/sweetalert2@11&quot;&gt;&lt;/script&gt;

    &lt;link phx-track-static rel=&quot;stylesheet&quot; href={~p&quot;/assets/app.css&quot;} /&gt;
    &lt;script defer phx-track-static type=&quot;text/javascript&quot; src={~p&quot;/assets/app.js&quot;}&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body class=&quot;min-h-screen bg-gradient-to-r from-gray-100 via-gray-200 to-gray-300 font-sans text-gray-800 antialiased&quot;&gt;
    &lt;header class=&quot;bg-white border-b border-gray-100 shadow-sm&quot;&gt;
      &lt;div class=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;
        &lt;div class=&quot;flex items-center justify-between h-16&quot;&gt;
          &lt;div class=&quot;flex-shrink-0&quot;&gt;
            &lt;a href=&quot;/&quot;&gt;
              &lt;img src={~p&quot;/images/logo.png&quot;} alt=&quot;Logo&quot; class=&quot;h-8 w-auto&quot; /&gt;
            &lt;/a&gt;
          &lt;/div&gt;

          &lt;div class=&quot;flex-1 flex items-center justify-center space-x-8&quot;&gt;
            &lt;h1 class=&quot;text-xl font-bold text-gray-900&quot;&gt;Wanderer Licenses&lt;/h1&gt;
            
            &lt;nav class=&quot;flex space-x-6&quot;&gt;
              &lt;a href=&quot;/licenses&quot; class={[
                &quot;inline-flex items-center text-gray-600 hover:text-gray-900&quot;,
                if(String.starts_with?(@conn.request_path, &quot;/licenses&quot;) or @conn.request_path == &quot;/&quot;, do: &quot;text-indigo-600 font-medium&quot;)
              ]}&gt;
                &lt;!-- Heroicon: document-text --&gt;
                &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                  &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M9 12l2 2 4-4&quot;/&gt;
                  &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z&quot;/&gt;
                &lt;/svg&gt;
                &lt;span class=&quot;ml-1&quot;&gt;Licenses&lt;/span&gt;
              &lt;/a&gt;
              
              &lt;a href=&quot;/bots&quot; class={[
                &quot;inline-flex items-center text-gray-600 hover:text-gray-900&quot;,
                if(String.starts_with?(@conn.request_path, &quot;/bots&quot;), do: &quot;text-indigo-600 font-medium&quot;)
              ]}&gt;
                &lt;!-- Heroicon: cog --&gt;
                &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                  &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M12 8c-1.657 0-3 1.343-3 3 0 .934.405 1.77 1.053 2.353a3.001 3.001 0 004.894 0A2.996 2.996 0 0015 11c0-1.657-1.343-3-3-3z&quot;/&gt;
                  &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09a1.65 1.65 0 00-1-1.51 1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09a1.65 1.65 0 001.51-1 1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06a1.65 1.65 0 001.82.33h.09a1.65 1.65 0 001-1.51V3a2 2 0 014 0v.09a1.65 1.65 0 001 1.51h.09a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06a1.65 1.65 0 00-.33 1.82v.09a1.65 1.65 0 001.51 1H21a2 2 0 010 4h-.09a1.65 1.65 0 00-1.51 1z&quot;/&gt;
                &lt;/svg&gt;
                &lt;span class=&quot;ml-1&quot;&gt;Bots&lt;/span&gt;
              &lt;/a&gt;
              
              &lt;a href=&quot;/analytics&quot; class={[
                &quot;inline-flex items-center text-gray-600 hover:text-gray-900&quot;,
                if(String.starts_with?(@conn.request_path, &quot;/analytics&quot;), do: &quot;text-indigo-600 font-medium&quot;)
              ]}&gt;
                &lt;!-- Heroicon: chart-bar --&gt;
                &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                  &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z&quot; /&gt;
                &lt;/svg&gt;
                &lt;span class=&quot;ml-1&quot;&gt;Analytics&lt;/span&gt;
              &lt;/a&gt;
            &lt;/nav&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/header&gt;

    &lt;main class=&quot;px-4 py-10 sm:px-6 lg:px-8&quot;&gt;
      &lt;div class=&quot;mx-auto max-w-7xl&quot;&gt;
        &lt;!-- Flash messages, if any --&gt;
        &lt;.flash_group flash={@flash} /&gt;
        &lt;!-- LiveView content goes here --&gt;
        &lt;%= @inner_content %&gt;
      &lt;/div&gt;
    &lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;</file><file path="lib/wanderer_licenses_web/components/core_components.ex">defmodule WandererLicensesWeb.CoreComponents do
  @moduledoc &quot;&quot;&quot;
  Provides core UI components.

  At first glance, this module may seem daunting, but its goal is to provide
  core building blocks for your application, such as modals, tables, and
  forms. The components consist mostly of markup and are well-documented
  with doc strings and declarative assigns. You may customize and style
  them in any way you want, based on your application growth and needs.

  The default components use Tailwind CSS, a utility-first CSS framework.
  See the [Tailwind CSS documentation](https://tailwindcss.com) to learn
  how to customize them or feel free to swap in another framework altogether.

  Icons are provided by [heroicons](https://heroicons.com). See `icon/1` for usage.
  &quot;&quot;&quot;
  use Phoenix.Component
  use Gettext, backend: WandererLicensesWeb.Gettext

  alias Phoenix.LiveView.JS

  @doc &quot;&quot;&quot;
  Renders a modal.

  ## Examples

      &lt;.modal id=&quot;confirm-modal&quot;&gt;
        This is a modal.
      &lt;/.modal&gt;

  JS commands may be passed to the `:on_cancel` to configure
  the closing/cancel event, for example:

      &lt;.modal id=&quot;confirm&quot; on_cancel={JS.navigate(~p&quot;/posts&quot;)}&gt;
        This is another modal.
      &lt;/.modal&gt;

  &quot;&quot;&quot;
  attr :id, :string, required: true
  attr :show, :boolean, default: false
  attr :on_cancel, JS, default: %JS{}
  slot :inner_block, required: true

  def modal(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div
      id={@id}
      phx-mounted={@show &amp;&amp; show_modal(@id)}
      phx-remove={hide_modal(@id)}
      data-cancel={JS.exec(@on_cancel, &quot;phx-remove&quot;)}
      class=&quot;relative z-50 hidden&quot;
    &gt;
      &lt;div id={&quot;#{@id}-bg&quot;} class=&quot;bg-zinc-50/90 fixed inset-0 transition-opacity&quot; aria-hidden=&quot;true&quot; /&gt;
      &lt;div
        class=&quot;fixed inset-0 overflow-y-auto&quot;
        aria-labelledby={&quot;#{@id}-title&quot;}
        aria-describedby={&quot;#{@id}-description&quot;}
        role=&quot;dialog&quot;
        aria-modal=&quot;true&quot;
        tabindex=&quot;0&quot;
      &gt;
        &lt;div class=&quot;flex min-h-full items-center justify-center&quot;&gt;
          &lt;div class=&quot;w-full max-w-3xl p-4 sm:p-6 lg:py-8&quot;&gt;
            &lt;.focus_wrap
              id={&quot;#{@id}-container&quot;}
              phx-window-keydown={JS.exec(&quot;data-cancel&quot;, to: &quot;##{@id}&quot;)}
              phx-key=&quot;escape&quot;
              phx-click-away={JS.exec(&quot;data-cancel&quot;, to: &quot;##{@id}&quot;)}
              class=&quot;shadow-zinc-700/10 ring-zinc-700/10 relative hidden rounded-2xl bg-white p-14 shadow-lg ring-1 transition&quot;
            &gt;
              &lt;div class=&quot;absolute top-6 right-5&quot;&gt;
                &lt;button
                  phx-click={JS.exec(&quot;data-cancel&quot;, to: &quot;##{@id}&quot;)}
                  type=&quot;button&quot;
                  class=&quot;-m-3 flex-none p-3 opacity-20 hover:opacity-40&quot;
                  aria-label={gettext(&quot;close&quot;)}
                &gt;
                  &lt;.icon name=&quot;hero-x-mark-solid&quot; class=&quot;h-5 w-5&quot; /&gt;
                &lt;/button&gt;
              &lt;/div&gt;
              &lt;div id={&quot;#{@id}-content&quot;}&gt;
                {render_slot(@inner_block)}
              &lt;/div&gt;
            &lt;/.focus_wrap&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders flash notices.

  ## Examples

      &lt;.flash kind={:info} flash={@flash} /&gt;
      &lt;.flash kind={:info} phx-mounted={show(&quot;#flash&quot;)}&gt;Welcome Back!&lt;/.flash&gt;
  &quot;&quot;&quot;
  attr :id, :string, doc: &quot;the optional id of flash container&quot;
  attr :flash, :map, default: %{}, doc: &quot;the map of flash messages to display&quot;
  attr :title, :string, default: nil
  attr :kind, :atom, values: [:info, :error], doc: &quot;used for styling and flash lookup&quot;
  attr :rest, :global, doc: &quot;the arbitrary HTML attributes to add to the flash container&quot;

  slot :inner_block, doc: &quot;the optional inner block that renders the flash message&quot;

  def flash(assigns) do
    assigns = assign_new(assigns, :id, fn -&gt; &quot;flash-#{assigns.kind}&quot; end)

    ~H&quot;&quot;&quot;
    &lt;div
      :if={msg = render_slot(@inner_block) || Phoenix.Flash.get(@flash, @kind)}
      id={@id}
      phx-click={JS.push(&quot;lv:clear-flash&quot;, value: %{key: @kind}) |&gt; hide(&quot;##{@id}&quot;)}
      role=&quot;alert&quot;
      class={[
        &quot;fixed top-2 right-2 mr-2 w-80 sm:w-96 z-50 rounded-lg p-3 ring-1&quot;,
        @kind == :info &amp;&amp; &quot;bg-emerald-50 text-emerald-800 ring-emerald-500 fill-cyan-900&quot;,
        @kind == :error &amp;&amp; &quot;bg-rose-50 text-rose-900 shadow-md ring-rose-500 fill-rose-900&quot;
      ]}
      {@rest}
    &gt;
      &lt;p :if={@title} class=&quot;flex items-center gap-1.5 text-sm font-semibold leading-6&quot;&gt;
        &lt;.icon :if={@kind == :info} name=&quot;hero-information-circle-mini&quot; class=&quot;h-4 w-4&quot; /&gt;
        &lt;.icon :if={@kind == :error} name=&quot;hero-exclamation-circle-mini&quot; class=&quot;h-4 w-4&quot; /&gt;
        {@title}
      &lt;/p&gt;
      &lt;p class=&quot;mt-2 text-sm leading-5&quot;&gt;{msg}&lt;/p&gt;
      &lt;button type=&quot;button&quot; class=&quot;group absolute top-1 right-1 p-2&quot; aria-label={gettext(&quot;close&quot;)}&gt;
        &lt;.icon name=&quot;hero-x-mark-solid&quot; class=&quot;h-5 w-5 opacity-40 group-hover:opacity-70&quot; /&gt;
      &lt;/button&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Shows the flash group with standard titles and content.

  ## Examples

      &lt;.flash_group flash={@flash} /&gt;
  &quot;&quot;&quot;
  attr :flash, :map, required: true, doc: &quot;the map of flash messages&quot;
  attr :id, :string, default: &quot;flash-group&quot;, doc: &quot;the optional id of flash container&quot;

  def flash_group(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div id={@id}&gt;
      &lt;.flash kind={:info} title={gettext(&quot;Success!&quot;)} flash={@flash} /&gt;
      &lt;.flash kind={:error} title={gettext(&quot;Error!&quot;)} flash={@flash} /&gt;
      &lt;.flash
        id=&quot;client-error&quot;
        kind={:error}
        title={gettext(&quot;We can&apos;t find the internet&quot;)}
        phx-disconnected={show(&quot;.phx-client-error #client-error&quot;)}
        phx-connected={hide(&quot;#client-error&quot;)}
        hidden
      &gt;
        {gettext(&quot;Attempting to reconnect&quot;)}
        &lt;.icon name=&quot;hero-arrow-path&quot; class=&quot;ml-1 h-3 w-3 animate-spin&quot; /&gt;
      &lt;/.flash&gt;

      &lt;.flash
        id=&quot;server-error&quot;
        kind={:error}
        title={gettext(&quot;Something went wrong!&quot;)}
        phx-disconnected={show(&quot;.phx-server-error #server-error&quot;)}
        phx-connected={hide(&quot;#server-error&quot;)}
        hidden
      &gt;
        {gettext(&quot;Hang in there while we get back on track&quot;)}
        &lt;.icon name=&quot;hero-arrow-path&quot; class=&quot;ml-1 h-3 w-3 animate-spin&quot; /&gt;
      &lt;/.flash&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a simple form.

  ## Examples

      &lt;.simple_form for={@form} phx-change=&quot;validate&quot; phx-submit=&quot;save&quot;&gt;
        &lt;.input field={@form[:email]} label=&quot;Email&quot;/&gt;
        &lt;.input field={@form[:username]} label=&quot;Username&quot; /&gt;
        &lt;:actions&gt;
          &lt;.button&gt;Save&lt;/.button&gt;
        &lt;/:actions&gt;
      &lt;/.simple_form&gt;
  &quot;&quot;&quot;
  attr :for, :any, required: true, doc: &quot;the data structure for the form&quot;
  attr :as, :any, default: nil, doc: &quot;the server side parameter to collect all input under&quot;

  attr :rest, :global,
    include: ~w(autocomplete name rel action enctype method novalidate target multipart),
    doc: &quot;the arbitrary HTML attributes to apply to the form tag&quot;

  slot :inner_block, required: true
  slot :actions, doc: &quot;the slot for form actions, such as a submit button&quot;

  def simple_form(assigns) do
    ~H&quot;&quot;&quot;
    &lt;.form :let={f} for={@for} as={@as} {@rest}&gt;
      &lt;div class=&quot;mt-10 space-y-8 bg-white&quot;&gt;
        {render_slot(@inner_block, f)}
        &lt;div :for={action &lt;- @actions} class=&quot;mt-2 flex items-center justify-between gap-6&quot;&gt;
          {render_slot(action, f)}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/.form&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a button.

  ## Examples

      &lt;.button&gt;Send!&lt;/.button&gt;
      &lt;.button phx-click=&quot;go&quot; class=&quot;ml-2&quot;&gt;Send!&lt;/.button&gt;
  &quot;&quot;&quot;
  attr :type, :string, default: nil
  attr :class, :string, default: nil
  attr :rest, :global, include: ~w(disabled form name value)

  slot :inner_block, required: true

  def button(assigns) do
    ~H&quot;&quot;&quot;
    &lt;button
      type={@type}
      class={[
        &quot;phx-submit-loading:opacity-75 rounded-lg bg-zinc-900 hover:bg-zinc-700 py-2 px-3&quot;,
        &quot;text-sm font-semibold leading-6 text-white active:text-white/80&quot;,
        @class
      ]}
      {@rest}
    &gt;
      {render_slot(@inner_block)}
    &lt;/button&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders an input with label and error messages.

  A `Phoenix.HTML.FormField` may be passed as argument,
  which is used to retrieve the input name, id, and values.
  Otherwise all attributes may be passed explicitly.

  ## Types

  This function accepts all HTML input types, considering that:

    * You may also set `type=&quot;select&quot;` to render a `&lt;select&gt;` tag

    * `type=&quot;checkbox&quot;` is used exclusively to render boolean values

    * For live file uploads, see `Phoenix.Component.live_file_input/1`

  See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
  for more information. Unsupported types, such as hidden and radio,
  are best written directly in your templates.

  ## Examples

      &lt;.input field={@form[:email]} type=&quot;email&quot; /&gt;
      &lt;.input name=&quot;my-input&quot; errors={[&quot;oh no!&quot;]} /&gt;
  &quot;&quot;&quot;
  attr :id, :any, default: nil
  attr :name, :any
  attr :label, :string, default: nil
  attr :value, :any

  attr :type, :string,
    default: &quot;text&quot;,
    values: ~w(checkbox color date datetime-local email file month number password
               range search select tel text textarea time url week)

  attr :field, Phoenix.HTML.FormField,
    doc: &quot;a form field struct retrieved from the form, for example: @form[:email]&quot;

  attr :errors, :list, default: []
  attr :checked, :boolean, doc: &quot;the checked flag for checkbox inputs&quot;
  attr :prompt, :string, default: nil, doc: &quot;the prompt for select inputs&quot;
  attr :options, :list, doc: &quot;the options to pass to Phoenix.HTML.Form.options_for_select/2&quot;
  attr :multiple, :boolean, default: false, doc: &quot;the multiple flag for select inputs&quot;

  attr :rest, :global,
    include: ~w(accept autocomplete capture cols disabled form list max maxlength min minlength
                multiple pattern placeholder readonly required rows size step)

  def input(%{field: %Phoenix.HTML.FormField{} = field} = assigns) do
    errors = if Phoenix.Component.used_input?(field), do: field.errors, else: []

    assigns
    |&gt; assign(field: nil, id: assigns.id || field.id)
    |&gt; assign(:errors, Enum.map(errors, &amp;translate_error(&amp;1)))
    |&gt; assign_new(:name, fn -&gt; if assigns.multiple, do: field.name &lt;&gt; &quot;[]&quot;, else: field.name end)
    |&gt; assign_new(:value, fn -&gt; field.value end)
    |&gt; input()
  end

  def input(%{type: &quot;checkbox&quot;} = assigns) do
    assigns =
      assign_new(assigns, :checked, fn -&gt;
        Phoenix.HTML.Form.normalize_value(&quot;checkbox&quot;, assigns[:value])
      end)

    ~H&quot;&quot;&quot;
    &lt;div&gt;
      &lt;label class=&quot;flex items-center gap-4 text-sm leading-6 text-zinc-600&quot;&gt;
        &lt;input type=&quot;hidden&quot; name={@name} value=&quot;false&quot; disabled={@rest[:disabled]} /&gt;
        &lt;input
          type=&quot;checkbox&quot;
          id={@id}
          name={@name}
          value=&quot;true&quot;
          checked={@checked}
          class=&quot;rounded border-zinc-300 text-zinc-900 focus:ring-0&quot;
          {@rest}
        /&gt;
        {@label}
      &lt;/label&gt;
      &lt;.error :for={msg &lt;- @errors}&gt;{msg}&lt;/.error&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def input(%{type: &quot;select&quot;} = assigns) do
    ~H&quot;&quot;&quot;
    &lt;div&gt;
      &lt;.label for={@id}&gt;{@label}&lt;/.label&gt;
      &lt;select
        id={@id}
        name={@name}
        class=&quot;mt-2 block w-full rounded-md border border-gray-300 bg-white shadow-sm focus:border-zinc-400 focus:ring-0 sm:text-sm&quot;
        multiple={@multiple}
        {@rest}
      &gt;
        &lt;option :if={@prompt} value=&quot;&quot;&gt;{@prompt}&lt;/option&gt;
        {Phoenix.HTML.Form.options_for_select(@options, @value)}
      &lt;/select&gt;
      &lt;.error :for={msg &lt;- @errors}&gt;{msg}&lt;/.error&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def input(%{type: &quot;textarea&quot;} = assigns) do
    ~H&quot;&quot;&quot;
    &lt;div&gt;
      &lt;.label for={@id}&gt;{@label}&lt;/.label&gt;
      &lt;textarea
        id={@id}
        name={@name}
        class={[
          &quot;mt-2 block w-full rounded-lg text-zinc-900 focus:ring-0 sm:text-sm sm:leading-6 min-h-[6rem]&quot;,
          @errors == [] &amp;&amp; &quot;border-zinc-300 focus:border-zinc-400&quot;,
          @errors != [] &amp;&amp; &quot;border-rose-400 focus:border-rose-400&quot;
        ]}
        {@rest}
      &gt;{Phoenix.HTML.Form.normalize_value(&quot;textarea&quot;, @value)}&lt;/textarea&gt;
      &lt;.error :for={msg &lt;- @errors}&gt;{msg}&lt;/.error&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  # All other inputs text, datetime-local, url, password, etc. are handled here...
  def input(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div&gt;
      &lt;.label for={@id}&gt;{@label}&lt;/.label&gt;
      &lt;input
        type={@type}
        name={@name}
        id={@id}
        value={Phoenix.HTML.Form.normalize_value(@type, @value)}
        class={[
          &quot;mt-2 block w-full rounded-lg text-zinc-900 focus:ring-0 sm:text-sm sm:leading-6&quot;,
          @errors == [] &amp;&amp; &quot;border-zinc-300 focus:border-zinc-400&quot;,
          @errors != [] &amp;&amp; &quot;border-rose-400 focus:border-rose-400&quot;
        ]}
        {@rest}
      /&gt;
      &lt;.error :for={msg &lt;- @errors}&gt;{msg}&lt;/.error&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a label.
  &quot;&quot;&quot;
  attr :for, :string, default: nil
  slot :inner_block, required: true

  def label(assigns) do
    ~H&quot;&quot;&quot;
    &lt;label for={@for} class=&quot;block text-sm font-semibold leading-6 text-zinc-800&quot;&gt;
      {render_slot(@inner_block)}
    &lt;/label&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Generates a generic error message.
  &quot;&quot;&quot;
  attr :class, :string, default: nil
  slot :inner_block, required: true

  def error(assigns) do
    ~H&quot;&quot;&quot;
    &lt;p class={[
          &quot;mt-3 flex gap-3 text-sm leading-6 text-rose-600&quot;,
          @class
        ]}&gt;
      &lt;.icon name=&quot;hero-exclamation-circle-mini&quot; class=&quot;mt-0.5 h-5 w-5 flex-none&quot; /&gt;
      &lt;%= render_slot(@inner_block) %&gt;
    &lt;/p&gt;
    &quot;&quot;&quot;
  end
  
  @doc &quot;&quot;&quot;
  Renders a header with title.
  &quot;&quot;&quot;
  attr :class, :string, default: nil

  slot :inner_block, required: true
  slot :subtitle
  slot :actions

  def header(assigns) do
    ~H&quot;&quot;&quot;
    &lt;header class={[@actions != [] &amp;&amp; &quot;flex items-center justify-between gap-6&quot;, @class]}&gt;
      &lt;div&gt;
        &lt;h1 class=&quot;text-lg font-semibold leading-8 text-zinc-800&quot;&gt;
          {render_slot(@inner_block)}
        &lt;/h1&gt;
        &lt;p :if={@subtitle != []} class=&quot;mt-2 text-sm leading-6 text-zinc-600&quot;&gt;
          {render_slot(@subtitle)}
        &lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;flex-none&quot;&gt;{render_slot(@actions)}&lt;/div&gt;
    &lt;/header&gt;
    &quot;&quot;&quot;
  end

  @doc ~S&quot;&quot;&quot;
  Renders a table with generic styling.

  ## Examples

      &lt;.table id=&quot;users&quot; rows={@users}&gt;
        &lt;:col :let={user} label=&quot;id&quot;&gt;{user.id}&lt;/:col&gt;
        &lt;:col :let={user} label=&quot;username&quot;&gt;{user.username}&lt;/:col&gt;
      &lt;/.table&gt;
  &quot;&quot;&quot;
  attr :id, :string, required: true
  attr :rows, :list, required: true
  attr :row_id, :any, default: nil, doc: &quot;the function for generating the row id&quot;
  attr :row_click, :any, default: nil, doc: &quot;the function for handling phx-click on each row&quot;

  attr :row_item, :any,
    default: &amp;Function.identity/1,
    doc: &quot;the function for mapping each row before calling the :col and :action slots&quot;

  slot :col, required: true do
    attr :label, :string
  end

  slot :action, doc: &quot;the slot for showing user actions in the last table column&quot;

  def table(assigns) do
    assigns =
      with %{rows: %Phoenix.LiveView.LiveStream{}} &lt;- assigns do
        assign(assigns, row_id: assigns.row_id || fn {id, _item} -&gt; id end)
      end

    ~H&quot;&quot;&quot;
    &lt;div class=&quot;overflow-y-auto px-4 sm:overflow-visible sm:px-0&quot;&gt;
      &lt;table class=&quot;w-[40rem] mt-11 sm:w-full&quot;&gt;
        &lt;thead class=&quot;text-sm text-left leading-6 text-zinc-500&quot;&gt;
          &lt;tr&gt;
            &lt;th :for={col &lt;- @col} class=&quot;p-0 pb-4 pr-6 font-normal&quot;&gt;{col[:label]}&lt;/th&gt;
            &lt;th :if={@action != []} class=&quot;relative p-0 pb-4&quot;&gt;
              &lt;span class=&quot;sr-only&quot;&gt;{gettext(&quot;Actions&quot;)}&lt;/span&gt;
            &lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody
          id={@id}
          phx-update={match?(%Phoenix.LiveView.LiveStream{}, @rows) &amp;&amp; &quot;stream&quot;}
          class=&quot;relative divide-y divide-zinc-100 border-t border-zinc-200 text-sm leading-6 text-zinc-700&quot;
        &gt;
          &lt;tr :for={row &lt;- @rows} id={@row_id &amp;&amp; @row_id.(row)} class=&quot;group hover:bg-zinc-50&quot;&gt;
            &lt;td
              :for={{col, i} &lt;- Enum.with_index(@col)}
              phx-click={@row_click &amp;&amp; @row_click.(row)}
              class={[&quot;relative p-0&quot;, @row_click &amp;&amp; &quot;hover:cursor-pointer&quot;]}
            &gt;
              &lt;div class=&quot;block py-4 pr-6&quot;&gt;
                &lt;span class=&quot;absolute -inset-y-px right-0 -left-4 group-hover:bg-zinc-50 sm:rounded-l-xl&quot; /&gt;
                &lt;span class={[&quot;relative&quot;, i == 0 &amp;&amp; &quot;font-semibold text-zinc-900&quot;]}&gt;
                  {render_slot(col, @row_item.(row))}
                &lt;/span&gt;
              &lt;/div&gt;
            &lt;/td&gt;
            &lt;td :if={@action != []} class=&quot;relative w-14 p-0&quot;&gt;
              &lt;div class=&quot;relative whitespace-nowrap py-4 text-right text-sm font-medium&quot;&gt;
                &lt;span class=&quot;absolute -inset-y-px -right-4 left-0 group-hover:bg-zinc-50 sm:rounded-r-xl&quot; /&gt;
                &lt;span
                  :for={action &lt;- @action}
                  class=&quot;relative ml-4 font-semibold leading-6 text-zinc-900 hover:text-zinc-700&quot;
                &gt;
                  {render_slot(action, @row_item.(row))}
                &lt;/span&gt;
              &lt;/div&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a data list.

  ## Examples

      &lt;.list&gt;
        &lt;:item title=&quot;Title&quot;&gt;{@post.title}&lt;/:item&gt;
        &lt;:item title=&quot;Views&quot;&gt;{@post.views}&lt;/:item&gt;
      &lt;/.list&gt;
  &quot;&quot;&quot;
  slot :item, required: true do
    attr :title, :string, required: true
  end

  def list(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;mt-14&quot;&gt;
      &lt;dl class=&quot;-my-4 divide-y divide-zinc-100&quot;&gt;
        &lt;div :for={item &lt;- @item} class=&quot;flex gap-4 py-4 text-sm leading-6 sm:gap-8&quot;&gt;
          &lt;dt class=&quot;w-1/4 flex-none text-zinc-500&quot;&gt;{item.title}&lt;/dt&gt;
          &lt;dd class=&quot;text-zinc-700&quot;&gt;{render_slot(item)}&lt;/dd&gt;
        &lt;/div&gt;
      &lt;/dl&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a back navigation link.

  ## Examples

      &lt;.back navigate={~p&quot;/posts&quot;}&gt;Back to posts&lt;/.back&gt;
  &quot;&quot;&quot;
  attr :navigate, :any, required: true
  slot :inner_block, required: true

  def back(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;mt-16&quot;&gt;
      &lt;.link
        navigate={@navigate}
        class=&quot;text-sm font-semibold leading-6 text-zinc-900 hover:text-zinc-700&quot;
      &gt;
        &lt;.icon name=&quot;hero-arrow-left-solid&quot; class=&quot;h-3 w-3&quot; /&gt;
        {render_slot(@inner_block)}
      &lt;/.link&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  @doc &quot;&quot;&quot;
  Renders a [Heroicon](https://heroicons.com).

  Heroicons come in three styles  outline, solid, and mini.
  By default, the outline style is used, but solid and mini may
  be applied by using the `-solid` and `-mini` suffix.

  You can customize the size and colors of the icons by setting
  width, height, and background color classes.

  Icons are extracted from the `deps/heroicons` directory and bundled within
  your compiled app.css by the plugin in your `assets/tailwind.config.js`.

  ## Examples

      &lt;.icon name=&quot;hero-x-mark-solid&quot; /&gt;
      &lt;.icon name=&quot;hero-arrow-path&quot; class=&quot;ml-1 w-3 h-3 animate-spin&quot; /&gt;
  &quot;&quot;&quot;
  attr :name, :string, required: true
  attr :class, :string, default: nil

  def icon(%{name: &quot;hero-&quot; &lt;&gt; _} = assigns) do
    ~H&quot;&quot;&quot;
    &lt;span class={[@name, @class]} /&gt;
    &quot;&quot;&quot;
  end

  ## JS Commands

  def show(js \\ %JS{}, selector) do
    JS.show(js,
      to: selector,
      time: 300,
      transition:
        {&quot;transition-all transform ease-out duration-300&quot;,
         &quot;opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95&quot;,
         &quot;opacity-100 translate-y-0 sm:scale-100&quot;}
    )
  end

  def hide(js \\ %JS{}, selector) do
    JS.hide(js,
      to: selector,
      time: 200,
      transition:
        {&quot;transition-all transform ease-in duration-200&quot;,
         &quot;opacity-100 translate-y-0 sm:scale-100&quot;,
         &quot;opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95&quot;}
    )
  end

  def show_modal(js \\ %JS{}, id) when is_binary(id) do
    js
    |&gt; JS.show(to: &quot;##{id}&quot;)
    |&gt; JS.show(
      to: &quot;##{id}-bg&quot;,
      time: 300,
      transition: {&quot;transition-all transform ease-out duration-300&quot;, &quot;opacity-0&quot;, &quot;opacity-100&quot;}
    )
    |&gt; show(&quot;##{id}-container&quot;)
    |&gt; JS.add_class(&quot;overflow-hidden&quot;, to: &quot;body&quot;)
    |&gt; JS.focus_first(to: &quot;##{id}-content&quot;)
  end

  def hide_modal(js \\ %JS{}, id) do
    js
    |&gt; JS.hide(
      to: &quot;##{id}-bg&quot;,
      transition: {&quot;transition-all transform ease-in duration-200&quot;, &quot;opacity-100&quot;, &quot;opacity-0&quot;}
    )
    |&gt; hide(&quot;##{id}-container&quot;)
    |&gt; JS.hide(to: &quot;##{id}&quot;, transition: {&quot;block&quot;, &quot;block&quot;, &quot;hidden&quot;})
    |&gt; JS.remove_class(&quot;overflow-hidden&quot;, to: &quot;body&quot;)
    |&gt; JS.pop_focus()
  end

  @doc &quot;&quot;&quot;
  Translates an error message using gettext.
  &quot;&quot;&quot;
  def translate_error({msg, opts}) do
    # When using gettext, we typically pass the strings we want
    # to translate as a static argument:
    #
    #     # Translate the number of files with plural rules
    #     dngettext(&quot;errors&quot;, &quot;1 file&quot;, &quot;%{count} files&quot;, count)
    #
    # However the error messages in our forms and APIs are generated
    # dynamically, so we need to translate them by calling Gettext
    # with our gettext backend as first argument. Translations are
    # available in the errors.po file (as we use the &quot;errors&quot; domain).
    if count = opts[:count] do
      Gettext.dngettext(WandererLicensesWeb.Gettext, &quot;errors&quot;, msg, msg, count, opts)
    else
      Gettext.dgettext(WandererLicensesWeb.Gettext, &quot;errors&quot;, msg, opts)
    end
  end

  @doc &quot;&quot;&quot;
  Translates the errors for a field from a keyword list of errors.
  &quot;&quot;&quot;
  def translate_errors(errors, field) when is_list(errors) do
    for {^field, {msg, opts}} &lt;- errors, do: translate_error({msg, opts})
  end
end</file><file path="lib/wanderer_licenses_web/components/layouts.ex">defmodule WandererLicensesWeb.Layouts do
  @moduledoc &quot;&quot;&quot;
  This module holds different layouts used by your application.

  See the `layouts` directory for all templates available.
  The &quot;root&quot; layout is a skeleton rendered as part of the
  application router. The &quot;app&quot; layout is set as the default
  layout on both `use WandererLicensesWeb, :controller` and
  `use WandererLicensesWeb, :live_view`.
  &quot;&quot;&quot;
  use WandererLicensesWeb, :html

  embed_templates &quot;layouts/*&quot;
end</file><file path="lib/wanderer_licenses_web/controllers/page_html/home.html.heex">&lt;.flash_group flash={@flash} /&gt;
&lt;div class=&quot;left-[40rem] fixed inset-y-0 right-0 z-0 hidden lg:block xl:left-[50rem]&quot;&gt;
  &lt;svg
    viewBox=&quot;0 0 1480 957&quot;
    fill=&quot;none&quot;
    aria-hidden=&quot;true&quot;
    class=&quot;absolute inset-0 h-full w-full&quot;
    preserveAspectRatio=&quot;xMinYMid slice&quot;
  &gt;
    &lt;path fill=&quot;#EE7868&quot; d=&quot;M0 0h1480v957H0z&quot; /&gt;
    &lt;path
      d=&quot;M137.542 466.27c-582.851-48.41-988.806-82.127-1608.412 658.2l67.39 810 3083.15-256.51L1535.94-49.622l-98.36 8.183C1269.29 281.468 734.115 515.799 146.47 467.012l-8.928-.742Z&quot;
      fill=&quot;#FF9F92&quot;
    /&gt;
    &lt;path
      d=&quot;M371.028 528.664C-169.369 304.988-545.754 149.198-1361.45 665.565l-182.58 792.025 3014.73 694.98 389.42-1689.25-96.18-22.171C1505.28 697.438 924.153 757.586 379.305 532.09l-8.277-3.426Z&quot;
      fill=&quot;#FA8372&quot;
    /&gt;
    &lt;path
      d=&quot;M359.326 571.714C-104.765 215.795-428.003-32.102-1349.55 255.554l-282.3 1224.596 3047.04 722.01 312.24-1354.467C1411.25 1028.3 834.355 935.995 366.435 577.166l-7.109-5.452Z&quot;
      fill=&quot;#E96856&quot;
      fill-opacity=&quot;.6&quot;
    /&gt;
    &lt;path
      d=&quot;M1593.87 1236.88c-352.15 92.63-885.498-145.85-1244.602-613.557l-5.455-7.105C-12.347 152.31-260.41-170.8-1225-131.458l-368.63 1599.048 3057.19 704.76 130.31-935.47Z&quot;
      fill=&quot;#C42652&quot;
      fill-opacity=&quot;.2&quot;
    /&gt;
    &lt;path
      d=&quot;M1411.91 1526.93c-363.79 15.71-834.312-330.6-1085.883-863.909l-3.822-8.102C72.704 125.95-101.074-242.476-1052.01-408.907l-699.85 1484.267 2837.75 1338.01 326.02-886.44Z&quot;
      fill=&quot;#A41C42&quot;
      fill-opacity=&quot;.2&quot;
    /&gt;
    &lt;path
      d=&quot;M1116.26 1863.69c-355.457-78.98-720.318-535.27-825.287-1115.521l-1.594-8.816C185.286 163.833 112.786-237.016-762.678-643.898L-1822.83 608.665 571.922 2635.55l544.338-771.86Z&quot;
      fill=&quot;#A41C42&quot;
      fill-opacity=&quot;.2&quot;
    /&gt;
  &lt;/svg&gt;
&lt;/div&gt;
&lt;div class=&quot;px-4 py-10 sm:px-6 sm:py-28 lg:px-8 xl:px-28 xl:py-32&quot;&gt;
  &lt;div class=&quot;mx-auto max-w-xl lg:mx-0&quot;&gt;
    &lt;svg viewBox=&quot;0 0 71 48&quot; class=&quot;h-12&quot; aria-hidden=&quot;true&quot;&gt;
      &lt;path
        d=&quot;m26.371 33.477-.552-.1c-3.92-.729-6.397-3.1-7.57-6.829-.733-2.324.597-4.035 3.035-4.148 1.995-.092 3.362 1.055 4.57 2.39 1.557 1.72 2.984 3.558 4.514 5.305 2.202 2.515 4.797 4.134 8.347 3.634 3.183-.448 5.958-1.725 8.371-3.828.363-.316.761-.592 1.144-.886l-.241-.284c-2.027.63-4.093.841-6.205.735-3.195-.16-6.24-.828-8.964-2.582-2.486-1.601-4.319-3.746-5.19-6.611-.704-2.315.736-3.934 3.135-3.6.948.133 1.746.56 2.463 1.165.583.493 1.143 1.015 1.738 1.493 2.8 2.25 6.712 2.375 10.265-.068-5.842-.026-9.817-3.24-13.308-7.313-1.366-1.594-2.7-3.216-4.095-4.785-2.698-3.036-5.692-5.71-9.79-6.623C12.8-.623 7.745.14 2.893 2.361 1.926 2.804.997 3.319 0 4.149c.494 0 .763.006 1.032 0 2.446-.064 4.28 1.023 5.602 3.024.962 1.457 1.415 3.104 1.761 4.798.513 2.515.247 5.078.544 7.605.761 6.494 4.08 11.026 10.26 13.346 2.267.852 4.591 1.135 7.172.555ZM10.751 3.852c-.976.246-1.756-.148-2.56-.962 1.377-.343 2.592-.476 3.897-.528-.107.848-.607 1.306-1.336 1.49Zm32.002 37.924c-.085-.626-.62-.901-1.04-1.228-1.857-1.446-4.03-1.958-6.333-2-1.375-.026-2.735-.128-4.031-.61-.595-.22-1.26-.505-1.244-1.272.015-.78.693-1 1.31-1.184.505-.15 1.026-.247 1.6-.382-1.46-.936-2.886-1.065-4.787-.3-2.993 1.202-5.943 1.06-8.926-.017-1.684-.608-3.179-1.563-4.735-2.408l-.043.03a2.96 2.96 0 0 0 .04-.029c-.038-.117-.107-.12-.197-.054l.122.107c1.29 2.115 3.034 3.817 5.004 5.271 3.793 2.8 7.936 4.471 12.784 3.73A66.714 66.714 0 0 1 37 40.877c1.98-.16 3.866.398 5.753.899Zm-9.14-30.345c-.105-.076-.206-.266-.42-.069 1.745 2.36 3.985 4.098 6.683 5.193 4.354 1.767 8.773 2.07 13.293.51 3.51-1.21 6.033-.028 7.343 3.38.19-3.955-2.137-6.837-5.843-7.401-2.084-.318-4.01.373-5.962.94-5.434 1.575-10.485.798-15.094-2.553Zm27.085 15.425c.708.059 1.416.123 2.124.185-1.6-1.405-3.55-1.517-5.523-1.404-3.003.17-5.167 1.903-7.14 3.972-1.739 1.824-3.31 3.87-5.903 4.604.043.078.054.117.066.117.35.005.699.021 1.047.005 3.768-.17 7.317-.965 10.14-3.7.89-.86 1.685-1.817 2.544-2.71.716-.746 1.584-1.159 2.645-1.07Zm-8.753-4.67c-2.812.246-5.254 1.409-7.548 2.943-1.766 1.18-3.654 1.738-5.776 1.37-.374-.066-.75-.114-1.124-.17l-.013.156c.135.07.265.151.405.207.354.14.702.308 1.07.395 4.083.971 7.992.474 11.516-1.803 2.221-1.435 4.521-1.707 7.013-1.336.252.038.503.083.756.107.234.022.479.255.795.003-2.179-1.574-4.526-2.096-7.094-1.872Zm-10.049-9.544c1.475.051 2.943-.142 4.486-1.059-.452.04-.643.04-.827.076-2.126.424-4.033-.04-5.733-1.383-.623-.493-1.257-.974-1.889-1.457-2.503-1.914-5.374-2.555-8.514-2.5.05.154.054.26.108.315 3.417 3.455 7.371 5.836 12.369 6.008Zm24.727 17.731c-2.114-2.097-4.952-2.367-7.578-.537 1.738.078 3.043.632 4.101 1.728.374.388.763.768 1.182 1.106 1.6 1.29 4.311 1.352 5.896.155-1.861-.726-1.861-.726-3.601-2.452Zm-21.058 16.06c-1.858-3.46-4.981-4.24-8.59-4.008a9.667 9.667 0 0 1 2.977 1.39c.84.586 1.547 1.311 2.243 2.055 1.38 1.473 3.534 2.376 4.962 2.07-.656-.412-1.238-.848-1.592-1.507Zm17.29-19.32c0-.023.001-.045.003-.068l-.006.006.006-.006-.036-.004.021.018.012.053Zm-20 14.744a7.61 7.61 0 0 0-.072-.041.127.127 0 0 0 .015.043c.005.008.038 0 .058-.002Zm-.072-.041-.008-.034-.008.01.008-.01-.022-.006.005.026.024.014Z&quot;
        fill=&quot;#FD4F00&quot;
      /&gt;
    &lt;/svg&gt;
    &lt;h1 class=&quot;text-brand mt-10 flex items-center text-sm font-semibold leading-6&quot;&gt;
      Phoenix Framework
      &lt;small class=&quot;bg-brand/5 text-[0.8125rem] ml-3 rounded-full px-2 font-medium leading-6&quot;&gt;
        v{Application.spec(:phoenix, :vsn)}
      &lt;/small&gt;
    &lt;/h1&gt;
    &lt;p class=&quot;text-[2rem] mt-4 font-semibold leading-10 tracking-tighter text-zinc-900 text-balance&quot;&gt;
      Peace of mind from prototype to production.
    &lt;/p&gt;
    &lt;p class=&quot;mt-4 text-base leading-7 text-zinc-600&quot;&gt;
      Build rich, interactive web applications quickly, with less code and fewer moving parts. Join our growing community of developers using Phoenix to craft APIs, HTML5 apps and more, for fun or at scale.
    &lt;/p&gt;
    &lt;div class=&quot;flex&quot;&gt;
      &lt;div class=&quot;w-full sm:w-auto&quot;&gt;
        &lt;div class=&quot;mt-10 grid grid-cols-1 gap-x-6 gap-y-4 sm:grid-cols-3&quot;&gt;
          &lt;a
            href=&quot;https://hexdocs.pm/phoenix/overview.html&quot;
            class=&quot;group relative rounded-2xl px-6 py-4 text-sm font-semibold leading-6 text-zinc-900 sm:py-6&quot;
          &gt;
            &lt;span class=&quot;absolute inset-0 rounded-2xl bg-zinc-50 transition group-hover:bg-zinc-100 sm:group-hover:scale-105&quot;&gt;
            &lt;/span&gt;
            &lt;span class=&quot;relative flex items-center gap-4 sm:flex-col&quot;&gt;
              &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; aria-hidden=&quot;true&quot; class=&quot;h-6 w-6&quot;&gt;
                &lt;path d=&quot;m12 4 10-2v18l-10 2V4Z&quot; fill=&quot;#18181B&quot; fill-opacity=&quot;.15&quot; /&gt;
                &lt;path
                  d=&quot;M12 4 2 2v18l10 2m0-18v18m0-18 10-2v18l-10 2&quot;
                  stroke=&quot;#18181B&quot;
                  stroke-width=&quot;2&quot;
                  stroke-linecap=&quot;round&quot;
                  stroke-linejoin=&quot;round&quot;
                /&gt;
              &lt;/svg&gt;
              Guides &amp;amp; Docs
            &lt;/span&gt;
          &lt;/a&gt;
          &lt;a
            href=&quot;https://github.com/phoenixframework/phoenix&quot;
            class=&quot;group relative rounded-2xl px-6 py-4 text-sm font-semibold leading-6 text-zinc-900 sm:py-6&quot;
          &gt;
            &lt;span class=&quot;absolute inset-0 rounded-2xl bg-zinc-50 transition group-hover:bg-zinc-100 sm:group-hover:scale-105&quot;&gt;
            &lt;/span&gt;
            &lt;span class=&quot;relative flex items-center gap-4 sm:flex-col&quot;&gt;
              &lt;svg viewBox=&quot;0 0 24 24&quot; aria-hidden=&quot;true&quot; class=&quot;h-6 w-6&quot;&gt;
                &lt;path
                  fill-rule=&quot;evenodd&quot;
                  clip-rule=&quot;evenodd&quot;
                  d=&quot;M12 0C5.37 0 0 5.506 0 12.303c0 5.445 3.435 10.043 8.205 11.674.6.107.825-.262.825-.585 0-.292-.015-1.261-.015-2.291C6 21.67 5.22 20.346 4.98 19.654c-.135-.354-.72-1.446-1.23-1.738-.42-.23-1.02-.8-.015-.815.945-.015 1.62.892 1.845 1.261 1.08 1.86 2.805 1.338 3.495 1.015.105-.8.42-1.338.765-1.645-2.67-.308-5.46-1.37-5.46-6.075 0-1.338.465-2.446 1.23-3.307-.12-.308-.54-1.569.12-3.26 0 0 1.005-.323 3.3 1.26.96-.276 1.98-.415 3-.415s2.04.139 3 .416c2.295-1.6 3.3-1.261 3.3-1.261.66 1.691.24 2.952.12 3.26.765.861 1.23 1.953 1.23 3.307 0 4.721-2.805 5.767-5.475 6.075.435.384.81 1.122.81 2.276 0 1.645-.015 2.968-.015 3.383 0 .323.225.707.825.585a12.047 12.047 0 0 0 5.919-4.489A12.536 12.536 0 0 0 24 12.304C24 5.505 18.63 0 12 0Z&quot;
                  fill=&quot;#18181B&quot;
                /&gt;
              &lt;/svg&gt;
              Source Code
            &lt;/span&gt;
          &lt;/a&gt;
          &lt;a
            href={&quot;https://github.com/phoenixframework/phoenix/blob/v#{Application.spec(:phoenix, :vsn)}/CHANGELOG.md&quot;}
            class=&quot;group relative rounded-2xl px-6 py-4 text-sm font-semibold leading-6 text-zinc-900 sm:py-6&quot;
          &gt;
            &lt;span class=&quot;absolute inset-0 rounded-2xl bg-zinc-50 transition group-hover:bg-zinc-100 sm:group-hover:scale-105&quot;&gt;
            &lt;/span&gt;
            &lt;span class=&quot;relative flex items-center gap-4 sm:flex-col&quot;&gt;
              &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; aria-hidden=&quot;true&quot; class=&quot;h-6 w-6&quot;&gt;
                &lt;path
                  d=&quot;M12 1v6M12 17v6&quot;
                  stroke=&quot;#18181B&quot;
                  stroke-width=&quot;2&quot;
                  stroke-linecap=&quot;round&quot;
                  stroke-linejoin=&quot;round&quot;
                /&gt;
                &lt;circle
                  cx=&quot;12&quot;
                  cy=&quot;12&quot;
                  r=&quot;4&quot;
                  fill=&quot;#18181B&quot;
                  fill-opacity=&quot;.15&quot;
                  stroke=&quot;#18181B&quot;
                  stroke-width=&quot;2&quot;
                  stroke-linecap=&quot;round&quot;
                  stroke-linejoin=&quot;round&quot;
                /&gt;
              &lt;/svg&gt;
              Changelog
            &lt;/span&gt;
          &lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;mt-10 grid grid-cols-1 gap-y-4 text-sm leading-6 text-zinc-700 sm:grid-cols-2&quot;&gt;
          &lt;div&gt;
            &lt;a
              href=&quot;https://twitter.com/elixirphoenix&quot;
              class=&quot;group -mx-2 -my-0.5 inline-flex items-center gap-3 rounded-lg px-2 py-0.5 hover:bg-zinc-50 hover:text-zinc-900&quot;
            &gt;
              &lt;svg
                viewBox=&quot;0 0 16 16&quot;
                aria-hidden=&quot;true&quot;
                class=&quot;h-4 w-4 fill-zinc-400 group-hover:fill-zinc-600&quot;
              &gt;
                &lt;path d=&quot;M5.403 14c5.283 0 8.172-4.617 8.172-8.62 0-.131 0-.262-.008-.391A6.033 6.033 0 0 0 15 3.419a5.503 5.503 0 0 1-1.65.477 3.018 3.018 0 0 0 1.263-1.676 5.579 5.579 0 0 1-1.824.736 2.832 2.832 0 0 0-1.63-.916 2.746 2.746 0 0 0-1.821.319A2.973 2.973 0 0 0 8.076 3.78a3.185 3.185 0 0 0-.182 1.938 7.826 7.826 0 0 1-3.279-.918 8.253 8.253 0 0 1-2.64-2.247 3.176 3.176 0 0 0-.315 2.208 3.037 3.037 0 0 0 1.203 1.836A2.739 2.739 0 0 1 1.56 6.22v.038c0 .7.23 1.377.65 1.919.42.54 1.004.912 1.654 1.05-.423.122-.866.14-1.297.052.184.602.541 1.129 1.022 1.506a2.78 2.78 0 0 0 1.662.598 5.656 5.656 0 0 1-2.007 1.074A5.475 5.475 0 0 1 1 12.64a7.827 7.827 0 0 0 4.403 1.358&quot; /&gt;
              &lt;/svg&gt;
              Follow on Twitter
            &lt;/a&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;a
              href=&quot;https://elixirforum.com&quot;
              class=&quot;group -mx-2 -my-0.5 inline-flex items-center gap-3 rounded-lg px-2 py-0.5 hover:bg-zinc-50 hover:text-zinc-900&quot;
            &gt;
              &lt;svg
                viewBox=&quot;0 0 16 16&quot;
                aria-hidden=&quot;true&quot;
                class=&quot;h-4 w-4 fill-zinc-400 group-hover:fill-zinc-600&quot;
              &gt;
                &lt;path d=&quot;M8 13.833c3.866 0 7-2.873 7-6.416C15 3.873 11.866 1 8 1S1 3.873 1 7.417c0 1.081.292 2.1.808 2.995.606 1.05.806 2.399.086 3.375l-.208.283c-.285.386-.01.905.465.85.852-.098 2.048-.318 3.137-.81a3.717 3.717 0 0 1 1.91-.318c.263.027.53.041.802.041Z&quot; /&gt;
              &lt;/svg&gt;
              Discuss on the Elixir Forum
            &lt;/a&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;a
              href=&quot;https://web.libera.chat/#elixir&quot;
              class=&quot;group -mx-2 -my-0.5 inline-flex items-center gap-3 rounded-lg px-2 py-0.5 hover:bg-zinc-50 hover:text-zinc-900&quot;
            &gt;
              &lt;svg
                viewBox=&quot;0 0 16 16&quot;
                aria-hidden=&quot;true&quot;
                class=&quot;h-4 w-4 fill-zinc-400 group-hover:fill-zinc-600&quot;
              &gt;
                &lt;path
                  fill-rule=&quot;evenodd&quot;
                  clip-rule=&quot;evenodd&quot;
                  d=&quot;M6.356 2.007a.75.75 0 0 1 .637.849l-1.5 10.5a.75.75 0 1 1-1.485-.212l1.5-10.5a.75.75 0 0 1 .848-.637ZM11.356 2.008a.75.75 0 0 1 .637.848l-1.5 10.5a.75.75 0 0 1-1.485-.212l1.5-10.5a.75.75 0 0 1 .848-.636Z&quot;
                /&gt;
                &lt;path
                  fill-rule=&quot;evenodd&quot;
                  clip-rule=&quot;evenodd&quot;
                  d=&quot;M14 5.25a.75.75 0 0 1-.75.75h-9.5a.75.75 0 0 1 0-1.5h9.5a.75.75 0 0 1 .75.75ZM13 10.75a.75.75 0 0 1-.75.75h-9.5a.75.75 0 0 1 0-1.5h9.5a.75.75 0 0 1 .75.75Z&quot;
                /&gt;
              &lt;/svg&gt;
              Chat on Libera IRC
            &lt;/a&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;a
              href=&quot;https://discord.gg/elixir&quot;
              class=&quot;group -mx-2 -my-0.5 inline-flex items-center gap-3 rounded-lg px-2 py-0.5 hover:bg-zinc-50 hover:text-zinc-900&quot;
            &gt;
              &lt;svg
                viewBox=&quot;0 0 16 16&quot;
                aria-hidden=&quot;true&quot;
                class=&quot;h-4 w-4 fill-zinc-400 group-hover:fill-zinc-600&quot;
              &gt;
                &lt;path d=&quot;M13.545 2.995c-1.02-.46-2.114-.8-3.257-.994a.05.05 0 0 0-.052.024c-.141.246-.297.567-.406.82a12.377 12.377 0 0 0-3.658 0 8.238 8.238 0 0 0-.412-.82.052.052 0 0 0-.052-.024 13.315 13.315 0 0 0-3.257.994.046.046 0 0 0-.021.018C.356 6.063-.213 9.036.066 11.973c.001.015.01.029.02.038a13.353 13.353 0 0 0 3.996 1.987.052.052 0 0 0 .056-.018c.308-.414.582-.85.818-1.309a.05.05 0 0 0-.028-.069 8.808 8.808 0 0 1-1.248-.585.05.05 0 0 1-.005-.084c.084-.062.168-.126.248-.191a.05.05 0 0 1 .051-.007c2.619 1.176 5.454 1.176 8.041 0a.05.05 0 0 1 .053.006c.08.065.164.13.248.192a.05.05 0 0 1-.004.084c-.399.23-.813.423-1.249.585a.05.05 0 0 0-.027.07c.24.457.514.893.817 1.307a.051.051 0 0 0 .056.019 13.31 13.31 0 0 0 4.001-1.987.05.05 0 0 0 .021-.037c.334-3.396-.559-6.345-2.365-8.96a.04.04 0 0 0-.021-.02Zm-8.198 7.19c-.789 0-1.438-.712-1.438-1.587 0-.874.637-1.586 1.438-1.586.807 0 1.45.718 1.438 1.586 0 .875-.637 1.587-1.438 1.587Zm5.316 0c-.788 0-1.438-.712-1.438-1.587 0-.874.637-1.586 1.438-1.586.807 0 1.45.718 1.438 1.586 0 .875-.63 1.587-1.438 1.587Z&quot; /&gt;
              &lt;/svg&gt;
              Join our Discord server
            &lt;/a&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;a
              href=&quot;https://fly.io/docs/elixir/getting-started/&quot;
              class=&quot;group -mx-2 -my-0.5 inline-flex items-center gap-3 rounded-lg px-2 py-0.5 hover:bg-zinc-50 hover:text-zinc-900&quot;
            &gt;
              &lt;svg
                viewBox=&quot;0 0 20 20&quot;
                aria-hidden=&quot;true&quot;
                class=&quot;h-4 w-4 fill-zinc-400 group-hover:fill-zinc-600&quot;
              &gt;
                &lt;path d=&quot;M1 12.5A4.5 4.5 0 005.5 17H15a4 4 0 001.866-7.539 3.504 3.504 0 00-4.504-4.272A4.5 4.5 0 004.06 8.235 4.502 4.502 0 001 12.5z&quot; /&gt;
              &lt;/svg&gt;
              Deploy your application
            &lt;/a&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</file><file path="lib/wanderer_licenses_web/controllers/api_controller.ex">defmodule WandererLicensesWeb.APIController do
  use WandererLicensesWeb, :controller
  import Ash.Query, only: [filter: 2]
  require Logger

  alias WandererLicenses.Licenses.License
  alias WandererLicenses.Licenses.LicenseBot
  alias WandererLicenses.Bots.Bot
  alias WandererLicenses.Analytics.BotUsage

  @doc &quot;&quot;&quot;
  Validates a license by checking if the provided token in the Authorization header is valid.
  Returns JSON with license_valid (boolean), valid_to (date) fields, and associated bots.
  &quot;&quot;&quot;
  def validate_license(conn, _params) do
    # Extract the Bearer token from the Authorization header
    with [&quot;Bearer &quot; &lt;&gt; license_key] &lt;- get_req_header(conn, &quot;authorization&quot;) do
      # Find the license by key
      license =
        License
        |&gt; filter(key == ^license_key)
        |&gt; Ash.Query.for_read(:read)
        |&gt; Ash.read!()
        |&gt; List.first()

      if license do
        # Get associated bots
        bots =
          LicenseBot
          |&gt; filter(license_id == ^license.id)
          |&gt; Ash.Query.for_read(:read)
          |&gt; Ash.read!()
          |&gt; Enum.map(fn mapping -&gt;
            bot = Ash.get!(Bot, mapping.bot_id)
            
            # Track bot usage
            track_bot_usage(bot.id, license.id, conn)
            
            %{
              id: bot.id,
              name: bot.name,
              description: bot.description,
              is_active: bot.is_active,
              api_token: bot.api_token
            }
          end)

        json(conn, %{
          license_valid: license.is_valid,
          valid_to: license.valid_to,
          license_id: license.id,
          license_name: license.name,
          bots: bots
        })
      else
        conn
        |&gt; put_status(:unauthorized)
        |&gt; json(%{error: &quot;Invalid license key&quot;})
      end
    else
      _ -&gt;
        conn
        |&gt; put_status(:unauthorized)
        |&gt; json(%{error: &quot;Missing or invalid Authorization header&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  Expects a JSON payload with a &quot;license_key&quot; parameter.
  Returns associated bots with their API tokens,
  as well as the license&apos;s validity and valid_to date.
  &quot;&quot;&quot;
  def license_info(conn, %{&quot;license_key&quot; =&gt; license_key}) do
    license =
      License
      |&gt; filter(key == ^license_key)
      |&gt; Ash.Query.for_read(:read)
      |&gt; Ash.read!()
      |&gt; List.first()

    if license do
      bots =
        LicenseBot
        |&gt; filter(license_id == ^license.id)
        |&gt; Ash.Query.for_read(:read)
        |&gt; Ash.read!()
        |&gt; Enum.map(fn mapping -&gt;
          bot = Ash.get!(Bot, mapping.bot_id)
          %{
            bot_name: bot.name,
            api_token: bot.api_token,
          }
        end)

      json(conn, %{
        license_valid: license.is_valid,
        valid_to: license.valid_to,
        bots: bots
      })
    else
      conn
      |&gt; put_status(:not_found)
      |&gt; json(%{error: &quot;License not found&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  Returns a list of all bots with their uuid, name, description, is_active status, and developer_email.
  &quot;&quot;&quot;
  def list_bots(conn, _params) do
    bots =
      Bot
      |&gt; Ash.Query.for_read(:read)
      |&gt; Ash.read!()
      |&gt; Enum.map(fn bot -&gt;
        %{
          id: bot.id,
          name: bot.name,
          description: bot.description,
          is_active: bot.is_active,
          developer_email: bot.developer_email
        }
      end)

    json(conn, %{bots: bots})
  end

  @doc &quot;&quot;&quot;
  Validates a bot by checking if the provided api_token matches the bot&apos;s token.
  Expects a JSON payload with:
    - id: The bot ID
    - api_token: The bot&apos;s API token
  Returns JSON with valid: true if the token is valid, or an error message if not.
  &quot;&quot;&quot;
  def validate_bot(conn, %{&quot;id&quot; =&gt; bot_id, &quot;api_token&quot; =&gt; api_token}) do
    bot =
      Bot
      |&gt; filter(id == ^bot_id)
      |&gt; Ash.Query.for_read(:read)
      |&gt; Ash.read!()
      |&gt; List.first()

    cond do
      is_nil(bot) -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Bot not found&quot;})

      bot.api_token == api_token and bot.is_active -&gt;
        # Track bot usage
        track_bot_usage(bot.id, nil, conn)
        
        json(conn, %{valid: true})

      bot.api_token != api_token -&gt;
        conn
        |&gt; put_status(:unauthorized)
        |&gt; json(%{valid: false, error: &quot;Invalid api_token&quot;})

      not bot.is_active -&gt;
        conn
        |&gt; put_status(:forbidden)
        |&gt; json(%{valid: false, error: &quot;Bot is inactive&quot;})
    end
  end

  @doc &quot;&quot;&quot;
  Creates a new license.
  Expects a JSON payload with license attributes:
    - name (required)
    - description (optional)
    - is_valid (optional, defaults to false)
    - valid_to (optional, date format YYYY-MM-DD)
    - link (required)
    - contact_email (optional)
  Returns the created license with its generated key.
  &quot;&quot;&quot;
  def create_license(conn, params) do
    required_fields = [&quot;name&quot;, &quot;link&quot;]
    
    # Check for required fields
    missing_fields = Enum.filter(required_fields, fn field -&gt; !Map.has_key?(params, field) end)
    
    if length(missing_fields) &gt; 0 do
      conn
      |&gt; put_status(:bad_request)
      |&gt; json(%{error: &quot;Missing required fields: #{Enum.join(missing_fields, &quot;, &quot;)}&quot;})
    else
      # Prepare attributes for license creation
      license_attrs = %{
        name: params[&quot;name&quot;],
        link: params[&quot;link&quot;],
        description: Map.get(params, &quot;description&quot;, &quot;&quot;),
        is_valid: Map.get(params, &quot;is_valid&quot;, false),
        contact_email: Map.get(params, &quot;contact_email&quot;)
      }
      
      # Add valid_to if provided
      license_attrs = case Map.get(params, &quot;valid_to&quot;) do
        nil -&gt; license_attrs
        date_str -&gt; 
          case Date.from_iso8601(date_str) do
            {:ok, date} -&gt; Map.put(license_attrs, :valid_to, date)
            {:error, _} -&gt; 
              conn
              |&gt; put_status(:bad_request)
              |&gt; json(%{error: &quot;Invalid date format for valid_to. Use YYYY-MM-DD.&quot;})
              |&gt; halt()
          end
      end
      
      # Create the license
      case Ash.create(License, license_attrs) do
        {:ok, license} -&gt;
          conn
          |&gt; put_status(:created)
          |&gt; json(%{
            id: license.id,
            name: license.name,
            description: license.description,
            is_valid: license.is_valid,
            valid_to: license.valid_to,
            link: license.link,
            contact_email: license.contact_email,
            key: license.key
          })
          
        {:error, error} -&gt;
          conn
          |&gt; put_status(:unprocessable_entity)
          |&gt; json(%{error: &quot;Failed to create license&quot;, details: inspect(error)})
      end
    end
  end

  @doc &quot;&quot;&quot;
  Updates an existing license by ID.
  Expects a JSON payload with license attributes to update:
    - is_valid (optional)
    - valid_to (optional, date format YYYY-MM-DD)
  Returns the updated license.
  &quot;&quot;&quot;
  def update_license(conn, %{&quot;id&quot; =&gt; id} = params) do
    # Find the license - Ash.get returns {:ok, license} or {:error, error}
    case Ash.get(License, id) do
      {:ok, license} -&gt;
        # Prepare attributes for update
        license_attrs = %{}
        
        # Add is_valid if provided
        license_attrs = case Map.get(params, &quot;is_valid&quot;) do
          nil -&gt; license_attrs
          is_valid when is_boolean(is_valid) -&gt; Map.put(license_attrs, :is_valid, is_valid)
          _ -&gt; 
            conn
            |&gt; put_status(:bad_request)
            |&gt; json(%{error: &quot;is_valid must be a boolean&quot;})
            |&gt; halt()
        end
        
        # Add valid_to if provided
        license_attrs = case Map.get(params, &quot;valid_to&quot;) do
          nil -&gt; license_attrs
          date_str -&gt; 
            case Date.from_iso8601(date_str) do
              {:ok, date} -&gt; Map.put(license_attrs, :valid_to, date)
              {:error, _} -&gt; 
                conn
                |&gt; put_status(:bad_request)
                |&gt; json(%{error: &quot;Invalid date format for valid_to. Use YYYY-MM-DD.&quot;})
                |&gt; halt()
            end
        end
        
        # If no attributes to update, return the license as is
        if Enum.empty?(license_attrs) do
          conn
          |&gt; json(%{
            id: license.id,
            name: license.name,
            description: license.description,
            is_valid: license.is_valid,
            valid_to: license.valid_to,
            link: license.link,
            contact_email: license.contact_email
          })
        else
          # Update the license - use the update action explicitly
          case Ash.update(license, license_attrs, action: :update) do
            {:ok, updated_license} -&gt;
              conn
              |&gt; json(%{
                id: updated_license.id,
                name: updated_license.name,
                description: updated_license.description,
                is_valid: updated_license.is_valid,
                valid_to: updated_license.valid_to,
                link: updated_license.link,
                contact_email: updated_license.contact_email
              })
              
            {:error, error} -&gt;
              conn
              |&gt; put_status(:unprocessable_entity)
              |&gt; json(%{error: &quot;Failed to update license&quot;, details: inspect(error)})
          end
        end
        
      {:error, _error} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;License not found&quot;})
        
      nil -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;License not found&quot;})
    end
  end

  # Private function to track bot usage
  defp track_bot_usage(bot_id, license_id, conn) do
    Logger.info(&quot;API: Tracking bot usage - Bot ID: #{bot_id}, License ID: #{inspect(license_id)}&quot;)
    
    # Get IP address and user agent from the connection
    ip_address = conn.remote_ip |&gt; Tuple.to_list() |&gt; Enum.join(&quot;.&quot;)
    user_agent = get_req_header(conn, &quot;user-agent&quot;) |&gt; List.first()
    
    Logger.info(&quot;API: Bot usage details - IP: #{ip_address}, User-Agent: #{inspect(user_agent)}&quot;)
    
    # Create a bot usage record
    Ash.create!(BotUsage, %{
      bot_id: bot_id,
      license_id: license_id,
      ip_address: ip_address,
      user_agent: user_agent
    })
    
    Logger.info(&quot;API: Successfully tracked bot usage&quot;)
  rescue
    e -&gt;
      Logger.error(&quot;API: Error tracking bot usage - #{inspect(e)}&quot;)
      :ok
  end

  @doc &quot;&quot;&quot;
  Creates a new bot.
  Expects a JSON payload with bot attributes:
    - name (required)
    - description (optional)
    - developer_email (required)
  Returns the created bot with its generated API token.
  &quot;&quot;&quot;
  def create_bot(conn, params) do
    required_fields = [&quot;name&quot;, &quot;developer_email&quot;]
    
    # Check for required fields
    missing_fields = Enum.filter(required_fields, fn field -&gt; !Map.has_key?(params, field) end)
    
    if length(missing_fields) &gt; 0 do
      conn
      |&gt; put_status(:bad_request)
      |&gt; json(%{error: &quot;Missing required fields: #{Enum.join(missing_fields, &quot;, &quot;)}&quot;})
    else
      # Prepare attributes for bot creation
      bot_attrs = %{
        name: params[&quot;name&quot;],
        description: Map.get(params, &quot;description&quot;, &quot;&quot;),
        developer_email: params[&quot;developer_email&quot;]
      }
      
      # Create the bot
      case Ash.create(Bot, bot_attrs) do
        {:ok, bot} -&gt;
          conn
          |&gt; put_status(:created)
          |&gt; json(%{
            id: bot.id,
            name: bot.name,
            description: bot.description,
            is_active: bot.is_active,
            api_token: bot.api_token,
            developer_email: bot.developer_email
          })
          
        {:error, error} -&gt;
          conn
          |&gt; put_status(:unprocessable_entity)
          |&gt; json(%{error: &quot;Failed to create bot&quot;, details: inspect(error)})
      end
    end
  end

  @doc &quot;&quot;&quot;
  Updates an existing bot by ID.
  Expects a JSON payload with bot attributes to update:
    - name (optional)
    - description (optional)
    - is_active (optional)
    - developer_email (optional)
  Returns the updated bot.
  &quot;&quot;&quot;
  def update_bot(conn, %{&quot;id&quot; =&gt; id} = params) do
    # Find the bot
    case Ash.get(Bot, id) do
      {:ok, bot} -&gt;
        # Prepare attributes for update
        bot_attrs = %{}
        
        # Add name if provided
        bot_attrs = if Map.has_key?(params, &quot;name&quot;), do: Map.put(bot_attrs, :name, params[&quot;name&quot;]), else: bot_attrs
        
        # Add description if provided
        bot_attrs = if Map.has_key?(params, &quot;description&quot;), do: Map.put(bot_attrs, :description, params[&quot;description&quot;]), else: bot_attrs
        
        # Add is_active if provided
        bot_attrs = case Map.get(params, &quot;is_active&quot;) do
          nil -&gt; bot_attrs
          is_active when is_boolean(is_active) -&gt; Map.put(bot_attrs, :is_active, is_active)
          _ -&gt; 
            conn
            |&gt; put_status(:bad_request)
            |&gt; json(%{error: &quot;is_active must be a boolean&quot;})
            |&gt; halt()
        end
        
        # Add developer_email if provided
        bot_attrs = if Map.has_key?(params, &quot;developer_email&quot;), do: Map.put(bot_attrs, :developer_email, params[&quot;developer_email&quot;]), else: bot_attrs
        
        # If no attributes to update, return the bot as is
        if Enum.empty?(bot_attrs) do
          conn
          |&gt; json(%{
            id: bot.id,
            name: bot.name,
            description: bot.description,
            is_active: bot.is_active,
            developer_email: bot.developer_email
          })
        else
          # Update the bot
          case Ash.update(bot, bot_attrs, action: :update) do
            {:ok, updated_bot} -&gt;
              conn
              |&gt; json(%{
                id: updated_bot.id,
                name: updated_bot.name,
                description: updated_bot.description,
                is_active: updated_bot.is_active,
                developer_email: updated_bot.developer_email
              })
              
            {:error, error} -&gt;
              conn
              |&gt; put_status(:unprocessable_entity)
              |&gt; json(%{error: &quot;Failed to update bot&quot;, details: inspect(error)})
          end
        end
        
      {:error, _error} -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Bot not found&quot;})
        
      nil -&gt;
        conn
        |&gt; put_status(:not_found)
        |&gt; json(%{error: &quot;Bot not found&quot;})
    end
  end
end</file><file path="lib/wanderer_licenses_web/controllers/auth_controller.ex">defmodule WandererLicensesWeb.AuthController do
  use WandererLicensesWeb, :controller
  use AshAuthentication.Phoenix.Controller

  def success(conn, activity, user, _token) do
    return_to = get_session(conn, :return_to) || ~p&quot;/&quot;

    message =
      case activity do
        {:confirm_new_user, :confirm} -&gt; &quot;Your email address has now been confirmed&quot;
        {:password, :reset} -&gt; &quot;Your password has successfully been reset&quot;
        _ -&gt; &quot;You are now signed in&quot;
      end

    conn
    |&gt; delete_session(:return_to)
    |&gt; store_in_session(user)
    # If your resource has a different name, update the assign name here (i.e :current_admin)
    |&gt; assign(:current_user, user)
    |&gt; put_flash(:info, message)
    |&gt; redirect(to: return_to)
  end

  def failure(conn, activity, reason) do
    message =
      case {activity, reason} do
        {_,
         %AshAuthentication.Errors.AuthenticationFailed{
           caused_by: %Ash.Error.Forbidden{
             errors: [%AshAuthentication.Errors.CannotConfirmUnconfirmedUser{}]
           }
         }} -&gt;
          &quot;&quot;&quot;
          You have already signed in another way, but have not confirmed your account.
          You can confirm your account using the link we sent to you, or by resetting your password.
          &quot;&quot;&quot;

        _ -&gt;
          &quot;Incorrect email or password&quot;
      end

    conn
    |&gt; put_flash(:error, message)
    |&gt; redirect(to: ~p&quot;/sign-in&quot;)
  end

  def sign_out(conn, _params) do
    return_to = get_session(conn, :return_to) || ~p&quot;/&quot;

    conn
    |&gt; clear_session()
    |&gt; put_flash(:info, &quot;You are now signed out&quot;)
    |&gt; redirect(to: return_to)
  end
end</file><file path="lib/wanderer_licenses_web/controllers/error_html.ex">defmodule WandererLicensesWeb.ErrorHTML do
  @moduledoc &quot;&quot;&quot;
  This module is invoked by your endpoint in case of errors on HTML requests.

  See config/config.exs.
  &quot;&quot;&quot;
  use WandererLicensesWeb, :html

  # If you want to customize your error pages,
  # uncomment the embed_templates/1 call below
  # and add pages to the error directory:
  #
  #   * lib/wanderer_licenses_web/controllers/error_html/404.html.heex
  #   * lib/wanderer_licenses_web/controllers/error_html/500.html.heex
  #
  # embed_templates &quot;error_html/*&quot;

  # The default is to render a plain text page based on
  # the template name. For example, &quot;404.html&quot; becomes
  # &quot;Not Found&quot;.
  def render(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end</file><file path="lib/wanderer_licenses_web/controllers/error_json.ex">defmodule WandererLicensesWeb.ErrorJSON do
  @moduledoc &quot;&quot;&quot;
  This module is invoked by your endpoint in case of errors on JSON requests.

  See config/config.exs.
  &quot;&quot;&quot;

  # If you want to customize a particular status code,
  # you may add your own clauses, such as:
  #
  # def render(&quot;500.json&quot;, _assigns) do
  #   %{errors: %{detail: &quot;Internal Server Error&quot;}}
  # end

  # By default, Phoenix returns the status message from
  # the template name. For example, &quot;404.json&quot; becomes
  # &quot;Not Found&quot;.
  def render(template, _assigns) do
    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}
  end
end</file><file path="lib/wanderer_licenses_web/controllers/page_controller.ex">defmodule WandererLicensesWeb.PageController do
  use WandererLicensesWeb, :controller

  def home(conn, _params) do
    # The home page is often custom made,
    # so skip the default app layout.
    render(conn, :home, layout: false)
  end
end</file><file path="lib/wanderer_licenses_web/controllers/page_html.ex">defmodule WandererLicensesWeb.PageHTML do
  @moduledoc &quot;&quot;&quot;
  This module contains pages rendered by PageController.

  See the `page_html` directory for all templates available.
  &quot;&quot;&quot;
  use WandererLicensesWeb, :html

  embed_templates &quot;page_html/*&quot;
end</file><file path="lib/wanderer_licenses_web/live/analytics_live/index.ex">defmodule WandererLicensesWeb.AnalyticsLive.Index do
  use WandererLicensesWeb, :live_view
  require Logger

  alias WandererLicenses.Analytics
  alias WandererLicenses.Bots

  @impl true
  def mount(_params, _session, socket) do
    # Default to current month
    today = Date.utc_today()
    start_of_month = Date.beginning_of_month(today)

    # Get all bots for the filter dropdown
    bots = Ash.read!(Bots.Bot)
    Logger.info(&quot;Analytics: Found #{length(bots)} bots for dropdown&quot;)
    
    # Extract unique developer emails for the developer filter dropdown
    developers = bots
                 |&gt; Enum.map(fn bot -&gt; bot.developer_email end)
                 |&gt; Enum.uniq()
                 |&gt; Enum.sort()
    Logger.info(&quot;Analytics: Found #{length(developers)} unique developers for dropdown&quot;)

    # Get initial report data
    report_data = Analytics.get_active_bots_report(start_of_month, today)
    Logger.info(&quot;Analytics: Initial report data contains #{length(report_data)} bot records&quot;)
    
    # Debug log the report data
    Enum.each(report_data, fn bot -&gt;
      Logger.info(&quot;Analytics: Bot #{bot.bot_name} (#{bot.bot_id}) - Usage count: #{bot.usage_count}, Last used: #{Calendar.strftime(bot.last_used_at, &quot;%Y-%m-%d %H:%M:%S&quot;)}&quot;)
    end)

    socket =
      socket
      |&gt; assign(:date_from, start_of_month)
      |&gt; assign(:date_to, today)
      |&gt; assign(:filter_bot_ids, [])
      |&gt; assign(:filter_developer, &quot;&quot;)
      |&gt; assign(:available_bots, bots)
      |&gt; assign(:available_developers, developers)
      |&gt; assign(:report_data, report_data)

    {:ok, socket}
  end

  @impl true
  def handle_event(&quot;filter&quot;, params, socket) do
    # Parse dates
    date_from = Date.from_iso8601!(params[&quot;date_from&quot;])
    date_to = Date.from_iso8601!(params[&quot;date_to&quot;])
    
    Logger.info(&quot;Analytics: Filter applied - Date range: #{Date.to_string(date_from)} to #{Date.to_string(date_to)}&quot;)

    # Parse filter_bot_ids (could be empty, a single ID, or multiple IDs, or missing)
    filter_bot_ids = 
      case Map.get(params, &quot;filter_bot_ids&quot;, []) do
        ids when is_list(ids) -&gt; ids
        id when is_binary(id) and id != &quot;&quot; -&gt; [id]
        _ -&gt; []
      end
    
    # Get developer filter
    filter_developer = Map.get(params, &quot;filter_developer&quot;, &quot;&quot;)
    
    Logger.info(&quot;Analytics: Filter applied - Bot IDs: #{inspect(filter_bot_ids)}&quot;)
    Logger.info(&quot;Analytics: Filter applied - Developer: #{inspect(filter_developer)}&quot;)

    # Get filtered report data
    report_data = Analytics.get_active_bots_report(date_from, date_to, filter_bot_ids)
    Logger.info(&quot;Analytics: Filtered report data contains #{length(report_data)} bot records&quot;)
    
    # Debug log the filtered report data
    Enum.each(report_data, fn bot -&gt;
      Logger.info(&quot;Analytics: Bot #{bot.bot_name} (#{bot.bot_id}) - Usage count: #{bot.usage_count}, Last used: #{Calendar.strftime(bot.last_used_at, &quot;%Y-%m-%d %H:%M:%S&quot;)}&quot;)
    end)

    socket =
      socket
      |&gt; assign(:date_from, date_from)
      |&gt; assign(:date_to, date_to)
      |&gt; assign(:filter_bot_ids, filter_bot_ids)
      |&gt; assign(:filter_developer, filter_developer)
      |&gt; assign(:report_data, report_data)

    {:noreply, socket}
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 py-10&quot;&gt;
      &lt;h1 class=&quot;text-2xl font-semibold text-gray-900 mb-6&quot;&gt;Bot Usage Analytics&lt;/h1&gt;
      
      &lt;div class=&quot;bg-white shadow overflow-hidden sm:rounded-lg mb-8&quot;&gt;
        &lt;div class=&quot;px-4 py-5 sm:p-6&quot;&gt;
          &lt;h2 class=&quot;text-lg font-medium text-gray-900 mb-4&quot;&gt;Filter Options&lt;/h2&gt;
          
          &lt;form phx-submit=&quot;filter&quot; class=&quot;space-y-4&quot;&gt;
            &lt;div class=&quot;grid grid-cols-1 gap-4 sm:grid-cols-2&quot;&gt;
              &lt;div&gt;
                &lt;label for=&quot;date_from&quot; class=&quot;block text-sm font-medium text-gray-700&quot;&gt;From Date&lt;/label&gt;
                &lt;input
                  type=&quot;date&quot;
                  id=&quot;date_from&quot;
                  name=&quot;date_from&quot;
                  value={Date.to_iso8601(@date_from)}
                  class=&quot;mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm&quot;
                /&gt;
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;label for=&quot;date_to&quot; class=&quot;block text-sm font-medium text-gray-700&quot;&gt;To Date&lt;/label&gt;
                &lt;input
                  type=&quot;date&quot;
                  id=&quot;date_to&quot;
                  name=&quot;date_to&quot;
                  value={Date.to_iso8601(@date_to)}
                  class=&quot;mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm&quot;
                /&gt;
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;label for=&quot;filter_bot_ids&quot; class=&quot;block text-sm font-medium text-gray-700&quot;&gt;Filter by Bots&lt;/label&gt;
                &lt;select
                  id=&quot;filter_bot_ids&quot;
                  name=&quot;filter_bot_ids[]&quot;
                  multiple
                  class=&quot;mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm&quot;
                &gt;
                  &lt;%= for bot &lt;- @available_bots do %&gt;
                    &lt;option value={bot.id} selected={bot.id in @filter_bot_ids}&gt;
                      &lt;%= bot.name %&gt;
                    &lt;/option&gt;
                  &lt;% end %&gt;
                &lt;/select&gt;
                &lt;p class=&quot;mt-1 text-xs text-gray-500&quot;&gt;Hold Ctrl/Cmd to select multiple bots&lt;/p&gt;
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;label for=&quot;filter_developer&quot; class=&quot;block text-sm font-medium text-gray-700&quot;&gt;Filter by Developer&lt;/label&gt;
                &lt;select
                  id=&quot;filter_developer&quot;
                  name=&quot;filter_developer&quot;
                  class=&quot;mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm&quot;
                &gt;
                  &lt;option value=&quot;&quot; selected={@filter_developer == &quot;&quot;}&gt;All Developers&lt;/option&gt;
                  &lt;%= for developer &lt;- @available_developers do %&gt;
                    &lt;option value={developer} selected={developer == @filter_developer}&gt;
                      &lt;%= developer %&gt;
                    &lt;/option&gt;
                  &lt;% end %&gt;
                &lt;/select&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;flex justify-end&quot;&gt;
              &lt;button
                type=&quot;submit&quot;
                class=&quot;inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500&quot;
              &gt;
                Apply Filters
              &lt;/button&gt;
            &lt;/div&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      
      &lt;div class=&quot;bg-white shadow overflow-hidden sm:rounded-lg&quot;&gt;
        &lt;div class=&quot;px-4 py-5 sm:p-6&quot;&gt;
          &lt;h2 class=&quot;text-lg font-medium text-gray-900 mb-4&quot;&gt;
            Active Bots Report
            &lt;span class=&quot;text-sm font-normal text-gray-500&quot;&gt;
              (&lt;%= Date.to_iso8601(@date_from) %&gt; to &lt;%= Date.to_iso8601(@date_to) %&gt;)
            &lt;/span&gt;
          &lt;/h2&gt;
          
          &lt;%= if Enum.empty?(@report_data) do %&gt;
            &lt;div class=&quot;text-center py-8 text-gray-500&quot;&gt;
              No bot usage data found for the selected period.
            &lt;/div&gt;
          &lt;% else %&gt;
            &lt;div class=&quot;overflow-x-auto&quot;&gt;
              &lt;table class=&quot;min-w-full divide-y divide-gray-200&quot;&gt;
                &lt;thead class=&quot;bg-gray-50&quot;&gt;
                  &lt;tr&gt;
                    &lt;th scope=&quot;col&quot; class=&quot;px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;
                      Bot Name
                    &lt;/th&gt;
                    &lt;th scope=&quot;col&quot; class=&quot;px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;
                      Developer
                    &lt;/th&gt;
                    &lt;th scope=&quot;col&quot; class=&quot;px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;
                      Status
                    &lt;/th&gt;
                    &lt;th scope=&quot;col&quot; class=&quot;px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;
                      Usage Count
                    &lt;/th&gt;
                    &lt;th scope=&quot;col&quot; class=&quot;px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider&quot;&gt;
                      Last Used
                    &lt;/th&gt;
                  &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody class=&quot;bg-white divide-y divide-gray-200&quot;&gt;
                  &lt;%= for bot &lt;- @report_data do %&gt;
                    &lt;tr&gt;
                      &lt;td class=&quot;px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900&quot;&gt;
                        &lt;%= bot.bot_name %&gt;
                      &lt;/td&gt;
                      &lt;td class=&quot;px-6 py-4 whitespace-nowrap text-sm text-gray-500&quot;&gt;
                        &lt;%= bot.developer_email %&gt;
                      &lt;/td&gt;
                      &lt;td class=&quot;px-6 py-4 whitespace-nowrap text-sm text-gray-500&quot;&gt;
                        &lt;%= if bot.is_active do %&gt;
                          &lt;span class=&quot;px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800&quot;&gt;
                            Active
                          &lt;/span&gt;
                        &lt;% else %&gt;
                          &lt;span class=&quot;px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-red-100 text-red-800&quot;&gt;
                            Inactive
                          &lt;/span&gt;
                        &lt;% end %&gt;
                      &lt;/td&gt;
                      &lt;td class=&quot;px-6 py-4 whitespace-nowrap text-sm text-gray-500&quot;&gt;
                        &lt;%= bot.usage_count %&gt;
                      &lt;/td&gt;
                      &lt;td class=&quot;px-6 py-4 whitespace-nowrap text-sm text-gray-500&quot;&gt;
                        &lt;%= Calendar.strftime(bot.last_used_at, &quot;%Y-%m-%d %H:%M:%S&quot;) %&gt;
                      &lt;/td&gt;
                    &lt;/tr&gt;
                  &lt;% end %&gt;
                &lt;/tbody&gt;
              &lt;/table&gt;
            &lt;/div&gt;
          &lt;% end %&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_licenses_web/live/bot_live/form_component.ex">defmodule WandererLicensesWeb.BotLive.FormComponent do
  use WandererLicensesWeb, :live_component
  require Ash.Query

  alias WandererLicenses.Bots.Bot
  alias AshPhoenix.Form

  @impl true
  def update(assigns, socket) do
    socket =
      socket
      |&gt; assign(:parent_pid, assigns.parent_pid)
      |&gt; assign(:action, assigns.action)
      |&gt; assign_new(:bot_params, fn -&gt;
        if assigns.bot do
          %{
            &quot;name&quot; =&gt; assigns.bot.name || &quot;&quot;,
            &quot;description&quot; =&gt; assigns.bot.description || &quot;&quot;,
            &quot;developer_email&quot; =&gt; assigns.bot.developer_email || &quot;&quot;
          }
        else
          %{}
        end
      end)
      |&gt; assign_new(:bot_form, fn -&gt;
        case assigns.action do
          :edit -&gt; Form.for_update(assigns.bot, :update)
          :new  -&gt; Form.for_create(Bot, :create)
          _     -&gt; Form.for_create(Bot, :create)
        end
      end)

    {:ok, socket}
  end

  defp clean_params(params) when is_map(params) do
    params
    |&gt; Enum.reject(fn {key, _} -&gt; String.starts_with?(key, &quot;_unused_&quot;) end)
    |&gt; Map.new()
  end

  @impl true
  def handle_event(&quot;validate&quot;, %{&quot;form&quot; =&gt; params}, socket) do
    params = clean_params(params)

    new_form =
      socket.assigns.bot_form
      |&gt; Form.update_params(fn current -&gt; Map.merge(current, params) end)
      |&gt; Map.put(:action, nil)

    {:noreply,
     socket
     |&gt; assign(:bot_form, new_form)
     |&gt; assign(:bot_params, new_form.raw_params)}
  end

  @impl true
  def handle_event(&quot;save&quot;, %{&quot;form&quot; =&gt; params}, socket) do
    params = clean_params(params)

    new_form =
      socket.assigns.bot_form
      |&gt; Form.update_params(fn current -&gt; Map.merge(current, params) end)

    case Form.submit(new_form, params: new_form.raw_params) do
      {:ok, record} -&gt;
        send(socket.assigns.parent_pid, {:saved, record})
        {:noreply, socket}

      {:error, updated_form} -&gt;
        {:noreply,
         socket
         |&gt; assign(:bot_form, updated_form)
         |&gt; assign(:bot_params, updated_form.raw_params)}
    end
  end

  def handle_event(&quot;save&quot;, _payload, socket), do: {:noreply, socket}

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;max-w-xl mx-auto&quot;&gt;
      &lt;h2 class=&quot;text-2xl font-bold mb-6 text-center&quot;&gt;
        &lt;%= if @action == :new, do: &quot;New Bot&quot;, else: &quot;Edit Bot&quot; %&gt;
      &lt;/h2&gt;
      &lt;.form
        :let={f}
        for={to_form(@bot_form)}
        phx-submit=&quot;save&quot;
        phx-change=&quot;validate&quot;
        phx-target={@myself}
        id=&quot;bot-form&quot;
        class=&quot;bg-gradient-to-r from-blue-100 to-blue-50 shadow-xl rounded-xl px-8 py-8 space-y-6&quot;
      &gt;
        &lt;div&gt;
          &lt;label class=&quot;block text-sm font-semibold text-gray-800 mb-1&quot; for={f[:name].id}&gt;
            Bot Name
          &lt;/label&gt;
          &lt;.input
            field={f[:name]}
            type=&quot;text&quot;
            phx-debounce=&quot;100&quot;
            class=&quot;block w-full bg-gray-50 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm&quot;
          /&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;label class=&quot;block text-sm font-semibold text-gray-800 mb-1&quot; for={f[:description].id}&gt;
            Description
          &lt;/label&gt;
          &lt;.input
            field={f[:description]}
            type=&quot;textarea&quot;
            rows=&quot;4&quot;
            phx-debounce=&quot;100&quot;
            class=&quot;block w-full bg-gray-50 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm&quot;
          /&gt;
        &lt;/div&gt;

        &lt;div&gt;
          &lt;label class=&quot;block text-sm font-semibold text-gray-800 mb-1&quot; for={f[:developer_email].id}&gt;
            Developer Email
          &lt;/label&gt;
          &lt;.input
            field={f[:developer_email]}
            type=&quot;email&quot;
            phx-debounce=&quot;100&quot;
            placeholder=&quot;developer@example.com&quot;
            required
            class=&quot;block w-full bg-gray-50 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm&quot;
          /&gt;
        &lt;/div&gt;

        &lt;div class=&quot;flex items-center justify-end&quot;&gt;
          &lt;button
            type=&quot;submit&quot;
            class=&quot;inline-flex items-center px-6 py-3 border border-transparent text-sm font-semibold rounded-md shadow-md text-white bg-gradient-to-r from-green-400 to-blue-500 hover:from-green-500 hover:to-blue-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-colors&quot;
          &gt;
            Save
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/.form&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_licenses_web/live/bot_live/index.ex">defmodule WandererLicensesWeb.BotLive.Index do
  use WandererLicensesWeb, :live_view
  require Ash.Query
  require Logger

  alias WandererLicenses.Bots.Bot
  alias WandererLicenses.Licenses.LicenseBot
  alias WandererLicenses.Licenses.License

  @impl true
  def mount(_params, _session, socket) do
    bots = list_bots()
    socket =
      socket
      |&gt; assign(:bots, bots)
      |&gt; assign(:selected_bot, nil)
      |&gt; assign(:live_action, :index)
      |&gt; assign(:parent_pid, self())
      |&gt; assign(:bot, nil)
    {:ok, socket}
  end

  @impl true
  def handle_params(params, _uri, socket) do
    cond do
      params[&quot;live_action&quot;] == &quot;edit&quot; and params[&quot;id&quot;] -&gt;
        bot = read_one!(Bot, params[&quot;id&quot;])
        {:noreply, assign(socket, :bot, bot) |&gt; assign(:live_action, :edit)}
      params[&quot;live_action&quot;] == &quot;new&quot; -&gt;
        {:noreply, assign(socket, :live_action, :new)}
      true -&gt;
        {:noreply, assign(socket, :live_action, :index)}
    end
  end

  @impl true
  def handle_event(&quot;new&quot;, _params, socket) do
    socket =
      socket
      |&gt; assign(:bot, %Bot{})
      |&gt; push_patch(to: ~p&quot;/bots?live_action=new&quot;)
    {:noreply, socket}
  end

  @impl true
  def handle_event(&quot;edit&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    socket =
      socket
      |&gt; push_patch(to: ~p&quot;/bots?live_action=edit&amp;id=#{id}&quot;)
    {:noreply, socket}
  end

  @impl true
  def handle_event(&quot;toggle_active&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    bot = read_one!(Bot, id)
    action = if bot.is_active, do: :deactivate, else: :activate
    changeset = Ash.Changeset.for_update(bot, action, %{})
    case Ash.update(changeset) do
      {:ok, _updated_bot} -&gt;
        bots = list_bots()
        {:noreply, assign(socket, :bots, bots)}
      {:error, error} -&gt;
        {:noreply, assign(socket, :error, error)}
    end
  end

  # When a bot row is clicked, load its details (including attached licenses).
  @impl true
  def handle_event(&quot;select_bot&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    bot = read_one!(Bot, id)
    attached_licenses = get_attached_licenses(bot.id)
    {:noreply, assign(socket, :selected_bot, %{bot: bot, attached_licenses: attached_licenses, token_visible: false})}
  end

  # Toggle token visibility in details.
  @impl true
  def handle_event(&quot;toggle_token&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    selected = socket.assigns.selected_bot || %{}
    token_visible = Map.get(selected, :token_visible, false)
    new_selected =
      if token_visible do
        Map.put(selected, :token_visible, false) |&gt; Map.delete(:token)
      else
        bot = read_one!(Bot, id)
        Map.put(selected, :token_visible, true) |&gt; Map.put(:token, bot.api_token)
      end
    {:noreply, assign(socket, :selected_bot, new_selected)}
  end

  @impl true
  def handle_event(&quot;close_details&quot;, _params, socket) do
    {:noreply, assign(socket, :selected_bot, nil)}
  end

  @impl true
  def handle_event(&quot;close_modal&quot;, _params, socket) do
    {:noreply, push_patch(socket, to: ~p&quot;/bots&quot;) |&gt; assign(:bot, nil)}
  end

  @impl true
  def handle_info({:saved, _record}, socket) do
    bots = list_bots()
    {:noreply, socket |&gt; assign(:bots, bots) |&gt; push_patch(to: ~p&quot;/bots&quot;)}
  end

  defp list_bots do
    Bot
    |&gt; Ash.Query.for_read(:read)
    |&gt; Ash.read!()
  end

  defp read_one!(resource, id) when is_binary(id) do
    query =
      resource
      |&gt; Ash.Query.new(action: :read)
      |&gt; Ash.Query.filter(id == ^id)
    case Ash.read(query) do
      {:ok, [record]} -&gt; record
      {:ok, []} -&gt; nil
      {:ok, results} -&gt; raise &quot;Expected one record, got multiple: #{inspect(results)}&quot;
      {:error, error} -&gt; raise &quot;Error reading resource: #{inspect(error)}&quot;
    end
  end

  defp get_attached_licenses(bot_id) do
    LicenseBot
    |&gt; Ash.Query.filter(bot_id == ^bot_id)
    |&gt; Ash.read!()
    |&gt; Enum.map(fn mapping -&gt;
      # Display the license name instead of the key
      %{license: Ash.get!(License, mapping.license_id)}
    end)
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;container mx-auto p-6 space-y-8&quot;&gt;
      &lt;!-- Register New Bot Button --&gt;
      &lt;div class=&quot;flex justify-end&quot;&gt;
        &lt;button phx-click=&quot;new&quot;
          class=&quot;inline-flex items-center rounded-md bg-gradient-to-r from-blue-600 to-blue-500 px-5 py-2 text-sm font-semibold text-white shadow hover:from-blue-700 hover:to-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-offset-2&quot;&gt;
          &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;&gt;
            &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z&quot; clip-rule=&quot;evenodd&quot; /&gt;
          &lt;/svg&gt;
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;!-- Bots Table --&gt;
      &lt;div class=&quot;overflow-x-auto border border-gray-300 rounded-lg bg-white shadow-lg&quot;&gt;
        &lt;table class=&quot;min-w-full divide-y divide-gray-300&quot;&gt;
          &lt;thead class=&quot;bg-blue-50&quot;&gt;
            &lt;tr&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Bot Name&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Description&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Developer Email&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Status&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Actions&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody class=&quot;divide-y divide-gray-200&quot;&gt;
            &lt;%= for bot &lt;- @bots do %&gt;
              &lt;tr phx-click=&quot;select_bot&quot; phx-value-id={bot.id} class=&quot;hover:bg-gray-50 cursor-pointer&quot;&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-900&quot;&gt;&lt;%= bot.name %&gt;&lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-700&quot;&gt;&lt;%= bot.description || &quot;N/A&quot; %&gt;&lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-700&quot;&gt;&lt;%= bot.developer_email || &quot;N/A&quot; %&gt;&lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-700&quot;&gt;
                  &lt;span phx-click=&quot;toggle_active&quot; phx-value-id={bot.id} class=&quot;cursor-pointer inline&quot;&gt;
                    &lt;%= if bot.is_active do %&gt;
                      &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6 text-green-500 inline&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M9 12l2 2 4-4&quot;/&gt;
                        &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z&quot;/&gt;
                      &lt;/svg&gt;
                    &lt;% else %&gt;
                      &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6 text-red-500 inline&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M6 18L18 6M6 6l12 12&quot;/&gt;
                        &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z&quot;/&gt;
                      &lt;/svg&gt;
                    &lt;% end %&gt;
                  &lt;/span&gt;
                &lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm space-x-3&quot;&gt;
                  &lt;!-- Edit button with PencilAlt icon --&gt;
                  &lt;button phx-click=&quot;edit&quot; phx-value-id={bot.id} class=&quot;inline-flex items-center text-green-600 hover:underline&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5 inline&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                      &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7M18.5 2.5a2.121 2.121 0 113 3L12 20H4v-6l12.5-12.5z&quot; /&gt;
                    &lt;/svg&gt;
                  &lt;/button&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
            &lt;% end %&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/div&gt;

      &lt;!-- Selected Bot Details Section (Card Layout) --&gt;
      &lt;%= if @selected_bot do %&gt;
        &lt;div class=&quot;bg-white rounded-xl shadow-lg p-6 mb-6&quot;&gt;
          &lt;div class=&quot;flex justify-between items-center border-b pb-2 mb-4&quot;&gt;
            &lt;h3 class=&quot;text-2xl font-bold text-gray-800&quot;&gt;Bot Details&lt;/h3&gt;
            &lt;button phx-click=&quot;close_details&quot; class=&quot;text-gray-400 hover:text-gray-600&quot;&gt;
              &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M6 18L18 6M6 6l12 12&quot; /&gt;
              &lt;/svg&gt;
            &lt;/button&gt;
          &lt;/div&gt;
          &lt;div class=&quot;space-y-4&quot;&gt;
            &lt;div class=&quot;flex items-center&quot;&gt;
              &lt;span class=&quot;w-32 text-sm font-medium text-gray-600&quot;&gt;Name:&lt;/span&gt;
              &lt;span class=&quot;text-xl font-semibold text-gray-800&quot;&gt;&lt;%= @selected_bot.bot.name %&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;flex items-center&quot;&gt;
              &lt;span class=&quot;w-32 text-sm font-medium text-gray-600&quot;&gt;Description:&lt;/span&gt;
              &lt;span class=&quot;text-xl text-gray-800&quot;&gt;&lt;%= @selected_bot.bot.description || &quot;N/A&quot; %&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;flex items-center&quot;&gt;
              &lt;span class=&quot;w-32 text-sm font-medium text-gray-600&quot;&gt;Developer:&lt;/span&gt;
              &lt;span class=&quot;text-xl text-gray-800&quot;&gt;&lt;%= @selected_bot.bot.developer_email || &quot;N/A&quot; %&gt;&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;mt-6 border-t pt-4&quot;&gt;
            &lt;div class=&quot;flex items-center justify-between&quot;&gt;
              &lt;span class=&quot;text-xl font-semibold text-gray-800&quot;&gt;API Token&lt;/span&gt;
              &lt;button phx-click=&quot;toggle_token&quot; phx-value-id={@selected_bot.bot.id}
                class=&quot;px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg shadow transition&quot;&gt;
                &lt;%= if @selected_bot.token_visible do %&gt;
                  Hide Token
                &lt;% else %&gt;
                  View Token
                &lt;% end %&gt;
              &lt;/button&gt;
            &lt;/div&gt;
            &lt;%= if @selected_bot.token_visible and Map.has_key?(@selected_bot, :token) do %&gt;
              &lt;div class=&quot;mt-3 flex items-center space-x-4&quot;&gt;
                &lt;span class=&quot;font-mono text-lg text-gray-800 break-words&quot;&gt;&lt;%= @selected_bot.token %&gt;&lt;/span&gt;
                &lt;button type=&quot;button&quot; class=&quot;px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg shadow transition&quot;
                  onclick={&quot;copyToken(&apos;#{@selected_bot.token}&apos;)&quot; }&gt;
                  Copy
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;% end %&gt;
          &lt;/div&gt;
          &lt;div class=&quot;mt-6 border-t pt-4&quot;&gt;
            &lt;h4 class=&quot;text-2xl font-bold text-gray-800 mb-4&quot;&gt;Attached Licenses&lt;/h4&gt;
            &lt;table class=&quot;min-w-full border border-gray-200 rounded-lg&quot;&gt;
              &lt;thead class=&quot;bg-gray-100&quot;&gt;
                &lt;tr&gt;
                  &lt;th class=&quot;py-2 px-4 text-left text-lg font-semibold text-gray-700&quot;&gt;License Name&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
                &lt;%= for %{license: license} &lt;- @selected_bot.attached_licenses do %&gt;
                  &lt;tr class=&quot;border-b border-gray-200&quot;&gt;
                    &lt;td class=&quot;py-3 px-4 font-mono text-gray-800&quot;&gt;&lt;%= license.name %&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                &lt;% end %&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;% end %&gt;

      &lt;!-- New/Edit modal overlay for bots --&gt;
      &lt;%= if @live_action in [:new, :edit] do %&gt;
        &lt;div id=&quot;modal-bot-index&quot; class=&quot;fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-30 backdrop-blur-sm&quot;&gt;
          &lt;div class=&quot;bg-white rounded shadow-lg max-w-xl w-full relative p-6&quot;&gt;
            &lt;button phx-click=&quot;close_modal&quot; class=&quot;absolute top-4 right-4 inline-flex items-center text-gray-400 hover:text-gray-600 focus:outline-none&quot;&gt;
              &lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;
              &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot;
                   viewBox=&quot;0 0 24 24&quot; stroke-width=&quot;1.5&quot; stroke=&quot;currentColor&quot;&gt;
                &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M6 18L18 6M6 6l12 12&quot;/&gt;
              &lt;/svg&gt;
            &lt;/button&gt;
            &lt;.live_component
              module={WandererLicensesWeb.BotLive.FormComponent}
              id={&quot;bot-form-&quot; &lt;&gt; (if @bot &amp;&amp; @bot.id, do: @bot.id, else: &quot;new&quot;)}
              bot={@bot}
              parent_pid={@parent_pid}
              action={@live_action}
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;% end %&gt;
    &lt;/div&gt;
    &lt;script phx-no-format&gt;
      function copyToken(token) {
        if (!token) {
          Swal.fire(&apos;No token to copy&apos;, &apos;&apos;, &apos;warning&apos;);
          return;
        }
        navigator.clipboard.writeText(token).then(function() {
          Swal.fire(&apos;Copied!&apos;, &apos;&apos;, &apos;success&apos;);
        });
      }
    &lt;/script&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_licenses_web/live/license_live/form_component.ex">defmodule WandererLicensesWeb.LicenseLive.FormComponent do
  use WandererLicensesWeb, :live_component
  require Ash.Query

  alias WandererLicenses.Licenses.License
  alias AshPhoenix.Form

  @impl true
  def update(assigns, socket) do
    # Ensure we always have a license in assigns
    license = Map.get(assigns, :license, %License{})
    socket =
      socket
      |&gt; assign(:parent_pid, assigns.parent_pid)
      |&gt; assign(:action, assigns.action)
      |&gt; assign(:license, license)
      |&gt; assign(:show_key, false)
      |&gt; assign_new(:license_params, fn -&gt;
           %{
             &quot;name&quot; =&gt; license.name || &quot;&quot;,
             &quot;description&quot; =&gt; license.description || &quot;&quot;,
             &quot;is_valid&quot; =&gt; to_string(license.is_valid || false),
             &quot;valid_to&quot; =&gt; to_string(license.valid_to || &quot;&quot;),
             &quot;link&quot; =&gt; license.link || &quot;&quot;,
             &quot;contact_email&quot; =&gt; license.contact_email || &quot;&quot;
           }
         end)
      |&gt; assign_new(:license_form, fn -&gt;
           case assigns.action do
             :edit -&gt; Form.for_update(license, :update)
             :new  -&gt; Form.for_create(License, :create)
             _     -&gt; Form.for_create(License, :create)
           end
         end)

    {:ok, socket}
  end

  defp clean_params(params) when is_map(params) do
    params
    |&gt; Enum.reject(fn {key, _} -&gt; String.starts_with?(key, &quot;_unused_&quot;) end)
    |&gt; Map.new()
  end

  @impl true
  def handle_event(&quot;validate&quot;, %{&quot;form&quot; =&gt; params}, socket) do
    params = clean_params(params)
    new_form =
      socket.assigns.license_form
      |&gt; Form.update_params(fn current -&gt; Map.merge(current, params) end)
      |&gt; Map.put(:action, nil)
    {:noreply,
     socket
     |&gt; assign(:license_form, new_form)
     |&gt; assign(:license_params, new_form.raw_params)}
  end

  @impl true
  def handle_event(&quot;save&quot;, %{&quot;form&quot; =&gt; params}, socket) do
    params = clean_params(params)
    new_form =
      socket.assigns.license_form
      |&gt; Form.update_params(fn current -&gt; Map.merge(current, params) end)
    case Form.submit(new_form, params: new_form.raw_params) do
      {:ok, record} -&gt;
        send(socket.assigns.parent_pid, {:saved, record})
        {:noreply, socket}
      {:error, updated_form} -&gt;
        {:noreply,
         socket
         |&gt; assign(:license_form, updated_form)
         |&gt; assign(:license_params, updated_form.raw_params)}
    end
  end

  @impl true
  def handle_event(&quot;toggle_key&quot;, _params, socket) do
    {:noreply, assign(socket, :show_key, !socket.assigns.show_key)}
  end

  def handle_event(&quot;save&quot;, _payload, socket), do: {:noreply, socket}

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;max-w-xl mx-auto&quot;&gt;
      &lt;h2 class=&quot;text-2xl font-bold mb-6 text-center&quot;&gt;
        &lt;%= if @action == :new, do: &quot;New License&quot;, else: &quot;Edit License&quot; %&gt;
      &lt;/h2&gt;
      &lt;.form
        :let={f}
        for={to_form(@license_form)}
        phx-submit=&quot;save&quot;
        phx-change=&quot;validate&quot;
        phx-target={@myself}
        id={&quot;license-form-&quot; &lt;&gt; (if @license &amp;&amp; @license.id, do: @license.id, else: &quot;new&quot;)}
        class=&quot;bg-gradient-to-r from-blue-100 to-blue-50 shadow-xl rounded-xl px-8 py-8 space-y-6&quot;
      &gt;
        &lt;div&gt;
          &lt;label class=&quot;block text-sm font-semibold text-gray-800 mb-1&quot; for={f[:name].id}&gt;
            Name
          &lt;/label&gt;
          &lt;.input
            field={f[:name]}
            type=&quot;text&quot;
            phx-debounce=&quot;100&quot;
            class=&quot;block w-full bg-gray-50 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm&quot;
          /&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;label class=&quot;block text-sm font-semibold text-gray-800 mb-1&quot; for={f[:description].id}&gt;
            Description
          &lt;/label&gt;
          &lt;.input
            field={f[:description]}
            type=&quot;textarea&quot;
            rows=&quot;4&quot;
            phx-debounce=&quot;100&quot;
            class=&quot;block w-full bg-gray-50 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm&quot;
          /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;flex items-center gap-2&quot;&gt;
          &lt;.input
            field={f[:is_valid]}
            type=&quot;checkbox&quot;
            phx-debounce=&quot;100&quot;
            class=&quot;h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500&quot;
          /&gt;
          &lt;label for={f[:is_valid].id} class=&quot;text-sm font-semibold text-gray-800&quot;&gt;
            Is Valid
          &lt;/label&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;label class=&quot;block text-sm font-semibold text-gray-800 mb-1&quot; for={f[:valid_to].id}&gt;
            Valid To
          &lt;/label&gt;
          &lt;.input
            field={f[:valid_to]}
            type=&quot;date&quot;
            phx-debounce=&quot;100&quot;
            class=&quot;block w-full bg-gray-50 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm&quot;
          /&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;label class=&quot;block text-sm font-semibold text-gray-800 mb-1&quot; for={f[:link].id}&gt;
            Link
          &lt;/label&gt;
          &lt;.input
            field={f[:link]}
            type=&quot;url&quot;
            phx-debounce=&quot;100&quot;
            class=&quot;block w-full bg-gray-50 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm&quot;
          /&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;label class=&quot;block text-sm font-semibold text-gray-800 mb-1&quot; for={f[:contact_email].id}&gt;
            Contact Email
          &lt;/label&gt;
          &lt;.input
            field={f[:contact_email]}
            type=&quot;email&quot;
            phx-debounce=&quot;100&quot;
            class=&quot;block w-full bg-gray-50 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm&quot;
          /&gt;
        &lt;/div&gt;

        &lt;%= if @action == :edit &amp;&amp; @license.key do %&gt;
          &lt;div class=&quot;border-t border-gray-200 pt-4&quot;&gt;
            &lt;div class=&quot;flex items-center justify-between&quot;&gt;
              &lt;label class=&quot;block text-sm font-semibold text-gray-800&quot;&gt;
                License Key
              &lt;/label&gt;
              &lt;button type=&quot;button&quot; phx-click=&quot;toggle_key&quot; phx-target={@myself}
                class=&quot;px-3 py-1 bg-purple-600 hover:bg-purple-700 text-white text-xs rounded shadow transition&quot;&gt;
                &lt;%= if @show_key, do: &quot;Hide Key&quot;, else: &quot;Show Key&quot; %&gt;
              &lt;/button&gt;
            &lt;/div&gt;
            &lt;%= if @show_key do %&gt;
              &lt;div class=&quot;mt-2 flex items-center space-x-2&quot;&gt;
                &lt;span class=&quot;font-mono text-sm text-gray-800 bg-gray-100 p-2 rounded break-all&quot;&gt;&lt;%= @license.key %&gt;&lt;/span&gt;
                &lt;button type=&quot;button&quot; class=&quot;text-blue-600 hover:text-blue-800&quot;
                  onclick={&quot;copyToken(&apos;#{@license.key}&apos;)&quot;}&gt;
                  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                    &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2&quot; /&gt;
                  &lt;/svg&gt;
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;% else %&gt;
              &lt;div class=&quot;mt-2 text-sm text-gray-500 italic&quot;&gt;
                Click &quot;Show Key&quot; to view the license key
              &lt;/div&gt;
            &lt;% end %&gt;
          &lt;/div&gt;
        &lt;% end %&gt;

        &lt;div class=&quot;flex items-center justify-end&quot;&gt;
          &lt;button
            type=&quot;submit&quot;
            class=&quot;inline-flex items-center px-6 py-3 border border-transparent text-sm font-semibold rounded-md shadow-md text-white bg-gradient-to-r from-green-400 to-blue-500 hover:from-green-500 hover:to-blue-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-colors&quot;
          &gt;
            Save
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/.form&gt;
      &lt;script phx-no-format&gt;
        function copyToken(token) {
          if (!token) {
            Swal.fire(&apos;No token to copy&apos;, &apos;&apos;, &apos;warning&apos;);
            return;
          }
          navigator.clipboard.writeText(token).then(function() {
            Swal.fire(&apos;Copied!&apos;, &apos;&apos;, &apos;success&apos;);
          });
        }
      &lt;/script&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_licenses_web/live/license_live/index.ex">defmodule WandererLicensesWeb.LicenseLive.Index do
  use WandererLicensesWeb, :live_view
  require Ash.Query
  require Logger

  alias WandererLicenses.Licenses.License
  alias WandererLicenses.Bots.Bot
  alias WandererLicenses.Licenses.LicenseBot

  @impl true
  def mount(_params, _session, socket) do
    licenses = list_licenses()
    bots = list_bots()

    socket =
      socket
      |&gt; assign(:licenses, licenses)
      |&gt; assign(:bots, bots)
      |&gt; assign(:selected_license, nil)
      |&gt; assign(:attached_bots, [])
      |&gt; assign(:live_action, :index)
      |&gt; assign(:parent_pid, self())
      |&gt; assign(:license, %License{})  # default to new struct
    {:ok, socket}
  end

  @impl true
  def handle_params(_params, _uri, socket), do: {:noreply, socket}

  # &quot;New&quot; event
  @impl true
  def handle_event(&quot;new&quot;, _params, socket) do
    socket =
      socket
      |&gt; assign(:license, %License{})
      |&gt; assign(:live_action, :new)
      |&gt; push_patch(to: ~p&quot;/licenses/new&quot;)
    {:noreply, socket}
  end

  # &quot;Edit&quot; event: show edit modal with pencil icon.
  @impl true
  def handle_event(&quot;edit&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    license = read_one!(License, id)
    socket =
      socket
      |&gt; assign(:license, license)
      |&gt; assign(:live_action, :edit)
      |&gt; push_patch(to: ~p&quot;/licenses/#{id}/edit&quot;)
    {:noreply, socket}
  end

  @impl true
  def handle_event(&quot;close_modal&quot;, _params, socket) do
    {:noreply, push_patch(socket, to: ~p&quot;/licenses&quot;) |&gt; assign(:license, %License{})}
  end

  @impl true
  def handle_event(&quot;toggle_valid&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    try do
      license = read_one!(License, id)
      if license.is_valid do
        update_license!(License, id, %{}, :revoke)
      else
        update_license!(License, id, %{}, :enable)
      end
      licenses = list_licenses()
      {:noreply, assign(socket, :licenses, licenses)}
    rescue
      error -&gt;
        {:noreply, assign(socket, :error, error)}
    end
  end

  # When a license row is clicked, load its details and assigned bots.
  @impl true
  def handle_event(&quot;select_license&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    license = read_one!(License, id)
    attached_bots = get_license_bots(id)
    {:noreply, assign(socket, :selected_license, %{license: license, attached_bots: attached_bots, token_visible: false})}
  end

  # &quot;Close Details&quot; event: hide the selected license details.
  @impl true
  def handle_event(&quot;close_details&quot;, _params, socket) do
    {:noreply, assign(socket, :selected_license, nil)}
  end

  # &quot;Assign Bot&quot; event: assign a bot to the selected license.
  @impl true
  def handle_event(&quot;assign_bot&quot;, %{&quot;bot_id&quot; =&gt; bot_id}, socket) do
    license = socket.assigns.selected_license.license
    Logger.debug(&quot;Assign bot: license_id=#{inspect(license.id)} bot_id=#{inspect(bot_id)}&quot;)
    case Ash.create(LicenseBot, %{license_id: license.id, bot_id: bot_id}) do
      {:ok, _mapping} -&gt;
        attached_bots = get_license_bots(license.id)
        new_sel = Map.put(socket.assigns.selected_license, :attached_bots, attached_bots)
        {:noreply, assign(socket, :selected_license, new_sel)}
      {:error, error} -&gt;
        {:noreply, put_flash(socket, :error, &quot;Assign bot failed: #{inspect(error)}&quot;)}
    end
  end

  # &quot;Remove Bot&quot; event: unassign a bot.
  @impl true
  def handle_event(&quot;remove_bot&quot;, %{&quot;bot_id&quot; =&gt; bot_id}, socket) do
    license = socket.assigns.selected_license.license

    mapping =
      LicenseBot
      |&gt; Ash.Query.filter(license_id == ^license.id and bot_id == ^bot_id)
      |&gt; Ash.read!()
      |&gt; List.first()

    case Ash.destroy(mapping) do
      :ok -&gt;
        attached_bots = get_license_bots(license.id)
        new_sel = Map.put(socket.assigns.selected_license, :attached_bots, attached_bots)
        {:noreply, assign(socket, :selected_license, new_sel)}
      {:ok, _mapping} -&gt;
        attached_bots = get_license_bots(license.id)
        new_sel = Map.put(socket.assigns.selected_license, :attached_bots, attached_bots)
        {:noreply, assign(socket, :selected_license, new_sel)}
      {:error, error} -&gt;
        {:noreply, put_flash(socket, :error, &quot;Unassign bot failed: #{inspect(error)}&quot;)}
    end
  end

  # &quot;Toggle Token&quot; event: toggle token visibility in license details.
  @impl true
  def handle_event(&quot;toggle_token&quot;, %{&quot;id&quot; =&gt; id}, socket) do
    selected = socket.assigns.selected_license || %{}
    token_visible = Map.get(selected, :token_visible, false)
    new_selected =
      if token_visible do
        Map.put(selected, :token_visible, false) |&gt; Map.delete(:token)
      else
        license = read_one!(License, id)
        Map.put(selected, :token_visible, true) |&gt; Map.put(:token, license.key)
      end
    {:noreply, assign(socket, :selected_license, new_selected)}
  end

  @impl true
  def handle_info({:saved, _record}, socket) do
    licenses = list_licenses()
    {:noreply, socket |&gt; assign(:licenses, licenses) |&gt; push_patch(to: ~p&quot;/licenses&quot;)}
  end

  defp list_licenses do
    License
    |&gt; Ash.Query.for_read(:read)
    |&gt; Ash.read!()
  end

  defp list_bots do
    Bot
    |&gt; Ash.Query.for_read(:read)
    |&gt; Ash.read!()
  end

  defp get_license_bots(license_id) do
    LicenseBot
    |&gt; Ash.Query.filter(license_id == ^license_id)
    |&gt; Ash.read!()
    |&gt; Enum.map(fn mapping -&gt;
      %{bot: Ash.get!(Bot, mapping.bot_id)}
    end)
  end

  defp read_one!(resource, id) when is_binary(id) do
    query =
      resource
      |&gt; Ash.Query.new(action: :read)
      |&gt; Ash.Query.filter(id == ^id)
    case Ash.read(query) do
      {:ok, [record]} -&gt; record
      {:ok, []} -&gt; nil
      {:ok, results} -&gt; raise &quot;Expected one record, got multiple: #{inspect(results)}&quot;
      {:error, error} -&gt; raise &quot;Error reading resource: #{inspect(error)}&quot;
    end
  end

  defp update_license!(resource, id, params, action) when is_binary(id) do
    record = read_one!(resource, id)
    changeset = Ash.Changeset.for_update(record, action, params)
    case Ash.update(changeset) do
      {:ok, updated} -&gt; updated
      {:error, error} -&gt; raise &quot;Error updating resource: #{inspect(error)}&quot;
    end
  end

  @impl true
  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div class=&quot;container mx-auto p-6 space-y-8&quot;&gt;
      &lt;!-- Add License Button --&gt;
      &lt;div class=&quot;flex justify-end&quot;&gt;
        &lt;button phx-click=&quot;new&quot;
          class=&quot;inline-flex items-center rounded-md bg-gradient-to-r from-blue-600 to-blue-500 px-5 py-2 text-sm font-semibold text-white shadow hover:from-blue-700 hover:to-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-offset-2&quot;&gt;
          &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5&quot; viewBox=&quot;0 0 20 20&quot; fill=&quot;currentColor&quot;&gt;
            &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z&quot; clip-rule=&quot;evenodd&quot; /&gt;
          &lt;/svg&gt;
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;!-- Licenses Table --&gt;
      &lt;div class=&quot;overflow-x-auto border border-gray-300 rounded-lg bg-white shadow-lg&quot;&gt;
        &lt;table class=&quot;min-w-full divide-y divide-gray-300&quot;&gt;
          &lt;thead class=&quot;bg-blue-50&quot;&gt;
            &lt;tr&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Name&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Description&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Valid&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Valid To&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Link&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Contact Email&lt;/th&gt;
              &lt;th class=&quot;px-4 py-2 text-left text-sm font-medium text-gray-700 uppercase&quot;&gt;Actions&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody class=&quot;divide-y divide-gray-200&quot;&gt;
            &lt;%= for license &lt;- @licenses do %&gt;
              &lt;tr phx-click=&quot;select_license&quot; phx-value-id={license.id} class=&quot;hover:bg-gray-50 cursor-pointer&quot;&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-900&quot;&gt;&lt;%= license.name %&gt;&lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-700&quot;&gt;&lt;%= license.description %&gt;&lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-700&quot;&gt;
                  &lt;span phx-click=&quot;toggle_valid&quot; phx-value-id={license.id} class=&quot;cursor-pointer inline&quot;&gt;
                    &lt;%= if license.is_valid do %&gt;
                      &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6 text-green-500 inline&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M9 12l2 2 4-4&quot;/&gt;
                        &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z&quot;/&gt;
                      &lt;/svg&gt;
                    &lt;% else %&gt;
                      &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6 text-red-500 inline&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M6 18L18 6M6 6l12 12&quot;/&gt;
                        &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z&quot;/&gt;
                      &lt;/svg&gt;
                    &lt;% end %&gt;
                  &lt;/span&gt;
                &lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-700&quot;&gt;&lt;%= license.valid_to || &quot;No Expiry&quot; %&gt;&lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm&quot;&gt;
                  &lt;a href={license.link} target=&quot;_blank&quot; class=&quot;text-blue-600 hover:underline&quot;&gt;
                    &lt;%= license.link %&gt;
                  &lt;/a&gt;
                &lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm text-gray-700&quot;&gt;&lt;%= license.contact_email %&gt;&lt;/td&gt;
                &lt;td class=&quot;px-4 py-2 text-sm space-x-3&quot;&gt;
                  &lt;!-- Edit button with pencil icon --&gt;
                  &lt;button phx-click=&quot;edit&quot; phx-value-id={license.id} class=&quot;inline-flex items-center text-green-600 hover:underline&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5 inline&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                      &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7M18.5 2.5a2.121 2.121 0 113 3L12 20H4v-6l12.5-12.5z&quot; /&gt;
                    &lt;/svg&gt;
                  &lt;/button&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
            &lt;% end %&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/div&gt;

      &lt;!-- License Details &amp; Assign Bots Section (Card Layout) --&gt;
      &lt;%= if @selected_license do %&gt;
        &lt;div class=&quot;bg-white rounded-xl shadow-lg p-6 mb-6&quot;&gt;
          &lt;div class=&quot;flex justify-between items-center border-b pb-2 mb-4&quot;&gt;
            &lt;h3 class=&quot;text-2xl font-bold text-gray-800&quot;&gt;License Details&lt;/h3&gt;
            &lt;button phx-click=&quot;close_details&quot; class=&quot;text-gray-400 hover:text-gray-600&quot;&gt;
              &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M6 18L18 6M6 6l12 12&quot; /&gt;
              &lt;/svg&gt;
            &lt;/button&gt;
          &lt;/div&gt;
          &lt;div class=&quot;space-y-3&quot;&gt;
            &lt;div class=&quot;flex items-center&quot;&gt;
              &lt;span class=&quot;w-32 text-sm font-medium text-gray-600&quot;&gt;Name:&lt;/span&gt;
              &lt;span class=&quot;text-xl font-semibold text-gray-800&quot;&gt;&lt;%= @selected_license.license.name %&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;flex items-center&quot;&gt;
              &lt;span class=&quot;w-32 text-sm font-medium text-gray-600&quot;&gt;Description:&lt;/span&gt;
              &lt;span class=&quot;text-xl text-gray-800&quot;&gt;&lt;%= @selected_license.license.description %&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;flex items-center&quot;&gt;
              &lt;span class=&quot;w-32 text-sm font-medium text-gray-600&quot;&gt;Key:&lt;/span&gt;
              &lt;span class=&quot;font-mono text-xl text-gray-800&quot;&gt;&lt;%= @selected_license.license.key %&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;flex items-center&quot;&gt;
              &lt;span class=&quot;w-32 text-sm font-medium text-gray-600&quot;&gt;Valid:&lt;/span&gt;
              &lt;span class=&quot;text-xl text-gray-800&quot;&gt;&lt;%= if @selected_license.license.is_valid, do: &quot;Yes&quot;, else: &quot;No&quot; %&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;flex items-center&quot;&gt;
              &lt;span class=&quot;w-32 text-sm font-medium text-gray-600&quot;&gt;Valid To:&lt;/span&gt;
              &lt;span class=&quot;text-xl text-gray-800&quot;&gt;&lt;%= @selected_license.license.valid_to || &quot;No Expiry&quot; %&gt;&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class=&quot;mt-6 border-t pt-4&quot;&gt;
            &lt;div class=&quot;flex items-center justify-between&quot;&gt;
              &lt;span class=&quot;text-xl font-semibold text-gray-800&quot;&gt;API Token&lt;/span&gt;
              &lt;button phx-click=&quot;toggle_token&quot; phx-value-id={@selected_license.license.id}
                class=&quot;px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg shadow transition&quot;&gt;
                &lt;%= if @selected_license.token_visible do %&gt;
                  Hide Token
                &lt;% else %&gt;
                  View Token
                &lt;% end %&gt;
              &lt;/button&gt;
            &lt;/div&gt;
            &lt;%= if @selected_license.token_visible and Map.has_key?(@selected_license, :token) do %&gt;
              &lt;div class=&quot;mt-3 flex items-center space-x-4&quot;&gt;
                &lt;span class=&quot;font-mono text-lg text-gray-800 break-words&quot;&gt;&lt;%= @selected_license.token %&gt;&lt;/span&gt;
                &lt;button type=&quot;button&quot; class=&quot;px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg shadow transition&quot;
                  onclick={&quot;copyToken(&apos;#{@selected_license.token}&apos;)&quot; }&gt;
                  Copy
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;% end %&gt;
          &lt;/div&gt;
          &lt;div class=&quot;mt-6 border-t pt-4&quot;&gt;
            &lt;h4 class=&quot;text-2xl font-bold text-gray-800 mb-4&quot;&gt;Assigned Bots&lt;/h4&gt;
            &lt;table class=&quot;min-w-full border border-gray-200 rounded-lg&quot;&gt;
              &lt;thead class=&quot;bg-gray-100&quot;&gt;
                &lt;tr&gt;
                  &lt;th class=&quot;py-2 px-4 text-left text-lg font-semibold text-gray-700&quot;&gt;Bot Name&lt;/th&gt;
                  &lt;th class=&quot;py-2 px-4 text-left text-lg font-semibold text-gray-700&quot;&gt;Actions&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
                &lt;%= for %{bot: bot} &lt;- @selected_license.attached_bots do %&gt;
                  &lt;tr class=&quot;border-b border-gray-200&quot;&gt;
                    &lt;td class=&quot;py-3 px-4 font-mono text-gray-800&quot;&gt;&lt;%= bot.name %&gt;&lt;/td&gt;
                    &lt;td class=&quot;py-3 px-4&quot;&gt;
                      &lt;button phx-click=&quot;remove_bot&quot; phx-value-bot_id={bot.id}
                        class=&quot;text-red-600 hover:text-red-800&quot;&gt;
                        &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-5 w-5 inline&quot; fill=&quot;none&quot; viewBox=&quot;0 0 24 24&quot; stroke=&quot;currentColor&quot;&gt;
                          &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; d=&quot;M6 18L18 6M6 6l12 12&quot; /&gt;
                        &lt;/svg&gt;
                      &lt;/button&gt;
                    &lt;/td&gt;
                  &lt;/tr&gt;
                &lt;% end %&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/div&gt;
          &lt;div class=&quot;mt-6 border-t pt-4&quot;&gt;
            &lt;h4 class=&quot;text-2xl font-bold text-gray-800 mb-4&quot;&gt;Assign a Bot&lt;/h4&gt;
            &lt;%# Compute available bots: exclude those already assigned %&gt;
            &lt;% available_bots = Enum.reject(@bots, fn bot -&gt;
                  Enum.any?(@selected_license.attached_bots, fn %{bot: b} -&gt; b.id == bot.id end)
                end) %&gt;
            &lt;form phx-submit=&quot;assign_bot&quot; class=&quot;space-y-4&quot;&gt;
              &lt;div&gt;
                &lt;label class=&quot;block text-sm font-semibold text-gray-800&quot;&gt;Select Bot&lt;/label&gt;
                &lt;select name=&quot;bot_id&quot; class=&quot;form-input w-full&quot;&gt;
                  &lt;%= for bot &lt;- available_bots do %&gt;
                    &lt;option value={bot.id}&gt;&lt;%= bot.name %&gt;&lt;/option&gt;
                  &lt;% end %&gt;
                &lt;/select&gt;
              &lt;/div&gt;
              &lt;button type=&quot;submit&quot; class=&quot;px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg shadow transition&quot;&gt;
                Assign Bot
              &lt;/button&gt;
            &lt;/form&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;% end %&gt;

      &lt;!-- New/Edit modal overlay for licenses --&gt;
      &lt;%= if @live_action in [:new, :edit] do %&gt;
        &lt;div id=&quot;modal-license-index&quot; class=&quot;fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-30 backdrop-blur-sm&quot;&gt;
          &lt;div class=&quot;bg-white rounded shadow-lg max-w-xl w-full relative p-6&quot;&gt;
            &lt;button phx-click=&quot;close_modal&quot; class=&quot;absolute top-4 right-4 inline-flex items-center text-gray-400 hover:text-gray-600 focus:outline-none&quot;&gt;
              &lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;
              &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;h-6 w-6&quot; fill=&quot;none&quot;
                   viewBox=&quot;0 0 24 24&quot; stroke-width=&quot;1.5&quot; stroke=&quot;currentColor&quot;&gt;
                &lt;path stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; d=&quot;M6 18L18 6M6 6l12 12&quot;/&gt;
              &lt;/svg&gt;
            &lt;/button&gt;
            &lt;.live_component
              module={WandererLicensesWeb.LicenseLive.FormComponent}
              id={&quot;license-form-&quot; &lt;&gt; (if @license &amp;&amp; @license.id, do: @license.id, else: &quot;new&quot;)}
              license={@license}
              parent_pid={@parent_pid}
              action={@live_action}
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;% end %&gt;
    &lt;/div&gt;
    &lt;script phx-no-format&gt;
      function copyToken(token) {
        if (!token) {
          Swal.fire(&apos;No token to copy&apos;, &apos;&apos;, &apos;warning&apos;);
          return;
        }
        navigator.clipboard.writeText(token).then(function() {
          Swal.fire(&apos;Copied!&apos;, &apos;&apos;, &apos;success&apos;);
        });
      }
    &lt;/script&gt;
    &quot;&quot;&quot;
  end
end</file><file path="lib/wanderer_licenses_web/plugs/api_key_auth.ex">defmodule WandererLicensesWeb.Plugs.ApiKeyAuth do
  @moduledoc &quot;&quot;&quot;
  A plug that authenticates API requests using an API key.
  
  This plug checks for the presence of a valid API key in the request headers.
  The API key should be provided in the &quot;Authorization&quot; header with the format:
  &quot;Bearer API_KEY&quot;.
  
  The expected API key is configured via the LM_AUTH_KEY environment variable
  and loaded through the application configuration.
  &quot;&quot;&quot;
  import Plug.Conn
  
  def init(opts), do: opts
  
  def call(conn, _opts) do
    with {:ok, token} &lt;- extract_token(conn),
         {:ok, _} &lt;- validate_token(token) do
      conn
    else
      _ -&gt;
        conn
        |&gt; put_status(:unauthorized)
        |&gt; Phoenix.Controller.json(%{error: &quot;Invalid or missing API key&quot;})
        |&gt; halt()
    end
  end
  
  defp extract_token(conn) do
    case get_req_header(conn, &quot;authorization&quot;) do
      [&quot;Bearer &quot; &lt;&gt; token] -&gt; {:ok, token}
      _ -&gt; :error
    end
  end
  
  defp validate_token(token) do
    api_key = Application.get_env(:wanderer_licenses, :api_auth)[:key]
    
    if api_key &amp;&amp; api_key == token do
      {:ok, token}
    else
      :error
    end
  end
end</file><file path="lib/wanderer_licenses_web/plugs/request_logger.ex">defmodule WandererLicensesWeb.Plugs.RequestLogger do
  @moduledoc &quot;&quot;&quot;
  A plug that logs detailed information about requests including user attribution.
  
  This plug captures:
  - Endpoint path
  - HTTP method
  - User information (if authenticated)
  - Request timestamp
  - Response status
  - Request duration
  
  It logs this information and attaches user information to the conn for use by Phoenix telemetry.
  &quot;&quot;&quot;
  
  require Logger
  import Plug.Conn
  
  def init(opts), do: opts
  
  def call(conn, _opts) do
    start_time = System.monotonic_time()
    
    # Store the start time in conn for later use
    conn = put_private(conn, :request_start_time, start_time)
    
    # Extract user information
    user_info = extract_user_info(conn)
    
    # Store user info in conn for telemetry
    conn = put_private(conn, :user_info, user_info)
    
    # Register a callback to be invoked after the response is sent
    register_before_send(conn, &amp;log_request/1)
  end
  
  defp log_request(conn) do
    # Calculate request duration
    start_time = conn.private[:request_start_time]
    stop_time = System.monotonic_time()
    duration = System.convert_time_unit(stop_time - start_time, :native, :millisecond)
    
    # Get user information
    user_info = conn.private[:user_info]
    
    # Extract request information
    path = conn.request_path
    method = conn.method
    status = conn.status
    
    # Log the request
    Logger.info(
      &quot;Request: #{method} #{path} - Status: #{status} - &quot; &lt;&gt;
      &quot;User: #{user_info} - Duration: #{duration}ms&quot;
    )
    
    # Add user info to conn.assigns for Phoenix telemetry
    # Phoenix telemetry will automatically capture this in the :phoenix, :endpoint, :stop event
    conn
    |&gt; assign(:user_info, user_info)
  end
  
  defp extract_user_info(conn) do
    cond do
      # For API requests with Bearer token (license key)
      match?([&quot;Bearer &quot; &lt;&gt; _], get_req_header(conn, &quot;authorization&quot;)) -&gt;
        [&quot;Bearer &quot; &lt;&gt; token] = get_req_header(conn, &quot;authorization&quot;)
        &quot;API:#{truncate_token(token)}&quot;
        
      # For authenticated web users
      conn.assigns[:current_user] -&gt;
        user = conn.assigns.current_user
        &quot;User:#{user.email}&quot;
        
      # For unauthenticated requests
      true -&gt;
        &quot;Anonymous&quot;
    end
  end
  
  defp truncate_token(token) do
    if String.length(token) &gt; 8 do
      String.slice(token, 0..7) &lt;&gt; &quot;...&quot;
    else
      token
    end
  end
end</file><file path="lib/wanderer_licenses_web/auth_overrides.ex">defmodule WandererLicensesWeb.AuthOverrides do
  use AshAuthentication.Phoenix.Overrides

  # configure your UI overrides here

  # First argument to `override` is the component name you are overriding.
  # The body contains any number of configurations you wish to override
  # Below are some examples

  # For a complete reference, see https://hexdocs.pm/ash_authentication_phoenix/ui-overrides.html

  # override AshAuthentication.Phoenix.Components.Banner do
  #   set :image_url, &quot;https://media.giphy.com/media/g7GKcSzwQfugw/giphy.gif&quot;
  #   set :text_class, &quot;bg-red-500&quot;
  # end

  # override AshAuthentication.Phoenix.Components.SignIn do
  #  set :show_banner, false
  # end
end</file><file path="lib/wanderer_licenses_web/endpoint.ex">defmodule WandererLicensesWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :wanderer_licenses

  # The session will be stored in the cookie and signed,
  # this means its contents can be read but not tampered with.
  # Set :encryption_salt if you would also like to encrypt it.
  @session_options [
    store: :cookie,
    key: &quot;_wanderer_licenses_key&quot;,
    signing_salt: &quot;Ww3WGQxy&quot;,
    same_site: &quot;Lax&quot;
  ]

  socket &quot;/live&quot;, Phoenix.LiveView.Socket,
    websocket: [connect_info: [session: @session_options]],
    longpoll: [connect_info: [session: @session_options]]

  # Serve at &quot;/&quot; the static files from &quot;priv/static&quot; directory.
  #
  # You should set gzip to true if you are running phx.digest
  # when deploying your static files in production.
  plug Plug.Static,
    at: &quot;/&quot;,
    from: :wanderer_licenses,
    gzip: false,
    only: WandererLicensesWeb.static_paths()

  # Code reloading can be explicitly enabled under the
  # :code_reloader configuration of your endpoint.
  if code_reloading? do
    socket &quot;/phoenix/live_reload/socket&quot;, Phoenix.LiveReloader.Socket
    plug Phoenix.LiveReloader
    plug Phoenix.CodeReloader
    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :wanderer_licenses
  end

  plug Phoenix.LiveDashboard.RequestLogger,
    param_key: &quot;request_logger&quot;,
    cookie_key: &quot;request_logger&quot;

  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  plug Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: [&quot;*/*&quot;],
    json_decoder: Phoenix.json_library()

  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session, @session_options
  
  # Add PromEx plug for exposing Prometheus metrics
  plug PromEx.Plug, prom_ex_module: WandererLicenses.PromEx
  
  plug WandererLicensesWeb.Router
end</file><file path="lib/wanderer_licenses_web/gettext.ex">defmodule WandererLicensesWeb.Gettext do
  @moduledoc &quot;&quot;&quot;
  A module providing Internationalization with a gettext-based API.

  By using [Gettext](https://hexdocs.pm/gettext), your module compiles translations
  that you can use in your application. To use this Gettext backend module,
  call `use Gettext` and pass it as an option:

      use Gettext, backend: WandererLicensesWeb.Gettext

      # Simple translation
      gettext(&quot;Here is the string to translate&quot;)

      # Plural translation
      ngettext(&quot;Here is the string to translate&quot;,
               &quot;Here are the strings to translate&quot;,
               3)

      # Domain-based translation
      dgettext(&quot;errors&quot;, &quot;Here is the error message to translate&quot;)

  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.
  &quot;&quot;&quot;
  use Gettext.Backend, otp_app: :wanderer_licenses
end</file><file path="lib/wanderer_licenses_web/live_user_auth.ex">defmodule WandererLicensesWeb.LiveUserAuth do
  @moduledoc &quot;&quot;&quot;
  Helpers for authenticating users in LiveViews.
  &quot;&quot;&quot;

  import Phoenix.Component
  use WandererLicensesWeb, :verified_routes

  def on_mount(:live_user_optional, _params, _session, socket) do
    if socket.assigns[:current_user] do
      {:cont, socket}
    else
      {:cont, assign(socket, :current_user, nil)}
    end
  end

  def on_mount(:live_user_required, _params, _session, socket) do
    if socket.assigns[:current_user] do
      {:cont, socket}
    else
      {:halt, Phoenix.LiveView.redirect(socket, to: ~p&quot;/sign-in&quot;)}
    end
  end

  def on_mount(:live_no_user, _params, _session, socket) do
    if socket.assigns[:current_user] do
      {:halt, Phoenix.LiveView.redirect(socket, to: ~p&quot;/&quot;)}
    else
      {:cont, assign(socket, :current_user, nil)}
    end
  end
end</file><file path="lib/wanderer_licenses_web/router.ex">defmodule WandererLicensesWeb.Router do
  use WandererLicensesWeb, :router

  use AshAuthentication.Phoenix.Router

  import AshAuthentication.Plug.Helpers

  pipeline :browser do
    plug :accepts, [&quot;html&quot;]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {WandererLicensesWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
    plug :load_from_session
    plug WandererLicensesWeb.Plugs.RequestLogger
  end

  pipeline :api do
    plug :accepts, [&quot;json&quot;]
    plug :load_from_bearer
    plug :set_actor, :user
    plug WandererLicensesWeb.Plugs.RequestLogger
  end

  pipeline :api_public do
    plug :accepts, [&quot;json&quot;]
    plug WandererLicensesWeb.Plugs.RequestLogger
  end

  pipeline :api_management do
    plug :accepts, [&quot;json&quot;]
    plug WandererLicensesWeb.Plugs.ApiKeyAuth
    plug WandererLicensesWeb.Plugs.RequestLogger
  end

  scope &quot;/&quot;, WandererLicensesWeb do
    pipe_through :browser

    ash_authentication_live_session :authenticated_routes do
      # In each liveview, add one of the following at the top of the module:
      #
      # If an authenticated user must be present:
      # on_mount {WandererLicensesWeb.LiveUserAuth, :live_user_required}
      #
      # If an authenticated user *may* be present:
      # on_mount {WandererLicensesWeb.LiveUserAuth, :live_user_optional}
      #
      # If an authenticated user must *not* be present:
      # on_mount {WandererLicensesWeb.LiveUserAuth, :live_no_user}
    end
  end

  scope &quot;/&quot;, WandererLicensesWeb do
    pipe_through :browser

    # Set &quot;/&quot; as the default page to your License index.
    live &quot;/&quot;, LicenseLive.Index, :index
    live &quot;/licenses&quot;, LicenseLive.Index, :index
    live &quot;/licenses/new&quot;, LicenseLive.Index, :new
    live &quot;/licenses/:id/edit&quot;, LicenseLive.Index, :edit

    live &quot;/bots&quot;, BotLive.Index, :index
    live &quot;/bots/new&quot;, BotLive.Index, :new
    live &quot;/bots/:id&quot;, BotLive.Show, :show
    live &quot;/bots/:id/edit&quot;, BotLive.Show, :edit

    # Add analytics route
    live &quot;/analytics&quot;, AnalyticsLive.Index, :index
  end

  scope &quot;/&quot;, WandererLicensesWeb do
    pipe_through :browser

    # get &quot;/&quot;, PageController, :home
    auth_routes AuthController, WandererLicenses.Accounts.User, path: &quot;/auth&quot;
    sign_out_route AuthController

    # Remove these if you&apos;d like to use your own authentication views
    sign_in_route register_path: &quot;/register&quot;,
                  reset_path: &quot;/reset&quot;,
                  auth_routes_prefix: &quot;/auth&quot;,
                  on_mount: [{WandererLicensesWeb.LiveUserAuth, :live_no_user}],
                  overrides: [
                    WandererLicensesWeb.AuthOverrides,
                    AshAuthentication.Phoenix.Overrides.Default
                  ]

    # Remove this if you do not want to use the reset password feature
    reset_route auth_routes_prefix: &quot;/auth&quot;,
                overrides: [
                  WandererLicensesWeb.AuthOverrides,
                  AshAuthentication.Phoenix.Overrides.Default
                ]
  end

  # Public API endpoints that don&apos;t require authentication.
  scope &quot;/api&quot;, WandererLicensesWeb do
    pipe_through :api_public

    get &quot;/bots&quot;, APIController, :list_bots
  end

  # Secure API endpoints that require a valid Bearer token.
  scope &quot;/api&quot;, WandererLicensesWeb do
    pipe_through :api

    # License endpoints
    get &quot;/license/validate&quot;, APIController, :validate_license
    get &quot;/license/bots&quot;, APIController, :license_bots

    # Bot endpoints
    post &quot;/validate_bot&quot;, APIController, :validate_bot
    get &quot;/bot_info&quot;, APIController, :bot_info
  end

  # Management API endpoints that require a valid API key.
  scope &quot;/api/manage&quot;, WandererLicensesWeb do
    pipe_through :api_management

    # License management endpoints
    post &quot;/licenses&quot;, APIController, :create_license
    put &quot;/licenses/:id&quot;, APIController, :update_license
    
    # Bot management endpoints
    post &quot;/bots&quot;, APIController, :create_bot
    put &quot;/bots/:id&quot;, APIController, :update_bot
  end

  # Enable LiveDashboard and Swoosh mailbox preview in development
  if Application.compile_env(:wanderer_licenses, :dev_routes) do
    import Phoenix.LiveDashboard.Router

    scope &quot;/dev&quot; do
      pipe_through :browser

      live_dashboard &quot;/dashboard&quot;, metrics: WandererLicensesWeb.Telemetry
      forward &quot;/mailbox&quot;, Plug.Swoosh.MailboxPreview
    end
  end

  if Application.compile_env(:wanderer_licenses, :dev_routes) do
    import AshAdmin.Router

    scope &quot;/admin&quot; do
      pipe_through :browser

      ash_admin &quot;/&quot;
    end
  end
end</file><file path="lib/wanderer_licenses_web/telemetry.ex">defmodule WandererLicensesWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      # Telemetry poller will execute the given period measurements
      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
      # Add reporters as children of your supervision tree.
      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary(&quot;phoenix.endpoint.start.system_time&quot;,
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.endpoint.stop.duration&quot;,
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.router_dispatch.start.system_time&quot;,
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.router_dispatch.exception.duration&quot;,
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.router_dispatch.stop.duration&quot;,
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      
      # Custom metrics for user tracking
      counter(&quot;phoenix.router_dispatch.stop.count&quot;,
        event_name: [:phoenix, :router_dispatch, :stop],
        tags: [:route],
        tag_values: fn %{conn: conn} -&gt; 
          %{
            route: &quot;#{conn.method}:#{Phoenix.Router.route_info(conn).route}&quot;,
            user: conn.assigns[:user_info] || &quot;Anonymous&quot;
          }
        end,
        description: &quot;Request count by route and user&quot;
      ),
      
      summary(&quot;phoenix.socket_connected.duration&quot;,
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.channel_joined.duration&quot;,
        unit: {:native, :millisecond}
      ),
      summary(&quot;phoenix.channel_handled_in.duration&quot;,
        tags: [:event],
        unit: {:native, :millisecond}
      ),

      # Database Metrics
      summary(&quot;wanderer_licenses.repo.query.total_time&quot;,
        unit: {:native, :millisecond},
        description: &quot;The sum of the other measurements&quot;
      ),
      summary(&quot;wanderer_licenses.repo.query.decode_time&quot;,
        unit: {:native, :millisecond},
        description: &quot;The time spent decoding the data received from the database&quot;
      ),
      summary(&quot;wanderer_licenses.repo.query.query_time&quot;,
        unit: {:native, :millisecond},
        description: &quot;The time spent executing the query&quot;
      ),
      summary(&quot;wanderer_licenses.repo.query.queue_time&quot;,
        unit: {:native, :millisecond},
        description: &quot;The time spent waiting for a database connection&quot;
      ),
      summary(&quot;wanderer_licenses.repo.query.idle_time&quot;,
        unit: {:native, :millisecond},
        description:
          &quot;The time the connection spent waiting before being checked out for the query&quot;
      ),

      # VM Metrics
      summary(&quot;vm.memory.total&quot;, unit: {:byte, :kilobyte}),
      summary(&quot;vm.total_run_queue_lengths.total&quot;),
      summary(&quot;vm.total_run_queue_lengths.cpu&quot;),
      summary(&quot;vm.total_run_queue_lengths.io&quot;)
    ]
  end

  defp periodic_measurements do
    [
      # A module, function and arguments to be invoked periodically.
      # This function must call :telemetry.execute/3 and a metric must be added above.
      # {WandererLicensesWeb, :count_users, []}
    ]
  end
end</file><file path="lib/wanderer_licenses_web.ex">defmodule WandererLicensesWeb do
  @moduledoc &quot;&quot;&quot;
  The entrypoint for defining your web interface, such
  as controllers, components, channels, and so on.

  This can be used in your application as:

      use WandererLicensesWeb, :controller
      use WandererLicensesWeb, :html

  The definitions below will be executed for every controller,
  component, etc, so keep them short and clean, focused
  on imports, uses and aliases.

  Do NOT define functions inside the quoted expressions
  below. Instead, define additional modules and import
  those modules here.
  &quot;&quot;&quot;

  def static_paths, do: ~w(assets fonts images favicon.ico robots.txt)

  def router do
    quote do
      use Phoenix.Router, helpers: false

      # Import common connection and controller functions to use in pipelines
      import Plug.Conn
      import Phoenix.Controller
      import Phoenix.LiveView.Router
    end
  end

  def channel do
    quote do
      use Phoenix.Channel
    end
  end

  def controller do
    quote do
      use Phoenix.Controller,
        formats: [:html, :json],
        layouts: [html: WandererLicensesWeb.Layouts]

      use Gettext, backend: WandererLicensesWeb.Gettext

      import Plug.Conn

      unquote(verified_routes())
    end
  end

  def live_view do
    quote do
      use Phoenix.LiveView,
        layout: {WandererLicensesWeb.Layouts, :app}

      unquote(html_helpers())
    end
  end

  def live_component do
    quote do
      use Phoenix.LiveComponent

      unquote(html_helpers())
    end
  end

  def html do
    quote do
      use Phoenix.Component

      # Import convenience functions from controllers
      import Phoenix.Controller,
        only: [get_csrf_token: 0, view_module: 1, view_template: 1]

      # Include general helpers for rendering HTML
      unquote(html_helpers())
    end
  end

  defp html_helpers do
    quote do
      # Translation
      use Gettext, backend: WandererLicensesWeb.Gettext

      # HTML escaping functionality
      import Phoenix.HTML
      # Core UI components
      import WandererLicensesWeb.CoreComponents

      # Shortcut for generating JS commands
      alias Phoenix.LiveView.JS

      # Routes generation with the ~p sigil
      unquote(verified_routes())
    end
  end

  def verified_routes do
    quote do
      use Phoenix.VerifiedRoutes,
        endpoint: WandererLicensesWeb.Endpoint,
        router: WandererLicensesWeb.Router,
        statics: WandererLicensesWeb.static_paths()
    end
  end

  @doc &quot;&quot;&quot;
  When used, dispatch to the appropriate controller/live_view/etc.
  &quot;&quot;&quot;
  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end
end</file><file path="lib/wanderer_licenses.ex">defmodule WandererLicenses do
  @moduledoc &quot;&quot;&quot;
  WandererLicenses keeps the contexts that define your domain
  and business logic.

  Contexts are also responsible for managing your data, regardless
  if it comes from the database, an external API or others.
  &quot;&quot;&quot;
end</file><file path="priv/gettext/en/LC_MESSAGES/errors.po">## `msgid`s in this file come from POT (.pot) files.
##
## Do not add, change, or remove `msgid`s manually here as
## they&apos;re tied to the ones in the corresponding POT file
## (with the same domain).
##
## Use `mix gettext.extract --merge` or `mix gettext.merge`
## to merge POT files into PO files.
msgid &quot;&quot;
msgstr &quot;&quot;
&quot;Language: en\n&quot;

## From Ecto.Changeset.cast/4
msgid &quot;can&apos;t be blank&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.unique_constraint/3
msgid &quot;has already been taken&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.put_change/3
msgid &quot;is invalid&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_acceptance/3
msgid &quot;must be accepted&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_format/3
msgid &quot;has invalid format&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_subset/3
msgid &quot;has an invalid entry&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_exclusion/3
msgid &quot;is reserved&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_confirmation/3
msgid &quot;does not match confirmation&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.no_assoc_constraint/3
msgid &quot;is still associated with this entry&quot;
msgstr &quot;&quot;

msgid &quot;are still associated with this entry&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_length/3
msgid &quot;should have %{count} item(s)&quot;
msgid_plural &quot;should have %{count} item(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be %{count} character(s)&quot;
msgid_plural &quot;should be %{count} character(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be %{count} byte(s)&quot;
msgid_plural &quot;should be %{count} byte(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should have at least %{count} item(s)&quot;
msgid_plural &quot;should have at least %{count} item(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be at least %{count} character(s)&quot;
msgid_plural &quot;should be at least %{count} character(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be at least %{count} byte(s)&quot;
msgid_plural &quot;should be at least %{count} byte(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should have at most %{count} item(s)&quot;
msgid_plural &quot;should have at most %{count} item(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be at most %{count} character(s)&quot;
msgid_plural &quot;should be at most %{count} character(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be at most %{count} byte(s)&quot;
msgid_plural &quot;should be at most %{count} byte(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

## From Ecto.Changeset.validate_number/3
msgid &quot;must be less than %{number}&quot;
msgstr &quot;&quot;

msgid &quot;must be greater than %{number}&quot;
msgstr &quot;&quot;

msgid &quot;must be less than or equal to %{number}&quot;
msgstr &quot;&quot;

msgid &quot;must be greater than or equal to %{number}&quot;
msgstr &quot;&quot;

msgid &quot;must be equal to %{number}&quot;
msgstr &quot;&quot;</file><file path="priv/gettext/errors.pot">## This is a PO Template file.
##
## `msgid`s here are often extracted from source code.
## Add new translations manually only if they&apos;re dynamic
## translations that can&apos;t be statically extracted.
##
## Run `mix gettext.extract` to bring this file up to
## date. Leave `msgstr`s empty as changing them here has no
## effect: edit them in PO (`.po`) files instead.
## From Ecto.Changeset.cast/4
msgid &quot;can&apos;t be blank&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.unique_constraint/3
msgid &quot;has already been taken&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.put_change/3
msgid &quot;is invalid&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_acceptance/3
msgid &quot;must be accepted&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_format/3
msgid &quot;has invalid format&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_subset/3
msgid &quot;has an invalid entry&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_exclusion/3
msgid &quot;is reserved&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_confirmation/3
msgid &quot;does not match confirmation&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.no_assoc_constraint/3
msgid &quot;is still associated with this entry&quot;
msgstr &quot;&quot;

msgid &quot;are still associated with this entry&quot;
msgstr &quot;&quot;

## From Ecto.Changeset.validate_length/3
msgid &quot;should have %{count} item(s)&quot;
msgid_plural &quot;should have %{count} item(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be %{count} character(s)&quot;
msgid_plural &quot;should be %{count} character(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be %{count} byte(s)&quot;
msgid_plural &quot;should be %{count} byte(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should have at least %{count} item(s)&quot;
msgid_plural &quot;should have at least %{count} item(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be at least %{count} character(s)&quot;
msgid_plural &quot;should be at least %{count} character(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be at least %{count} byte(s)&quot;
msgid_plural &quot;should be at least %{count} byte(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should have at most %{count} item(s)&quot;
msgid_plural &quot;should have at most %{count} item(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be at most %{count} character(s)&quot;
msgid_plural &quot;should be at most %{count} character(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

msgid &quot;should be at most %{count} byte(s)&quot;
msgid_plural &quot;should be at most %{count} byte(s)&quot;
msgstr[0] &quot;&quot;
msgstr[1] &quot;&quot;

## From Ecto.Changeset.validate_number/3
msgid &quot;must be less than %{number}&quot;
msgstr &quot;&quot;

msgid &quot;must be greater than %{number}&quot;
msgstr &quot;&quot;

msgid &quot;must be less than or equal to %{number}&quot;
msgstr &quot;&quot;

msgid &quot;must be greater than or equal to %{number}&quot;
msgstr &quot;&quot;

msgid &quot;must be equal to %{number}&quot;
msgstr &quot;&quot;</file><file path="priv/grafana_dashboards/request_tracking.json">{
  &quot;annotations&quot;: {
    &quot;list&quot;: [
      {
        &quot;builtIn&quot;: 1,
        &quot;datasource&quot;: &quot;-- Grafana --&quot;,
        &quot;enable&quot;: true,
        &quot;hide&quot;: true,
        &quot;iconColor&quot;: &quot;rgba(0, 211, 255, 1)&quot;,
        &quot;name&quot;: &quot;Annotations &amp; Alerts&quot;,
        &quot;type&quot;: &quot;dashboard&quot;
      }
    ]
  },
  &quot;editable&quot;: true,
  &quot;gnetId&quot;: null,
  &quot;graphTooltip&quot;: 0,
  &quot;id&quot;: null,
  &quot;links&quot;: [],
  &quot;panels&quot;: [
    {
      &quot;aliasColors&quot;: {},
      &quot;bars&quot;: false,
      &quot;dashLength&quot;: 10,
      &quot;dashes&quot;: false,
      &quot;datasource&quot;: &quot;${datasource_id}&quot;,
      &quot;fieldConfig&quot;: {
        &quot;defaults&quot;: {
          &quot;custom&quot;: {}
        },
        &quot;overrides&quot;: []
      },
      &quot;fill&quot;: 1,
      &quot;fillGradient&quot;: 0,
      &quot;gridPos&quot;: {
        &quot;h&quot;: 8,
        &quot;w&quot;: 12,
        &quot;x&quot;: 0,
        &quot;y&quot;: 0
      },
      &quot;hiddenSeries&quot;: false,
      &quot;id&quot;: 1,
      &quot;legend&quot;: {
        &quot;avg&quot;: false,
        &quot;current&quot;: false,
        &quot;max&quot;: false,
        &quot;min&quot;: false,
        &quot;show&quot;: true,
        &quot;total&quot;: false,
        &quot;values&quot;: false
      },
      &quot;lines&quot;: true,
      &quot;linewidth&quot;: 1,
      &quot;nullPointMode&quot;: &quot;null&quot;,
      &quot;options&quot;: {
        &quot;alertThreshold&quot;: true
      },
      &quot;percentage&quot;: false,
      &quot;pluginVersion&quot;: &quot;7.3.7&quot;,
      &quot;pointradius&quot;: 2,
      &quot;points&quot;: false,
      &quot;renderer&quot;: &quot;flot&quot;,
      &quot;seriesOverrides&quot;: [],
      &quot;spaceLength&quot;: 10,
      &quot;stack&quot;: false,
      &quot;steppedLine&quot;: false,
      &quot;targets&quot;: [
        {
          &quot;expr&quot;: &quot;sum by (path) (rate(wanderer_licenses_request_count[5m]))&quot;,
          &quot;interval&quot;: &quot;&quot;,
          &quot;legendFormat&quot;: &quot;{{path}}&quot;,
          &quot;refId&quot;: &quot;A&quot;
        }
      ],
      &quot;thresholds&quot;: [],
      &quot;timeFrom&quot;: null,
      &quot;timeRegions&quot;: [],
      &quot;timeShift&quot;: null,
      &quot;title&quot;: &quot;Request Rate by Path&quot;,
      &quot;tooltip&quot;: {
        &quot;shared&quot;: true,
        &quot;sort&quot;: 0,
        &quot;value_type&quot;: &quot;individual&quot;
      },
      &quot;type&quot;: &quot;graph&quot;,
      &quot;xaxis&quot;: {
        &quot;buckets&quot;: null,
        &quot;mode&quot;: &quot;time&quot;,
        &quot;name&quot;: null,
        &quot;show&quot;: true,
        &quot;values&quot;: []
      },
      &quot;yaxes&quot;: [
        {
          &quot;format&quot;: &quot;short&quot;,
          &quot;label&quot;: &quot;Requests / Second&quot;,
          &quot;logBase&quot;: 1,
          &quot;max&quot;: null,
          &quot;min&quot;: null,
          &quot;show&quot;: true
        },
        {
          &quot;format&quot;: &quot;short&quot;,
          &quot;label&quot;: null,
          &quot;logBase&quot;: 1,
          &quot;max&quot;: null,
          &quot;min&quot;: null,
          &quot;show&quot;: true
        }
      ],
      &quot;yaxis&quot;: {
        &quot;align&quot;: false,
        &quot;alignLevel&quot;: null
      }
    },
    {
      &quot;datasource&quot;: &quot;${datasource_id}&quot;,
      &quot;fieldConfig&quot;: {
        &quot;defaults&quot;: {
          &quot;custom&quot;: {
            &quot;align&quot;: null,
            &quot;filterable&quot;: false
          },
          &quot;mappings&quot;: [],
          &quot;thresholds&quot;: {
            &quot;mode&quot;: &quot;absolute&quot;,
            &quot;steps&quot;: [
              {
                &quot;color&quot;: &quot;green&quot;,
                &quot;value&quot;: null
              }
            ]
          }
        },
        &quot;overrides&quot;: []
      },
      &quot;gridPos&quot;: {
        &quot;h&quot;: 8,
        &quot;w&quot;: 12,
        &quot;x&quot;: 12,
        &quot;y&quot;: 0
      },
      &quot;id&quot;: 2,
      &quot;options&quot;: {
        &quot;showHeader&quot;: true
      },
      &quot;pluginVersion&quot;: &quot;7.3.7&quot;,
      &quot;targets&quot;: [
        {
          &quot;expr&quot;: &quot;topk(10, sum by (path) (wanderer_licenses_request_count))&quot;,
          &quot;format&quot;: &quot;table&quot;,
          &quot;instant&quot;: true,
          &quot;interval&quot;: &quot;&quot;,
          &quot;legendFormat&quot;: &quot;&quot;,
          &quot;refId&quot;: &quot;A&quot;
        }
      ],
      &quot;timeFrom&quot;: null,
      &quot;timeShift&quot;: null,
      &quot;title&quot;: &quot;Top 10 Endpoints by Request Count&quot;,
      &quot;transformations&quot;: [
        {
          &quot;id&quot;: &quot;organize&quot;,
          &quot;options&quot;: {
            &quot;excludeByName&quot;: {
              &quot;Time&quot;: true
            },
            &quot;indexByName&quot;: {},
            &quot;renameByName&quot;: {
              &quot;Value&quot;: &quot;Count&quot;,
              &quot;path&quot;: &quot;Endpoint&quot;
            }
          }
        }
      ],
      &quot;type&quot;: &quot;table&quot;
    },
    {
      &quot;datasource&quot;: &quot;${datasource_id}&quot;,
      &quot;fieldConfig&quot;: {
        &quot;defaults&quot;: {
          &quot;custom&quot;: {},
          &quot;mappings&quot;: [],
          &quot;thresholds&quot;: {
            &quot;mode&quot;: &quot;absolute&quot;,
            &quot;steps&quot;: [
              {
                &quot;color&quot;: &quot;green&quot;,
                &quot;value&quot;: null
              }
            ]
          }
        },
        &quot;overrides&quot;: []
      },
      &quot;gridPos&quot;: {
        &quot;h&quot;: 8,
        &quot;w&quot;: 12,
        &quot;x&quot;: 0,
        &quot;y&quot;: 8
      },
      &quot;id&quot;: 3,
      &quot;options&quot;: {
        &quot;displayLabels&quot;: [&quot;name&quot;, &quot;percent&quot;],
        &quot;legend&quot;: {
          &quot;displayMode&quot;: &quot;list&quot;,
          &quot;placement&quot;: &quot;bottom&quot;
        },
        &quot;pieType&quot;: &quot;pie&quot;,
        &quot;reduceOptions&quot;: {
          &quot;calcs&quot;: [&quot;sum&quot;],
          &quot;fields&quot;: &quot;&quot;,
          &quot;values&quot;: false
        },
        &quot;strokeWidth&quot;: 1
      },
      &quot;pluginVersion&quot;: &quot;7.3.7&quot;,
      &quot;targets&quot;: [
        {
          &quot;expr&quot;: &quot;sum by (user) (wanderer_licenses_request_count)&quot;,
          &quot;interval&quot;: &quot;&quot;,
          &quot;legendFormat&quot;: &quot;{{user}}&quot;,
          &quot;refId&quot;: &quot;A&quot;
        }
      ],
      &quot;timeFrom&quot;: null,
      &quot;timeShift&quot;: null,
      &quot;title&quot;: &quot;Requests by User&quot;,
      &quot;type&quot;: &quot;piechart&quot;
    },
    {
      &quot;datasource&quot;: &quot;${datasource_id}&quot;,
      &quot;fieldConfig&quot;: {
        &quot;defaults&quot;: {
          &quot;custom&quot;: {
            &quot;align&quot;: null,
            &quot;filterable&quot;: false
          },
          &quot;mappings&quot;: [],
          &quot;thresholds&quot;: {
            &quot;mode&quot;: &quot;absolute&quot;,
            &quot;steps&quot;: [
              {
                &quot;color&quot;: &quot;green&quot;,
                &quot;value&quot;: null
              }
            ]
          }
        },
        &quot;overrides&quot;: []
      },
      &quot;gridPos&quot;: {
        &quot;h&quot;: 8,
        &quot;w&quot;: 12,
        &quot;x&quot;: 12,
        &quot;y&quot;: 8
      },
      &quot;id&quot;: 4,
      &quot;options&quot;: {
        &quot;showHeader&quot;: true
      },
      &quot;pluginVersion&quot;: &quot;7.3.7&quot;,
      &quot;targets&quot;: [
        {
          &quot;expr&quot;: &quot;topk(10, sum by (user) (wanderer_licenses_request_count))&quot;,
          &quot;format&quot;: &quot;table&quot;,
          &quot;instant&quot;: true,
          &quot;interval&quot;: &quot;&quot;,
          &quot;legendFormat&quot;: &quot;&quot;,
          &quot;refId&quot;: &quot;A&quot;
        }
      ],
      &quot;timeFrom&quot;: null,
      &quot;timeShift&quot;: null,
      &quot;title&quot;: &quot;Top 10 Users by Request Count&quot;,
      &quot;transformations&quot;: [
        {
          &quot;id&quot;: &quot;organize&quot;,
          &quot;options&quot;: {
            &quot;excludeByName&quot;: {
              &quot;Time&quot;: true
            },
            &quot;indexByName&quot;: {},
            &quot;renameByName&quot;: {
              &quot;Value&quot;: &quot;Count&quot;,
              &quot;user&quot;: &quot;User&quot;
            }
          }
        }
      ],
      &quot;type&quot;: &quot;table&quot;
    },
    {
      &quot;aliasColors&quot;: {},
      &quot;bars&quot;: false,
      &quot;dashLength&quot;: 10,
      &quot;dashes&quot;: false,
      &quot;datasource&quot;: &quot;${datasource_id}&quot;,
      &quot;fieldConfig&quot;: {
        &quot;defaults&quot;: {
          &quot;custom&quot;: {}
        },
        &quot;overrides&quot;: []
      },
      &quot;fill&quot;: 1,
      &quot;fillGradient&quot;: 0,
      &quot;gridPos&quot;: {
        &quot;h&quot;: 8,
        &quot;w&quot;: 24,
        &quot;x&quot;: 0,
        &quot;y&quot;: 16
      },
      &quot;hiddenSeries&quot;: false,
      &quot;id&quot;: 5,
      &quot;legend&quot;: {
        &quot;avg&quot;: false,
        &quot;current&quot;: false,
        &quot;max&quot;: false,
        &quot;min&quot;: false,
        &quot;show&quot;: true,
        &quot;total&quot;: false,
        &quot;values&quot;: false
      },
      &quot;lines&quot;: true,
      &quot;linewidth&quot;: 1,
      &quot;nullPointMode&quot;: &quot;null&quot;,
      &quot;options&quot;: {
        &quot;alertThreshold&quot;: true
      },
      &quot;percentage&quot;: false,
      &quot;pluginVersion&quot;: &quot;7.3.7&quot;,
      &quot;pointradius&quot;: 2,
      &quot;points&quot;: false,
      &quot;renderer&quot;: &quot;flot&quot;,
      &quot;seriesOverrides&quot;: [],
      &quot;spaceLength&quot;: 10,
      &quot;stack&quot;: false,
      &quot;steppedLine&quot;: false,
      &quot;targets&quot;: [
        {
          &quot;expr&quot;: &quot;histogram_quantile(0.95, sum(rate(wanderer_licenses_request_duration_milliseconds_bucket[5m])) by (le, path))&quot;,
          &quot;interval&quot;: &quot;&quot;,
          &quot;legendFormat&quot;: &quot;{{path}}&quot;,
          &quot;refId&quot;: &quot;A&quot;
        }
      ],
      &quot;thresholds&quot;: [],
      &quot;timeFrom&quot;: null,
      &quot;timeRegions&quot;: [],
      &quot;timeShift&quot;: null,
      &quot;title&quot;: &quot;95th Percentile Request Duration by Path&quot;,
      &quot;tooltip&quot;: {
        &quot;shared&quot;: true,
        &quot;sort&quot;: 0,
        &quot;value_type&quot;: &quot;individual&quot;
      },
      &quot;type&quot;: &quot;graph&quot;,
      &quot;xaxis&quot;: {
        &quot;buckets&quot;: null,
        &quot;mode&quot;: &quot;time&quot;,
        &quot;name&quot;: null,
        &quot;show&quot;: true,
        &quot;values&quot;: []
      },
      &quot;yaxes&quot;: [
        {
          &quot;format&quot;: &quot;ms&quot;,
          &quot;label&quot;: &quot;Duration (ms)&quot;,
          &quot;logBase&quot;: 1,
          &quot;max&quot;: null,
          &quot;min&quot;: null,
          &quot;show&quot;: true
        },
        {
          &quot;format&quot;: &quot;short&quot;,
          &quot;label&quot;: null,
          &quot;logBase&quot;: 1,
          &quot;max&quot;: null,
          &quot;min&quot;: null,
          &quot;show&quot;: true
        }
      ],
      &quot;yaxis&quot;: {
        &quot;align&quot;: false,
        &quot;alignLevel&quot;: null
      }
    },
    {
      &quot;datasource&quot;: &quot;${datasource_id}&quot;,
      &quot;fieldConfig&quot;: {
        &quot;defaults&quot;: {
          &quot;custom&quot;: {
            &quot;align&quot;: null,
            &quot;filterable&quot;: false
          },
          &quot;mappings&quot;: [],
          &quot;thresholds&quot;: {
            &quot;mode&quot;: &quot;absolute&quot;,
            &quot;steps&quot;: [
              {
                &quot;color&quot;: &quot;green&quot;,
                &quot;value&quot;: null
              },
              {
                &quot;color&quot;: &quot;red&quot;,
                &quot;value&quot;: 500
              }
            ]
          },
          &quot;unit&quot;: &quot;ms&quot;
        },
        &quot;overrides&quot;: []
      },
      &quot;gridPos&quot;: {
        &quot;h&quot;: 8,
        &quot;w&quot;: 24,
        &quot;x&quot;: 0,
        &quot;y&quot;: 24
      },
      &quot;id&quot;: 6,
      &quot;options&quot;: {
        &quot;showHeader&quot;: true,
        &quot;sortBy&quot;: [
          {
            &quot;desc&quot;: true,
            &quot;displayName&quot;: &quot;Avg Duration&quot;
          }
        ]
      },
      &quot;pluginVersion&quot;: &quot;7.3.7&quot;,
      &quot;targets&quot;: [
        {
          &quot;expr&quot;: &quot;avg by (path, method) (rate(wanderer_licenses_request_duration_milliseconds_sum[5m]) / rate(wanderer_licenses_request_duration_milliseconds_count[5m]))&quot;,
          &quot;format&quot;: &quot;table&quot;,
          &quot;instant&quot;: true,
          &quot;interval&quot;: &quot;&quot;,
          &quot;legendFormat&quot;: &quot;&quot;,
          &quot;refId&quot;: &quot;A&quot;
        }
      ],
      &quot;timeFrom&quot;: null,
      &quot;timeShift&quot;: null,
      &quot;title&quot;: &quot;Average Request Duration by Endpoint&quot;,
      &quot;transformations&quot;: [
        {
          &quot;id&quot;: &quot;organize&quot;,
          &quot;options&quot;: {
            &quot;excludeByName&quot;: {
              &quot;Time&quot;: true
            },
            &quot;indexByName&quot;: {},
            &quot;renameByName&quot;: {
              &quot;Value&quot;: &quot;Avg Duration&quot;,
              &quot;method&quot;: &quot;Method&quot;,
              &quot;path&quot;: &quot;Endpoint&quot;
            }
          }
        }
      ],
      &quot;type&quot;: &quot;table&quot;
    },
    {
      &quot;datasource&quot;: &quot;${datasource_id}&quot;,
      &quot;fieldConfig&quot;: {
        &quot;defaults&quot;: {
          &quot;custom&quot;: {
            &quot;align&quot;: null,
            &quot;filterable&quot;: false
          },
          &quot;mappings&quot;: [],
          &quot;thresholds&quot;: {
            &quot;mode&quot;: &quot;absolute&quot;,
            &quot;steps&quot;: [
              {
                &quot;color&quot;: &quot;green&quot;,
                &quot;value&quot;: null
              },
              {
                &quot;color&quot;: &quot;red&quot;,
                &quot;value&quot;: 400
              }
            ]
          }
        },
        &quot;overrides&quot;: []
      },
      &quot;gridPos&quot;: {
        &quot;h&quot;: 8,
        &quot;w&quot;: 24,
        &quot;x&quot;: 0,
        &quot;y&quot;: 32
      },
      &quot;id&quot;: 7,
      &quot;options&quot;: {
        &quot;showHeader&quot;: true
      },
      &quot;pluginVersion&quot;: &quot;7.3.7&quot;,
      &quot;targets&quot;: [
        {
          &quot;expr&quot;: &quot;sum by (path, method, status) (wanderer_licenses_request_count)&quot;,
          &quot;format&quot;: &quot;table&quot;,
          &quot;instant&quot;: true,
          &quot;interval&quot;: &quot;&quot;,
          &quot;legendFormat&quot;: &quot;&quot;,
          &quot;refId&quot;: &quot;A&quot;
        }
      ],
      &quot;timeFrom&quot;: null,
      &quot;timeShift&quot;: null,
      &quot;title&quot;: &quot;Request Count by Endpoint and Status&quot;,
      &quot;transformations&quot;: [
        {
          &quot;id&quot;: &quot;organize&quot;,
          &quot;options&quot;: {
            &quot;excludeByName&quot;: {
              &quot;Time&quot;: true
            },
            &quot;indexByName&quot;: {},
            &quot;renameByName&quot;: {
              &quot;Value&quot;: &quot;Count&quot;,
              &quot;method&quot;: &quot;Method&quot;,
              &quot;path&quot;: &quot;Endpoint&quot;,
              &quot;status&quot;: &quot;Status&quot;
            }
          }
        }
      ],
      &quot;type&quot;: &quot;table&quot;
    }
  ],
  &quot;refresh&quot;: &quot;10s&quot;,
  &quot;schemaVersion&quot;: 26,
  &quot;style&quot;: &quot;dark&quot;,
  &quot;tags&quot;: [&quot;wanderer_licenses&quot;, &quot;requests&quot;, &quot;users&quot;],
  &quot;templating&quot;: {
    &quot;list&quot;: []
  },
  &quot;time&quot;: {
    &quot;from&quot;: &quot;now-1h&quot;,
    &quot;to&quot;: &quot;now&quot;
  },
  &quot;timepicker&quot;: {
    &quot;refresh_intervals&quot;: [
      &quot;5s&quot;,
      &quot;10s&quot;,
      &quot;30s&quot;,
      &quot;1m&quot;,
      &quot;5m&quot;,
      &quot;15m&quot;,
      &quot;30m&quot;,
      &quot;1h&quot;,
      &quot;2h&quot;,
      &quot;1d&quot;
    ]
  },
  &quot;timezone&quot;: &quot;&quot;,
  &quot;title&quot;: &quot;WandererLicenses Request Tracking&quot;,
  &quot;uid&quot;: &quot;wanderer-licenses-request-tracking&quot;,
  &quot;version&quot;: 1
}</file><file path="priv/repo/migrations/.formatter.exs">[
  import_deps: [:ecto_sql],
  inputs: [&quot;*.exs&quot;]
]</file><file path="priv/repo/migrations/20250218191247_initialize_and_add_authentication_resources_and_add_magic_link_auth_extensions_1.exs">defmodule WandererLicenses.Repo.Migrations.InitializeAndAddAuthenticationResourcesAndAddMagicLinkAuthExtensions1 do
  @moduledoc &quot;&quot;&quot;
  Installs any extensions that are mentioned in the repo&apos;s `installed_extensions/0` callback

  This file was autogenerated with `mix ash_postgres.generate_migrations`
  &quot;&quot;&quot;

  use Ecto.Migration

  def up do
    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION ash_elixir_or(left BOOLEAN, in right ANYCOMPATIBLE, out f1 ANYCOMPATIBLE)
    AS $$ SELECT COALESCE(NULLIF($1, FALSE), $2) $$
    LANGUAGE SQL
    SET search_path = &apos;&apos;
    IMMUTABLE;
    &quot;&quot;&quot;)

    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION ash_elixir_or(left ANYCOMPATIBLE, in right ANYCOMPATIBLE, out f1 ANYCOMPATIBLE)
    AS $$ SELECT COALESCE($1, $2) $$
    LANGUAGE SQL
    SET search_path = &apos;&apos;
    IMMUTABLE;
    &quot;&quot;&quot;)

    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION ash_elixir_and(left BOOLEAN, in right ANYCOMPATIBLE, out f1 ANYCOMPATIBLE) AS $$
      SELECT CASE
        WHEN $1 IS TRUE THEN $2
        ELSE $1
      END $$
    LANGUAGE SQL
    SET search_path = &apos;&apos;
    IMMUTABLE;
    &quot;&quot;&quot;)

    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION ash_elixir_and(left ANYCOMPATIBLE, in right ANYCOMPATIBLE, out f1 ANYCOMPATIBLE) AS $$
      SELECT CASE
        WHEN $1 IS NOT NULL THEN $2
        ELSE $1
      END $$
    LANGUAGE SQL
    SET search_path = &apos;&apos;
    IMMUTABLE;
    &quot;&quot;&quot;)

    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION ash_trim_whitespace(arr text[])
    RETURNS text[] AS $$
    DECLARE
        start_index INT = 1;
        end_index INT = array_length(arr, 1);
    BEGIN
        WHILE start_index &lt;= end_index AND arr[start_index] = &apos;&apos; LOOP
            start_index := start_index + 1;
        END LOOP;

        WHILE end_index &gt;= start_index AND arr[end_index] = &apos;&apos; LOOP
            end_index := end_index - 1;
        END LOOP;

        IF start_index &gt; end_index THEN
            RETURN ARRAY[]::text[];
        ELSE
            RETURN arr[start_index : end_index];
        END IF;
    END; $$
    LANGUAGE plpgsql
    SET search_path = &apos;&apos;
    IMMUTABLE;
    &quot;&quot;&quot;)

    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION ash_raise_error(json_data jsonb)
    RETURNS BOOLEAN AS $$
    BEGIN
        -- Raise an error with the provided JSON data.
        -- The JSON object is converted to text for inclusion in the error message.
        RAISE EXCEPTION &apos;ash_error: %&apos;, json_data::text;
        RETURN NULL;
    END;
    $$ LANGUAGE plpgsql
    STABLE
    SET search_path = &apos;&apos;;
    &quot;&quot;&quot;)

    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION ash_raise_error(json_data jsonb, type_signal ANYCOMPATIBLE)
    RETURNS ANYCOMPATIBLE AS $$
    BEGIN
        -- Raise an error with the provided JSON data.
        -- The JSON object is converted to text for inclusion in the error message.
        RAISE EXCEPTION &apos;ash_error: %&apos;, json_data::text;
        RETURN NULL;
    END;
    $$ LANGUAGE plpgsql
    STABLE
    SET search_path = &apos;&apos;;
    &quot;&quot;&quot;)

    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION uuid_generate_v7()
    RETURNS UUID
    AS $$
    DECLARE
      timestamp    TIMESTAMPTZ;
      microseconds INT;
    BEGIN
      timestamp    = clock_timestamp();
      microseconds = (cast(extract(microseconds FROM timestamp)::INT - (floor(extract(milliseconds FROM timestamp))::INT * 1000) AS DOUBLE PRECISION) * 4.096)::INT;

      RETURN encode(
        set_byte(
          set_byte(
            overlay(uuid_send(gen_random_uuid()) placing substring(int8send(floor(extract(epoch FROM timestamp) * 1000)::BIGINT) FROM 3) FROM 1 FOR 6
          ),
          6, (b&apos;0111&apos; || (microseconds &gt;&gt; 8)::bit(4))::bit(8)::int
        ),
        7, microseconds::bit(8)::int
      ),
      &apos;hex&apos;)::UUID;
    END
    $$
    LANGUAGE PLPGSQL
    SET search_path = &apos;&apos;
    VOLATILE;
    &quot;&quot;&quot;)

    execute(&quot;&quot;&quot;
    CREATE OR REPLACE FUNCTION timestamp_from_uuid_v7(_uuid uuid)
    RETURNS TIMESTAMP WITHOUT TIME ZONE
    AS $$
      SELECT to_timestamp((&apos;x0000&apos; || substr(_uuid::TEXT, 1, 8) || substr(_uuid::TEXT, 10, 4))::BIT(64)::BIGINT::NUMERIC / 1000);
    $$
    LANGUAGE SQL
    SET search_path = &apos;&apos;
    IMMUTABLE PARALLEL SAFE STRICT;
    &quot;&quot;&quot;)

    execute(&quot;CREATE EXTENSION IF NOT EXISTS \&quot;citext\&quot;&quot;)
  end

  def down do
    # Uncomment this if you actually want to uninstall the extensions
    # when this migration is rolled back:
    execute(
      &quot;DROP FUNCTION IF EXISTS uuid_generate_v7(), timestamp_from_uuid_v7(uuid), ash_raise_error(jsonb), ash_raise_error(jsonb, ANYCOMPATIBLE), ash_elixir_and(BOOLEAN, ANYCOMPATIBLE), ash_elixir_and(ANYCOMPATIBLE, ANYCOMPATIBLE), ash_elixir_or(ANYCOMPATIBLE, ANYCOMPATIBLE), ash_elixir_or(BOOLEAN, ANYCOMPATIBLE), ash_trim_whitespace(text[])&quot;
    )

    # execute(&quot;DROP EXTENSION IF EXISTS \&quot;citext\&quot;&quot;)
  end
end</file><file path="priv/repo/migrations/20250218191248_initialize_and_add_authentication_resources_and_add_magic_link_auth.exs">defmodule WandererLicenses.Repo.Migrations.InitializeAndAddAuthenticationResourcesAndAddMagicLinkAuth do
  @moduledoc &quot;&quot;&quot;
  Updates resources based on their most recent snapshots.

  This file was autogenerated with `mix ash_postgres.generate_migrations`
  &quot;&quot;&quot;

  use Ecto.Migration

  def up do
    create table(:users, primary_key: false) do
      add :id, :uuid, null: false, default: fragment(&quot;gen_random_uuid()&quot;), primary_key: true
      add :email, :citext, null: false
    end

    create unique_index(:users, [:email], name: &quot;users_unique_email_index&quot;)

    create table(:tokens, primary_key: false) do
      add :created_at, :utc_datetime_usec,
        null: false,
        default: fragment(&quot;(now() AT TIME ZONE &apos;utc&apos;)&quot;)

      add :jti, :text, null: false, primary_key: true
      add :subject, :text, null: false
      add :expires_at, :utc_datetime, null: false
      add :purpose, :text, null: false
      add :extra_data, :map

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment(&quot;(now() AT TIME ZONE &apos;utc&apos;)&quot;)

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment(&quot;(now() AT TIME ZONE &apos;utc&apos;)&quot;)
    end
  end

  def down do
    drop table(:tokens)

    drop_if_exists unique_index(:users, [:email], name: &quot;users_unique_email_index&quot;)

    drop table(:users)
  end
end</file><file path="priv/repo/migrations/20250221235038_add_license_and_bot.exs">defmodule WandererLicenses.Repo.Migrations.AddLicenseAndBot do
  @moduledoc &quot;&quot;&quot;
  Updates resources based on their most recent snapshots.

  This file was autogenerated with `mix ash_postgres.generate_migrations`
  &quot;&quot;&quot;

  use Ecto.Migration

  def up do
    create table(:licenses_bots, primary_key: false) do
      add :id, :uuid, null: false, default: fragment(&quot;gen_random_uuid()&quot;), primary_key: true
      add :license_id, :uuid, null: false
      add :bot_id, :uuid, null: false
    end

    create table(:licenses, primary_key: false) do
      add :id, :uuid, null: false, default: fragment(&quot;gen_random_uuid()&quot;), primary_key: true
    end

    alter table(:licenses_bots) do
      modify :license_id,
             references(:licenses,
               column: :id,
               name: &quot;licenses_bots_license_id_fkey&quot;,
               type: :uuid,
               prefix: &quot;public&quot;
             )
    end

    alter table(:licenses) do
      add :name, :text, null: false
      add :description, :text
      add :is_valid, :boolean, default: false
      add :valid_to, :date
      add :link, :text, null: false
      add :contact_email, :citext
      add :key, :uuid, default: fragment(&quot;gen_random_uuid()&quot;)
    end

    create table(:bots, primary_key: false) do
      add :id, :uuid, null: false, default: fragment(&quot;gen_random_uuid()&quot;), primary_key: true
    end

    alter table(:licenses_bots) do
      modify :bot_id,
             references(:bots,
               column: :id,
               name: &quot;licenses_bots_bot_id_fkey&quot;,
               type: :uuid,
               prefix: &quot;public&quot;
             )
    end

    alter table(:bots) do
      add :name, :text, null: false
      add :description, :text
      add :api_token, :text, default: fragment(&quot;gen_random_uuid()&quot;)
      add :is_active, :boolean, default: true
    end
  end

  def down do
    alter table(:bots) do
      remove :is_active
      remove :api_token
      remove :description
      remove :name
    end

    drop constraint(:licenses_bots, &quot;licenses_bots_bot_id_fkey&quot;)

    alter table(:licenses_bots) do
      modify :bot_id, :uuid
    end

    drop table(:bots)

    alter table(:licenses) do
      remove :key
      remove :contact_email
      remove :link
      remove :valid_to
      remove :is_valid
      remove :description
      remove :name
    end

    drop constraint(:licenses_bots, &quot;licenses_bots_license_id_fkey&quot;)

    alter table(:licenses_bots) do
      modify :license_id, :uuid
    end

    drop table(:licenses)

    drop table(:licenses_bots)
  end
end</file><file path="priv/repo/migrations/20250305163050_add_bot_usage_and_developer_info.exs">defmodule WandererLicenses.Repo.Migrations.AddBotUsageAndDeveloperInfo do
  use Ecto.Migration

  def change do
    # Add developer_info column to bots table
    alter table(:bots) do
      add :developer_info, :string, null: true
    end

    # Create bot_usage table
    create table(:bot_usage, primary_key: false) do
      add :id, :uuid, primary_key: true
      add :bot_id, references(:bots, type: :uuid, on_delete: :delete_all), null: false
      add :license_id, references(:licenses, type: :uuid, on_delete: :nilify_all), null: true
      add :used_at, :utc_datetime, null: false
      add :ip_address, :string, null: true
      add :user_agent, :string, null: true

      timestamps()
    end

    # Add indexes for efficient querying
    create index(:bot_usage, [:bot_id])
    create index(:bot_usage, [:license_id])
    create index(:bot_usage, [:used_at])
  end
end</file><file path="priv/repo/migrations/20250305181122_rename_developer_info_to_email.exs">defmodule WandererLicenses.Repo.Migrations.RenameDeveloperInfoToEmail do
  use Ecto.Migration

  def change do
    # Step 1: Rename the column
    rename table(:bots), :developer_info, to: :developer_email
    
    # Step 2: Update existing NULL values to a default email
    execute &quot;UPDATE bots SET developer_email = &apos;unknown@example.com&apos; WHERE developer_email IS NULL&quot;
    
    # Step 3: Make the column NOT NULL
    alter table(:bots) do
      modify :developer_email, :string, null: false
    end
    
    # Create an index on developer_email for faster filtering
    create index(:bots, [:developer_email])
  end
end</file><file path="priv/repo/seeds.exs"># Script for populating the database. You can run it as:
#
#     mix run priv/repo/seeds.exs
#
# Inside the script, you can read and write to any of your
# repositories directly:
#
#     WandererLicenses.Repo.insert!(%WandererLicenses.SomeSchema{})
#
# We recommend using the bang functions (`insert!`, `update!`
# and so on) as they will fail if something goes wrong.</file><file path="priv/resource_snapshots/repo/bot_usage/20250305181005.json">{
  &quot;attributes&quot;: [
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;gen_random_uuid()\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: true,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: {
        &quot;deferrable&quot;: false,
        &quot;destination_attribute&quot;: &quot;id&quot;,
        &quot;destination_attribute_default&quot;: null,
        &quot;destination_attribute_generated&quot;: null,
        &quot;index?&quot;: false,
        &quot;match_type&quot;: null,
        &quot;match_with&quot;: null,
        &quot;multitenancy&quot;: {
          &quot;attribute&quot;: null,
          &quot;global&quot;: null,
          &quot;strategy&quot;: null
        },
        &quot;name&quot;: &quot;bot_usage_bot_id_fkey&quot;,
        &quot;on_delete&quot;: null,
        &quot;on_update&quot;: null,
        &quot;primary_key?&quot;: true,
        &quot;schema&quot;: &quot;public&quot;,
        &quot;table&quot;: &quot;bots&quot;
      },
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;bot_id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: {
        &quot;deferrable&quot;: false,
        &quot;destination_attribute&quot;: &quot;id&quot;,
        &quot;destination_attribute_default&quot;: null,
        &quot;destination_attribute_generated&quot;: null,
        &quot;index?&quot;: false,
        &quot;match_type&quot;: null,
        &quot;match_with&quot;: null,
        &quot;multitenancy&quot;: {
          &quot;attribute&quot;: null,
          &quot;global&quot;: null,
          &quot;strategy&quot;: null
        },
        &quot;name&quot;: &quot;bot_usage_license_id_fkey&quot;,
        &quot;on_delete&quot;: null,
        &quot;on_update&quot;: null,
        &quot;primary_key?&quot;: true,
        &quot;schema&quot;: &quot;public&quot;,
        &quot;table&quot;: &quot;licenses&quot;
      },
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;license_id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;(now() AT TIME ZONE &apos;utc&apos;)\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;used_at&quot;,
      &quot;type&quot;: &quot;utc_datetime&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;ip_address&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;user_agent&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;(now() AT TIME ZONE &apos;utc&apos;)\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;inserted_at&quot;,
      &quot;type&quot;: &quot;utc_datetime_usec&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;(now() AT TIME ZONE &apos;utc&apos;)\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;updated_at&quot;,
      &quot;type&quot;: &quot;utc_datetime_usec&quot;
    }
  ],
  &quot;base_filter&quot;: null,
  &quot;check_constraints&quot;: [],
  &quot;custom_indexes&quot;: [],
  &quot;custom_statements&quot;: [],
  &quot;has_create_action&quot;: true,
  &quot;hash&quot;: &quot;CEA40AF5AFDCC5CBC5AF823A988679C9F47873CC611069B4EC3D731650D0DB61&quot;,
  &quot;identities&quot;: [],
  &quot;multitenancy&quot;: {
    &quot;attribute&quot;: null,
    &quot;global&quot;: null,
    &quot;strategy&quot;: null
  },
  &quot;repo&quot;: &quot;Elixir.WandererLicenses.Repo&quot;,
  &quot;schema&quot;: null,
  &quot;table&quot;: &quot;bot_usage&quot;
}</file><file path="priv/resource_snapshots/repo/bots/20250305181005.json">{
  &quot;attributes&quot;: [
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;gen_random_uuid()\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: true,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;name&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;description&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;fragment(\&quot;gen_random_uuid()\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;api_token&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;true&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;is_active&quot;,
      &quot;type&quot;: &quot;boolean&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;developer_email&quot;,
      &quot;type&quot;: &quot;text&quot;
    }
  ],
  &quot;base_filter&quot;: null,
  &quot;check_constraints&quot;: [],
  &quot;custom_indexes&quot;: [],
  &quot;custom_statements&quot;: [],
  &quot;has_create_action&quot;: true,
  &quot;hash&quot;: &quot;195FAB02838BF7C844EE041ADFAF9CA8482EE8CDDD912D27A8D5B556287D2A62&quot;,
  &quot;identities&quot;: [],
  &quot;multitenancy&quot;: {
    &quot;attribute&quot;: null,
    &quot;global&quot;: null,
    &quot;strategy&quot;: null
  },
  &quot;repo&quot;: &quot;Elixir.WandererLicenses.Repo&quot;,
  &quot;schema&quot;: null,
  &quot;table&quot;: &quot;bots&quot;
}</file><file path="priv/resource_snapshots/repo/licenses/20250221235038.json">{
  &quot;attributes&quot;: [
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;gen_random_uuid()\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: true,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;name&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;description&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;false&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;is_valid&quot;,
      &quot;type&quot;: &quot;boolean&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;valid_to&quot;,
      &quot;type&quot;: &quot;date&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;link&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;contact_email&quot;,
      &quot;type&quot;: &quot;citext&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;fragment(\&quot;gen_random_uuid()\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;key&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    }
  ],
  &quot;base_filter&quot;: null,
  &quot;check_constraints&quot;: [],
  &quot;custom_indexes&quot;: [],
  &quot;custom_statements&quot;: [],
  &quot;has_create_action&quot;: true,
  &quot;hash&quot;: &quot;3A79A709F57034C650BEA8348EEA8A9DA52D8F0B0984802AF75B6E0A461CC79A&quot;,
  &quot;identities&quot;: [],
  &quot;multitenancy&quot;: {
    &quot;attribute&quot;: null,
    &quot;global&quot;: null,
    &quot;strategy&quot;: null
  },
  &quot;repo&quot;: &quot;Elixir.WandererLicenses.Repo&quot;,
  &quot;schema&quot;: null,
  &quot;table&quot;: &quot;licenses&quot;
}</file><file path="priv/resource_snapshots/repo/licenses_bots/20250221235038.json">{
  &quot;attributes&quot;: [
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;gen_random_uuid()\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: true,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: {
        &quot;deferrable&quot;: false,
        &quot;destination_attribute&quot;: &quot;id&quot;,
        &quot;destination_attribute_default&quot;: null,
        &quot;destination_attribute_generated&quot;: null,
        &quot;index?&quot;: false,
        &quot;match_type&quot;: null,
        &quot;match_with&quot;: null,
        &quot;multitenancy&quot;: {
          &quot;attribute&quot;: null,
          &quot;global&quot;: null,
          &quot;strategy&quot;: null
        },
        &quot;name&quot;: &quot;licenses_bots_license_id_fkey&quot;,
        &quot;on_delete&quot;: null,
        &quot;on_update&quot;: null,
        &quot;primary_key?&quot;: true,
        &quot;schema&quot;: &quot;public&quot;,
        &quot;table&quot;: &quot;licenses&quot;
      },
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;license_id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: {
        &quot;deferrable&quot;: false,
        &quot;destination_attribute&quot;: &quot;id&quot;,
        &quot;destination_attribute_default&quot;: null,
        &quot;destination_attribute_generated&quot;: null,
        &quot;index?&quot;: false,
        &quot;match_type&quot;: null,
        &quot;match_with&quot;: null,
        &quot;multitenancy&quot;: {
          &quot;attribute&quot;: null,
          &quot;global&quot;: null,
          &quot;strategy&quot;: null
        },
        &quot;name&quot;: &quot;licenses_bots_bot_id_fkey&quot;,
        &quot;on_delete&quot;: null,
        &quot;on_update&quot;: null,
        &quot;primary_key?&quot;: true,
        &quot;schema&quot;: &quot;public&quot;,
        &quot;table&quot;: &quot;bots&quot;
      },
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;bot_id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    }
  ],
  &quot;base_filter&quot;: null,
  &quot;check_constraints&quot;: [],
  &quot;custom_indexes&quot;: [],
  &quot;custom_statements&quot;: [],
  &quot;has_create_action&quot;: true,
  &quot;hash&quot;: &quot;B44672143933C6A9CFDC11409A8DF13E27A700E1985394B91C8AB609DAC150D5&quot;,
  &quot;identities&quot;: [],
  &quot;multitenancy&quot;: {
    &quot;attribute&quot;: null,
    &quot;global&quot;: null,
    &quot;strategy&quot;: null
  },
  &quot;repo&quot;: &quot;Elixir.WandererLicenses.Repo&quot;,
  &quot;schema&quot;: null,
  &quot;table&quot;: &quot;licenses_bots&quot;
}</file><file path="priv/resource_snapshots/repo/tokens/20250218191248.json">{
  &quot;attributes&quot;: [
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;(now() AT TIME ZONE &apos;utc&apos;)\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;created_at&quot;,
      &quot;type&quot;: &quot;utc_datetime_usec&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: true,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;jti&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;subject&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;expires_at&quot;,
      &quot;type&quot;: &quot;utc_datetime&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;purpose&quot;,
      &quot;type&quot;: &quot;text&quot;
    },
    {
      &quot;allow_nil?&quot;: true,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;extra_data&quot;,
      &quot;type&quot;: &quot;map&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;(now() AT TIME ZONE &apos;utc&apos;)\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;inserted_at&quot;,
      &quot;type&quot;: &quot;utc_datetime_usec&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;(now() AT TIME ZONE &apos;utc&apos;)\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;updated_at&quot;,
      &quot;type&quot;: &quot;utc_datetime_usec&quot;
    }
  ],
  &quot;base_filter&quot;: null,
  &quot;check_constraints&quot;: [],
  &quot;custom_indexes&quot;: [],
  &quot;custom_statements&quot;: [],
  &quot;has_create_action&quot;: true,
  &quot;hash&quot;: &quot;279EDB9162258AEB793A184F071BFD727A2092CB34163A69D71F622EC1B03093&quot;,
  &quot;identities&quot;: [],
  &quot;multitenancy&quot;: {
    &quot;attribute&quot;: null,
    &quot;global&quot;: null,
    &quot;strategy&quot;: null
  },
  &quot;repo&quot;: &quot;Elixir.WandererLicenses.Repo&quot;,
  &quot;schema&quot;: null,
  &quot;table&quot;: &quot;tokens&quot;
}</file><file path="priv/resource_snapshots/repo/users/20250218191248.json">{
  &quot;attributes&quot;: [
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;fragment(\&quot;gen_random_uuid()\&quot;)&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: true,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;id&quot;,
      &quot;type&quot;: &quot;uuid&quot;
    },
    {
      &quot;allow_nil?&quot;: false,
      &quot;default&quot;: &quot;nil&quot;,
      &quot;generated?&quot;: false,
      &quot;primary_key?&quot;: false,
      &quot;references&quot;: null,
      &quot;size&quot;: null,
      &quot;source&quot;: &quot;email&quot;,
      &quot;type&quot;: &quot;citext&quot;
    }
  ],
  &quot;base_filter&quot;: null,
  &quot;check_constraints&quot;: [],
  &quot;custom_indexes&quot;: [],
  &quot;custom_statements&quot;: [],
  &quot;has_create_action&quot;: true,
  &quot;hash&quot;: &quot;F7BFB15A11B9EE4EEB77A19A937958291CA665A3A573A09E71D570548C1EA0BB&quot;,
  &quot;identities&quot;: [
    {
      &quot;all_tenants?&quot;: false,
      &quot;base_filter&quot;: null,
      &quot;index_name&quot;: &quot;users_unique_email_index&quot;,
      &quot;keys&quot;: [
        {
          &quot;type&quot;: &quot;atom&quot;,
          &quot;value&quot;: &quot;email&quot;
        }
      ],
      &quot;name&quot;: &quot;unique_email&quot;,
      &quot;nils_distinct?&quot;: true,
      &quot;where&quot;: null
    }
  ],
  &quot;multitenancy&quot;: {
    &quot;attribute&quot;: null,
    &quot;global&quot;: null,
    &quot;strategy&quot;: null
  },
  &quot;repo&quot;: &quot;Elixir.WandererLicenses.Repo&quot;,
  &quot;schema&quot;: null,
  &quot;table&quot;: &quot;users&quot;
}</file><file path="priv/resource_snapshots/repo/extensions.json">{
  &quot;ash_functions_version&quot;: 5,
  &quot;installed&quot;: [
    &quot;ash-functions&quot;,
    &quot;citext&quot;
  ]
}</file><file path="priv/static/robots.txt"># See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file
#
# To ban all spiders from the entire site uncomment the next two lines:
# User-agent: *
# Disallow: /</file><file path="rel/overlays/bin/createdb.sh">#!/bin/sh
set -eu

BIN_DIR=$(dirname &quot;$0&quot;)

&quot;${BIN_DIR}&quot;/wanderer_licenses eval WandererLicenses.Release.createdb</file><file path="rel/overlays/bin/migrate.sh">#!/bin/sh
set -eu

BIN_DIR=$(dirname &quot;$0&quot;)

&quot;${BIN_DIR}&quot;/wanderer_licenses eval WandererLicenses.Release.interweave_migrate</file><file path="rel/overlays/bin/rollback.sh">#!/bin/sh

BIN_DIR=$(dirname &quot;$0&quot;)

&quot;${BIN_DIR}&quot;/wanderer_licenses eval WandererLicenses.Release.rollback</file><file path="rel/overlays/bin/server">#!/bin/sh
set -eu

cd -P -- &quot;$(dirname -- &quot;$0&quot;)&quot;
PHX_SERVER=true exec ./wanderer_licenses start</file><file path="rel/docker-entrypoint.sh">#!/bin/sh
set -e

if [ &quot;$1&quot; = &apos;run&apos; ]; then
      exec /app/bin/wanderer_licenses start

elif [ &quot;$1&quot; = &apos;db&apos; ]; then
      exec /app/bin/&quot;$2&quot;.sh
 else
      exec &quot;$@&quot;

fi

exec &quot;$@&quot;</file><file path="scripts/check_api_url.sh">#!/bin/bash

# Script to check different API URL formats
# This helps identify the correct URL format for the API

# Set your API key here
API_KEY=&quot;J5j9r9JBPUk8QrHFIce5MVt4V4y6+ny9nxXAkWnJrK8=&quot;

# Colors for output
GREEN=&apos;\033[0;32m&apos;
RED=&apos;\033[0;31m&apos;
YELLOW=&apos;\033[0;33m&apos;
BLUE=&apos;\033[0;34m&apos;
NC=&apos;\033[0m&apos; # No Color

# Function to print section headers
print_header() {
  echo -e &quot;\n${YELLOW}==== $1 ====${NC}\n&quot;
}

# Function to print a separator
print_separator() {
  echo -e &quot;\n${YELLOW}----------------------------------------${NC}\n&quot;
}

# Test different base URLs
test_base_urls() {
  print_header &quot;Testing Different Base URLs&quot;
  
  # Create a temporary file for the JSON payload
  PAYLOAD_FILE=$(mktemp)
  cat &gt; $PAYLOAD_FILE &lt;&lt; EOF
{
  &quot;name&quot;: &quot;URL Test License&quot;,
  &quot;link&quot;: &quot;https://example.com/url-test&quot;
}
EOF
  
  # Test localhost with different ports
  echo -e &quot;${BLUE}Testing http://localhost:4000/api/manage/licenses${NC}&quot;
  curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d @$PAYLOAD_FILE \
    http://localhost:4000/api/manage/licenses | head -n 20
  print_separator
  
  echo -e &quot;${BLUE}Testing http://127.0.0.1:4000/api/manage/licenses${NC}&quot;
  curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d @$PAYLOAD_FILE \
    http://127.0.0.1:4000/api/manage/licenses | head -n 20
  print_separator
  
  # Test with different ports
  echo -e &quot;${BLUE}Testing http://localhost:4001/api/manage/licenses${NC}&quot;
  curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d @$PAYLOAD_FILE \
    http://localhost:4001/api/manage/licenses | head -n 20
  print_separator
  
  # Test with different path formats
  echo -e &quot;${BLUE}Testing http://localhost:4000/api/manage/licenses/${NC}&quot;
  curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d @$PAYLOAD_FILE \
    http://localhost:4000/api/manage/licenses/ | head -n 20
  print_separator
  
  # Clean up
  rm $PAYLOAD_FILE
}

# Test public endpoints to verify API is accessible
test_public_endpoints() {
  print_header &quot;Testing Public Endpoints&quot;
  
  echo -e &quot;${BLUE}Testing GET http://localhost:4000/api/bots${NC}&quot;
  curl -s -X GET \
    -H &quot;Accept: application/json&quot; \
    http://localhost:4000/api/bots | head -n 20
  print_separator
  
  echo -e &quot;${BLUE}Testing GET http://127.0.0.1:4000/api/bots${NC}&quot;
  curl -s -X GET \
    -H &quot;Accept: application/json&quot; \
    http://127.0.0.1:4000/api/bots | head -n 20
  print_separator
}

# Main function
main() {
  echo -e &quot;${YELLOW}WandererLicenses API URL Test${NC}&quot;
  echo &quot;This script tests different URL formats to identify the correct one for the API.&quot;
  echo
  
  # Test public endpoints first to verify API is accessible
  test_public_endpoints
  
  # Test different base URLs
  test_base_urls
  
  echo -e &quot;\n${YELLOW}Testing completed.${NC}&quot;
  echo &quot;Check the responses above to identify which URL format works correctly.&quot;
  echo &quot;Look for JSON responses instead of HTML or error messages.&quot;
}

# Run the main function
main</file><file path="scripts/generate_analytics_data.sh">#!/bin/bash

# Generate Analytics Data Script for WandererLicenses
# This script generates artificial traffic for testing the analytics feature

# Base URL for the API
API_URL=&quot;http://localhost:4000&quot;

# Colors for output
GREEN=&apos;\033[0;32m&apos;
RED=&apos;\033[0;31m&apos;
YELLOW=&apos;\033[0;33m&apos;
BLUE=&apos;\033[0;34m&apos;
CYAN=&apos;\033[0;36m&apos;
NC=&apos;\033[0m&apos; # No Color

# Function to print section headers
print_header() {
  echo -e &quot;\n${YELLOW}==== $1 ====${NC}\n&quot;
}

# Function to print a separator
print_separator() {
  echo -e &quot;\n${YELLOW}----------------------------------------${NC}\n&quot;
}

# Function to fetch all bots
fetch_bots() {
  print_header &quot;Fetching Bots&quot;
  
  echo -e &quot;${BLUE}Executing: curl GET to fetch all bots${NC}&quot;
  
  # Execute the curl command
  RESPONSE=$(curl -s -X GET \
    -H &quot;Accept: application/json&quot; \
    $API_URL/api/bots)
  
  # Check if the response contains bots
  if [[ $RESPONSE != *&quot;bots&quot;* ]]; then
    echo -e &quot;${RED}Failed to fetch bots. Please check if the server is running.${NC}&quot;
    return 1
  fi
  
  echo -e &quot;${GREEN}Successfully fetched bots.${NC}&quot;
  
  # Display bot information in a more readable format
  if command -v jq &amp;&gt; /dev/null; then
    echo -e &quot;\n${CYAN}Available Bots:${NC}&quot;
    echo &quot;$RESPONSE&quot; | jq -r &apos;.bots[] | &quot;ID: \(.id)\nName: \(.name)\nDescription: \(.description // &quot;N/A&quot;)\nDeveloper: \(.developer_email // &quot;N/A&quot;)\nActive: \(.is_active)\n&quot;&apos;
  else
    echo $RESPONSE | jq .
  fi
  
  print_separator
  
  # Return the response
  echo &quot;$RESPONSE&quot;
}

# Function to get a bot&apos;s API token
get_bot_token() {
  local bot_id=$1
  
  # This is a placeholder function since we don&apos;t have a direct API to get a bot&apos;s token
  # In a real implementation, you would need to have this information stored or retrieved securely
  
  echo -e &quot;${YELLOW}Note: In a real implementation, you would retrieve the bot token securely.${NC}&quot;
  read -p &quot;Enter API token for bot $bot_id: &quot; bot_token
  
  echo &quot;$bot_token&quot;
}

# Function to automatically select a bot
auto_select_bot() {
  print_header &quot;Auto-selecting a Bot&quot;
  
  echo -e &quot;${BLUE}Fetching available bots...${NC}&quot;
  
  # Get the list of bots
  BOTS_RESPONSE=$(fetch_bots)
  
  # Check if we got a valid response
  if [[ $BOTS_RESPONSE != *&quot;bots&quot;* ]]; then
    echo -e &quot;${RED}Failed to fetch bots. Cannot auto-select.${NC}&quot;
    return 1
  fi
  
  # Extract bot information using jq if available
  if command -v jq &amp;&gt; /dev/null; then
    # Get the number of bots
    BOT_COUNT=$(echo &quot;$BOTS_RESPONSE&quot; | jq &apos;.bots | length&apos;)
    
    if [[ $BOT_COUNT -eq 0 ]]; then
      echo -e &quot;${RED}No bots found in the system.${NC}&quot;
      return 1
    fi
    
    # Select a random bot index
    RANDOM_INDEX=$(($RANDOM % $BOT_COUNT))
    
    # Get the bot ID and name
    BOT_ID=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$RANDOM_INDEX].id&quot;)
    BOT_NAME=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$RANDOM_INDEX].name&quot;)
    
    echo -e &quot;${GREEN}Selected bot: $BOT_NAME (ID: $BOT_ID)${NC}&quot;
    
    # Get the bot&apos;s API token
    BOT_TOKEN=$(get_bot_token &quot;$BOT_ID&quot;)
    
    # Return the bot ID and token
    echo &quot;$BOT_ID|$BOT_TOKEN&quot;
  else
    # If jq is not available, ask the user to select a bot
    echo -e &quot;${YELLOW}jq is not installed. Please select a bot manually.${NC}&quot;
    echo &quot;$BOTS_RESPONSE&quot;
    
    read -p &quot;Enter bot ID: &quot; BOT_ID
    BOT_TOKEN=$(get_bot_token &quot;$BOT_ID&quot;)
    
    echo &quot;$BOT_ID|$BOT_TOKEN&quot;
  fi
}

# Function to validate a bot
validate_bot() {
  local bot_id=$1
  local api_token=$2
  local user_agent=$3
  
  # Create a temporary file for the JSON payload
  PAYLOAD_FILE=$(mktemp)
  cat &gt; $PAYLOAD_FILE &lt;&lt; EOF
{
  &quot;id&quot;: &quot;$bot_id&quot;,
  &quot;api_token&quot;: &quot;$api_token&quot;
}
EOF
  
  # Execute the curl command
  RESPONSE=$(curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;User-Agent: $user_agent&quot; \
    -d @$PAYLOAD_FILE \
    $API_URL/api/validate_bot)
  
  # Clean up
  rm $PAYLOAD_FILE
  
  # Return the response
  echo $RESPONSE
}

# Function to validate a license
validate_license() {
  local license_key=$1
  local user_agent=$2
  
  # Execute the curl command
  RESPONSE=$(curl -s -X GET \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $license_key&quot; \
    -H &quot;User-Agent: $user_agent&quot; \
    $API_URL/api/license/validate)
  
  # Return the response
  echo $RESPONSE
}

# Function to generate traffic for a single bot
generate_bot_traffic() {
  local bot_id=$1
  local api_token=$2
  local count=$3
  
  echo -e &quot;${BLUE}Generating $count validation requests for bot $bot_id...${NC}&quot;
  
  # List of user agents to simulate different clients
  USER_AGENTS=(
    &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&quot;
    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15&quot;
    &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36&quot;
    &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0&quot;
    &quot;TrafficGenerator/1.0&quot;
    &quot;WandererBot/2.1&quot;
    &quot;TestClient/3.0&quot;
  )
  
  # Generate traffic
  for i in $(seq 1 $count); do
    # Select a random user agent
    USER_AGENT=${USER_AGENTS[$RANDOM % ${#USER_AGENTS[@]}]}
    
    echo -e &quot;${CYAN}Request $i of $count${NC} (User-Agent: ${USER_AGENT:0:20}...)&quot;
    
    # Validate the bot
    RESPONSE=$(validate_bot &quot;$bot_id&quot; &quot;$api_token&quot; &quot;$USER_AGENT&quot;)
    
    # Check response
    if [[ $RESPONSE == *&quot;valid\&quot;:true&quot;* ]]; then
      echo -e &quot;${GREEN} Validation successful${NC}&quot;
    else
      echo -e &quot;${RED} Validation failed: $RESPONSE${NC}&quot;
    fi
    
    # Add a small random delay between requests (0.1 to 2 seconds)
    sleep $(awk -v min=0.1 -v max=2 &apos;BEGIN{srand(); print min+rand()*(max-min)}&apos;)
  done
}

# Function to generate traffic for a license
generate_license_traffic() {
  local license_key=$1
  local count=$2
  
  echo -e &quot;${BLUE}Generating $count validation requests for license key $license_key...${NC}&quot;
  
  # List of user agents to simulate different clients
  USER_AGENTS=(
    &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&quot;
    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15&quot;
    &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36&quot;
    &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0&quot;
    &quot;TrafficGenerator/1.0&quot;
    &quot;WandererLicense/2.1&quot;
    &quot;TestClient/3.0&quot;
  )
  
  # Generate traffic
  for i in $(seq 1 $count); do
    # Select a random user agent
    USER_AGENT=${USER_AGENTS[$RANDOM % ${#USER_AGENTS[@]}]}
    
    echo -e &quot;${CYAN}Request $i of $count${NC} (User-Agent: ${USER_AGENT:0:20}...)&quot;
    
    # Validate the license
    RESPONSE=$(validate_license &quot;$license_key&quot; &quot;$USER_AGENT&quot;)
    
    # Check response
    if [[ $RESPONSE == *&quot;license_valid&quot;* ]]; then
      echo -e &quot;${GREEN} License validation successful${NC}&quot;
    else
      echo -e &quot;${RED} License validation failed: $RESPONSE${NC}&quot;
    fi
    
    # Add a small random delay between requests (0.1 to 2 seconds)
    sleep $(awk -v min=0.1 -v max=2 &apos;BEGIN{srand(); print min+rand()*(max-min)}&apos;)
  done
}

# Function to generate traffic for multiple bots
generate_multi_bot_traffic() {
  print_header &quot;Generating Traffic for Multiple Bots&quot;
  
  # Ask for the number of bots
  read -p &quot;How many bots would you like to configure? &quot; num_bots
  
  # Array to store bot IDs and tokens
  declare -a bot_ids
  declare -a bot_tokens
  declare -a bot_counts
  
  # Collect bot information
  for i in $(seq 1 $num_bots); do
    echo -e &quot;\n${YELLOW}Bot $i Configuration:${NC}&quot;
    read -p &quot;Enter bot ID: &quot; bot_id
    read -p &quot;Enter bot API token: &quot; bot_token
    read -p &quot;How many validation requests for this bot? &quot; bot_count
    
    bot_ids[$i-1]=$bot_id
    bot_tokens[$i-1]=$bot_token
    bot_counts[$i-1]=$bot_count
  done
  
  # Generate traffic for each bot
  for i in $(seq 0 $(($num_bots-1))); do
    generate_bot_traffic &quot;${bot_ids[$i]}&quot; &quot;${bot_tokens[$i]}&quot; &quot;${bot_counts[$i]}&quot;
    print_separator
  done
  
  echo -e &quot;${GREEN}Multi-bot traffic generation complete!${NC}&quot;
}

# Function to generate traffic for multiple licenses
generate_multi_license_traffic() {
  print_header &quot;Generating Traffic for Multiple Licenses&quot;
  
  # Ask for the number of licenses
  read -p &quot;How many licenses would you like to configure? &quot; num_licenses
  
  # Array to store license keys and counts
  declare -a license_keys
  declare -a license_counts
  
  # Collect license information
  for i in $(seq 1 $num_licenses); do
    echo -e &quot;\n${YELLOW}License $i Configuration:${NC}&quot;
    read -p &quot;Enter license key: &quot; license_key
    read -p &quot;How many validation requests for this license? &quot; license_count
    
    license_keys[$i-1]=$license_key
    license_counts[$i-1]=$license_count
  done
  
  # Generate traffic for each license
  for i in $(seq 0 $(($num_licenses-1))); do
    generate_license_traffic &quot;${license_keys[$i]}&quot; &quot;${license_counts[$i]}&quot;
    print_separator
  done
  
  echo -e &quot;${GREEN}Multi-license traffic generation complete!${NC}&quot;
}

# Function to generate random traffic over time
generate_random_traffic() {
  print_header &quot;Generating Random Traffic Over Time&quot;
  
  # Auto-select a bot
  BOT_INFO=$(auto_select_bot)
  
  # Check if auto-selection was successful
  if [[ $? -ne 0 ]]; then
    echo -e &quot;${RED}Failed to auto-select a bot. Please try again or select manually.${NC}&quot;
    read -p &quot;Enter bot ID: &quot; bot_id
    read -p &quot;Enter bot API token: &quot; api_token
  else
    # Split the bot info
    IFS=&apos;|&apos; read -r bot_id api_token &lt;&lt;&lt; &quot;$BOT_INFO&quot;
  fi
  
  read -p &quot;Enter license key (leave empty to skip license validation): &quot; license_key
  read -p &quot;How many total requests? &quot; total_requests
  read -p &quot;Maximum delay between requests in seconds (default: 5): &quot; max_delay
  max_delay=${max_delay:-5}
  
  echo -e &quot;${BLUE}Generating $total_requests random requests...${NC}&quot;
  
  # List of user agents to simulate different clients
  USER_AGENTS=(
    &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&quot;
    &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15&quot;
    &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36&quot;
    &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0&quot;
    &quot;TrafficGenerator/1.0&quot;
    &quot;WandererBot/2.1&quot;
    &quot;TestClient/3.0&quot;
  )
  
  # Generate traffic
  for i in $(seq 1 $total_requests); do
    # Select a random user agent
    USER_AGENT=${USER_AGENTS[$RANDOM % ${#USER_AGENTS[@]}]}
    
    echo -e &quot;${CYAN}Request $i of $total_requests${NC} (User-Agent: ${USER_AGENT:0:20}...)&quot;
    
    # Randomly choose between bot and license validation (if license key provided)
    if [[ -n &quot;$license_key&quot; &amp;&amp; $(($RANDOM % 2)) -eq 0 ]]; then
      echo &quot;Validating license...&quot;
      RESPONSE=$(validate_license &quot;$license_key&quot; &quot;$USER_AGENT&quot;)
      
      # Check response
      if [[ $RESPONSE == *&quot;license_valid&quot;* ]]; then
        echo -e &quot;${GREEN} License validation successful${NC}&quot;
      else
        echo -e &quot;${RED} License validation failed: $RESPONSE${NC}&quot;
      fi
    else
      echo &quot;Validating bot...&quot;
      RESPONSE=$(validate_bot &quot;$bot_id&quot; &quot;$api_token&quot; &quot;$USER_AGENT&quot;)
      
      # Check response
      if [[ $RESPONSE == *&quot;valid\&quot;:true&quot;* ]]; then
        echo -e &quot;${GREEN} Bot validation successful${NC}&quot;
      else
        echo -e &quot;${RED} Bot validation failed: $RESPONSE${NC}&quot;
      fi
    fi
    
    # Add a random delay between requests (0.1 to max_delay seconds)
    delay=$(awk -v min=0.1 -v max=$max_delay &apos;BEGIN{srand(); print min+rand()*(max-min)}&apos;)
    echo &quot;Waiting ${delay}s before next request...&quot;
    sleep $delay
  done
  
  echo -e &quot;${GREEN}Random traffic generation complete!${NC}&quot;
}

# Function to generate traffic with auto-selected bot
generate_auto_bot_traffic() {
  print_header &quot;Generating Traffic with Auto-Selected Bot&quot;
  
  # Auto-select a bot
  BOT_INFO=$(auto_select_bot)
  
  # Check if auto-selection was successful
  if [[ $? -ne 0 ]]; then
    echo -e &quot;${RED}Failed to auto-select a bot. Please try again or select manually.${NC}&quot;
    return 1
  fi
  
  # Split the bot info
  IFS=&apos;|&apos; read -r bot_id api_token &lt;&lt;&lt; &quot;$BOT_INFO&quot;
  
  # Ask for the number of validation requests
  read -p &quot;How many validation requests? (default: 20) &quot; count
  count=${count:-20}
  
  # Generate traffic for the selected bot
  generate_bot_traffic &quot;$bot_id&quot; &quot;$api_token&quot; &quot;$count&quot;
  
  echo -e &quot;${GREEN}Auto-bot traffic generation complete!${NC}&quot;
}

# Main menu
main_menu() {
  clear
  echo -e &quot;${YELLOW}WandererLicenses Analytics Data Generator${NC}&quot;
  echo
  echo &quot;1. Fetch all bots&quot;
  echo &quot;2. Generate traffic for a single bot&quot;
  echo &quot;3. Generate traffic for a single license&quot;
  echo &quot;4. Generate traffic for multiple bots&quot;
  echo &quot;5. Generate traffic for multiple licenses&quot;
  echo &quot;6. Generate random traffic over time&quot;
  echo &quot;7. Generate traffic with auto-selected bot (NEW!)&quot;
  echo &quot;8. Exit&quot;
  echo
  read -p &quot;Enter your choice (1-8): &quot; choice
  
  case $choice in
    1) fetch_bots; press_enter_to_continue; main_menu ;;
    2) 
      read -p &quot;Enter bot ID: &quot; bot_id
      read -p &quot;Enter bot API token: &quot; api_token
      read -p &quot;How many validation requests? &quot; count
      generate_bot_traffic &quot;$bot_id&quot; &quot;$api_token&quot; &quot;$count&quot;
      press_enter_to_continue
      main_menu 
      ;;
    3) 
      read -p &quot;Enter license key: &quot; license_key
      read -p &quot;How many validation requests? &quot; count
      generate_license_traffic &quot;$license_key&quot; &quot;$count&quot;
      press_enter_to_continue
      main_menu 
      ;;
    4) generate_multi_bot_traffic; press_enter_to_continue; main_menu ;;
    5) generate_multi_license_traffic; press_enter_to_continue; main_menu ;;
    6) generate_random_traffic; press_enter_to_continue; main_menu ;;
    7) generate_auto_bot_traffic; press_enter_to_continue; main_menu ;;
    8) exit 0 ;;
    *) echo &quot;Invalid choice&quot;; press_enter_to_continue; main_menu ;;
  esac
}

# Helper function
press_enter_to_continue() {
  echo
  read -p &quot;Press Enter to continue...&quot;
}

# Check if jq is installed
if ! command -v jq &amp;&gt; /dev/null; then
  echo -e &quot;${YELLOW}Warning: &apos;jq&apos; is not installed. JSON output will not be formatted.${NC}&quot;
  echo &quot;You can install jq with: sudo apt-get install jq&quot;
  echo
fi

# Start the script
main_menu</file><file path="scripts/manual_api_test.sh">#!/bin/bash

# Manual API Test Script for WandererLicenses
# This script provides simple curl commands for testing the API endpoints

# Set your API key here
API_KEY=&quot;J5j9r9JBPUk8QrHFIce5MVt4V4y6+ny9nxXAkWnJrK8=&quot;

# Base URL for the API
API_URL=&quot;http://localhost:4000&quot;

# Colors for output
GREEN=&apos;\033[0;32m&apos;
RED=&apos;\033[0;31m&apos;
YELLOW=&apos;\033[0;33m&apos;
BLUE=&apos;\033[0;34m&apos;
NC=&apos;\033[0m&apos; # No Color
CYAN=&apos;\033[0;36m&apos;

# Function to print section headers
print_header() {
  echo -e &quot;\n${YELLOW}==== $1 ====${NC}\n&quot;
}

# Function to print a separator
print_separator() {
  echo -e &quot;\n${YELLOW}----------------------------------------${NC}\n&quot;
}

# Function to check if the API server is reachable
check_api_reachable() {
  echo -e &quot;${BLUE}Checking if API server is reachable at $API_URL...${NC}&quot;
  
  # Try to connect to the server with a timeout
  if curl -s --connect-timeout 5 --max-time 10 &quot;$API_URL/api/bots&quot; &gt; /dev/null; then
    echo -e &quot;${GREEN}API server is reachable.${NC}&quot;
    return 0
  else
    echo -e &quot;${RED}Cannot reach API server at $API_URL${NC}&quot;
    return 1
  fi
}

# Function to fetch all bots
fetch_bots() {
  print_header &quot;Fetching Bots&quot;
  
  # First check if the API server is reachable
  if ! check_api_reachable; then
    echo -e &quot;${YELLOW}Troubleshooting suggestions:${NC}&quot;
    echo &quot;1. Verify the API URL is correct: $API_URL&quot;
    echo &quot;2. Check that the server is running&quot;
    echo &quot;3. Check for network connectivity issues&quot;
    echo &quot;4. Try changing the port if needed (currently using port $(echo $API_URL | grep -oP &apos;(?&lt;=:)\d+&apos;))&quot;
    
    # Ask if the user wants to change the API URL
    read -p &quot;Would you like to change the API URL? (y/n): &quot; change_url
    if [[ $change_url == &quot;y&quot; || $change_url == &quot;Y&quot; ]]; then
      read -p &quot;Enter new API URL (e.g., http://localhost:4000): &quot; new_url
      if [[ -n &quot;$new_url&quot; ]]; then
        API_URL=&quot;$new_url&quot;
        echo -e &quot;${BLUE}API URL updated to: $API_URL${NC}&quot;
        # Try again with the new URL
        fetch_bots
        return $?
      fi
    fi
    
    return 1
  fi
  
  echo -e &quot;${BLUE}Executing: curl GET to fetch all bots${NC}&quot;
  
  # Execute the curl command
  RESPONSE=$(curl -s -X GET \
    -H &quot;Accept: application/json&quot; \
    $API_URL/api/bots)
  
  # Check if the response is empty
  if [[ -z &quot;$RESPONSE&quot; ]]; then
    echo -e &quot;${RED}Empty response received from the server.${NC}&quot;
    return 1
  fi
  
  # Check if the response contains bots
  if [[ $RESPONSE != *&quot;bots&quot;* ]]; then
    echo -e &quot;${RED}Failed to fetch bots. The API server responded but did not return the expected data.${NC}&quot;
    echo -e &quot;${YELLOW}Response received:${NC}&quot;
    echo &quot;$RESPONSE&quot;
    return 1
  fi
  
  echo -e &quot;${GREEN}Successfully fetched bots.${NC}&quot;
  
  # If jq is available, format the output
  if command -v jq &amp;&gt; /dev/null; then
    # Try to parse with jq, but handle errors gracefully
    JQ_OUTPUT=$(echo &quot;$RESPONSE&quot; | jq . 2&gt;&amp;1)
    if [[ $? -ne 0 ]]; then
      echo -e &quot;${RED}Error parsing JSON response:${NC}&quot;
      echo &quot;$JQ_OUTPUT&quot;
      echo -e &quot;${YELLOW}Raw response:${NC}&quot;
      echo &quot;$RESPONSE&quot;
    else
      echo -e &quot;\n${CYAN}Available Bots:${NC}&quot;
      # Try to extract and format bot information
      BOT_FORMAT=$(echo &quot;$RESPONSE&quot; | jq -r &apos;.bots[] | &quot;ID: \(.id)\nName: \(.name)\nDescription: \(.description // &quot;N/A&quot;)\nDeveloper: \(.developer_email // &quot;N/A&quot;)\nActive: \(.is_active)\n&quot;&apos; 2&gt;&amp;1)
      if [[ $? -ne 0 ]]; then
        echo -e &quot;${RED}Error formatting bot information:${NC}&quot;
        echo &quot;$BOT_FORMAT&quot;
        echo -e &quot;${YELLOW}Displaying raw JSON instead:${NC}&quot;
        echo &quot;$JQ_OUTPUT&quot;
      else
        echo &quot;$BOT_FORMAT&quot;
      fi
    fi
  else
    echo &quot;$RESPONSE&quot;
  fi
  
  print_separator
  
  # Return the response
  echo &quot;$RESPONSE&quot;
}

# Function to select a bot by name (simplified version)
select_bot_by_name() {
  echo &quot;Selecting a bot by name...&quot; &gt;&amp;2
  
  # Get the list of bots
  BOTS_RESPONSE=$(curl -s -X GET -H &quot;Accept: application/json&quot; $API_URL/api/bots)
  
  # Check if the response is empty
  if [[ -z &quot;$BOTS_RESPONSE&quot; ]]; then
    echo &quot;Empty response received from the server.&quot; &gt;&amp;2
    return 1
  fi
  
  # Check if the response contains bots
  if [[ $BOTS_RESPONSE != *&quot;bots&quot;* ]]; then
    echo &quot;Failed to fetch bots. The API server responded but did not return the expected data.&quot; &gt;&amp;2
    echo &quot;Response received:&quot; &gt;&amp;2
    echo &quot;$BOTS_RESPONSE&quot; &gt;&amp;2
    return 1
  fi
  
  # Extract bot information using jq if available
  if command -v jq &amp;&gt; /dev/null; then
    # Try to parse with jq, but handle errors gracefully
    JQ_TEST=$(echo &quot;$BOTS_RESPONSE&quot; | jq . 2&gt;&amp;1)
    if [[ $? -ne 0 ]]; then
      echo &quot;Error parsing JSON response:&quot; &gt;&amp;2
      echo &quot;$JQ_TEST&quot; &gt;&amp;2
      echo &quot;Raw response:&quot; &gt;&amp;2
      echo &quot;$BOTS_RESPONSE&quot; &gt;&amp;2
      return 1
    fi
    
    # Get the number of bots
    BOT_COUNT=$(echo &quot;$BOTS_RESPONSE&quot; | jq &apos;.bots | length&apos; 2&gt;/dev/null)
    if [[ $? -ne 0 || -z &quot;$BOT_COUNT&quot; ]]; then
      echo &quot;Error getting bot count from JSON.&quot; &gt;&amp;2
      return 1
    fi
    
    if [[ $BOT_COUNT -eq 0 ]]; then
      echo &quot;No bots found in the system.&quot; &gt;&amp;2
      return 1
    fi
    
    # Display a list of bots with numbers
    echo &quot;Available bots:&quot; &gt;&amp;2
    echo &quot;-------------------------------------&quot; &gt;&amp;2
    echo &quot;| # | Name | Description | Developer |&quot; &gt;&amp;2
    echo &quot;-------------------------------------&quot; &gt;&amp;2
    
    # Extract and display bot information
    for i in $(seq 0 $(($BOT_COUNT-1))); do
      BOT_NAME=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$i].name&quot; 2&gt;/dev/null)
      BOT_DESC=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$i].description // \&quot;N/A\&quot;&quot; 2&gt;/dev/null)
      BOT_DEV=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$i].developer_email // \&quot;N/A\&quot;&quot; 2&gt;/dev/null)
      
      # Truncate long descriptions
      if [[ ${#BOT_DESC} -gt 30 ]]; then
        BOT_DESC=&quot;${BOT_DESC:0:27}...&quot;
      fi
      
      echo &quot;| $i | $BOT_NAME | $BOT_DESC | $BOT_DEV |&quot; &gt;&amp;2
    done
    echo &quot;-------------------------------------&quot; &gt;&amp;2
    
    # Ask the user to select a bot by number
    read -p &quot;Enter the number of the bot you want to select (0-$(($BOT_COUNT-1))): &quot; bot_number
    
    # Validate the input
    if ! [[ &quot;$bot_number&quot; =~ ^[0-9]+$ ]] || [[ $bot_number -lt 0 ]] || [[ $bot_number -ge $BOT_COUNT ]]; then
      echo &quot;Invalid selection. Please enter a number between 0 and $(($BOT_COUNT-1)).&quot; &gt;&amp;2
      return 1
    fi
    
    # Get the selected bot&apos;s ID and name
    BOT_ID=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$bot_number].id&quot; 2&gt;/dev/null)
    BOT_NAME=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$bot_number].name&quot; 2&gt;/dev/null)
    
    if [[ -z &quot;$BOT_ID&quot; || -z &quot;$BOT_NAME&quot; ]]; then
      echo &quot;Error extracting bot information from JSON.&quot; &gt;&amp;2
      return 1
    fi
    
    echo &quot;Selected bot: $BOT_NAME (ID: $BOT_ID)&quot; &gt;&amp;2
    
    # Get the bot&apos;s API token (we need to ask for this as it&apos;s not in the public API)
    read -p &quot;Enter API token for bot $BOT_NAME: &quot; BOT_TOKEN
    
    # Return the bot ID and token
    echo &quot;$BOT_ID|$BOT_TOKEN&quot;
  else
    # If jq is not available, display raw JSON and ask for manual input
    echo &quot;jq is not installed. Here&apos;s the raw bot data:&quot; &gt;&amp;2
    echo &quot;$BOTS_RESPONSE&quot; &gt;&amp;2
    
    read -p &quot;Enter bot ID: &quot; BOT_ID
    read -p &quot;Enter bot API token: &quot; BOT_TOKEN
    
    echo &quot;$BOT_ID|$BOT_TOKEN&quot;
  fi
}

# Function to automatically select a bot
auto_select_bot() {
  echo -e &quot;${BLUE}Auto-selecting a bot for testing...${NC}&quot;
  
  # Get the list of bots
  BOTS_RESPONSE=$(curl -s -X GET -H &quot;Accept: application/json&quot; $API_URL/api/bots)
  
  # Check if the response is empty
  if [[ -z &quot;$BOTS_RESPONSE&quot; ]]; then
    echo -e &quot;${RED}Empty response received from the server.${NC}&quot;
    
    # Ask if the user wants to manually enter bot details
    read -p &quot;Would you like to manually enter bot details instead? (y/n): &quot; manual_entry
    if [[ $manual_entry == &quot;y&quot; || $manual_entry == &quot;Y&quot; ]]; then
      read -p &quot;Enter bot ID: &quot; BOT_ID
      read -p &quot;Enter bot API token: &quot; BOT_TOKEN
      echo &quot;$BOT_ID|$BOT_TOKEN&quot;
      return 0
    else
      return 1
    fi
  fi
  
  # Check if the response contains bots
  if [[ $BOTS_RESPONSE != *&quot;bots&quot;* ]]; then
    echo -e &quot;${RED}Failed to fetch bots. The API server responded but did not return the expected data.${NC}&quot;
    echo -e &quot;${YELLOW}Response received:${NC}&quot;
    echo &quot;$BOTS_RESPONSE&quot;
    
    # Ask if the user wants to manually enter bot details
    read -p &quot;Would you like to manually enter bot details instead? (y/n): &quot; manual_entry
    if [[ $manual_entry == &quot;y&quot; || $manual_entry == &quot;Y&quot; ]]; then
      read -p &quot;Enter bot ID: &quot; BOT_ID
      read -p &quot;Enter bot API token: &quot; BOT_TOKEN
      echo &quot;$BOT_ID|$BOT_TOKEN&quot;
      return 0
    else
      return 1
    fi
  fi
  
  # Extract bot information using jq if available
  if command -v jq &amp;&gt; /dev/null; then
    # Try to parse with jq, but handle errors gracefully
    JQ_TEST=$(echo &quot;$BOTS_RESPONSE&quot; | jq . 2&gt;&amp;1)
    if [[ $? -ne 0 ]]; then
      echo -e &quot;${RED}Error parsing JSON response:${NC}&quot;
      echo &quot;$JQ_TEST&quot;
      echo -e &quot;${YELLOW}Raw response:${NC}&quot;
      echo &quot;$BOTS_RESPONSE&quot;
      
      # Ask if the user wants to manually enter bot details
      read -p &quot;Would you like to manually enter bot details instead? (y/n): &quot; manual_entry
      if [[ $manual_entry == &quot;y&quot; || $manual_entry == &quot;Y&quot; ]]; then
        read -p &quot;Enter bot ID: &quot; BOT_ID
        read -p &quot;Enter bot API token: &quot; BOT_TOKEN
        echo &quot;$BOT_ID|$BOT_TOKEN&quot;
        return 0
      else
        return 1
      fi
    fi
    
    # Get the number of bots
    BOT_COUNT=$(echo &quot;$BOTS_RESPONSE&quot; | jq &apos;.bots | length&apos; 2&gt;/dev/null)
    if [[ $? -ne 0 || -z &quot;$BOT_COUNT&quot; ]]; then
      echo -e &quot;${RED}Error getting bot count from JSON.${NC}&quot;
      
      # Ask if the user wants to manually enter bot details
      read -p &quot;Would you like to manually enter bot details instead? (y/n): &quot; manual_entry
      if [[ $manual_entry == &quot;y&quot; || $manual_entry == &quot;Y&quot; ]]; then
        read -p &quot;Enter bot ID: &quot; BOT_ID
        read -p &quot;Enter bot API token: &quot; BOT_TOKEN
        echo &quot;$BOT_ID|$BOT_TOKEN&quot;
        return 0
      else
        return 1
      fi
    fi
    
    if [[ $BOT_COUNT -eq 0 ]]; then
      echo -e &quot;${RED}No bots found in the system.${NC}&quot;
      
      # Ask if the user wants to manually enter bot details
      read -p &quot;Would you like to manually enter bot details instead? (y/n): &quot; manual_entry
      if [[ $manual_entry == &quot;y&quot; || $manual_entry == &quot;Y&quot; ]]; then
        read -p &quot;Enter bot ID: &quot; BOT_ID
        read -p &quot;Enter bot API token: &quot; BOT_TOKEN
        echo &quot;$BOT_ID|$BOT_TOKEN&quot;
        return 0
      else
        return 1
      fi
    fi
    
    # Select a random bot index
    RANDOM_INDEX=$(($RANDOM % $BOT_COUNT))
    
    # Get the bot ID and name
    BOT_ID=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$RANDOM_INDEX].id&quot; 2&gt;/dev/null)
    BOT_NAME=$(echo &quot;$BOTS_RESPONSE&quot; | jq -r &quot;.bots[$RANDOM_INDEX].name&quot; 2&gt;/dev/null)
    
    if [[ -z &quot;$BOT_ID&quot; || -z &quot;$BOT_NAME&quot; ]]; then
      echo -e &quot;${RED}Error extracting bot information from JSON.${NC}&quot;
      
      # Ask if the user wants to manually enter bot details
      read -p &quot;Would you like to manually enter bot details instead? (y/n): &quot; manual_entry
      if [[ $manual_entry == &quot;y&quot; || $manual_entry == &quot;Y&quot; ]]; then
        read -p &quot;Enter bot ID: &quot; BOT_ID
        read -p &quot;Enter bot API token: &quot; BOT_TOKEN
        echo &quot;$BOT_ID|$BOT_TOKEN&quot;
        return 0
      else
        return 1
      fi
    fi
    
    echo -e &quot;${GREEN}Selected bot: $BOT_NAME (ID: $BOT_ID)${NC}&quot;
    
    # Get the bot&apos;s API token (we need to ask for this as it&apos;s not in the public API)
    read -p &quot;Enter API token for bot $BOT_NAME: &quot; BOT_TOKEN
    
    # Return the bot ID and token
    echo &quot;$BOT_ID|$BOT_TOKEN&quot;
  else
    # If jq is not available, ask the user to select a bot
    echo -e &quot;${YELLOW}jq is not installed. Please select a bot manually.${NC}&quot;
    echo &quot;$BOTS_RESPONSE&quot;
    
    read -p &quot;Enter bot ID: &quot; BOT_ID
    read -p &quot;Enter bot API token: &quot; BOT_TOKEN
    
    echo &quot;$BOT_ID|$BOT_TOKEN&quot;
  fi
}

# Create a license
create_license() {
  print_header &quot;Creating a License&quot;
  
  # Check if API is reachable
  if ! check_api_reachable; then
    echo -e &quot;${RED}Cannot proceed with license creation as the API server is not reachable.${NC}&quot;
    return 1
  fi
  
  echo -e &quot;${BLUE}Executing: curl POST to create a license${NC}&quot;
  
  # Create JSON payload directly
  PAYLOAD=$(cat &lt;&lt; EOF
{
  &quot;name&quot;: &quot;Manual Test License&quot;,
  &quot;description&quot;: &quot;Created via manual API test&quot;,
  &quot;is_valid&quot;: true,
  &quot;valid_to&quot;: &quot;2025-12-31&quot;,
  &quot;link&quot;: &quot;https://example.com/manual-test&quot;,
  &quot;contact_email&quot;: &quot;manual-test@example.com&quot;
}
EOF
)
  
  echo -e &quot;${YELLOW}Request URL:${NC} $API_URL/api/manage/licenses&quot;
  echo -e &quot;${YELLOW}Request Headers:${NC}&quot;
  echo &quot;Content-Type: application/json&quot;
  echo &quot;Authorization: Bearer $API_KEY&quot;
  echo -e &quot;${YELLOW}Request Body:${NC}&quot;
  echo &quot;$PAYLOAD&quot;
  echo
  
  # Execute the curl command
  RESPONSE=$(curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d &quot;$PAYLOAD&quot; \
    $API_URL/api/manage/licenses)
    
  # Display the raw response for debugging
  echo -e &quot;${YELLOW}Raw response:${NC}&quot;
  echo &quot;$RESPONSE&quot;
  
  # Check if the response is valid JSON
  if command -v jq &amp;&gt; /dev/null; then
    echo &quot;$RESPONSE&quot; | jq . 2&gt;/dev/null
    if [ $? -eq 0 ]; then
      echo -e &quot;${GREEN}Response is valid JSON${NC}&quot;
    else
      echo -e &quot;${RED}Response is not valid JSON${NC}&quot;
    fi
  fi
  
  print_separator
  echo &quot;If successful, you should see a JSON response with an &apos;id&apos; and &apos;key&apos;.&quot;
  echo &quot;Copy the &apos;id&apos; value for use in the update test.&quot;
  
  # Offer to check the API endpoint URL
  echo
  echo -e &quot;${YELLOW}Troubleshooting:${NC}&quot;
  echo &quot;1. Verify the API URL is correct: $API_URL&quot;
  echo &quot;2. Check that the server is running and accessible&quot;
  echo &quot;3. Ensure the API endpoint path is correct: /api/manage/licenses&quot;
  echo &quot;4. Confirm the API key is valid and properly configured in the server&quot;
}

# Update a license
update_license() {
  print_header &quot;Updating a License&quot;
  
  # Check if API is reachable
  if ! check_api_reachable; then
    echo -e &quot;${RED}Cannot proceed with license update as the API server is not reachable.${NC}&quot;
    return 1
  fi
  
  read -p &quot;Enter the license ID to update: &quot; license_id
  
  echo -e &quot;${BLUE}Executing: curl PUT to update license $license_id${NC}&quot;
  
  # Create JSON payload directly
  PAYLOAD=$(cat &lt;&lt; EOF
{
  &quot;is_valid&quot;: false,
  &quot;valid_to&quot;: &quot;2026-06-30&quot;
}
EOF
)
  
  echo -e &quot;${YELLOW}Request URL:${NC} $API_URL/api/manage/licenses/$license_id&quot;
  echo -e &quot;${YELLOW}Request Headers:${NC}&quot;
  echo &quot;Content-Type: application/json&quot;
  echo &quot;Authorization: Bearer $API_KEY&quot;
  echo -e &quot;${YELLOW}Request Body:${NC}&quot;
  echo &quot;$PAYLOAD&quot;
  echo
  
  # Execute the curl command
  RESPONSE=$(curl -s -X PUT \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d &quot;$PAYLOAD&quot; \
    $API_URL/api/manage/licenses/$license_id)
    
  # Display the raw response for debugging
  echo -e &quot;${YELLOW}Raw response:${NC}&quot;
  echo &quot;$RESPONSE&quot;
  
  # Check if the response is valid JSON
  if command -v jq &amp;&gt; /dev/null; then
    echo &quot;$RESPONSE&quot; | jq . 2&gt;/dev/null
    if [ $? -eq 0 ]; then
      echo -e &quot;${GREEN}Response is valid JSON${NC}&quot;
    else
      echo -e &quot;${RED}Response is not valid JSON${NC}&quot;
    fi
  fi
  
  print_separator
  echo &quot;If successful, you should see a JSON response with the updated license details.&quot;
}

# Test with invalid authentication
test_invalid_auth() {
  print_header &quot;Testing Invalid Authentication&quot;
  
  # Check if API is reachable
  if ! check_api_reachable; then
    echo -e &quot;${RED}Cannot proceed with authentication test as the API server is not reachable.${NC}&quot;
    return 1
  fi
  
  echo -e &quot;${BLUE}Executing: curl POST with invalid API key${NC}&quot;
  
  # Create JSON payload directly
  PAYLOAD=$(cat &lt;&lt; EOF
{
  &quot;name&quot;: &quot;Test License&quot;,
  &quot;link&quot;: &quot;https://example.com/test&quot;
}
EOF
)
  
  echo -e &quot;${YELLOW}Request URL:${NC} $API_URL/api/manage/licenses&quot;
  echo -e &quot;${YELLOW}Request Headers:${NC}&quot;
  echo &quot;Content-Type: application/json&quot;
  echo &quot;Authorization: Bearer invalid_key&quot;
  echo -e &quot;${YELLOW}Request Body:${NC}&quot;
  echo &quot;$PAYLOAD&quot;
  echo
  
  # Execute the curl command
  RESPONSE=$(curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer invalid_key&quot; \
    -d &quot;$PAYLOAD&quot; \
    $API_URL/api/manage/licenses)
    
  # Display the raw response for debugging
  echo -e &quot;${YELLOW}Raw response:${NC}&quot;
  echo &quot;$RESPONSE&quot;
  
  print_separator
  echo &quot;You should see an error message about invalid or missing API key.&quot;
}

# Test missing required fields
test_missing_fields() {
  print_header &quot;Testing Missing Required Fields&quot;
  
  # Check if API is reachable
  if ! check_api_reachable; then
    echo -e &quot;${RED}Cannot proceed with missing fields test as the API server is not reachable.${NC}&quot;
    return 1
  fi
  
  echo -e &quot;${BLUE}Executing: curl POST with missing required fields${NC}&quot;
  
  # Create JSON payload directly
  PAYLOAD=$(cat &lt;&lt; EOF
{
  &quot;description&quot;: &quot;Missing required fields&quot;
}
EOF
)
  
  echo -e &quot;${YELLOW}Request URL:${NC} $API_URL/api/manage/licenses&quot;
  echo -e &quot;${YELLOW}Request Headers:${NC}&quot;
  echo &quot;Content-Type: application/json&quot;
  echo &quot;Authorization: Bearer $API_KEY&quot;
  echo -e &quot;${YELLOW}Request Body:${NC}&quot;
  echo &quot;$PAYLOAD&quot;
  echo
  
  # Execute the curl command
  RESPONSE=$(curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d &quot;$PAYLOAD&quot; \
    $API_URL/api/manage/licenses)
    
  # Display the raw response for debugging
  echo -e &quot;${YELLOW}Raw response:${NC}&quot;
  echo &quot;$RESPONSE&quot;
  
  print_separator
  echo &quot;You should see an error message about missing required fields.&quot;
}

# Test license validation
test_validate_license() {
  print_header &quot;Testing License Validation&quot;
  
  # Check if API is reachable
  if ! check_api_reachable; then
    echo -e &quot;${RED}Cannot proceed with license validation as the API server is not reachable.${NC}&quot;
    return 1
  fi
  
  read -p &quot;Enter the license key to validate: &quot; license_key
  
  echo -e &quot;${BLUE}Executing: curl GET to validate license${NC}&quot;
  
  echo -e &quot;${YELLOW}Request URL:${NC} $API_URL/api/license/validate&quot;
  echo -e &quot;${YELLOW}Request Headers:${NC}&quot;
  echo &quot;Authorization: Bearer $license_key&quot;
  echo &quot;Accept: application/json&quot;
  echo
  
  # Execute the curl command with verbose output
  RESPONSE=$(curl -s -X GET \
    -H &quot;Accept: application/json&quot; \
    -H &quot;Authorization: Bearer $license_key&quot; \
    $API_URL/api/license/validate)
    
  # Display the raw response for debugging
  echo -e &quot;${YELLOW}Raw response:${NC}&quot;
  echo &quot;$RESPONSE&quot;
  
  # Check if the response is valid JSON
  if command -v jq &amp;&gt; /dev/null; then
    echo &quot;$RESPONSE&quot; | jq . 2&gt;/dev/null
    if [ $? -eq 0 ]; then
      echo -e &quot;${GREEN}Response is valid JSON${NC}&quot;
    else
      echo -e &quot;${RED}Response is not valid JSON${NC}&quot;
    fi
  fi
  
  print_separator
  echo &quot;If successful, you should see a JSON response with:&quot;
  echo &quot;- &apos;license_valid&apos; (boolean)&quot;
  echo &quot;- &apos;valid_to&apos; (date)&quot;
  echo &quot;- &apos;license_id&apos; (UUID)&quot;
  echo &quot;- &apos;license_name&apos; (string)&quot;
  echo &quot;- &apos;bots&apos; (array of associated bots with their details)&quot;
  echo
  echo &quot;If the license key is invalid, you&apos;ll see an error message.&quot;
}

# Check API server status
check_api_status() {
  print_header &quot;Checking API Server Status&quot;
  
  echo -e &quot;${BLUE}Executing: curl GET to check API server status${NC}&quot;
  
  # Execute the curl command with a timeout
  RESPONSE=$(curl -s --connect-timeout 5 --max-time 10 -X GET \
    -H &quot;Accept: application/json&quot; \
    $API_URL)
  
  # Check if we got a response
  if [ $? -ne 0 ]; then
    echo -e &quot;${RED}Failed to connect to the API server at $API_URL${NC}&quot;
    echo -e &quot;${YELLOW}Troubleshooting suggestions:${NC}&quot;
    echo &quot;1. Verify the API URL is correct: $API_URL&quot;
    echo &quot;2. Check that the server is running&quot;
    echo &quot;3. Check for network connectivity issues&quot;
    echo &quot;4. Try changing the port if needed (currently using port $(echo $API_URL | grep -oP &apos;(?&lt;=:)\d+&apos;))&quot;
    
    # Ask if the user wants to change the API URL
    read -p &quot;Would you like to change the API URL? (y/n): &quot; change_url
    if [[ $change_url == &quot;y&quot; || $change_url == &quot;Y&quot; ]]; then
      read -p &quot;Enter new API URL (e.g., http://localhost:4000): &quot; new_url
      if [[ -n &quot;$new_url&quot; ]]; then
        API_URL=&quot;$new_url&quot;
        echo -e &quot;${BLUE}API URL updated to: $API_URL${NC}&quot;
        # Try again with the new URL
        check_api_status
        return
      fi
    fi
    
    return 1
  fi
  
  echo -e &quot;${GREEN}API server responded.${NC}&quot;
  echo &quot;Response: $RESPONSE&quot;
  
  print_separator
  
  # Also check the public API endpoint
  echo -e &quot;\n${BLUE}Checking public API endpoint:${NC}&quot;
  BOTS_RESPONSE=$(curl -s --connect-timeout 5 --max-time 10 -X GET \
    -H &quot;Accept: application/json&quot; \
    $API_URL/api/bots)
  
  # Check if we got a response
  if [ $? -ne 0 ]; then
    echo -e &quot;${RED}Failed to connect to the bots endpoint at $API_URL/api/bots${NC}&quot;
    return 1
  fi
  
  # Check if the response contains bots
  if [[ $BOTS_RESPONSE == *&quot;bots&quot;* ]]; then
    echo -e &quot;${GREEN}Successfully connected to the bots endpoint.${NC}&quot;
    
    # If jq is available, format the output
    if command -v jq &amp;&gt; /dev/null; then
      echo $BOTS_RESPONSE | jq .
    else
      echo $BOTS_RESPONSE
    fi
  else
    echo -e &quot;${RED}Connected to the bots endpoint, but did not receive the expected data.${NC}&quot;
    echo &quot;Response: $BOTS_RESPONSE&quot;
  fi
  
  print_separator
  echo &quot;This test helps verify if the API server is running and accessible.&quot;
}

# Function to validate a bot (completely rewritten)
validate_bot() {
  # Get bot ID and API token
  BOT_ID=&quot;$1&quot;
  API_TOKEN=&quot;$2&quot;
  
  echo &quot;Validating bot with ID: $BOT_ID&quot;
  
  # Create JSON payload without any color codes or formatting
  # Make sure to properly escape quotes and use a simple string
  JSON_PAYLOAD=&quot;{\&quot;id\&quot;:\&quot;$BOT_ID\&quot;,\&quot;api_token\&quot;:\&quot;$API_TOKEN\&quot;}&quot;
  
  # Show the request details
  echo &quot;Request URL: $API_URL/api/validate_bot&quot;
  echo &quot;Request Headers:&quot;
  echo &quot;Content-Type: application/json&quot;
  echo &quot;Accept: application/json&quot;
  echo &quot;Request Body:&quot;
  echo &quot;$JSON_PAYLOAD&quot;
  
  # Execute the curl command with the plain JSON payload
  RESPONSE=$(curl -s --connect-timeout 5 --max-time 10 -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Accept: application/json&quot; \
    -H &quot;User-Agent: TrafficGenerator/1.0&quot; \
    -d &quot;$JSON_PAYLOAD&quot; \
    $API_URL/api/validate_bot)
  
  # Check if the request was successful
  if [ $? -ne 0 ]; then
    echo &quot; Request failed - could not connect to the server&quot;
    return 1
  fi
  
  # Check if the response is empty
  if [[ -z &quot;$RESPONSE&quot; ]]; then
    echo &quot; Empty response received&quot;
    return 1
  fi
  
  # Display the raw response for debugging
  echo &quot;Raw response:&quot;
  echo &quot;$RESPONSE&quot;
  
  # Check response
  if [[ $RESPONSE == *&quot;valid\&quot;:true&quot;* || $RESPONSE == *&quot;\&quot;valid\&quot;: true&quot;* ]]; then
    echo &quot; Validation successful&quot;
    return 0
  else
    echo &quot; Validation failed&quot;
    return 1
  fi
}

# Test bot validation
test_validate_bot() {
  print_header &quot;Testing Bot Validation&quot;
  
  # Check if API is reachable
  if ! check_api_reachable; then
    echo &quot;Cannot proceed with bot validation as the API server is not reachable.&quot;
    return 1
  fi
  
  # Present options for bot selection
  echo &quot;How would you like to select a bot?&quot;
  echo &quot;1. Select a bot by name&quot;
  echo &quot;2. Enter bot details manually&quot;
  read -p &quot;Enter your choice (1-2): &quot; selection_method
  
  case $selection_method in
    1)
      # Select a bot by name
      BOT_INFO=$(select_bot_by_name)
      
      # Check if selection was successful
      if [[ $? -ne 0 ]]; then
        echo &quot;Failed to select a bot by name. Please enter details manually.&quot;
        read -p &quot;Enter a bot ID to validate: &quot; bot_id
        read -p &quot;Enter the bot&apos;s API token: &quot; api_token
      else
        # Split the bot info
        IFS=&apos;|&apos; read -r bot_id api_token &lt;&lt;&lt; &quot;$BOT_INFO&quot;
      fi
      ;;
    2)
      # Manual entry
      read -p &quot;Enter a bot ID to validate: &quot; bot_id
      read -p &quot;Enter the bot&apos;s API token: &quot; api_token
      ;;
    *)
      echo &quot;Invalid choice. Defaulting to manual entry.&quot;
      read -p &quot;Enter a bot ID to validate: &quot; bot_id
      read -p &quot;Enter the bot&apos;s API token: &quot; api_token
      ;;
  esac
  
  echo &quot;Testing validation for bot ID: $bot_id&quot;
  
  # Validate the bot
  validate_bot &quot;$bot_id&quot; &quot;$api_token&quot;
  
  print_separator
  echo &quot;This test helps verify if a bot can be validated with the provided credentials.&quot;
}

# Generate artificial traffic for analytics testing
generate_traffic() {
  print_header &quot;Generating Artificial Traffic for Analytics Testing&quot;
  
  # Check if API is reachable
  if ! check_api_reachable; then
    echo &quot;Cannot proceed with traffic generation as the API server is not reachable.&quot;
    
    # Ask if the user wants to change the API URL
    read -p &quot;Would you like to change the API URL? (y/n): &quot; change_url
    if [[ $change_url == &quot;y&quot; || $change_url == &quot;Y&quot; ]]; then
      read -p &quot;Enter new API URL (e.g., http://localhost:4000): &quot; new_url
      if [[ -n &quot;$new_url&quot; ]]; then
        API_URL=&quot;$new_url&quot;
        echo &quot;API URL updated to: $API_URL&quot;
        # Try again with the new URL
        generate_traffic
        return
      fi
    fi
    
    # Ask if the user wants to manually enter bot details
    read -p &quot;Would you like to manually enter bot details and continue anyway? (y/n): &quot; manual_entry
    if [[ $manual_entry != &quot;y&quot; &amp;&amp; $manual_entry != &quot;Y&quot; ]]; then
      return 1
    fi
    
    # Manual entry
    read -p &quot;Enter a bot ID to validate: &quot; bot_id
    read -p &quot;Enter the bot&apos;s API token: &quot; api_token
  else
    # Present options for bot selection
    echo &quot;How would you like to select a bot?&quot;
    echo &quot;1. Select a bot by name&quot;
    echo &quot;2. Enter bot details manually&quot;
    read -p &quot;Enter your choice (1-2): &quot; selection_method
    
    case $selection_method in
      1)
        # Select a bot by name
        BOT_INFO=$(select_bot_by_name)
        
        # Check if selection was successful
        if [[ $? -ne 0 ]]; then
          echo &quot;Failed to select a bot by name. Please enter details manually.&quot;
          read -p &quot;Enter a bot ID to validate: &quot; bot_id
          read -p &quot;Enter the bot&apos;s API token: &quot; api_token
        else
          # Split the bot info
          IFS=&apos;|&apos; read -r bot_id api_token &lt;&lt;&lt; &quot;$BOT_INFO&quot;
        fi
        ;;
      2)
        # Manual entry
        read -p &quot;Enter a bot ID to validate: &quot; bot_id
        read -p &quot;Enter the bot&apos;s API token: &quot; api_token
        ;;
      *)
        echo &quot;Invalid choice. Defaulting to manual entry.&quot;
        read -p &quot;Enter a bot ID to validate: &quot; bot_id
        read -p &quot;Enter the bot&apos;s API token: &quot; api_token
        ;;
    esac
  fi
  
  # Verify the bot ID and API token
  echo &quot;Selected bot ID: $bot_id&quot;
  echo &quot;API token: $api_token&quot;
  
  # Test a single validation first to make sure it works
  echo &quot;Testing bot validation before generating traffic...&quot;
  if ! validate_bot &quot;$bot_id&quot; &quot;$api_token&quot;; then
    echo &quot;Bot validation test failed. Please check your bot ID and API token.&quot;
    echo &quot;Would you like to continue with traffic generation anyway?&quot;
    read -p &quot;Continue anyway? (y/n): &quot; continue_anyway
    if [[ $continue_anyway != &quot;y&quot; &amp;&amp; $continue_anyway != &quot;Y&quot; ]]; then
      return 1
    fi
  else
    echo &quot;Bot validation test successful! Proceeding with traffic generation.&quot;
  fi
  
  read -p &quot;How many bot validations would you like to simulate? (default: 10) &quot; num_validations
  num_validations=${num_validations:-10}
  
  echo &quot;Generating $num_validations validation requests for bot $bot_id...&quot;
  
  # Counter for successful validations
  successful_validations=0
  
  for i in $(seq 1 $num_validations); do
    echo &quot;Sending validation request $i of $num_validations&quot;
    
    if validate_bot &quot;$bot_id&quot; &quot;$api_token&quot;; then
      ((successful_validations++))
    fi
    
    # Add a small random delay between requests (0.1 to 1 second)
    sleep $(awk -v min=0.1 -v max=1 &apos;BEGIN{srand(); print min+rand()*(max-min)}&apos;)
  done
  
  print_separator
  echo &quot;Traffic generation complete!&quot;
  echo &quot;Successfully completed $successful_validations out of $num_validations validation requests.&quot;
  echo &quot;You can now check the analytics page at $API_URL/analytics to see the usage data.&quot;
}

# Main menu
main_menu() {
  clear
  echo -e &quot;${YELLOW}WandererLicenses API Manual Test${NC}&quot;
  echo
  echo &quot;1. Create a license&quot;
  echo &quot;2. Update a license&quot;
  echo &quot;3. Test invalid authentication&quot;
  echo &quot;4. Test missing required fields&quot;
  echo &quot;5. Test bot validation&quot;
  echo &quot;6. Test license validation&quot;
  echo &quot;7. Check API server status&quot;
  echo &quot;8. Generate traffic for analytics testing&quot;
  echo &quot;9. Change API URL (current: $API_URL)&quot;
  echo &quot;10. Exit&quot;
  echo
  read -p &quot;Enter your choice (1-10): &quot; choice
  
  case $choice in
    1) create_license; press_enter_to_continue; main_menu ;;
    2) update_license; press_enter_to_continue; main_menu ;;
    3) test_invalid_auth; press_enter_to_continue; main_menu ;;
    4) test_missing_fields; press_enter_to_continue; main_menu ;;
    5) test_validate_bot; press_enter_to_continue; main_menu ;;
    6) test_validate_license; press_enter_to_continue; main_menu ;;
    7) check_api_status; press_enter_to_continue; main_menu ;;
    8) generate_traffic; press_enter_to_continue; main_menu ;;
    9) 
      read -p &quot;Enter new API URL (e.g., http://localhost:4000): &quot; new_url
      if [[ -n &quot;$new_url&quot; ]]; then
        API_URL=&quot;$new_url&quot;
        echo -e &quot;${GREEN}API URL updated to: $API_URL${NC}&quot;
      fi
      press_enter_to_continue
      main_menu 
      ;;
    10) exit 0 ;;
    *) echo &quot;Invalid choice&quot;; press_enter_to_continue; main_menu ;;
  esac
}

# Helper function
press_enter_to_continue() {
  echo
  read -p &quot;Press Enter to continue...&quot;
}

# Start the script
main_menu</file><file path="scripts/test_api.sh">#!/bin/bash

# Test script for WandererLicenses API
# This script tests the license management API endpoints

# Configuration
API_URL=&quot;http://localhost:4000&quot;
API_KEY=&quot;your_api_key_here&quot;  # Replace with your actual API key

# Colors for output
GREEN=&apos;\033[0;32m&apos;
RED=&apos;\033[0;31m&apos;
YELLOW=&apos;\033[0;33m&apos;
NC=&apos;\033[0m&apos; # No Color

# Function to print section headers
print_header() {
  echo -e &quot;\n${YELLOW}==== $1 ====${NC}\n&quot;
}

# Function to print success messages
print_success() {
  echo -e &quot;${GREEN}SUCCESS: $1${NC}&quot;
}

# Function to print error messages
print_error() {
  echo -e &quot;${RED}ERROR: $1${NC}&quot;
}

# Check if jq is installed
if ! command -v jq &amp;&gt; /dev/null; then
  print_error &quot;jq is required but not installed. Please install jq to parse JSON responses.&quot;
  exit 1
fi

# Test creating a license
test_create_license() {
  print_header &quot;Testing Create License API&quot;
  
  # Create a license
  echo &quot;Creating a new license...&quot;
  
  # Create a temporary file for the JSON payload
  PAYLOAD_FILE=$(mktemp)
  cat &gt; $PAYLOAD_FILE &lt;&lt; EOF
{
  &quot;name&quot;: &quot;Test License&quot;,
  &quot;description&quot;: &quot;Created via API for testing&quot;,
  &quot;is_valid&quot;: true,
  &quot;valid_to&quot;: &quot;2025-12-31&quot;,
  &quot;link&quot;: &quot;https://example.com/test&quot;,
  &quot;contact_email&quot;: &quot;test@example.com&quot;
}
EOF
  
  response=$(curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d @$PAYLOAD_FILE \
    &quot;$API_URL/api/manage/licenses&quot;)
  
  # Clean up
  rm $PAYLOAD_FILE
  
  echo &quot;Response: $response&quot;
  
  # Check if the response contains an ID (success)
  if echo &quot;$response&quot; | jq -e &apos;.id&apos; &gt; /dev/null; then
    license_id=$(echo &quot;$response&quot; | jq -r &apos;.id&apos;)
    license_key=$(echo &quot;$response&quot; | jq -r &apos;.key&apos;)
    license_name=$(echo &quot;$response&quot; | jq -r &apos;.name&apos;)
    print_success &quot;License created with ID: $license_id, key: $license_key, name: $license_name&quot;
    echo &quot;$license_id&quot; &gt; /tmp/license_id.txt
    return 0
  else
    error_msg=$(echo &quot;$response&quot; | jq -r &apos;.error // &quot;Unknown error&quot;&apos;)
    print_error &quot;Failed to create license: $error_msg&quot;
    return 1
  fi
}

# Test updating a license
test_update_license() {
  print_header &quot;Testing Update License API&quot;
  
  # Get the license ID from the previous test
  if [ ! -f /tmp/license_id.txt ]; then
    print_error &quot;No license ID found. Run create license test first.&quot;
    return 1
  fi
  
  license_id=$(cat /tmp/license_id.txt)
  echo &quot;Updating license with ID: $license_id&quot;
  
  # Create a temporary file for the JSON payload
  PAYLOAD_FILE=$(mktemp)
  cat &gt; $PAYLOAD_FILE &lt;&lt; EOF
{
  &quot;is_valid&quot;: false,
  &quot;valid_to&quot;: &quot;2026-06-30&quot;
}
EOF
  
  # Update the license
  response=$(curl -s -X PUT \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d @$PAYLOAD_FILE \
    &quot;$API_URL/api/manage/licenses/$license_id&quot;)
  
  # Clean up
  rm $PAYLOAD_FILE
  
  echo &quot;Response: $response&quot;
  
  # Check if the response contains an ID (success)
  if echo &quot;$response&quot; | jq -e &apos;.id&apos; &gt; /dev/null; then
    is_valid=$(echo &quot;$response&quot; | jq -r &apos;.is_valid&apos;)
    valid_to=$(echo &quot;$response&quot; | jq -r &apos;.valid_to&apos;)
    print_success &quot;License updated. is_valid: $is_valid, valid_to: $valid_to&quot;
    return 0
  else
    error_msg=$(echo &quot;$response&quot; | jq -r &apos;.error // &quot;Unknown error&quot;&apos;)
    print_error &quot;Failed to update license: $error_msg&quot;
    return 1
  fi
}

# Test invalid API key
test_invalid_auth() {
  print_header &quot;Testing Invalid Authentication&quot;
  
  # Try to create a license with an invalid API key
  echo &quot;Attempting to create a license with invalid API key...&quot;
  
  # Create a temporary file for the JSON payload
  PAYLOAD_FILE=$(mktemp)
  cat &gt; $PAYLOAD_FILE &lt;&lt; EOF
{
  &quot;name&quot;: &quot;Test License&quot;,
  &quot;link&quot;: &quot;https://example.com/test&quot;
}
EOF
  
  response=$(curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Authorization: Bearer invalid_key&quot; \
    -d @$PAYLOAD_FILE \
    &quot;$API_URL/api/manage/licenses&quot;)
  
  # Clean up
  rm $PAYLOAD_FILE
  
  echo &quot;Response: $response&quot;
  
  # Check if the response contains an error about invalid API key
  if echo &quot;$response&quot; | grep -q &quot;Invalid or missing API key&quot;; then
    print_success &quot;Authentication check working correctly&quot;
    return 0
  else
    print_error &quot;Authentication check failed&quot;
    return 1
  fi
}

# Test missing required fields
test_missing_fields() {
  print_header &quot;Testing Missing Required Fields&quot;
  
  # Try to create a license without required fields
  echo &quot;Attempting to create a license without required fields...&quot;
  
  # Create a temporary file for the JSON payload
  PAYLOAD_FILE=$(mktemp)
  cat &gt; $PAYLOAD_FILE &lt;&lt; EOF
{
  &quot;description&quot;: &quot;Missing required fields&quot;
}
EOF
  
  response=$(curl -s -X POST \
    -H &quot;Content-Type: application/json&quot; \
    -H &quot;Authorization: Bearer $API_KEY&quot; \
    -d @$PAYLOAD_FILE \
    &quot;$API_URL/api/manage/licenses&quot;)
  
  # Clean up
  rm $PAYLOAD_FILE
  
  echo &quot;Response: $response&quot;
  
  # Check if the response contains an error about missing fields
  if echo &quot;$response&quot; | grep -q &quot;Missing required fields&quot;; then
    print_success &quot;Required fields validation working correctly&quot;
    return 0
  else
    print_error &quot;Required fields validation failed&quot;
    return 1
  fi
}

# Run the tests
main() {
  echo &quot;Starting API tests...&quot;
  
  # Replace the placeholder API key with the actual one
  if [ &quot;$API_KEY&quot; = &quot;your_api_key_here&quot; ]; then
    read -p &quot;Enter your API key: &quot; API_KEY
  fi
  
  # Run tests
  test_invalid_auth
  test_missing_fields
  test_create_license
  test_update_license
  
  echo -e &quot;\nAPI tests completed.&quot;
}

# Run the main function
main</file><file path="test/support/conn_case.ex">defmodule WandererLicensesWeb.ConnCase do
  @moduledoc &quot;&quot;&quot;
  This module defines the test case to be used by
  tests that require setting up a connection.

  Such tests rely on `Phoenix.ConnTest` and also
  import other functionality to make it easier
  to build common data structures and query the data layer.

  Finally, if the test case interacts with the database,
  we enable the SQL sandbox, so changes done to the database
  are reverted at the end of every test. If you are using
  PostgreSQL, you can even run database tests asynchronously
  by setting `use WandererLicensesWeb.ConnCase, async: true`, although
  this option is not recommended for other databases.
  &quot;&quot;&quot;

  use ExUnit.CaseTemplate

  using do
    quote do
      # The default endpoint for testing
      @endpoint WandererLicensesWeb.Endpoint

      use WandererLicensesWeb, :verified_routes

      # Import conveniences for testing with connections
      import Plug.Conn
      import Phoenix.ConnTest
      import WandererLicensesWeb.ConnCase
    end
  end

  setup tags do
    WandererLicenses.DataCase.setup_sandbox(tags)
    {:ok, conn: Phoenix.ConnTest.build_conn()}
  end
end</file><file path="test/support/data_case.ex">defmodule WandererLicenses.DataCase do
  @moduledoc &quot;&quot;&quot;
  This module defines the setup for tests requiring
  access to the application&apos;s data layer.

  You may define functions here to be used as helpers in
  your tests.

  Finally, if the test case interacts with the database,
  we enable the SQL sandbox, so changes done to the database
  are reverted at the end of every test. If you are using
  PostgreSQL, you can even run database tests asynchronously
  by setting `use WandererLicenses.DataCase, async: true`, although
  this option is not recommended for other databases.
  &quot;&quot;&quot;

  use ExUnit.CaseTemplate

  using do
    quote do
      alias WandererLicenses.Repo

      import Ecto
      import Ecto.Changeset
      import Ecto.Query
      import WandererLicenses.DataCase
    end
  end

  setup tags do
    WandererLicenses.DataCase.setup_sandbox(tags)
    :ok
  end

  @doc &quot;&quot;&quot;
  Sets up the sandbox based on the test tags.
  &quot;&quot;&quot;
  def setup_sandbox(tags) do
    pid = Ecto.Adapters.SQL.Sandbox.start_owner!(WandererLicenses.Repo, shared: not tags[:async])
    on_exit(fn -&gt; Ecto.Adapters.SQL.Sandbox.stop_owner(pid) end)
  end

  @doc &quot;&quot;&quot;
  A helper that transforms changeset errors into a map of messages.

      assert {:error, changeset} = Accounts.create_user(%{password: &quot;short&quot;})
      assert &quot;password is too short&quot; in errors_on(changeset).password
      assert %{password: [&quot;password is too short&quot;]} = errors_on(changeset)

  &quot;&quot;&quot;
  def errors_on(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {message, opts} -&gt;
      Regex.replace(~r&quot;%{(\w+)}&quot;, message, fn _, key -&gt;
        opts |&gt; Keyword.get(String.to_existing_atom(key), key) |&gt; to_string()
      end)
    end)
  end
end</file><file path="test/wanderer_licenses_web/controllers/error_html_test.exs">defmodule WandererLicensesWeb.ErrorHTMLTest do
  use WandererLicensesWeb.ConnCase, async: true

  # Bring render_to_string/4 for testing custom views
  import Phoenix.Template

  test &quot;renders 404.html&quot; do
    assert render_to_string(WandererLicensesWeb.ErrorHTML, &quot;404&quot;, &quot;html&quot;, []) == &quot;Not Found&quot;
  end

  test &quot;renders 500.html&quot; do
    assert render_to_string(WandererLicensesWeb.ErrorHTML, &quot;500&quot;, &quot;html&quot;, []) ==
             &quot;Internal Server Error&quot;
  end
end</file><file path="test/wanderer_licenses_web/controllers/error_json_test.exs">defmodule WandererLicensesWeb.ErrorJSONTest do
  use WandererLicensesWeb.ConnCase, async: true

  test &quot;renders 404&quot; do
    assert WandererLicensesWeb.ErrorJSON.render(&quot;404.json&quot;, %{}) == %{
             errors: %{detail: &quot;Not Found&quot;}
           }
  end

  test &quot;renders 500&quot; do
    assert WandererLicensesWeb.ErrorJSON.render(&quot;500.json&quot;, %{}) ==
             %{errors: %{detail: &quot;Internal Server Error&quot;}}
  end
end</file><file path="test/wanderer_licenses_web/controllers/page_controller_test.exs">defmodule WandererLicensesWeb.PageControllerTest do
  use WandererLicensesWeb.ConnCase

  test &quot;GET /&quot;, %{conn: conn} do
    conn = get(conn, ~p&quot;/&quot;)
    assert html_response(conn, 200) =~ &quot;Wanderer Licenses&quot;
  end
end</file><file path="test/wanderer_licenses_web/plugs/api_key_auth_simple_test.exs">defmodule WandererLicensesWeb.Plugs.ApiKeyAuthSimpleTest do
  use ExUnit.Case
  use Plug.Test
  
  alias WandererLicensesWeb.Plugs.ApiKeyAuth

  test &quot;ApiKeyAuth plug functionality&quot; do
    # Set a test API key in the application environment
    test_api_key = &quot;test_api_key_for_testing&quot;
    Application.put_env(:wanderer_licenses, :api_auth, [key: test_api_key])

    # Create a test connection
    conn = conn(:get, &quot;/api/test&quot;)
    
    # Test with valid API key
    conn_with_valid_key = 
      conn
      |&gt; put_req_header(&quot;authorization&quot;, &quot;Bearer #{test_api_key}&quot;)
      |&gt; ApiKeyAuth.call(%{})
    
    refute conn_with_valid_key.halted
    
    # Test with invalid API key
    conn_with_invalid_key = 
      conn
      |&gt; put_req_header(&quot;authorization&quot;, &quot;Bearer invalid_key&quot;)
      |&gt; ApiKeyAuth.call(%{})
    
    assert conn_with_invalid_key.halted
    assert conn_with_invalid_key.status == 401
    
    # Clean up
    Application.put_env(:wanderer_licenses, :api_auth, [key: nil])
  end
end</file><file path="test/wanderer_licenses_web/plugs/api_key_auth_test.exs">defmodule WandererLicensesWeb.Plugs.ApiKeyAuthTest do
  use ExUnit.Case, async: true
  use Plug.Test
  
  alias WandererLicensesWeb.Plugs.ApiKeyAuth

  describe &quot;ApiKeyAuth plug&quot; do
    setup do
      # Set a test API key in the application environment
      test_api_key = &quot;test_api_key_for_testing&quot;
      Application.put_env(:wanderer_licenses, :api_auth, [key: test_api_key])

      on_exit(fn -&gt;
        # Clean up after tests
        Application.put_env(:wanderer_licenses, :api_auth, [key: nil])
      end)

      # Create a test connection
      conn = conn(:get, &quot;/api/test&quot;)
      
      %{conn: conn, api_key: test_api_key}
    end

    test &quot;allows requests with valid API key&quot;, %{conn: conn, api_key: api_key} do
      # Create a connection with a valid Authorization header
      conn = 
        conn
        |&gt; put_req_header(&quot;authorization&quot;, &quot;Bearer #{api_key}&quot;)
        |&gt; ApiKeyAuth.call(%{})

      # The connection should pass through without being halted
      refute conn.halted
    end

    test &quot;rejects requests with invalid API key&quot;, %{conn: conn} do
      # Create a connection with an invalid Authorization header
      conn = 
        conn
        |&gt; put_req_header(&quot;authorization&quot;, &quot;Bearer invalid_key&quot;)
        |&gt; ApiKeyAuth.call(%{})

      # The connection should be halted with a 401 status
      assert conn.halted
      assert conn.status == 401
      assert Jason.decode!(conn.resp_body) == %{&quot;error&quot; =&gt; &quot;Invalid or missing API key&quot;}
    end

    test &quot;rejects requests with missing Authorization header&quot;, %{conn: conn} do
      # Create a connection without an Authorization header
      conn = ApiKeyAuth.call(conn, %{})

      # The connection should be halted with a 401 status
      assert conn.halted
      assert conn.status == 401
      assert Jason.decode!(conn.resp_body) == %{&quot;error&quot; =&gt; &quot;Invalid or missing API key&quot;}
    end

    test &quot;rejects requests with malformed Authorization header&quot;, %{conn: conn} do
      # Create a connection with a malformed Authorization header
      conn = 
        conn
        |&gt; put_req_header(&quot;authorization&quot;, &quot;NotBearer some_token&quot;)
        |&gt; ApiKeyAuth.call(%{})

      # The connection should be halted with a 401 status
      assert conn.halted
      assert conn.status == 401
      assert Jason.decode!(conn.resp_body) == %{&quot;error&quot; =&gt; &quot;Invalid or missing API key&quot;}
    end

    test &quot;handles case when API key is not configured&quot;, %{conn: conn, api_key: api_key} do
      # Temporarily remove the API key from the application environment
      Application.put_env(:wanderer_licenses, :api_auth, [key: nil])

      # Even with a valid token format, it should fail if no API key is configured
      conn = 
        conn
        |&gt; put_req_header(&quot;authorization&quot;, &quot;Bearer #{api_key}&quot;)
        |&gt; ApiKeyAuth.call(%{})

      # The connection should be halted with a 401 status
      assert conn.halted
      assert conn.status == 401
      assert Jason.decode!(conn.resp_body) == %{&quot;error&quot; =&gt; &quot;Invalid or missing API key&quot;}
      
      # Restore the API key for other tests
      Application.put_env(:wanderer_licenses, :api_auth, [key: api_key])
    end
  end
end</file><file path="test/test_helper.exs">ExUnit.start()
Ecto.Adapters.SQL.Sandbox.mode(WandererLicenses.Repo, :manual)</file><file path=".dockerignore"># This file excludes paths from the Docker build context.
#
# By default, Docker&apos;s build context includes all files (and folders) in the
# current directory. Even if a file isn&apos;t copied into the container it is still sent to
# the Docker daemon.
#
# There are multiple reasons to exclude files from the build context:
#
# 1. Prevent nested folders from being copied into the container (ex: exclude
#    /assets/node_modules when copying /assets)
# 2. Reduce the size of the build context and improve build time (ex. /build, /deps, /doc)
# 3. Avoid sending files containing sensitive information
#
# More information on using .dockerignore is available here:
# https://docs.docker.com/engine/reference/builder/#dockerignore-file

.dockerignore

# Ignore git, but keep git HEAD and refs to access current commit hash if needed:
#
# $ cat .git/HEAD | awk &apos;{print &quot;.git/&quot;$2}&apos; | xargs cat
# d0b8727759e1e0e7aa3d41707d12376e373d5ecc
.git
!.git/HEAD
!.git/refs

# Common development/test artifacts
/cover/
/doc/
/test/
/tmp/
.elixir_ls

# Mix artifacts
*.ez

# Generated on crash by the VM
erl_crash.dump

# Static artifacts - These should be fetched and built inside the Docker image
/priv/static/assets/
/priv/static/cache_manifest.json</file><file path=".env.example">export WEB_APP_URL=&quot;http://localhost:4444&quot;
export RELEASE_COOKIE=&quot;GFpbnyo6mEI_0T4ZsHH_ESmi1vT1toQ8PTc0vbfg5FIT4Ih-Lh98mw==&quot;
export GIT_SHA=&quot;1111&quot;
export LM_AUTH_KEY=&quot;&lt;openssl rand -base64 32&gt;&quot;</file><file path=".envrc">use flake
source .env</file><file path=".formatter.exs">[
  import_deps: [
    :ash_admin,
    :ash_authentication_phoenix,
    :ash_authentication,
    :ash_postgres,
    :ash,
    :ecto,
    :ecto_sql,
    :phoenix
  ],
  subdirectories: [&quot;priv/*/migrations&quot;],
  plugins: [Spark.Formatter, Phoenix.LiveView.HTMLFormatter],
  inputs: [&quot;*.{heex,ex,exs}&quot;, &quot;{config,lib,test}/**/*.{heex,ex,exs}&quot;, &quot;priv/*/seeds.exs&quot;]
]</file><file path=".gitignore"># Also ignore archive artifacts (built via &quot;mix archive.build&quot;).
*.ez

*.iml

*.key

/.idea/
/node_modules/
/assets/node_modules/
/assets/lib/ui-kit/dist/

# Ignore assets that are produced by build tools.
/priv/static/assets/
/priv/static/icons/
/priv/static/images/
/priv/static/*.js
/priv/static/*.css

.DS_Store
**/.DS_Store

# Temporary files, for example, from tests.
/tmp/


.env
*.local.env

.direnv/
.cache/
.nix-shell/
.lexical/

/_build
/cover
/deps
/doc
/.fetch
erl_crash.dump
*.ez
*.beam
/config/*.secret.exs
.elixir_ls/

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?</file><file path=".gitmessage">&lt;type&gt;(&lt;scope&gt;): &lt;summary&gt;

&lt;Describe the motivation behind this change - explain WHY you are making this change. Wrap all lines
at 100 characters.&gt;

Fixes #&lt;issue number&gt;

#  100 chars 


# Example Commit Messages
# =======================


#  Example: Simple refactor 
# refactor(core): rename refreshDynamicEmbeddedViews to refreshEmbeddedViews
#
# Improve code readability. The original name no longer matches how the function is used.
# 


#  Example: Simple docs change 
# docs: clarify the service limitation in providers.md guide
#
# Fixes #36332
# 


#  Example: A bug fix 
# fix(ngcc): ensure lockfile is removed when `analyzeFn` fails
#
# Previously an error thrown in the `analyzeFn` would cause the ngcc process to exit immediately
# without removing the lockfile, and potentially before the unlocker process had been successfully
# spawned resulting in the lockfile being orphaned and left behind.
#
# Now we catch these errors and remove the lockfile as needed.
# 


#  Example: Breaking change 
# feat(bazel): simplify ng_package by dropping esm5 and fesm5
#
# BREAKING CHANGE: 
#
#
# Fixes #1234
# 



# Commit Message Format
# =============================
#
# The full specification of the Angular Commit Message Format can be found at
# https://github.com/angular/angular/blob/main/CONTRIBUTING.md#commit
#
# The following is an excerpt of the specification with the most commonly needed info.
#
# Each commit message consists of a *header*, a *body*, and a *footer*.
#
# &lt;header&gt;
# &lt;BLANK LINE&gt;
# &lt;body&gt;
# &lt;BLANK LINE&gt;
# &lt;footer&gt;
#
# The header is mandatory.
#
# The body is mandatory for all commits except for those of scope &quot;docs&quot;. When the body is required
# it must be at least 20 characters long.
#
# The footer is optional.
#
# Any line of the commit message cannot be longer than 100 characters.
#
#
# Commit Message Header
# ---------------------
#
# &lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;
#                       
#                        Summary in present tense. Not capitalized. No period at the end.
#          
#           Commit Scope: animations|bazel|benchpress|common|compiler|compiler-cli|core|
#                             elements|forms|http|language-service|localize|platform-browser|
#                             platform-browser-dynamic|platform-server|router|service-worker|
#                             upgrade|zone.js|packaging|changelog|docs-infra|migrations|ngcc|ve|
#                             devtools
#                             https://github.com/angular/angular/blob/main/CONTRIBUTING.md#scope
#   
#    Commit Type: build|ci|docs|feat|fix|perf|refactor|style|test
#                     https://github.com/angular/angular/blob/main/CONTRIBUTING.md#type
#
#
# Commit Message Body
# ---------------------
#
# Just as in the summary, use the imperative, present tense: &quot;fix&quot; not &quot;fixed&quot; nor &quot;fixes&quot;.
#
# Explain the motivation for the change in the commit message body. This commit message should
# explain WHY you are making the change. You can include a comparison of the previous behavior with
# the new behavior in order to illustrate the impact of the change.
#
#
# Commit Message Footer
# ---------------------
#
# The footer can contain information about breaking changes and is also the place to reference
# GitHub issues, Jira tickets, and other PRs that this commit closes or is related to.
#
# ```
# BREAKING CHANGE: &lt;breaking change summary&gt;
# &lt;BLANK LINE&gt;
# &lt;breaking change description + migration instructions&gt;
# &lt;BLANK LINE&gt;
# &lt;BLANK LINE&gt;
# Fixes #&lt;issue number&gt;
# ```
#
# Breaking Change section should start with the phrase &quot;BREAKING CHANGE: &quot; followed by a summary of
# the breaking change, a blank line, and a detailed description of the breaking change that also
# includes migration instructions.
#</file><file path=".igniter.exs"># This is a configuration file for igniter.
# For option documentation, see https://hexdocs.pm/igniter/Igniter.Project.IgniterConfig.html
# To keep it up to date, use `mix igniter.setup`
[
  module_location: :outside_matching_folder,
  extensions: [{Igniter.Extensions.Phoenix, []}],
  deps_location: :last_list_literal,
  source_folders: [&quot;lib&quot;, &quot;test/support&quot;],
  dont_move_files: [~r&quot;lib/mix&quot;]
]</file><file path=".tool-versions">erlang 27
elixir 1.17.2-otp-27
nodejs 18.0.0</file><file path="API.md"># WandererLicenses API Documentation

This document describes the API endpoints for managing licenses and bots.  
All endpoints (except the public bots list) require authentication via a Bearer token.  
For license endpoints, the Bearer token must be a valid license token.  
For bot endpoints, the Bearer token must be a valid bot token.  
For management endpoints, the Bearer token must be the LM_AUTH_KEY.

---

## API Authentication

### Authentication Types

The WandererLicenses API uses different authentication methods depending on the endpoint:

1. **Public Endpoints**: No authentication required
2. **License Endpoints**: Bearer token with a valid license key
3. **Bot Endpoints**: Bearer token with a valid bot API token
4. **Management Endpoints**: Bearer token with the LM_AUTH_KEY

### Management API Authentication (LM_AUTH_KEY)

The management endpoints require a special API key called `LM_AUTH_KEY`. This key is used to authenticate requests to create or update licenses.

#### Setting Up LM_AUTH_KEY

1. **Generate a Secure Key**:

   ```bash
   # Using Elixir
   iex -e &quot;IO.puts(:crypto.strong_rand_bytes(32) |&gt; Base.encode64(padding: false))&quot;

   # Using OpenSSL
   openssl rand -base64 32
   ```

2. **Configure the Environment Variable**:

   - Development: Add to your `.env` file (not tracked in git)

   ```
   LM_AUTH_KEY=your_generated_key
   ```

   - Production: Set in your deployment environment

3. **Using the Key in Requests**:
   ```bash
   curl -X POST http://localhost:4000/api/manage/licenses \
     -H &quot;Authorization: Bearer YOUR_LM_AUTH_KEY&quot; \
     -H &quot;Content-Type: application/json&quot; \
     -d &apos;{&quot;name&quot;: &quot;License Name&quot;, &quot;link&quot;: &quot;https://example.com&quot;}&apos;
   ```

#### Security Best Practices

- Use a strong, randomly generated key
- Keep the key secure and never expose it in client-side code
- Use different keys for different environments
- Limit access to the key to authorized personnel only

---

## License Endpoints

### Validate License

**Endpoint:** `/api/license/validate`  
**Method:** `GET`

**Description:**  
Validates the license token passed as a Bearer token. Returns the license&apos;s validity and expiration date (`valid_to`).

**Request Example:**

```bash
curl -X GET http://localhost:4000/api/license/validate \\
  -H &quot;Authorization: Bearer YOUR_LICENSE_TOKEN&quot; \\
  -H &quot;Accept: application/json&quot;
```

**Successful Response Example (HTTP 200):**

```json
{
  &quot;license_valid&quot;: true,
  &quot;valid_to&quot;: &quot;2025-12-31&quot;
}
```

**Error Response Example (Invalid or missing token, HTTP 401):**

```json
{
  &quot;error&quot;: &quot;Invalid or missing license token&quot;
}
```

---

### List Bots for a License

**Endpoint:** `/api/license/bots`  
**Method:** `GET`

**Description:**  
Returns a list of bots associated with the authenticated license.  
Each bot object includes:

- `id` (UUID)
- `name`
- `description`
- `is_active`

**Request Example:**

```bash
curl -X GET http://localhost:4000/api/license/bots \\
  -H &quot;Authorization: Bearer YOUR_LICENSE_TOKEN&quot; \\
  -H &quot;Accept: application/json&quot;
```

**Successful Response Example (HTTP 200):**

```json
{
  &quot;bots&quot;: [
    {
      &quot;id&quot;: &quot;uuid-1&quot;,
      &quot;name&quot;: &quot;Bot One&quot;,
      &quot;description&quot;: &quot;First bot&quot;,
      &quot;is_active&quot;: true
    },
    {
      &quot;id&quot;: &quot;uuid-2&quot;,
      &quot;name&quot;: &quot;Bot Two&quot;,
      &quot;description&quot;: &quot;Second bot&quot;,
      &quot;is_active&quot;: false
    }
  ]
}
```

**Error Response Example (Invalid or missing token, HTTP 401):**

```json
{
  &quot;error&quot;: &quot;Invalid or missing license token&quot;
}
```

---

## Bot Endpoints

### Public Bots List

**Endpoint:** `/api/bots`  
**Method:** `GET`

**Description:**  
Returns a public list of all bots, including:

- `id`
- `name`
- `description`
- `is_active`

**Request Example:**

```bash
curl -X GET http://localhost:4000/api/bots \\
  -H &quot;Accept: application/json&quot;
```

**Successful Response Example (HTTP 200):**

```json
{
  &quot;bots&quot;: [
    {
      &quot;id&quot;: &quot;uuid-1&quot;,
      &quot;name&quot;: &quot;Bot One&quot;,
      &quot;description&quot;: &quot;First bot&quot;,
      &quot;is_active&quot;: true
    },
    {
      &quot;id&quot;: &quot;uuid-2&quot;,
      &quot;name&quot;: &quot;Bot Two&quot;,
      &quot;description&quot;: &quot;Second bot&quot;,
      &quot;is_active&quot;: false
    }
  ]
}
```

---

### Validate Bot

**Endpoint:** `/api/validate_bot`  
**Method:** `POST`

**Description:**  
Validates a bot by checking if the Bearer token matches the bot&apos;s stored token.  
Requires a JSON payload with either:

- `bot_id` (UUID) or
- `bot_name`

**Request Example Using `bot_id`:**

```bash
curl -X POST http://localhost:4000/api/validate_bot \\
  -H &quot;Authorization: Bearer YOUR_BOT_TOKEN&quot; \\
  -H &quot;Content-Type: application/json&quot; \\
  -d &apos;{&quot;bot_id&quot;: &quot;YOUR_BOT_UUID&quot;}&apos;
```

**Request Example Using `bot_name`:**

```bash
curl -X POST http://localhost:4000/api/validate_bot \\
  -H &quot;Authorization: Bearer YOUR_BOT_TOKEN&quot; \\
  -H &quot;Content-Type: application/json&quot; \\
  -d &apos;{&quot;bot_name&quot;: &quot;Bot One&quot;}&apos;
```

**Successful Response Example (HTTP 200):**

```json
{
  &quot;valid&quot;: true
}
```

**Error Response Examples:**

- _Invalid Bot Token (HTTP 401):_

  ```json
  {
    &quot;valid&quot;: false,
    &quot;error&quot;: &quot;Invalid bot token&quot;
  }
  ```

- _Bot Inactive (HTTP 403):_

  ```json
  {
    &quot;valid&quot;: false,
    &quot;error&quot;: &quot;Bot is inactive&quot;
  }
  ```

- _Bot Not Found (HTTP 404):_

  ```json
  {
    &quot;error&quot;: &quot;Bot not found&quot;
  }
  ```

- _Missing Parameters (HTTP 400):_

  ```json
  {
    &quot;error&quot;: &quot;Missing bearer token or bot identifier (bot_id or bot_name)&quot;
  }
  ```

---

### Bot Info

**Endpoint:** `/api/bot_info`  
**Method:** `GET`

**Description:**  
Returns detailed information for the authenticated bot, including:

- `id`
- `name`
- `description`
- `is_active`
- `licenses`: A list of licenses associated with the bot, each containing:
  - `id`
  - `name`

**Request Example:**

```bash
curl -X GET http://localhost:4000/api/bot_info \\
  -H &quot;Authorization: Bearer YOUR_BOT_TOKEN&quot; \\
  -H &quot;Accept: application/json&quot;
```

**Successful Response Example (HTTP 200):**

```json
{
  &quot;id&quot;: &quot;bot-uuid&quot;,
  &quot;name&quot;: &quot;Bot One&quot;,
  &quot;description&quot;: &quot;Detailed description of Bot One&quot;,
  &quot;is_active&quot;: true,
  &quot;licenses&quot;: [
    {
      &quot;id&quot;: &quot;license-uuid-1&quot;,
      &quot;name&quot;: &quot;License One&quot;
    },
    {
      &quot;id&quot;: &quot;license-uuid-2&quot;,
      &quot;name&quot;: &quot;License Two&quot;
    }
  ]
}
```

**Error Response Example (Invalid or missing token, HTTP 401):**

```json
{
  &quot;error&quot;: &quot;Invalid or missing bot token&quot;
}
```

---

## Management API Endpoints

These endpoints are used for managing licenses programmatically. They require authentication with the LM_AUTH_KEY as a Bearer token.

The LM_AUTH_KEY is a secure API key that should be kept confidential and only used for server-to-server communication. See the [API Authentication](#api-authentication) section for details on generating and configuring this key.

**Authentication Header Format:**

```
Authorization: Bearer YOUR_LM_AUTH_KEY
```

### Create License

**Endpoint:** `/api/manage/licenses`  
**Method:** `POST`  
**Authentication:** Bearer token with LM_AUTH_KEY

**Description:**  
Creates a new license with the provided attributes.

**Request Body:**

```json
{
  &quot;name&quot;: &quot;License Name&quot;,
  &quot;description&quot;: &quot;License Description&quot;,
  &quot;is_valid&quot;: false,
  &quot;valid_to&quot;: &quot;2025-12-31&quot;,
  &quot;link&quot;: &quot;https://example.com&quot;,
  &quot;contact_email&quot;: &quot;contact@example.com&quot;
}
```

**Required Fields:**

- `name`: String
- `link`: String

**Optional Fields:**

- `description`: String
- `is_valid`: Boolean (defaults to false)
- `valid_to`: Date in YYYY-MM-DD format
- `contact_email`: String

**Successful Response Example (HTTP 201):**

```json
{
  &quot;id&quot;: &quot;uuid-1&quot;,
  &quot;name&quot;: &quot;License Name&quot;,
  &quot;description&quot;: &quot;License Description&quot;,
  &quot;is_valid&quot;: false,
  &quot;valid_to&quot;: &quot;2025-12-31&quot;,
  &quot;link&quot;: &quot;https://example.com&quot;,
  &quot;contact_email&quot;: &quot;contact@example.com&quot;,
  &quot;key&quot;: &quot;license-key-uuid&quot;
}
```

**Error Response Examples:**

- _Missing Required Fields (HTTP 400):_

  ```json
  {
    &quot;error&quot;: &quot;Missing required fields: name, link&quot;
  }
  ```

- _Invalid Date Format (HTTP 400):_

  ```json
  {
    &quot;error&quot;: &quot;Invalid date format for valid_to. Use YYYY-MM-DD.&quot;
  }
  ```

- _Creation Failed (HTTP 422):_

  ```json
  {
    &quot;error&quot;: &quot;Failed to create license&quot;,
    &quot;details&quot;: &quot;Error details&quot;
  }
  ```

- _Authentication Failed (HTTP 401):_

  ```json
  {
    &quot;error&quot;: &quot;Invalid or missing API key&quot;
  }
  ```

---

### Update License

**Endpoint:** `/api/manage/licenses/:id`  
**Method:** `PUT`  
**Authentication:** Bearer token with LM_AUTH_KEY

**Description:**  
Updates an existing license with the provided attributes.

**URL Parameters:**

- `id`: UUID of the license to update

**Request Body:**

```json
{
  &quot;is_valid&quot;: true,
  &quot;valid_to&quot;: &quot;2026-12-31&quot;
}
```

**Optional Fields:**

- `is_valid`: Boolean
- `valid_to`: Date in YYYY-MM-DD format

**Successful Response Example (HTTP 200):**

```json
{
  &quot;id&quot;: &quot;uuid-1&quot;,
  &quot;name&quot;: &quot;License Name&quot;,
  &quot;description&quot;: &quot;License Description&quot;,
  &quot;is_valid&quot;: true,
  &quot;valid_to&quot;: &quot;2026-12-31&quot;,
  &quot;link&quot;: &quot;https://example.com&quot;,
  &quot;contact_email&quot;: &quot;contact@example.com&quot;
}
```

**Error Response Examples:**

- _License Not Found (HTTP 404):_

  ```json
  {
    &quot;error&quot;: &quot;License not found&quot;
  }
  ```

- _Invalid Boolean Value (HTTP 400):_

  ```json
  {
    &quot;error&quot;: &quot;is_valid must be a boolean&quot;
  }
  ```

- _Invalid Date Format (HTTP 400):_

  ```json
  {
    &quot;error&quot;: &quot;Invalid date format for valid_to. Use YYYY-MM-DD.&quot;
  }
  ```

- _Update Failed (HTTP 422):_

  ```json
  {
    &quot;error&quot;: &quot;Failed to update license&quot;,
    &quot;details&quot;: &quot;Error details&quot;
  }
  ```

- _Authentication Failed (HTTP 401):_

  ```json
  {
    &quot;error&quot;: &quot;Invalid or missing API key&quot;
  }
  ```</file><file path="default.nix">with import &lt;nixpkgs&gt; { };
let
  pname = &quot;license-manager&quot;;
  version = &quot;0.0.0&quot;;
  src = ./.; #FIXME once uploaded to repository, change the source
  packages = beam.packagesWith beam.interpreters.erlang_25;
  erlang = beam.interpreters.erlang_25;
  elixir = beam.packages.erlang_25.elixir_1_16;

  mixFodDeps = packages.fetchMixDeps {
    pname = &quot;mix-deps-${pname}&quot;;
    inherit src version elixir;
    hash = &quot;sha256-rILIBMHOHGyCuog8ZtmQAVCiHqn6b7CBrSMNBeSycNM=&quot;;
  };

  # yarnDeps = mkYarnModules {
  #   pname = &quot;${pname}-yarn-deps&quot;;
  #   inherit version;
  #   packageJSON = ./apps/portal_web/assets/package.json;
  #   yarnLock = ./apps/portal_web/assets/yarn.lock;
  #   yarnNix = ./yarn.nix;
  #   preBuild = &apos;&apos;
  #     mkdir -p tmp/deps
  #     cp -r ${mixFodDeps}/phoenix tmp/deps/phoenix
  #     cp -r ${mixFodDeps}/phoenix_html tmp/deps/phoenix_html
  #   &apos;&apos;;
  # };
in
packages.mixRelease {
  inherit pname version src elixir erlang mixFodDeps;

  nativeBuildInputs = [ nodejs ];

  # tportal is an umbrella app
  # override configurePhase to not skip umbrella children
  configurePhase = &apos;&apos;
    runHook preConfigure
    mix deps.compile --no-deps-check
    runHook postConfigure
  &apos;&apos;;

  postBuild = &apos;&apos;
    # for external task you need a workaround for the no deps check flag
    # https://github.com/phoenixframework/phoenix/issues/2690
    mix do deps.loadpaths --no-deps-check, phx.digest
    mix phx.digest --no-deps-check
  &apos;&apos;;
}</file><file path="docker-compose.yml">version: &quot;3&quot;

services:
  db:
    image: arm64v8/postgres:13-alpine
    restart: always
    networks:
      lm-internal:
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: wanderer_licenses
    ports:
      - &quot;5432:5432&quot;
    volumes:
      - db:/var/lib/postgresql/data
    healthcheck:
      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U postgres&quot;]
      interval: 5s
      timeout: 5s
      retries: 5

  license-manager:
    environment:
      PORT: 8000
      DB_HOST: db
      WEB_APP_URL: &quot;http://localhost:8000&quot;
      ERL_AFLAGS: &quot;-kernel shell_history enabled&quot;
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 8000:8000
    volumes:
      - ..:/app:delegated
      - ~/.gitconfig:/root/.gitconfig
      - ~/.gitignore:/root/.gitignore
      - ~/.ssh:/root/.ssh
      - elixir-artifacts:/opt/elixir-artifacts
    restart: always
    command: sh -c &quot;sleep 10 &amp;&amp; /app/entrypoint.sh db createdb &amp;&amp; /app/entrypoint.sh db migrate &amp;&amp; /app/entrypoint.sh run&quot;
    depends_on:
      db:
        condition: service_healthy
    networks:
      lm-internal:
      web:

volumes:
  elixir-artifacts: {}
  db:
    driver: local
  prometheus_data: {}
  grafana_data: {}

networks:
  lm-internal:
    internal: true
  web:
    external: true
    name: web</file><file path="Dockerfile">ARG BUILDER_IMAGE=&quot;wandererltd/build-base:latest&quot;
ARG RUNNER_IMAGE=&quot;wandererltd/runner-base:latest&quot;

FROM ${BUILDER_IMAGE} as builder

RUN apt install -yq curl gnupg
RUN apt --fix-broken install

# prepare build dir
WORKDIR /app

# set build ENV
ENV MIX_ENV=&quot;prod&quot;

# Set ERL_FLAGS for ARM compatibility
ENV ERL_FLAGS=&quot;+JPperf true&quot;

# install mix dependencies
COPY mix.exs mix.lock ./
RUN rm -Rf _build deps &amp;&amp; mix deps.get --only $MIX_ENV
RUN mkdir config

# copy compile-time config files before we compile dependencies
# to ensure any relevant config change will trigger the dependencies
# to be re-compiled.
COPY config/config.exs config/${MIX_ENV}.exs config/

COPY priv priv

COPY lib lib

COPY assets assets

RUN mix compile

RUN mix assets.deploy

# Changes to config/runtime.exs don&apos;t require recompiling the code
COPY config/runtime.exs config/

COPY rel rel
RUN mix release

# start a new build stage so that the final image will only contain
# the compiled release and other runtime necessities
FROM ${RUNNER_IMAGE}

WORKDIR &quot;/app&quot;
COPY --chmod=755 ./rel/docker-entrypoint.sh /app/entrypoint.sh
RUN chown nobody /app

# set runner ENV
ENV MIX_ENV=&quot;prod&quot;

# Only copy the final release from the build stage
COPY --from=builder --chown=nobody:root /app/_build/${MIX_ENV}/rel/wanderer_licenses ./

USER nobody

ENTRYPOINT [&quot;/app/entrypoint.sh&quot;]

CMD [&quot;run&quot;]</file><file path="flake.lock">{
  &quot;nodes&quot;: {
    &quot;flake-utils&quot;: {
      &quot;inputs&quot;: {
        &quot;systems&quot;: &quot;systems&quot;
      },
      &quot;locked&quot;: {
        &quot;lastModified&quot;: 1731533236,
        &quot;narHash&quot;: &quot;sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=&quot;,
        &quot;owner&quot;: &quot;numtide&quot;,
        &quot;repo&quot;: &quot;flake-utils&quot;,
        &quot;rev&quot;: &quot;11707dc2f618dd54ca8739b309ec4fc024de578b&quot;,
        &quot;type&quot;: &quot;github&quot;
      },
      &quot;original&quot;: {
        &quot;owner&quot;: &quot;numtide&quot;,
        &quot;repo&quot;: &quot;flake-utils&quot;,
        &quot;type&quot;: &quot;github&quot;
      }
    },
    &quot;nixpkgs&quot;: {
      &quot;locked&quot;: {
        &quot;lastModified&quot;: 1739863612,
        &quot;narHash&quot;: &quot;sha256-UbtgxplOhFcyjBcNbTVO8+HUHAl/WXFDOb6LvqShiZo=&quot;,
        &quot;owner&quot;: &quot;nixos&quot;,
        &quot;repo&quot;: &quot;nixpkgs&quot;,
        &quot;rev&quot;: &quot;632f04521e847173c54fa72973ec6c39a371211c&quot;,
        &quot;type&quot;: &quot;github&quot;
      },
      &quot;original&quot;: {
        &quot;owner&quot;: &quot;nixos&quot;,
        &quot;ref&quot;: &quot;nixpkgs-unstable&quot;,
        &quot;repo&quot;: &quot;nixpkgs&quot;,
        &quot;type&quot;: &quot;github&quot;
      }
    },
    &quot;root&quot;: {
      &quot;inputs&quot;: {
        &quot;flake-utils&quot;: &quot;flake-utils&quot;,
        &quot;nixpkgs&quot;: &quot;nixpkgs&quot;
      }
    },
    &quot;systems&quot;: {
      &quot;locked&quot;: {
        &quot;lastModified&quot;: 1681028828,
        &quot;narHash&quot;: &quot;sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=&quot;,
        &quot;owner&quot;: &quot;nix-systems&quot;,
        &quot;repo&quot;: &quot;default&quot;,
        &quot;rev&quot;: &quot;da67096a3b9bf56a91d16901293e51ba5b49a27e&quot;,
        &quot;type&quot;: &quot;github&quot;
      },
      &quot;original&quot;: {
        &quot;owner&quot;: &quot;nix-systems&quot;,
        &quot;repo&quot;: &quot;default&quot;,
        &quot;type&quot;: &quot;github&quot;
      }
    }
  },
  &quot;root&quot;: &quot;root&quot;,
  &quot;version&quot;: 7
}</file><file path="flake.nix">{
  description = &quot;Main flake&quot;;

  nixConfig.bash-prompt = &quot;\\e[0;32m[nix-develop@\\h] \\W&gt;\\e[m &quot;;

  inputs = {
    nixpkgs = { url = &quot;github:nixos/nixpkgs/nixpkgs-unstable&quot;; };
    flake-utils = { url = &quot;github:numtide/flake-utils&quot;; };
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        LANG = &quot;C.UTF-8&quot;;
        # LANG= &quot;en_US.UTF-8&quot;;
        root = ./.;
        inherit (pkgs.lib) optional optionals;

        overlay = (final: prev: {
          yarn = prev.yarn.override {
                  nodejs = final.pkgs.nodejs-18_x;
                };
        });

        pkgs = import nixpkgs {
          inherit system;
          overlays = [ overlay ];
        };

        pname = &quot;license-manager&quot;;

        erlang = pkgs.beam.interpreters.erlang_27;
        elixir = pkgs.beam.packages.erlang_27.elixir_1_17;
        elixir-ls = pkgs.beam.packages.erlang_27.elixir_ls;
        packages = pkgs.beam.packagesWith erlang;
        nodejs = pkgs.nodejs-18_x;
        postgresql = pkgs.postgresql_14;
        yarn = pkgs.yarn;

        # This is opinionated instead of simple using:
        # pkgs.beam.packages.erlang.hex;
        hex = packages.hex;
        MIX_PATH = &quot;${hex}/archives/hex-${hex.version}/hex-${hex.version}/ebin&quot;;

        # This is opinionated instead of simple using:
        # pkgs.beam.packages.erlang.rebar3;
        rebar3 = pkgs.beam.packages.erlang_27.rebar3;

        MIX_REBAR3 = &quot;${rebar3}/bin/rebar3&quot;;
      in
      with pkgs;
      {
        devShells.default = pkgs.mkShell {
          inherit LANG MIX_PATH MIX_REBAR3 elixir erlang nodejs yarn;
          # use local HOME to avoid global things
          MIX_HOME = &quot;.cache/mix&quot;;
          HEX_HOME = &quot;.cache/hex&quot;;
          MIX_ENV = &quot;dev&quot;;
          # enable IEx shell history
          ERL_AFLAGS = &quot;-kernel shell_history enabled&quot;;

          shellHook = &apos;&apos;
          # this allows mix to work on the local directory
          if ! test -d .nix-shell; then
            mkdir .nix-shell
          fi

          export NIX_SHELL_DIR=$PWD/.nix-shell
          # Put the PostgreSQL databases in the project directory.
          export PGDATA=$NIX_SHELL_DIR/db
          export MIX_HOME=$NIX_SHELL_DIR/.mix
          export MIX_ARCHIVES=$MIX_HOME/archives
          export HEX_HOME=$NIX_SHELL_DIR/.hex

          export PATH=$MIX_HOME/bin:$PATH
          export PATH=$HEX_HOME/bin:$PATH
          export PATH=$MIX_HOME/escripts:$PATH
          export LIVEBOOK_HOME=$PWD

          # make hex from Nixpkgs available
          # `mix local.hex` will install hex into MIX_HOME and should take precedence
          export LANG=C.UTF-8
          # keep your shell history in iex
          export ERL_AFLAGS=&quot;-kernel shell_history enabled&quot;

          # add your project env vars here, word readable in the nix store.
          # export ENV_VAR=&quot;your_env_var&quot;
          ${elixir}/bin/mix --version
          ${elixir}/bin/iex --version
        &apos;&apos;;

          buildInputs = [
            nodejs
            yarn
            git
            postgresql
            elixir
            elixir_ls
            pgcli
            flyctl
            glibcLocales
            nixpkgs-fmt
            (pkgs.writeShellScriptBin &quot;pg-stop&quot; &apos;&apos;
              pg_ctl -D $PGDATA -U postgres stop
            &apos;&apos;)
            (pkgs.writeShellScriptBin &quot;pg-reset&quot; &apos;&apos;
              rm -rf $PGDATA
            &apos;&apos;)
            (pkgs.writeShellScriptBin &quot;pg-setup&quot; &apos;&apos;
              ####################################################################
              # If database is not initialized (i.e., $PGDATA directory does not
              # exist), then set it up. Seems superfluous given the cleanup step
              # above, but handy when one gets to force reboot the iron.
              ####################################################################
              if ! test -d $PGDATA; then
                ######################################################
                # Init PostgreSQL
                ######################################################
                pg_ctl initdb -D  $PGDATA -o &quot;--no-locale --encoding=UTF8&quot;
                #### initdb --locale=C --encoding=UTF8 --auth-local=peer --auth-host=scram-sha-256 &gt; /dev/null || exit
                # initdb --encoding=UTF8 --no-locale --no-instructions -U postgres
                ######################################################
                # PORT ALREADY IN USE
                ######################################################
                # If another `nix-shell` is  running with a PostgreSQL
                # instance,  the logs  will show  complaints that  the
                # default port 5432  is already in use.  Edit the line
                # below with  a different  port number,  uncomment it,
                # and try again.
                ######################################################
                if [[ &quot;$PGPORT&quot; ]]; then
                  sed -i &quot;s|^#port.*$|port = $PGPORT|&quot; $PGDATA/postgresql.conf
                fi
                echo &quot;listen_addresses = ${&quot;&apos;&quot;}${&quot;&apos;&quot;}&quot; &gt;&gt; $PGDATA/postgresql.conf
                echo &quot;unix_socket_directories = &apos;$PGDATA&apos;&quot; &gt;&gt; $PGDATA/postgresql.conf
                echo &quot;CREATE USER postgres WITH PASSWORD &apos;postgres&apos; CREATEDB SUPERUSER;&quot; | postgres --single -E postgres
              fi
            &apos;&apos;)
            (pkgs.writeShellScriptBin &quot;pg-start&quot; &apos;&apos;
              ## # Postgres Fallback using docker
              ## docker run -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 postgres:14

              [ ! -d $PGDATA ] &amp;&amp; pg-setup

              ####################################################################
              # Start PostgreSQL
              # ==================================================================
              # Setting all  necessary configuration  options via  `pg_ctl` (which
              # is  basically  a wrapper  around  `postgres`)  instead of  editing
              # `postgresql.conf` directly with `sed`. See docs:
              #
              # + https://www.postgresql.org/docs/current/app-pg-ctl.html
              # + https://www.postgresql.org/docs/current/app-postgres.html
              #
              # See more on the caveats at
              # https://discourse.nixos.org/t/how-to-configure-postgresql-declaratively-nixos-and-non-nixos/4063/1
              # but recapping out of paranoia:
              #
              # &gt; use `SHOW`  commands to  check the  options because  `postgres -C`
              # &gt; &quot;_returns values  from postgresql.conf_&quot; (which is  not changed by
              # &gt; supplying  the  configuration options  on  the  command line)  and
              # &gt; &quot;_it does  not reflect  parameters supplied  when the  cluster was
              # &gt; started._&quot;
              #
              # OPTION SUMMARY
              # --------------------------------------------------------------------
              #
              #  + `unix_socket_directories`
              #
              #    &gt; PostgreSQL  will  attempt  to create  a  pidfile  in
              #    &gt; `/run/postgresql` by default, but it will fail as it
              #    &gt; doesn&apos;t exist. By  changing the configuration option
              #    &gt; below, it will get created in $PGDATA.
              #
              #   + `listen_addresses`
              #
              #     &gt; In   tandem  with   edits   in  `pg_hba.conf`   (see
              #     &gt; `HOST_COMMON`  below), it  configures PostgreSQL  to
              #     &gt; allow remote connections (otherwise only `localhost`
              #     &gt; will get  authenticated and the rest  of the traffic
              #     &gt; discarded).
              #     &gt;
              #     &gt; NOTE: the  edit  to  `pga_hba.conf`  needs  to  come
              #     &gt;       **before**  `pg_ctl  start`  (or  the  service
              #     &gt;       needs to be restarted otherwise), because then
              #     &gt;       the changes are not being reloaded.
              #     &gt;
              #     &gt; More info  on setting up and  troubleshooting remote
              #     &gt; PosgreSQL connections (these are  all mirrors of the
              #     &gt; same text; again, paranoia):
              #     &gt;
              #     &gt;   + https://stackoverflow.com/questions/24504680/connect-to-postgres-server-on-google-compute-engine
              #     &gt;   + https://stackoverflow.com/questions/47794979/connecting-to-postgres-server-on-google-compute-engine
              #     &gt;   + https://medium.com/scientific-breakthrough-of-the-afternoon/configure-postgresql-to-allow-remote-connections-af5a1a392a38
              #     &gt;   + https://gist.github.com/toraritte/f8c7fe001365c50294adfe8509080201#file-configure-postgres-to-allow-remote-connection-md
              HOST_COMMON=&quot;host\s\+all\s\+all&quot;
              sed -i &quot;s|^$HOST_COMMON.*127.*$|host all all 0.0.0.0/0 trust|&quot; $PGDATA/pg_hba.conf
              sed -i &quot;s|^$HOST_COMMON.*::1.*$|host all all ::/0 trust|&quot;      $PGDATA/pg_hba.conf
              #  + `log*`
              #
              #    &gt; Setting up basic logging,  to see remote connections
              #    &gt; for example.
              #    &gt;
              #    &gt; See the docs for more:
              #    &gt; https://www.postgresql.org/docs/current/runtime-config-logging.html

              pg_ctl                                                  \
                -D $PGDATA                                            \
                -l $PGDATA/postgres.log                               \
                -o &quot;-c unix_socket_directories=&apos;$PGDATA&apos;&quot;             \
                -o &quot;-c listen_addresses=&apos;*&apos;&quot;                          \
                -o &quot;-c log_destination=&apos;stderr&apos;&quot;                      \
                -o &quot;-c logging_collector=on&quot;                          \
                -o &quot;-c log_directory=&apos;log&apos;&quot;                           \
                -o &quot;-c log_filename=&apos;postgresql-%Y-%m-%d_%H%M%S.log&apos;&quot; \
                -o &quot;-c log_min_messages=info&quot;                         \
                -o &quot;-c log_min_error_statement=info&quot;                  \
                -o &quot;-c log_connections=on&quot;                            \
                start
            &apos;&apos;)
            (pkgs.writeShellScriptBin &quot;pg-console&quot; &apos;&apos;
              psql --host $PGDATA -U postgres
            &apos;&apos;)
          ] ++ optional stdenv.isLinux inotify-tools
            ++ optional stdenv.isDarwin terminal-notifier
            ++ optionals stdenv.isDarwin (with darwin.apple_sdk.frameworks; [
              CoreFoundation
              CoreServices
            ]);

          packages = with pkgs; [ nodejs yarn ];
        };
      });
}</file><file path="LICENSE">MIT License

Copyright (c) 2025 Wanderer Industries

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</file><file path="m">#!/bin/bash

set -e

COMMAND=$1

case $COMMAND in
  e|env)
    export ERL_AFLAGS=&quot;-kernel shell_history enabled&quot;
    ;;
  i|install)
    MIX_ENV=dev mix deps.get
    cd assets &amp;&amp; yarn install
    ;;
  deps)
    MIX_ENV=dev mix deps.get
    ;;
  setup)
    MIX_ENV=dev mix setup
    ;;
  createdb)
    MIX_ENV=dev mix ecto.create
    ;;
  testdb)
    MIX_ENV=dev mix ash.codegen test111
    ;;
  depsf)
    MIX_ENV=dev mix deps.compile syslog --force
    ;;
  d|deploy)
    mix assets.build &amp;&amp; mix assets.deploy
    ;;
  c|cleanup)
    pkill -SIGTERM -f &apos;tailwind&apos; || true
    ;;
  y|yarn)
    cd assets &amp;&amp; yarn
    ;;
  w|watch)
    cd assets &amp;&amp; yarn watch
    ;;
  s|server|start)
    source .env &amp;&amp; MIX_ENV=dev iex -S mix phx.server
    ;;
  m|migrate)
    MIX_ENV=dev mix ash.migrate
    ;;
  r|reset)
    MIX_ENV=dev mix ecto.reset
    ;;
  si|seeds)
    MIX_ENV=dev mix run priv/repo/seeds.exs
    ;;
  f|format)
    mix format
    ;;
  t|test)
    mix test
    ;;
  cover|coverage|co)
    mix test --cover
    ;;
  v|versions)
    echo &quot;Tool Versions&quot;
    cat .tool-versions
    cat Aptfile
    echo
    ;;
  *)
    echo &quot;Usage: $0 {e|env|i|install|dg|deps|depsf|d|deploy|c|cleanup|y|yarn|s|server|start|m|migrate|f|format|t|test|cover|coverage|co|v|versions|watch|seeds}&quot;
    exit 1
    ;;
esac</file><file path="Makefile">.PHONY: deploy install cleanup start yarn migrate format test coverage versions

ROOT_DIR:=$(shell dirname $(realpath $(firstword $(MAKEFILE_LIST))))
SHELL := /bin/bash

evn e:
	export ERL_AFLAGS=&quot;-kernel shell_history enabled&quot;

install i:
	mix deps.get
	cd assets &amp;&amp; yarn install

deploy d:
	mix assets.build &amp;&amp; mix assets.deploy

cleanup c:
	-pkill -SIGTERM -f &apos;tailwind&apos;

yarn y:
	cd assets &amp;&amp; yarn

start server s:
	make cleanup
	source .env &amp;&amp; MIX_ENV=dev iex -S mix phx.server

migrate m:
	MIX_ENV=dev mix ash.migrate

format f:
	mix format

test t:
	mix test

coverage cover co:
	mix test --cover

versions v:
	@echo &quot;Tool Versions&quot;
	@cat .tool-versions
	@cat Aptfile
	@echo</file><file path="mix.exs">defmodule WandererLicenses.MixProject do
  use Mix.Project

  def project do
    [
      app: :wanderer_licenses,
      version: &quot;0.1.0&quot;,
      elixir: &quot;~&gt; 1.14&quot;,
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      consolidate_protocols: Mix.env() != :dev,
      aliases: aliases(),
      deps: deps(),
      releases: [
        wanderer_licenses: [
          include_executables_for: [:unix],
          steps: [:assemble, :tar],
          applications: [
            wanderer_licenses: :permanent
          ],
          version: &quot;0.1.0&quot;
        ]
      ]
    ]
  end

  # Configuration for the OTP application.
  #
  # Type `mix help compile.app` for more information.
  def application do
    [
      mod: {WandererLicenses.Application, []},
      extra_applications: [:logger, :runtime_tools]
    ]
  end

  # Specifies which paths to compile per environment.
  defp elixirc_paths(:test), do: [&quot;lib&quot;, &quot;test/support&quot;]
  defp elixirc_paths(_), do: [&quot;lib&quot;]

  # Specifies your project dependencies.
  #
  # Type `mix help deps` for examples and options.
  defp deps do
    [
      {:prom_ex, &quot;~&gt; 1.11.0&quot;},
      {:picosat_elixir, &quot;~&gt; 0.2&quot;},
      {:ash_admin, &quot;~&gt; 0.13&quot;},
      {:ash_authentication_phoenix, &quot;~&gt; 2.0&quot;},
      {:ash_authentication, &quot;~&gt; 4.0&quot;},
      {:ash_postgres, &quot;~&gt; 2.1&quot;},
      {:ash_phoenix, &quot;~&gt; 2.1.8&quot;},
      {:sourceror, &quot;~&gt; 1.7&quot;, only: [:dev, :test]},
      {:ash, &quot;~&gt; 3.4&quot;},
      {:igniter, &quot;~&gt; 0.5&quot;, only: [:dev, :test]},
      {:phoenix, &quot;~&gt; 1.7.20&quot;},
      {:phoenix_ecto, &quot;~&gt; 4.6.3&quot;},
      {:ecto_sql, &quot;~&gt; 3.12.1&quot;},
      {:postgrex, &quot;&gt;= 0.0.0&quot;},
      {:phoenix_html, &quot;~&gt; 4.2&quot;},
      {:phoenix_live_reload, &quot;~&gt; 1.5.3&quot;, only: :dev},
      {:phoenix_live_view, &quot;~&gt; 1.0.0&quot;},
      {:floki, &quot;&gt;= 0.30.0&quot;, only: :test},
      {:phoenix_live_dashboard, &quot;~&gt; 0.8.3&quot;},
      {:esbuild, &quot;~&gt; 0.8&quot;, runtime: Mix.env() == :dev},
      {:tailwind, &quot;~&gt; 0.2&quot;, runtime: Mix.env() == :dev},
      {:phoenix_html_helpers, &quot;~&gt; 1.0&quot;},
      {:heroicons,
       github: &quot;tailwindlabs/heroicons&quot;,
       tag: &quot;v2.1.1&quot;,
       sparse: &quot;optimized&quot;,
       app: false,
       compile: false,
       depth: 1},
      {:swoosh, &quot;~&gt; 1.5&quot;},
      {:finch, &quot;~&gt; 0.13&quot;},
      {:telemetry_metrics, &quot;~&gt; 1.0&quot;},
      {:telemetry_poller, &quot;~&gt; 1.0&quot;},
      {:gettext, &quot;~&gt; 0.26&quot;},
      {:jason, &quot;~&gt; 1.2&quot;},
      {:dns_cluster, &quot;~&gt; 0.1.1&quot;},
      {:bandit, &quot;~&gt; 1.5&quot;}
    ]
  end

  # Aliases are shortcuts or tasks specific to the current project.
  # For example, to install project dependencies and perform other setup tasks, run:
  #
  #     $ mix setup
  #
  # See the documentation for `Mix` for more info on aliases.
  defp aliases do
    [
      setup: [&quot;deps.get&quot;, &quot;ash.setup&quot;, &quot;assets.setup&quot;, &quot;assets.build&quot;, &quot;run priv/repo/seeds.exs&quot;],
      &quot;ecto.setup&quot;: [&quot;ecto.create&quot;, &quot;ecto.migrate&quot;, &quot;run priv/repo/seeds.exs&quot;],
      &quot;ecto.reset&quot;: [&quot;ecto.drop&quot;, &quot;ecto.setup&quot;],
      test: [&quot;ash.setup --quiet&quot;, &quot;test&quot;],
      &quot;assets.setup&quot;: [&quot;tailwind.install --if-missing&quot;, &quot;esbuild.install --if-missing&quot;],
      &quot;assets.build&quot;: [&quot;tailwind wanderer_licenses&quot;, &quot;esbuild wanderer_licenses&quot;],
      &quot;assets.deploy&quot;: [
        &quot;tailwind wanderer_licenses --minify&quot;,
        &quot;esbuild wanderer_licenses --minify&quot;,
        &quot;phx.digest&quot;
      ],
      &quot;phx.routes&quot;: [&quot;phx.routes&quot;, &quot;ash_authentication.phoenix.routes&quot;]
    ]
  end
end</file><file path="README.md"># WandererLicenses


Wanderer Licenses is a Phoenix-based application designed to manage bots and licenses. It leverages the [Ash framework](https://ash-hq.org/) for resource management and [AshPostgres](https://github.com/ash-project/ash_postgres) for data persistence. The application provides an interactive web interface built with Phoenix LiveView, allowing users to manage bots, licenses, and the associations between them.

## Features

- **Bot Management**
  - Create, update, activate, and deactivate bots.
  - Each bot is assigned a unique API token (generated automatically).
- **License Management**
  - Create, update, enable, and revoke licenses.
  - Manage license properties including validity, expiration date, link, and contact details.
- **Associations**
  - Map bots to licenses using a dedicated join resource.

## Getting Started

### Prerequisites

- [Elixir](https://elixir-lang.org/) and [Erlang](https://www.erlang.org/) installed.
- [Phoenix Framework](https://www.phoenixframework.org/) installed.
- [PostgreSQL](https://www.postgresql.org/) database setup.

### Installation

1. **Clone the Repository**

   ```bash
   git clone https://github.com/yourusername/wanderer_licenses.git
   cd wanderer_licenses
   ```

2. **Install Dependencies**

   ```bash
   mix deps.get
   ```

3. **Setup the Database**

   If you havent already created and migrated the database, run:

   ```bash
   mix ecto.setup
   ```

### Running the Application

Start the Phoenix server with:

```bash
mix phx.server
```

To start your Phoenix server:

  * Run `mix setup` to install and setup dependencies
  * Start Phoenix endpoint with `mix phx.server` or inside IEx with `iex -S mix phx.server`


#### Using .devcontainer

- Run devcontainer
- Install additional dependencies inside Dev container

```
apt update
curl -sL https://deb.nodesource.com/setup_18.x  | bash -
apt-get install nodejs inotify-tools -y
npm install -g yarn
mix setup
```

Now you can visit [`localhost:4000`](http://localhost:4000) from your browser.

## Public API Documentation

The application exposes a public API. For detailed documentation on the API endpoints, please refer to the [API Documentation](./API.md).

## Code Structure

- **Ash Resources**:   
  - *Bots*: Managed through `WandererLicenses.Bots.Bot`, supporting actions like create, update, activate, and deactivate.
  - *Licenses*: Defined in `WandererLicenses.Licenses.License` with actions to create, update, enable, and revoke.
  - *License-Bot Mapping*: Implemented via `WandererLicenses.Licenses.LicenseBot` for associating licenses to bots.

- **Phoenix LiveView**:  
  The LiveViews (e.g., `WandererLicensesWeb.BotLive.Index` and `WandererLicensesWeb.LicenseLive.Index`) provide a seamless, interactive experience. The use of live components for forms (e.g., `BotLive.FormComponent` and `LicenseLive.FormComponent`) promotes reusability and maintainability.</file><file path="repomix.config.json">{
  &quot;output&quot;: {
    &quot;filePath&quot;: &quot;repomix-output.xml&quot;,
    &quot;style&quot;: &quot;xml&quot;,
    &quot;parsableStyle&quot;: true,
    &quot;compress&quot;: false,
    &quot;fileSummary&quot;: true,
    &quot;directoryStructure&quot;: true,
    &quot;removeComments&quot;: false,
    &quot;removeEmptyLines&quot;: false,
    &quot;showLineNumbers&quot;: false,
    &quot;copyToClipboard&quot;: true,
    &quot;topFilesLength&quot;: 5,
    &quot;includeEmptyDirectories&quot;: false
  },
  &quot;include&quot;: [
    &quot;**/*&quot;
  ],
  &quot;ignore&quot;: {
    &quot;useGitignore&quot;: true,
    &quot;useDefaultPatterns&quot;: true,
    &quot;customPatterns&quot;: [
      &quot;additional-folder&quot;,
      &quot;**/*.log&quot;
    ]
  },
  &quot;security&quot;: {
    &quot;enableSecurityCheck&quot;: true
  },
  &quot;tokenCount&quot;: {
    &quot;encoding&quot;: &quot;o200k_base&quot;
  }
}</file></files></repomix>