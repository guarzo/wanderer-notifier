A. Goals
Single Cache Behaviour
All modules use the same interface (get/1, put/3, delete/1).

Pluggable Implementations

Production: backed by Cachex.

Test: in-memory stub.

Built-in TTL & Metrics
Ability to specify key expiry and emit Telemetry.

B. Define the Cache Behaviour
File: lib/wanderer_notifier/cache.ex

elixir
Copy
Edit
defmodule WandererNotifier.Cache do
  @moduledoc """
  Behaviour and interface for application caching.
  """

  @type key   :: any()
  @type value :: any()
  @type ttl   :: non_neg_integer()

  @callback get(key) ::
              {:ok, value} | :not_found | {:error, term()}
  @callback put(key, value, ttl) ::
              :ok | {:error, term()}
  @callback delete(key) ::
              :ok | {:error, term()}
end
C. Provide a Cachex-Backed Implementation
File: lib/wanderer_notifier/cache/cachex_impl.ex

elixir
Copy
Edit
defmodule WandererNotifier.Cache.CachexImpl do
  @behaviour WandererNotifier.Cache

  alias Cachex

  @cache_name :wanderer_cache

  # Ensure cache is started in your supervision tree:
  # {Cachex, name: @cache_name, default_ttl: :timer.hours(1)}

  @impl true
  def get(key) do
    case Cachex.get(@cache_name, key) do
      {:ok, nil} -> :not_found
      {:ok, val} -> {:ok, val}
      error      -> error
    end
  end

  @impl true
  def put(key, value, ttl) do
    # ttl in seconds
    Cachex.put(@cache_name, key, value, ttl: ttl * 1_000)
  end

  @impl true
  def delete(key) do
    Cachex.del(@cache_name, key)
  end
end
Configuration: in config/config.exs:

elixir
Copy
Edit
config :wanderer_notifier, :cache_impl, WandererNotifier.Cache.CachexImpl

# And add to your application children:
{Cachex, name: :wanderer_cache, default_ttl: :timer.hours(1)}
D. Refactor Existing Caches
Replace all modules under lib/wanderer_notifier/data/cache/ and lib/wanderer_notifier/processing/killmail/cache.ex with simple delegations:

elixir
Copy
Edit
defmodule WandererNotifier.Data.Cache.Repository do
  @behaviour WandererNotifier.Cache

  @impl true
  def get(key),    do: impl().get(key)
  def put(k, v, t),do: impl().put(k, v, t)
  def delete(k),   do: impl().delete(k)

  defp impl, do: Application.fetch_env!(:wanderer_notifier, :cache_impl)
end
Update every call:

elixir
Copy
Edit
# old
CacheRepo.get(key)
# new
WandererNotifier.Data.Cache.Repository.get(key)
E. Test Adapter & Usage
File: test/support/cache_mock.ex

elixir
Copy
Edit
defmodule Support.CacheMock do
  @behaviour WandererNotifier.Cache

  def start_link(_) do
    Agent.start_link(fn -> %{} end, name: __MODULE__)
  end

  @impl true
  def get(key) do
    Agent.get(__MODULE__, &Map.get(&1, key, :not_found))
  end

  @impl true
  def put(key, value, _ttl) do
    Agent.update(__MODULE__, &Map.put(&1, key, value))
  end

  @impl true
  def delete(key) do
    Agent.update(__MODULE__, &Map.delete(&1, key))
  end
end
In config/test.exs:

elixir
Copy
Edit
config :wanderer_notifier, :cache_impl, Support.CacheMock

# Ensure the mock agent starts in test
config :wanderer_notifier, WandererNotifier.Application,
  extra_children: [Support.CacheMock]
Example Test:

elixir
Copy
Edit
test "caches and retrieves value" do
  assert :not_found = CacheRepo.get(:foo)
  :ok = CacheRepo.put(:foo, 123, 60)
  assert {:ok, 123} = CacheRepo.get(:foo)
  :ok = CacheRepo.delete(:foo)
  assert :not_found = CacheRepo.get(:foo)
end
F. Add Telemetry Around Cache Operations
(Optional but recommended)

In lib/wanderer_notifier/cache/cachex_impl.ex, wrap calls:

elixir
Copy
Edit
def put(key, val, ttl) do
  :telemetry.execute([:wanderer_notifier, :cache, :put], %{count: 1}, %{key: key, ttl: ttl})
  Cachex.put(@cache_name, key, val, ttl: ttl * 1_000)
end
And similarly for get/delete.

G. Milestones & Checklist

Task	Done
[ ] Create WandererNotifier.Cache behaviour
[ ] Implement CachexImpl and wire in config/*.exs
[ ] Refactor all existing cache modules to delegate
[ ] Provide Support.CacheMock and configure for :test
[ ] Write tests for key modules using CacheMock
[ ] (Optional) Emit Telemetry events on cache ops
[ ] Update documentation (README.md) with caching guide
By following these steps, you’ll have one consistent caching API, easy to swap out implementations, and clear test-only stubs—greatly improving maintainability and reliability.
