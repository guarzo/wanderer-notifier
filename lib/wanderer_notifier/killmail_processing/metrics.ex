defmodule WandererNotifier.KillmailProcessing.Metrics do
  @moduledoc """
  Metrics collection and reporting for killmail processing.
  """

  alias WandererNotifier.KillmailProcessing.Context
  alias WandererNotifier.Logger.Logger, as: AppLogger

  # Agent name for metrics storage
  @agent_name :killmail_metrics_agent

  # Registered metrics that are allowed to be tracked
  @registered_metrics %{
    # Base processing metrics for all modes
    "killmail.processing.realtime.start" => :counter,
    "killmail.processing.historical.start" => :counter,
    "killmail.processing.manual.start" => :counter,
    "killmail.processing.batch.start" => :counter,
    "killmail.processing.unknown.start" => :counter,

    # Complete metrics for all modes with success/error variants
    "killmail.processing.realtime.complete" => :counter,
    "killmail.processing.historical.complete" => :counter,
    "killmail.processing.manual.complete" => :counter,
    "killmail.processing.batch.complete" => :counter,
    "killmail.processing.unknown.complete" => :counter,
    "killmail.processing.realtime.complete.success" => :counter,
    "killmail.processing.historical.complete.success" => :counter,
    "killmail.processing.manual.complete.success" => :counter,
    "killmail.processing.batch.complete.success" => :counter,
    "killmail.processing.unknown.complete.success" => :counter,
    "killmail.processing.realtime.complete.error" => :counter,
    "killmail.processing.historical.complete.error" => :counter,
    "killmail.processing.manual.complete.error" => :counter,
    "killmail.processing.batch.complete.error" => :counter,
    "killmail.processing.unknown.complete.error" => :counter,

    # Skipped metrics for all modes
    "killmail.processing.realtime.skipped" => :counter,
    "killmail.processing.historical.skipped" => :counter,
    "killmail.processing.manual.skipped" => :counter,
    "killmail.processing.batch.skipped" => :counter,
    "killmail.processing.unknown.skipped" => :counter,

    # Error metrics for all modes
    "killmail.processing.realtime.error" => :counter,
    "killmail.processing.historical.error" => :counter,
    "killmail.processing.manual.error" => :counter,
    "killmail.processing.batch.error" => :counter,
    "killmail.processing.unknown.error" => :counter,

    # Persistence metrics for all modes
    "killmail.persistence.realtime" => :counter,
    "killmail.persistence.historical" => :counter,
    "killmail.persistence.manual" => :counter,
    "killmail.persistence.batch" => :counter,
    "killmail.persistence.unknown" => :counter,

    # Notification metrics for all modes
    "killmail.notification.realtime.sent" => :counter,
    "killmail.notification.historical.sent" => :counter,
    "killmail.notification.manual.sent" => :counter,
    "killmail.notification.batch.sent" => :counter,
    "killmail.notification.unknown.sent" => :counter,

    # Combined metrics generated by the MetricRegistry
    "killmail.processing.realtime.persistence" => :counter,
    "killmail.processing.historical.persistence" => :counter,
    "killmail.processing.manual.persistence" => :counter,
    "killmail.processing.batch.persistence" => :counter,
    "killmail.processing.unknown.persistence" => :counter,

    # Special compound metrics that might be generated
    "killmail.processing.realtime.complete.realtime" => :counter,
    "killmail.processing.historical.complete.historical" => :counter,
    "killmail.processing.manual.complete.manual" => :counter,
    "killmail.processing.batch.complete.batch" => :counter,
    "killmail.processing.unknown.complete.unknown" => :counter,

    # Existing combined metrics
    "killmail.processing.realtime.processing.realtime.complete" => :counter,
    "killmail.processing.historical.processing.historical.complete" => :counter,
    "killmail.processing.manual.processing.manual.complete" => :counter,
    "killmail.processing.batch.processing.batch.complete" => :counter,
    "killmail.processing.unknown.processing.unknown.complete" => :counter,
    "killmail.processing.realtime.processing.realtime.complete.success" => :counter,
    "killmail.processing.historical.processing.historical.complete.success" => :counter,
    "killmail.processing.manual.processing.manual.complete.success" => :counter,
    "killmail.processing.batch.processing.batch.complete.success" => :counter,
    "killmail.processing.unknown.processing.unknown.complete.success" => :counter,
    "killmail.processing.realtime.processing.realtime.complete.error" => :counter,
    "killmail.processing.historical.processing.historical.complete.error" => :counter,
    "killmail.processing.manual.processing.manual.complete.error" => :counter,
    "killmail.processing.batch.processing.batch.complete.error" => :counter,
    "killmail.processing.unknown.processing.unknown.complete.error" => :counter,
    "killmail.processing.realtime.notification.realtime.sent" => :counter,
    "killmail.processing.historical.notification.historical.sent" => :counter,
    "killmail.processing.manual.notification.manual.sent" => :counter,
    "killmail.processing.batch.notification.batch.sent" => :counter,
    "killmail.processing.unknown.notification.unknown.sent" => :counter
  }

  @doc """
  Required child_spec implementation for supervisor integration.
  """
  def child_spec(opts) do
    %{
      id: __MODULE__,
      start: {__MODULE__, :start_link, [opts]},
      type: :worker,
      restart: :permanent,
      shutdown: 500
    }
  end

  @doc """
  Initializes the metrics agent.
  Call this during application startup before using any metrics functions.
  """
  def start_link(_opts \\ []) do
    # Initialize the agent with the initial state
    initial_state = %{
      counters: %{},
      timestamp: DateTime.utc_now()
    }

    # Start the agent with a name
    result = Agent.start_link(fn -> initial_state end, name: @agent_name)

    # Synchronize with metric registry
    synchronize_registry()

    result
  end

  @doc """
  Synchronizes the registered metrics with the metric registry to avoid errors.
  """
  def synchronize_registry do
    alias WandererNotifier.KillmailProcessing.MetricRegistry

    # Get all registered metrics from the registry
    registry_metrics = MetricRegistry.registered_metrics()

    # Convert atom metrics to strings
    registry_metric_strings = Enum.map(registry_metrics, &Atom.to_string/1)

    # Find metrics that are in the registry but not in @registered_metrics
    missing_metrics =
      Enum.filter(registry_metric_strings, fn metric_string ->
        !Map.has_key?(@registered_metrics, metric_string)
      end)

    # Log any discrepancies
    if !Enum.empty?(missing_metrics) do
      # More detailed logging with categorized missing metrics
      sample_metrics = Enum.take(missing_metrics, 10)

      # Dump all missing metrics to a file for easier debugging
      File.write!("missing_metrics.txt", Enum.join(missing_metrics, "\n"))

      AppLogger.startup_warn(
        "Found metrics in registry that aren't in @registered_metrics map",
        %{
          count: length(missing_metrics),
          samples: sample_metrics,
          recommendation: "Check missing_metrics.txt file for all missing metrics"
        }
      )

      # Create a dynamic map of missing metrics to complement @registered_metrics
      # This is a runtime workaround since we can't modify @registered_metrics at runtime
      missing_metrics_map = Map.new(missing_metrics, fn key -> {key, :counter} end)

      # Store this in the process dictionary so increment_counter_impl can check it
      Process.put(:dynamic_metrics_extension, missing_metrics_map)
    end

    :ok
  end

  @doc """
  Resets all counters to zero.
  """
  def reset_counters do
    Agent.update(@agent_name, fn state ->
      %{state | counters: %{}, timestamp: DateTime.utc_now()}
    end)
  end

  @doc """
  Gets the current counter values.
  """
  def get_counters do
    Agent.get(@agent_name, fn state -> state.counters end)
  end

  @doc false
  def __registered_metrics_for_debug__ do
    @registered_metrics
  end

  @doc """
  Tracks the start of killmail processing.
  """
  @spec track_processing_start(Context.t()) :: :ok
  def track_processing_start(%Context{} = ctx) do
    metric_key = "killmail.processing.#{mode_name(ctx)}.start"
    increment_counter(metric_key)
    :ok
  end

  @doc """
  Tracks the completion of killmail processing.
  """
  @spec track_processing_complete(Context.t(), {:ok, term()} | {:error, term()}) :: :ok
  def track_processing_complete(%Context{} = ctx, result) do
    mode = mode_name(ctx)
    # Directly use the metric key format that matches our registry
    metric_key = "killmail.processing.#{mode}.complete"

    # # Add more detailed debugging
    # if Mix.env() == :dev do
    #   IO.puts("\nDEBUG: In track_processing_complete with mode='#{mode}'")
    #   IO.puts("DEBUG: Using metric_key='#{metric_key}'")

    #   # Inspect the context for more clues
    #   IO.inspect(ctx, label: "Context")
    #   IO.inspect(result, label: "Result")
    # end

    increment_counter(metric_key)

    case result do
      {:ok, _} ->
        success_key = "killmail.processing.#{mode}.complete.success"
        # if Mix.env() == :dev, do: IO.puts("DEBUG: Success metric='#{success_key}'")
        increment_counter(success_key)

      {:error, _} ->
        error_key = "killmail.processing.#{mode}.complete.error"
        # if Mix.env() == :dev, do: IO.puts("DEBUG: Error metric='#{error_key}'")
        increment_counter(error_key)
    end

    :ok
  end

  @doc """
  Tracks when a killmail is skipped.
  """
  @spec track_processing_skipped(Context.t()) :: :ok
  def track_processing_skipped(%Context{} = ctx) do
    metric_key = "killmail.processing.#{mode_name(ctx)}.skipped"
    increment_counter(metric_key)
    :ok
  end

  @doc """
  Tracks when a killmail processing fails.
  """
  @spec track_processing_error(Context.t()) :: :ok
  def track_processing_error(%Context{} = ctx) do
    metric_key = "killmail.processing.#{mode_name(ctx)}.error"
    increment_counter(metric_key)
    :ok
  end

  @doc """
  Tracks when a killmail is persisted.
  """
  @spec track_persistence(Context.t()) :: :ok
  def track_persistence(%Context{} = ctx), do: track_metric(ctx, "persistence")

  @doc """
  Tracks a notification being sent.
  """
  @spec track_notification_sent(Context.t()) :: :ok
  def track_notification_sent(%Context{} = ctx) do
    metric_key = "killmail.notification.#{mode_name(ctx)}.sent"
    increment_counter(metric_key)
    :ok
  end

  # Private functions

  # Generic function to track metrics with a specific key pattern
  defp track_metric(%Context{} = ctx, operation) do
    # The operation already includes the mode name for operations that have "processing.MODE.complete"
    # Let's special case the processing complete metrics to avoid double mode names
    metric_key =
      if String.contains?(operation, "processing.") do
        # Directly use the operation name since it already has the mode embedded
        "killmail.#{operation}"
      else
        # Normal case - append the mode name
        "killmail.#{operation}.#{mode_name(ctx)}"
      end

    # Debug: Print what we're about to track
    # if Mix.env() == :dev do
    #   IO.puts("TRACKING METRIC: #{metric_key}")
    # end

    increment_counter(metric_key)
    :ok
  end

  defp mode_name(%Context{mode: %{mode: mode}}) when not is_nil(mode), do: Atom.to_string(mode)
  defp mode_name(%Context{mode: mode}) when is_atom(mode), do: Atom.to_string(mode)
  defp mode_name(%Context{mode: mode}) when is_binary(mode), do: mode

  defp mode_name(%Context{}) do
    # Default to batch mode if no mode is specified
    IO.puts("WARNING: No mode specified in Context, defaulting to 'batch'")
    "batch"
  end

  defp mode_name(_), do: "unknown"

  defp increment_counter(key) do
    # Track metrics using Core Stats
    increment_counter_impl(key)
  end

  defp increment_counter_impl(key) when is_binary(key) do
    # For simple string keys, use a default value of 1
    increment_counter_impl({key, 1})
  end

  defp increment_counter_impl({counter, value}) do
    current_value = Agent.get(@agent_name, fn state -> Map.get(state.counters, counter, 0) end)
    new_value = current_value + value

    # Check if metric exists in @registered_metrics or in dynamic extension
    dynamic_metrics = Process.get(:dynamic_metrics_extension, %{})

    is_registered =
      Map.has_key?(@registered_metrics, counter) || Map.has_key?(dynamic_metrics, counter)

    # Always update the counter to avoid data loss
    update_counter(counter, new_value)

    # Log warning if metric is not registered
    unless is_registered do
      maybe_log_unregistered_metric_warning(counter, value)
    end
  rescue
    e ->
      AppLogger.processor_error("Error tracking metric", %{
        counter: counter,
        value: value,
        error: Exception.message(e)
      })
  end

  defp update_counter(counter, new_value) do
    Agent.update(@agent_name, fn state ->
      counters = Map.put(state.counters, counter, new_value)
      %{state | counters: counters}
    end)
  end

  defp maybe_log_unregistered_metric_warning(counter, value) do
    warning_cache_key = {:metric_warning, counter}
    already_warned = Process.get(warning_cache_key, false)

    unless already_warned do
      log_unregistered_metric_warning(counter, value)
      Process.put(warning_cache_key, true)
    end
  end

  defp log_unregistered_metric_warning(counter, value) do
    IO.puts("\n!!! UNREGISTERED METRIC: '#{counter}' !!!\n")

    parts = String.split(counter, ".")
    prefix = Enum.take(parts, 1) |> Enum.join(".")
    mode = if length(parts) > 2, do: Enum.at(parts, 2)
    operation = if length(parts) > 1, do: Enum.at(parts, 1)

    AppLogger.processor_warn("Attempted to track metrics with non-registered key", %{
      counter: counter,
      counter_parts: %{
        prefix: prefix,
        operation: operation,
        mode: mode
      },
      value: value,
      recommendation:
        "Add this key to @registered_metrics in WandererNotifier.KillmailProcessing.Metrics"
    })
  end
end
