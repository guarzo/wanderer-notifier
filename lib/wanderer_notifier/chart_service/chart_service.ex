defmodule WandererNotifier.ChartService do
  @moduledoc """
  Unified service for chart generation and delivery.

  This module provides a centralized interface for all chart-related functionality,
  including configuration, URL generation, and delivery to various platforms.
  It consolidates functionality previously spread across multiple adapters.
  """

  require Logger
  alias WandererNotifier.ChartService.ChartConfig
  alias WandererNotifier.ChartService.ChartTypes
  alias WandererNotifier.Discord.Client, as: DiscordClient

  # Chart service configuration
  @quickchart_url "https://quickchart.io/chart"
  @default_width 800
  @default_height 400
  # Discord dark theme
  @default_background_color "rgb(47, 49, 54)"
  # White text
  @default_text_color "rgb(255, 255, 255)"

  @doc """
  Generates a chart URL from a configuration.

  ## Parameters
    - config: A %ChartConfig{} struct or a map with chart configuration

  ## Returns
    - {:ok, url} on success
    - {:error, reason} on failure
  """
  def generate_chart_url(%ChartConfig{} = config) do
    # Convert the config to a JSON-compatible map
    chart_map = ChartConfig.to_json_map(config)

    # Generate the URL
    do_generate_chart_url(chart_map, config.width, config.height, config.background_color)
  end

  def generate_chart_url(config) when is_map(config) do
    # Try to convert the map to a ChartConfig struct
    case ChartConfig.new(
           config[:type] || config["type"],
           config[:data] || config["data"],
           config[:title] || config["title"],
           config[:options] || config["options"],
           config[:width] || config["width"] || @default_width,
           config[:height] || config["height"] || @default_height,
           config[:background_color] || config["background_color"] || @default_background_color
         ) do
      {:ok, chart_config} -> generate_chart_url(chart_config)
      {:error, reason} -> {:error, reason}
    end
  end

  @doc """
  Creates a "No Data Available" chart with customized message.

  ## Parameters
    - title: Chart title
    - message: Custom message to display (optional)

  ## Returns
    - {:ok, url} with the chart URL
  """
  def create_no_data_chart(title, message \\ "No data available for this chart") do
    # Create a minimalist chart displaying the message
    chart_data = %{
      "labels" => [message],
      "datasets" => [
        %{
          "label" => "",
          "data" => [0],
          "backgroundColor" => "rgba(200, 200, 200, 0.2)",
          "borderColor" => "rgba(200, 200, 200, 0.2)",
          "borderWidth" => 0
        }
      ]
    }

    # Options for a clean, message-focused chart
    options = %{
      "plugins" => %{
        "title" => %{
          "display" => true,
          "text" => title,
          "color" => @default_text_color,
          "font" => %{
            "size" => 18
          }
        },
        "legend" => %{
          "display" => false
        }
      },
      "scales" => %{
        "x" => %{
          "display" => false
        },
        "y" => %{
          "display" => false
        }
      }
    }

    # Create a bar chart (simplest option)
    case ChartConfig.new(ChartTypes.bar(), chart_data, title, options) do
      {:ok, config} -> generate_chart_url(config)
      {:error, reason} -> {:error, reason}
    end
  end

  @doc """
  Sends a chart to Discord as an embed.

  ## Parameters
    - chart_url_or_config: The URL of the chart to send, or a chart configuration
    - title: The embed title
    - description: The embed description (optional)
    - channel_id: The Discord channel ID (optional, uses configured default if not provided)

  ## Returns
    - {:ok, response} on success
    - {:error, reason} on failure
  """
  @spec send_chart_to_discord(
          binary() | map() | ChartConfig.t(),
          binary(),
          binary() | nil,
          binary() | nil
        ) ::
          {:ok, any()} | {:error, any()}
  def send_chart_to_discord(chart_url, title, description \\ nil, channel_id \\ nil)

  def send_chart_to_discord(chart_url, title, description, channel_id)
      when is_binary(chart_url) do
    Logger.info("Sending chart to Discord: #{title}")

    # Create the embed for the chart
    embed = %{
      title: title,
      description: description,
      # Discord blue
      color: 3_447_003,
      image: %{
        url: chart_url
      },
      footer: %{
        text: "Generated by WandererNotifier"
      },
      timestamp: DateTime.utc_now() |> DateTime.to_iso8601()
    }

    # Send the embed to Discord
    DiscordClient.send_embed(embed, channel_id)
  end

  def send_chart_to_discord(config, title, description, channel_id) do
    case generate_chart_url(config) do
      {:ok, url} -> send_chart_to_discord(url, title, description, channel_id)
      {:error, reason} -> {:error, reason}
    end
  end

  # Private helpers

  # Core function to generate chart URL from a map
  defp do_generate_chart_url(chart_map, width, height, background_color) do
    try do
      # Try to encode the chart configuration to JSON
      case Jason.encode(chart_map) do
        {:ok, json} ->
          # Check JSON size to determine approach
          json_size = byte_size(json)
          Logger.debug("Chart JSON size: #{json_size} bytes")

          if json_size > 8000 or String.length(json) > 2000 do
            Logger.warning("Chart JSON is large (#{json_size} bytes), using POST method instead")
            create_chart_via_post(chart_map, width, height, background_color)
          else
            # Standard encoding for normal-sized JSON
            encoded_config = URI.encode_www_form(json)

            # Construct URL with query parameters
            url = "#{@quickchart_url}?c=#{encoded_config}"
            url = "#{url}&backgroundColor=#{URI.encode_www_form(background_color)}"
            url = "#{url}&width=#{width}&height=#{height}"

            # Check URL length
            url_length = String.length(url)
            Logger.debug("Generated chart URL with length: #{url_length}")

            if url_length > 2000 do
              Logger.warning(
                "Chart URL is very long (#{url_length} chars), using POST method instead"
              )

              create_chart_via_post(chart_map, width, height, background_color)
            else
              {:ok, url}
            end
          end

        {:error, reason} ->
          Logger.error("Failed to encode chart configuration: #{inspect(reason)}")
          {:error, "Failed to encode chart configuration: #{inspect(reason)}"}
      end
    rescue
      e ->
        Logger.error("Exception encoding chart: #{inspect(e)}")
        {:error, "Exception encoding chart: #{inspect(e)}"}
    end
  end

  # Creates a chart via POST request when configuration is too large for URL
  defp create_chart_via_post(chart_map, width, height, background_color) do
    # Create the full chart configuration with dimensions and background
    full_config = %{
      "chart" => chart_map,
      "width" => width,
      "height" => height,
      "backgroundColor" => background_color,
      "format" => "png"
    }

    # Send the POST request to QuickChart API
    post_url = "#{@quickchart_url}/create"

    headers = [
      {"Content-Type", "application/json"},
      {"Accept", "application/json"}
    ]

    # Encode to JSON
    case Jason.encode(full_config) do
      {:ok, json_body} ->
        # Make the HTTP POST request using HTTPoison
        case HTTPoison.post(post_url, json_body, headers) do
          {:ok, %HTTPoison.Response{status_code: 200, body: response_body}} ->
            # Parse the response to get the chart URL
            case Jason.decode(response_body) do
              {:ok, %{"success" => true, "url" => chart_url}} ->
                Logger.info("Successfully created chart via POST request")
                {:ok, chart_url}

              {:ok, %{"success" => false, "message" => message}} ->
                Logger.error("QuickChart API error: #{message}")
                {:error, "QuickChart API error: #{message}"}

              {:error, reason} ->
                Logger.error("Failed to parse QuickChart response: #{inspect(reason)}")
                {:error, "Failed to parse QuickChart response"}
            end

          {:ok, %HTTPoison.Response{status_code: status, body: body}} ->
            Logger.error("QuickChart API returned #{status}: #{body}")
            {:error, "QuickChart API error (HTTP #{status})"}

          {:error, %HTTPoison.Error{reason: reason}} ->
            Logger.error("HTTP request to QuickChart failed: #{inspect(reason)}")
            {:error, "HTTP request to QuickChart failed"}
        end

      {:error, reason} ->
        Logger.error("Failed to encode chart configuration for POST: #{inspect(reason)}")
        {:error, "Failed to encode chart configuration for POST"}
    end
  end
end
